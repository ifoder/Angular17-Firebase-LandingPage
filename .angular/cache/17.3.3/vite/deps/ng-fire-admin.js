import "./chunk-XH6Y7NFP.js";
import {
  FormsModule
} from "./chunk-6UKPEYCI.js";
import "./chunk-VNBQNBJZ.js";
import {
  ActivatedRoute,
  Router,
  RouterModule
} from "./chunk-6T4JIRNW.js";
import {
  DomSanitizer
} from "./chunk-KFN4XCC3.js";
import "./chunk-Z5YEAFHA.js";
import "./chunk-3DEZ5MRG.js";
import "./chunk-WYYHD7HM.js";
import "./chunk-QN5Y54JU.js";
import "./chunk-B6MYZVS2.js";
import "./chunk-TI24BFSE.js";
import {
  CommonModule,
  DatePipe,
  isPlatformServer,
  registerLocaleData
} from "./chunk-DIUYAEL7.js";
import {
  Component,
  Directive,
  ElementRef,
  EventEmitter,
  Inject,
  Injectable,
  InjectionToken,
  Input,
  NgModule,
  NgZone,
  Optional,
  Output,
  PLATFORM_ID,
  Pipe,
  VERSION,
  Version,
  ViewChild,
  ViewEncapsulation$1,
  ɵɵdefineInjectable,
  ɵɵinject
} from "./chunk-FNVBMXYR.js";
import {
  Observable,
  Subject,
  Subscription,
  asyncScheduler,
  filter,
  first,
  from,
  map,
  merge,
  mergeMap,
  observeOn,
  of,
  queueScheduler,
  scan,
  subscribeOn,
  switchMap,
  take,
  takeUntil,
  tap
} from "./chunk-ELRSAQZ7.js";
import "./chunk-ECDNAN6X.js";
import {
  __commonJS,
  __esm,
  __export,
  __objRest,
  __spreadValues,
  __toCommonJS,
  __toESM
} from "./chunk-KA6IPRFH.js";

// node_modules/ng-fire-admin/node_modules/tslib/tslib.es6.js
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __read: () => __read,
  __rest: () => __rest,
  __spread: () => __spread,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values
});
function __extends(d, b2) {
  extendStatics(d, b2);
  function __() {
    this.constructor = d;
  }
  d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
function __rest(s, e) {
  var t = {};
  for (var p2 in s)
    if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
      t[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
      if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
        t[p2[i2]] = s[p2[i2]];
    }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r2 = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d = decorators[i2])
        r2 = (c < 3 ? d(r2) : c > 3 ? d(target, key, r2) : d(target, key)) || r2;
  return c > 3 && r2 && Object.defineProperty(target, key, r2), r2;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y2, t, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f = 1, y2 && (t = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t = y2["return"]) && t.call(y2), 0) : y2.next) && !(t = t.call(y2, op[1])).done)
          return t;
        if (y2 = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t = _2.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t[1]) {
              _2.label = t[1];
              t = op;
              break;
            }
            if (t && _2.label < t[2]) {
              _2.label = t[2];
              _2.ops.push(op);
              break;
            }
            if (t[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e) {
        op = [6, e];
        y2 = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __createBinding(o, m, k3, k22) {
  if (k22 === void 0)
    k22 = k3;
  o[k22] = m[k3];
}
function __exportStar(m, exports) {
  for (var p2 in m)
    if (p2 !== "default" && !exports.hasOwnProperty(p2))
      exports[p2] = m[p2];
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i2 >= o.length)
          o = void 0;
        return { value: o && o[i2++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n2) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r2, ar2 = [], e;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar2.push(r2.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar2;
}
function __spread() {
  for (var ar2 = [], i2 = 0; i2 < arguments.length; i2++)
    ar2 = ar2.concat(__read(arguments[i2]));
  return ar2;
}
function __spreadArrays() {
  for (var s = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
    s += arguments[i2].length;
  for (var r2 = Array(s), k3 = 0, i2 = 0; i2 < il; i2++)
    for (var a = arguments[i2], j2 = 0, jl = a.length; j2 < jl; j2++, k3++)
      r2[k3] = a[j2];
  return r2;
}
function __await(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i2, q3 = [];
  return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function verb(n2) {
    if (g2[n2])
      i2[n2] = function(v2) {
        return new Promise(function(a, b2) {
          q3.push([n2, v2, a, b2]) > 1 || resume(n2, v2);
        });
      };
  }
  function resume(n2, v2) {
    try {
      step(g2[n2](v2));
    } catch (e) {
      settle(q3[0][3], e);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q3[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v2) {
    if (f(v2), q3.shift(), q3.length)
      resume(q3[0][0], q3[0][1]);
  }
}
function __asyncDelegator(o) {
  var i2, p2;
  return i2 = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i2[Symbol.iterator] = function() {
    return this;
  }, i2;
  function verb(n2, f) {
    i2[n2] = o[n2] ? function(v2) {
      return (p2 = !p2) ? { value: __await(o[n2](v2)), done: n2 === "return" } : f ? f(v2) : v2;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i2;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n2) {
    i2[n2] = o[n2] && function(v2) {
      return new Promise(function(resolve2, reject) {
        v2 = o[n2](v2), settle(resolve2, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve2, reject, d, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve2({ value: v3, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod2) {
  if (mod2 && mod2.__esModule)
    return mod2;
  var result = {};
  if (mod2 != null) {
    for (var k3 in mod2)
      if (Object.hasOwnProperty.call(mod2, k3))
        result[k3] = mod2[k3];
  }
  result.default = mod2;
  return result;
}
function __importDefault(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
}
function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
}
var extendStatics, __assign;
var init_tslib_es6 = __esm({
  "node_modules/ng-fire-admin/node_modules/tslib/tslib.es6.js"() {
    extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p2 in b3)
          if (b3.hasOwnProperty(p2))
            d2[p2] = b3[p2];
      };
      return extendStatics(d, b2);
    };
    __assign = function() {
      __assign = Object.assign || function __assign3(t) {
        for (var s, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s = arguments[i2];
          for (var p2 in s)
            if (Object.prototype.hasOwnProperty.call(s, p2))
              t[p2] = s[p2];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
  }
});

// node_modules/ng-fire-admin/node_modules/@firebase/util/dist/index.cjs.js
var require_index_cjs = __commonJS({
  "node_modules/ng-fire-admin/node_modules/@firebase/util/dist/index.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var CONSTANTS = {
      /**
       * @define {boolean} Whether this is the client Node.js SDK.
       */
      NODE_CLIENT: false,
      /**
       * @define {boolean} Whether this is the Admin Node.js SDK.
       */
      NODE_ADMIN: false,
      /**
       * Firebase SDK Version
       */
      SDK_VERSION: "${JSCORE_VERSION}"
    };
    var assert = function(assertion, message) {
      if (!assertion) {
        throw assertionError(message);
      }
    };
    var assertionError = function(message) {
      return new Error("Firebase Database (" + CONSTANTS.SDK_VERSION + ") INTERNAL ASSERT FAILED: " + message);
    };
    var stringToByteArray = function(str) {
      var out = [];
      var p2 = 0;
      for (var i2 = 0; i2 < str.length; i2++) {
        var c = str.charCodeAt(i2);
        if (c < 128) {
          out[p2++] = c;
        } else if (c < 2048) {
          out[p2++] = c >> 6 | 192;
          out[p2++] = c & 63 | 128;
        } else if ((c & 64512) === 55296 && i2 + 1 < str.length && (str.charCodeAt(i2 + 1) & 64512) === 56320) {
          c = 65536 + ((c & 1023) << 10) + (str.charCodeAt(++i2) & 1023);
          out[p2++] = c >> 18 | 240;
          out[p2++] = c >> 12 & 63 | 128;
          out[p2++] = c >> 6 & 63 | 128;
          out[p2++] = c & 63 | 128;
        } else {
          out[p2++] = c >> 12 | 224;
          out[p2++] = c >> 6 & 63 | 128;
          out[p2++] = c & 63 | 128;
        }
      }
      return out;
    };
    var byteArrayToString = function(bytes) {
      var out = [];
      var pos = 0, c = 0;
      while (pos < bytes.length) {
        var c1 = bytes[pos++];
        if (c1 < 128) {
          out[c++] = String.fromCharCode(c1);
        } else if (c1 > 191 && c1 < 224) {
          var c2 = bytes[pos++];
          out[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);
        } else if (c1 > 239 && c1 < 365) {
          var c2 = bytes[pos++];
          var c3 = bytes[pos++];
          var c4 = bytes[pos++];
          var u4 = ((c1 & 7) << 18 | (c2 & 63) << 12 | (c3 & 63) << 6 | c4 & 63) - 65536;
          out[c++] = String.fromCharCode(55296 + (u4 >> 10));
          out[c++] = String.fromCharCode(56320 + (u4 & 1023));
        } else {
          var c2 = bytes[pos++];
          var c3 = bytes[pos++];
          out[c++] = String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
        }
      }
      return out.join("");
    };
    var base64 = {
      /**
       * Maps bytes to characters.
       */
      byteToCharMap_: null,
      /**
       * Maps characters to bytes.
       */
      charToByteMap_: null,
      /**
       * Maps bytes to websafe characters.
       * @private
       */
      byteToCharMapWebSafe_: null,
      /**
       * Maps websafe characters to bytes.
       * @private
       */
      charToByteMapWebSafe_: null,
      /**
       * Our default alphabet, shared between
       * ENCODED_VALS and ENCODED_VALS_WEBSAFE
       */
      ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
      /**
       * Our default alphabet. Value 64 (=) is special; it means "nothing."
       */
      get ENCODED_VALS() {
        return this.ENCODED_VALS_BASE + "+/=";
      },
      /**
       * Our websafe alphabet.
       */
      get ENCODED_VALS_WEBSAFE() {
        return this.ENCODED_VALS_BASE + "-_.";
      },
      /**
       * Whether this browser supports the atob and btoa functions. This extension
       * started at Mozilla but is now implemented by many browsers. We use the
       * ASSUME_* variables to avoid pulling in the full useragent detection library
       * but still allowing the standard per-browser compilations.
       *
       */
      HAS_NATIVE_SUPPORT: typeof atob === "function",
      /**
       * Base64-encode an array of bytes.
       *
       * @param input An array of bytes (numbers with
       *     value in [0, 255]) to encode.
       * @param webSafe Boolean indicating we should use the
       *     alternative alphabet.
       * @return The base64 encoded string.
       */
      encodeByteArray: function(input, webSafe) {
        if (!Array.isArray(input)) {
          throw Error("encodeByteArray takes an array as a parameter");
        }
        this.init_();
        var byteToCharMap = webSafe ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;
        var output = [];
        for (var i2 = 0; i2 < input.length; i2 += 3) {
          var byte1 = input[i2];
          var haveByte2 = i2 + 1 < input.length;
          var byte2 = haveByte2 ? input[i2 + 1] : 0;
          var haveByte3 = i2 + 2 < input.length;
          var byte3 = haveByte3 ? input[i2 + 2] : 0;
          var outByte1 = byte1 >> 2;
          var outByte2 = (byte1 & 3) << 4 | byte2 >> 4;
          var outByte3 = (byte2 & 15) << 2 | byte3 >> 6;
          var outByte4 = byte3 & 63;
          if (!haveByte3) {
            outByte4 = 64;
            if (!haveByte2) {
              outByte3 = 64;
            }
          }
          output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);
        }
        return output.join("");
      },
      /**
       * Base64-encode a string.
       *
       * @param input A string to encode.
       * @param webSafe If true, we should use the
       *     alternative alphabet.
       * @return The base64 encoded string.
       */
      encodeString: function(input, webSafe) {
        if (this.HAS_NATIVE_SUPPORT && !webSafe) {
          return btoa(input);
        }
        return this.encodeByteArray(stringToByteArray(input), webSafe);
      },
      /**
       * Base64-decode a string.
       *
       * @param input to decode.
       * @param webSafe True if we should use the
       *     alternative alphabet.
       * @return string representing the decoded value.
       */
      decodeString: function(input, webSafe) {
        if (this.HAS_NATIVE_SUPPORT && !webSafe) {
          return atob(input);
        }
        return byteArrayToString(this.decodeStringToByteArray(input, webSafe));
      },
      /**
       * Base64-decode a string.
       *
       * In base-64 decoding, groups of four characters are converted into three
       * bytes.  If the encoder did not apply padding, the input length may not
       * be a multiple of 4.
       *
       * In this case, the last group will have fewer than 4 characters, and
       * padding will be inferred.  If the group has one or two characters, it decodes
       * to one byte.  If the group has three characters, it decodes to two bytes.
       *
       * @param input Input to decode.
       * @param webSafe True if we should use the web-safe alphabet.
       * @return bytes representing the decoded value.
       */
      decodeStringToByteArray: function(input, webSafe) {
        this.init_();
        var charToByteMap = webSafe ? this.charToByteMapWebSafe_ : this.charToByteMap_;
        var output = [];
        for (var i2 = 0; i2 < input.length; ) {
          var byte1 = charToByteMap[input.charAt(i2++)];
          var haveByte2 = i2 < input.length;
          var byte2 = haveByte2 ? charToByteMap[input.charAt(i2)] : 0;
          ++i2;
          var haveByte3 = i2 < input.length;
          var byte3 = haveByte3 ? charToByteMap[input.charAt(i2)] : 64;
          ++i2;
          var haveByte4 = i2 < input.length;
          var byte4 = haveByte4 ? charToByteMap[input.charAt(i2)] : 64;
          ++i2;
          if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {
            throw Error();
          }
          var outByte1 = byte1 << 2 | byte2 >> 4;
          output.push(outByte1);
          if (byte3 !== 64) {
            var outByte2 = byte2 << 4 & 240 | byte3 >> 2;
            output.push(outByte2);
            if (byte4 !== 64) {
              var outByte3 = byte3 << 6 & 192 | byte4;
              output.push(outByte3);
            }
          }
        }
        return output;
      },
      /**
       * Lazy static initialization function. Called before
       * accessing any of the static map variables.
       * @private
       */
      init_: function() {
        if (!this.byteToCharMap_) {
          this.byteToCharMap_ = {};
          this.charToByteMap_ = {};
          this.byteToCharMapWebSafe_ = {};
          this.charToByteMapWebSafe_ = {};
          for (var i2 = 0; i2 < this.ENCODED_VALS.length; i2++) {
            this.byteToCharMap_[i2] = this.ENCODED_VALS.charAt(i2);
            this.charToByteMap_[this.byteToCharMap_[i2]] = i2;
            this.byteToCharMapWebSafe_[i2] = this.ENCODED_VALS_WEBSAFE.charAt(i2);
            this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i2]] = i2;
            if (i2 >= this.ENCODED_VALS_BASE.length) {
              this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i2)] = i2;
              this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i2)] = i2;
            }
          }
        }
      }
    };
    var base64Encode = function(str) {
      var utf8Bytes = stringToByteArray(str);
      return base64.encodeByteArray(utf8Bytes, true);
    };
    var base64Decode = function(str) {
      try {
        return base64.decodeString(str, true);
      } catch (e) {
        console.error("base64Decode failed: ", e);
      }
      return null;
    };
    function deepCopy(value) {
      return deepExtend(void 0, value);
    }
    function deepExtend(target, source) {
      if (!(source instanceof Object)) {
        return source;
      }
      switch (source.constructor) {
        case Date:
          var dateValue = source;
          return new Date(dateValue.getTime());
        case Object:
          if (target === void 0) {
            target = {};
          }
          break;
        case Array:
          target = [];
          break;
        default:
          return source;
      }
      for (var prop in source) {
        if (!source.hasOwnProperty(prop)) {
          continue;
        }
        target[prop] = deepExtend(target[prop], source[prop]);
      }
      return target;
    }
    var Deferred2 = (
      /** @class */
      function() {
        function Deferred3() {
          var _this = this;
          this.reject = function() {
          };
          this.resolve = function() {
          };
          this.promise = new Promise(function(resolve2, reject) {
            _this.resolve = resolve2;
            _this.reject = reject;
          });
        }
        Deferred3.prototype.wrapCallback = function(callback) {
          var _this = this;
          return function(error, value) {
            if (error) {
              _this.reject(error);
            } else {
              _this.resolve(value);
            }
            if (typeof callback === "function") {
              _this.promise.catch(function() {
              });
              if (callback.length === 1) {
                callback(error);
              } else {
                callback(error, value);
              }
            }
          };
        };
        return Deferred3;
      }()
    );
    function getUA2() {
      if (typeof navigator !== "undefined" && typeof navigator["userAgent"] === "string") {
        return navigator["userAgent"];
      } else {
        return "";
      }
    }
    function isMobileCordova2() {
      return typeof window !== "undefined" && // @ts-ignore Setting up an broadly applicable index signature for Window
      // just to deal with this case would probably be a bad idea.
      !!(window["cordova"] || window["phonegap"] || window["PhoneGap"]) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA2());
    }
    function isNode() {
      try {
        return Object.prototype.toString.call(global.process) === "[object process]";
      } catch (e) {
        return false;
      }
    }
    function isBrowser2() {
      return typeof self === "object" && self.self === self;
    }
    function isBrowserExtension2() {
      var runtime = typeof chrome === "object" ? chrome.runtime : typeof browser === "object" ? browser.runtime : void 0;
      return typeof runtime === "object" && runtime.id !== void 0;
    }
    function isReactNative2() {
      return typeof navigator === "object" && navigator["product"] === "ReactNative";
    }
    function isElectron2() {
      return getUA2().indexOf("Electron/") >= 0;
    }
    function isIE3() {
      var ua3 = getUA2();
      return ua3.indexOf("MSIE ") >= 0 || ua3.indexOf("Trident/") >= 0;
    }
    function isUWP2() {
      return getUA2().indexOf("MSAppHost/") >= 0;
    }
    function isNodeSdk() {
      return CONSTANTS.NODE_CLIENT === true || CONSTANTS.NODE_ADMIN === true;
    }
    function isSafari() {
      return !isNode() && navigator.userAgent.includes("Safari") && !navigator.userAgent.includes("Chrome");
    }
    function isIndexedDBAvailable() {
      return "indexedDB" in self && indexedDB != null;
    }
    function validateIndexedDBOpenable() {
      return new Promise(function(resolve2, reject) {
        try {
          var preExist_1 = true;
          var DB_CHECK_NAME_1 = "validate-browser-context-for-indexeddb-analytics-module";
          var request_1 = window.indexedDB.open(DB_CHECK_NAME_1);
          request_1.onsuccess = function() {
            request_1.result.close();
            if (!preExist_1) {
              window.indexedDB.deleteDatabase(DB_CHECK_NAME_1);
            }
            resolve2(true);
          };
          request_1.onupgradeneeded = function() {
            preExist_1 = false;
          };
          request_1.onerror = function() {
            var _a3;
            reject(((_a3 = request_1.error) === null || _a3 === void 0 ? void 0 : _a3.message) || "");
          };
        } catch (error) {
          reject(error);
        }
      });
    }
    function areCookiesEnabled() {
      if (!navigator || !navigator.cookieEnabled) {
        return false;
      }
      return true;
    }
    var ERROR_NAME2 = "FirebaseError";
    var FirebaseError2 = (
      /** @class */
      function(_super) {
        tslib.__extends(FirebaseError3, _super);
        function FirebaseError3(code, message) {
          var _this = _super.call(this, message) || this;
          _this.code = code;
          _this.name = ERROR_NAME2;
          Object.setPrototypeOf(_this, FirebaseError3.prototype);
          if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, ErrorFactory2.prototype.create);
          }
          return _this;
        }
        return FirebaseError3;
      }(Error)
    );
    var ErrorFactory2 = (
      /** @class */
      function() {
        function ErrorFactory3(service, serviceName, errors) {
          this.service = service;
          this.serviceName = serviceName;
          this.errors = errors;
        }
        ErrorFactory3.prototype.create = function(code) {
          var data = [];
          for (var _i2 = 1; _i2 < arguments.length; _i2++) {
            data[_i2 - 1] = arguments[_i2];
          }
          var customData = data[0] || {};
          var fullCode = this.service + "/" + code;
          var template = this.errors[code];
          var message = template ? replaceTemplate2(template, customData) : "Error";
          var fullMessage = this.serviceName + ": " + message + " (" + fullCode + ").";
          var error = new FirebaseError2(fullCode, fullMessage);
          for (var _a3 = 0, _b = Object.keys(customData); _a3 < _b.length; _a3++) {
            var key = _b[_a3];
            if (key.slice(-1) !== "_") {
              if (key in error) {
                console.warn('Overwriting FirebaseError base field "' + key + '" can cause unexpected behavior.');
              }
              error[key] = customData[key];
            }
          }
          return error;
        };
        return ErrorFactory3;
      }()
    );
    function replaceTemplate2(template, data) {
      return template.replace(PATTERN2, function(_2, key) {
        var value = data[key];
        return value != null ? String(value) : "<" + key + "?>";
      });
    }
    var PATTERN2 = /\{\$([^}]+)}/g;
    function jsonEval(str) {
      return JSON.parse(str);
    }
    function stringify(data) {
      return JSON.stringify(data);
    }
    var decode = function(token) {
      var header = {}, claims = {}, data = {}, signature = "";
      try {
        var parts = token.split(".");
        header = jsonEval(base64Decode(parts[0]) || "");
        claims = jsonEval(base64Decode(parts[1]) || "");
        signature = parts[2];
        data = claims["d"] || {};
        delete claims["d"];
      } catch (e) {
      }
      return {
        header,
        claims,
        data,
        signature
      };
    };
    var isValidTimestamp = function(token) {
      var claims = decode(token).claims;
      var now2 = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);
      var validSince = 0, validUntil = 0;
      if (typeof claims === "object") {
        if (claims.hasOwnProperty("nbf")) {
          validSince = claims["nbf"];
        } else if (claims.hasOwnProperty("iat")) {
          validSince = claims["iat"];
        }
        if (claims.hasOwnProperty("exp")) {
          validUntil = claims["exp"];
        } else {
          validUntil = validSince + 86400;
        }
      }
      return !!now2 && !!validSince && !!validUntil && now2 >= validSince && now2 <= validUntil;
    };
    var issuedAtTime = function(token) {
      var claims = decode(token).claims;
      if (typeof claims === "object" && claims.hasOwnProperty("iat")) {
        return claims["iat"];
      }
      return null;
    };
    var isValidFormat = function(token) {
      var decoded = decode(token), claims = decoded.claims;
      return !!claims && typeof claims === "object" && claims.hasOwnProperty("iat");
    };
    var isAdmin = function(token) {
      var claims = decode(token).claims;
      return typeof claims === "object" && claims["admin"] === true;
    };
    function contains(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    function safeGet(obj, key) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        return obj[key];
      } else {
        return void 0;
      }
    }
    function isEmpty(obj) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          return false;
        }
      }
      return true;
    }
    function map3(obj, fn2, contextObj) {
      var res = {};
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          res[key] = fn2.call(contextObj, obj[key], key, obj);
        }
      }
      return res;
    }
    function querystring(querystringParams) {
      var params = [];
      var _loop_1 = function(key2, value2) {
        if (Array.isArray(value2)) {
          value2.forEach(function(arrayVal) {
            params.push(encodeURIComponent(key2) + "=" + encodeURIComponent(arrayVal));
          });
        } else {
          params.push(encodeURIComponent(key2) + "=" + encodeURIComponent(value2));
        }
      };
      for (var _i2 = 0, _a3 = Object.entries(querystringParams); _i2 < _a3.length; _i2++) {
        var _b = _a3[_i2], key = _b[0], value = _b[1];
        _loop_1(key, value);
      }
      return params.length ? "&" + params.join("&") : "";
    }
    function querystringDecode(querystring2) {
      var obj = {};
      var tokens = querystring2.replace(/^\?/, "").split("&");
      tokens.forEach(function(token) {
        if (token) {
          var key = token.split("=");
          obj[key[0]] = key[1];
        }
      });
      return obj;
    }
    var Sha12 = (
      /** @class */
      function() {
        function Sha13() {
          this.chain_ = [];
          this.buf_ = [];
          this.W_ = [];
          this.pad_ = [];
          this.inbuf_ = 0;
          this.total_ = 0;
          this.blockSize = 512 / 8;
          this.pad_[0] = 128;
          for (var i2 = 1; i2 < this.blockSize; ++i2) {
            this.pad_[i2] = 0;
          }
          this.reset();
        }
        Sha13.prototype.reset = function() {
          this.chain_[0] = 1732584193;
          this.chain_[1] = 4023233417;
          this.chain_[2] = 2562383102;
          this.chain_[3] = 271733878;
          this.chain_[4] = 3285377520;
          this.inbuf_ = 0;
          this.total_ = 0;
        };
        Sha13.prototype.compress_ = function(buf, offset2) {
          if (!offset2) {
            offset2 = 0;
          }
          var W3 = this.W_;
          if (typeof buf === "string") {
            for (var i2 = 0; i2 < 16; i2++) {
              W3[i2] = buf.charCodeAt(offset2) << 24 | buf.charCodeAt(offset2 + 1) << 16 | buf.charCodeAt(offset2 + 2) << 8 | buf.charCodeAt(offset2 + 3);
              offset2 += 4;
            }
          } else {
            for (var i2 = 0; i2 < 16; i2++) {
              W3[i2] = buf[offset2] << 24 | buf[offset2 + 1] << 16 | buf[offset2 + 2] << 8 | buf[offset2 + 3];
              offset2 += 4;
            }
          }
          for (var i2 = 16; i2 < 80; i2++) {
            var t = W3[i2 - 3] ^ W3[i2 - 8] ^ W3[i2 - 14] ^ W3[i2 - 16];
            W3[i2] = (t << 1 | t >>> 31) & 4294967295;
          }
          var a = this.chain_[0];
          var b2 = this.chain_[1];
          var c = this.chain_[2];
          var d = this.chain_[3];
          var e = this.chain_[4];
          var f, k3;
          for (var i2 = 0; i2 < 80; i2++) {
            if (i2 < 40) {
              if (i2 < 20) {
                f = d ^ b2 & (c ^ d);
                k3 = 1518500249;
              } else {
                f = b2 ^ c ^ d;
                k3 = 1859775393;
              }
            } else {
              if (i2 < 60) {
                f = b2 & c | d & (b2 | c);
                k3 = 2400959708;
              } else {
                f = b2 ^ c ^ d;
                k3 = 3395469782;
              }
            }
            var t = (a << 5 | a >>> 27) + f + e + k3 + W3[i2] & 4294967295;
            e = d;
            d = c;
            c = (b2 << 30 | b2 >>> 2) & 4294967295;
            b2 = a;
            a = t;
          }
          this.chain_[0] = this.chain_[0] + a & 4294967295;
          this.chain_[1] = this.chain_[1] + b2 & 4294967295;
          this.chain_[2] = this.chain_[2] + c & 4294967295;
          this.chain_[3] = this.chain_[3] + d & 4294967295;
          this.chain_[4] = this.chain_[4] + e & 4294967295;
        };
        Sha13.prototype.update = function(bytes, length) {
          if (bytes == null) {
            return;
          }
          if (length === void 0) {
            length = bytes.length;
          }
          var lengthMinusBlock = length - this.blockSize;
          var n2 = 0;
          var buf = this.buf_;
          var inbuf = this.inbuf_;
          while (n2 < length) {
            if (inbuf === 0) {
              while (n2 <= lengthMinusBlock) {
                this.compress_(bytes, n2);
                n2 += this.blockSize;
              }
            }
            if (typeof bytes === "string") {
              while (n2 < length) {
                buf[inbuf] = bytes.charCodeAt(n2);
                ++inbuf;
                ++n2;
                if (inbuf === this.blockSize) {
                  this.compress_(buf);
                  inbuf = 0;
                  break;
                }
              }
            } else {
              while (n2 < length) {
                buf[inbuf] = bytes[n2];
                ++inbuf;
                ++n2;
                if (inbuf === this.blockSize) {
                  this.compress_(buf);
                  inbuf = 0;
                  break;
                }
              }
            }
          }
          this.inbuf_ = inbuf;
          this.total_ += length;
        };
        Sha13.prototype.digest = function() {
          var digest = [];
          var totalBits = this.total_ * 8;
          if (this.inbuf_ < 56) {
            this.update(this.pad_, 56 - this.inbuf_);
          } else {
            this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));
          }
          for (var i2 = this.blockSize - 1; i2 >= 56; i2--) {
            this.buf_[i2] = totalBits & 255;
            totalBits /= 256;
          }
          this.compress_(this.buf_);
          var n2 = 0;
          for (var i2 = 0; i2 < 5; i2++) {
            for (var j2 = 24; j2 >= 0; j2 -= 8) {
              digest[n2] = this.chain_[i2] >> j2 & 255;
              ++n2;
            }
          }
          return digest;
        };
        return Sha13;
      }()
    );
    function createSubscribe(executor, onNoObservers) {
      var proxy = new ObserverProxy2(executor, onNoObservers);
      return proxy.subscribe.bind(proxy);
    }
    var ObserverProxy2 = (
      /** @class */
      function() {
        function ObserverProxy3(executor, onNoObservers) {
          var _this = this;
          this.observers = [];
          this.unsubscribes = [];
          this.observerCount = 0;
          this.task = Promise.resolve();
          this.finalized = false;
          this.onNoObservers = onNoObservers;
          this.task.then(function() {
            executor(_this);
          }).catch(function(e) {
            _this.error(e);
          });
        }
        ObserverProxy3.prototype.next = function(value) {
          this.forEachObserver(function(observer) {
            observer.next(value);
          });
        };
        ObserverProxy3.prototype.error = function(error) {
          this.forEachObserver(function(observer) {
            observer.error(error);
          });
          this.close(error);
        };
        ObserverProxy3.prototype.complete = function() {
          this.forEachObserver(function(observer) {
            observer.complete();
          });
          this.close();
        };
        ObserverProxy3.prototype.subscribe = function(nextOrObserver, error, complete) {
          var _this = this;
          var observer;
          if (nextOrObserver === void 0 && error === void 0 && complete === void 0) {
            throw new Error("Missing Observer.");
          }
          if (implementsAnyMethods2(nextOrObserver, [
            "next",
            "error",
            "complete"
          ])) {
            observer = nextOrObserver;
          } else {
            observer = {
              next: nextOrObserver,
              error,
              complete
            };
          }
          if (observer.next === void 0) {
            observer.next = noop4;
          }
          if (observer.error === void 0) {
            observer.error = noop4;
          }
          if (observer.complete === void 0) {
            observer.complete = noop4;
          }
          var unsub = this.unsubscribeOne.bind(this, this.observers.length);
          if (this.finalized) {
            this.task.then(function() {
              try {
                if (_this.finalError) {
                  observer.error(_this.finalError);
                } else {
                  observer.complete();
                }
              } catch (e) {
              }
              return;
            });
          }
          this.observers.push(observer);
          return unsub;
        };
        ObserverProxy3.prototype.unsubscribeOne = function(i2) {
          if (this.observers === void 0 || this.observers[i2] === void 0) {
            return;
          }
          delete this.observers[i2];
          this.observerCount -= 1;
          if (this.observerCount === 0 && this.onNoObservers !== void 0) {
            this.onNoObservers(this);
          }
        };
        ObserverProxy3.prototype.forEachObserver = function(fn2) {
          if (this.finalized) {
            return;
          }
          for (var i2 = 0; i2 < this.observers.length; i2++) {
            this.sendOne(i2, fn2);
          }
        };
        ObserverProxy3.prototype.sendOne = function(i2, fn2) {
          var _this = this;
          this.task.then(function() {
            if (_this.observers !== void 0 && _this.observers[i2] !== void 0) {
              try {
                fn2(_this.observers[i2]);
              } catch (e) {
                if (typeof console !== "undefined" && console.error) {
                  console.error(e);
                }
              }
            }
          });
        };
        ObserverProxy3.prototype.close = function(err) {
          var _this = this;
          if (this.finalized) {
            return;
          }
          this.finalized = true;
          if (err !== void 0) {
            this.finalError = err;
          }
          this.task.then(function() {
            _this.observers = void 0;
            _this.onNoObservers = void 0;
          });
        };
        return ObserverProxy3;
      }()
    );
    function async3(fn2, onError) {
      return function() {
        var args = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          args[_i2] = arguments[_i2];
        }
        Promise.resolve(true).then(function() {
          fn2.apply(void 0, args);
        }).catch(function(error) {
          if (onError) {
            onError(error);
          }
        });
      };
    }
    function implementsAnyMethods2(obj, methods) {
      if (typeof obj !== "object" || obj === null) {
        return false;
      }
      for (var _i2 = 0, methods_1 = methods; _i2 < methods_1.length; _i2++) {
        var method = methods_1[_i2];
        if (method in obj && typeof obj[method] === "function") {
          return true;
        }
      }
      return false;
    }
    function noop4() {
    }
    var validateArgCount = function(fnName, minCount, maxCount, argCount) {
      var argError;
      if (argCount < minCount) {
        argError = "at least " + minCount;
      } else if (argCount > maxCount) {
        argError = maxCount === 0 ? "none" : "no more than " + maxCount;
      }
      if (argError) {
        var error = fnName + " failed: Was called with " + argCount + (argCount === 1 ? " argument." : " arguments.") + " Expects " + argError + ".";
        throw new Error(error);
      }
    };
    function errorPrefix(fnName, argumentNumber, optional) {
      var argName = "";
      switch (argumentNumber) {
        case 1:
          argName = optional ? "first" : "First";
          break;
        case 2:
          argName = optional ? "second" : "Second";
          break;
        case 3:
          argName = optional ? "third" : "Third";
          break;
        case 4:
          argName = optional ? "fourth" : "Fourth";
          break;
        default:
          throw new Error("errorPrefix called with argumentNumber > 4.  Need to update it?");
      }
      var error = fnName + " failed: ";
      error += argName + " argument ";
      return error;
    }
    function validateNamespace(fnName, argumentNumber, namespace, optional) {
      if (optional && !namespace) {
        return;
      }
      if (typeof namespace !== "string") {
        throw new Error(errorPrefix(fnName, argumentNumber, optional) + "must be a valid firebase namespace.");
      }
    }
    function validateCallback(fnName, argumentNumber, callback, optional) {
      if (optional && !callback) {
        return;
      }
      if (typeof callback !== "function") {
        throw new Error(errorPrefix(fnName, argumentNumber, optional) + "must be a valid function.");
      }
    }
    function validateContextObject(fnName, argumentNumber, context, optional) {
      if (optional && !context) {
        return;
      }
      if (typeof context !== "object" || context === null) {
        throw new Error(errorPrefix(fnName, argumentNumber, optional) + "must be a valid context object.");
      }
    }
    var stringToByteArray$1 = function(str) {
      var out = [];
      var p2 = 0;
      for (var i2 = 0; i2 < str.length; i2++) {
        var c = str.charCodeAt(i2);
        if (c >= 55296 && c <= 56319) {
          var high = c - 55296;
          i2++;
          assert(i2 < str.length, "Surrogate pair missing trail surrogate.");
          var low = str.charCodeAt(i2) - 56320;
          c = 65536 + (high << 10) + low;
        }
        if (c < 128) {
          out[p2++] = c;
        } else if (c < 2048) {
          out[p2++] = c >> 6 | 192;
          out[p2++] = c & 63 | 128;
        } else if (c < 65536) {
          out[p2++] = c >> 12 | 224;
          out[p2++] = c >> 6 & 63 | 128;
          out[p2++] = c & 63 | 128;
        } else {
          out[p2++] = c >> 18 | 240;
          out[p2++] = c >> 12 & 63 | 128;
          out[p2++] = c >> 6 & 63 | 128;
          out[p2++] = c & 63 | 128;
        }
      }
      return out;
    };
    var stringLength = function(str) {
      var p2 = 0;
      for (var i2 = 0; i2 < str.length; i2++) {
        var c = str.charCodeAt(i2);
        if (c < 128) {
          p2++;
        } else if (c < 2048) {
          p2 += 2;
        } else if (c >= 55296 && c <= 56319) {
          p2 += 4;
          i2++;
        } else {
          p2 += 3;
        }
      }
      return p2;
    };
    var DEFAULT_INTERVAL_MILLIS = 1e3;
    var DEFAULT_BACKOFF_FACTOR = 2;
    var MAX_VALUE_MILLIS2 = 4 * 60 * 60 * 1e3;
    var RANDOM_FACTOR = 0.5;
    function calculateBackoffMillis(backoffCount, intervalMillis, backoffFactor) {
      if (intervalMillis === void 0) {
        intervalMillis = DEFAULT_INTERVAL_MILLIS;
      }
      if (backoffFactor === void 0) {
        backoffFactor = DEFAULT_BACKOFF_FACTOR;
      }
      var currBaseValue = intervalMillis * Math.pow(backoffFactor, backoffCount);
      var randomWait = Math.round(
        // A fraction of the backoff value to add/subtract.
        // Deviation: changes multiplication order to improve readability.
        RANDOM_FACTOR * currBaseValue * // A random float (rounded to int by Math.round above) in the range [-1, 1]. Determines
        // if we add or subtract.
        (Math.random() - 0.5) * 2
      );
      return Math.min(MAX_VALUE_MILLIS2, currBaseValue + randomWait);
    }
    exports.CONSTANTS = CONSTANTS;
    exports.Deferred = Deferred2;
    exports.ErrorFactory = ErrorFactory2;
    exports.FirebaseError = FirebaseError2;
    exports.MAX_VALUE_MILLIS = MAX_VALUE_MILLIS2;
    exports.RANDOM_FACTOR = RANDOM_FACTOR;
    exports.Sha1 = Sha12;
    exports.areCookiesEnabled = areCookiesEnabled;
    exports.assert = assert;
    exports.assertionError = assertionError;
    exports.async = async3;
    exports.base64 = base64;
    exports.base64Decode = base64Decode;
    exports.base64Encode = base64Encode;
    exports.calculateBackoffMillis = calculateBackoffMillis;
    exports.contains = contains;
    exports.createSubscribe = createSubscribe;
    exports.decode = decode;
    exports.deepCopy = deepCopy;
    exports.deepExtend = deepExtend;
    exports.errorPrefix = errorPrefix;
    exports.getUA = getUA2;
    exports.isAdmin = isAdmin;
    exports.isBrowser = isBrowser2;
    exports.isBrowserExtension = isBrowserExtension2;
    exports.isElectron = isElectron2;
    exports.isEmpty = isEmpty;
    exports.isIE = isIE3;
    exports.isIndexedDBAvailable = isIndexedDBAvailable;
    exports.isMobileCordova = isMobileCordova2;
    exports.isNode = isNode;
    exports.isNodeSdk = isNodeSdk;
    exports.isReactNative = isReactNative2;
    exports.isSafari = isSafari;
    exports.isUWP = isUWP2;
    exports.isValidFormat = isValidFormat;
    exports.isValidTimestamp = isValidTimestamp;
    exports.issuedAtTime = issuedAtTime;
    exports.jsonEval = jsonEval;
    exports.map = map3;
    exports.querystring = querystring;
    exports.querystringDecode = querystringDecode;
    exports.safeGet = safeGet;
    exports.stringLength = stringLength;
    exports.stringToByteArray = stringToByteArray$1;
    exports.stringify = stringify;
    exports.validateArgCount = validateArgCount;
    exports.validateCallback = validateCallback;
    exports.validateContextObject = validateContextObject;
    exports.validateIndexedDBOpenable = validateIndexedDBOpenable;
    exports.validateNamespace = validateNamespace;
  }
});

// node_modules/ng-fire-admin/node_modules/@firebase/component/dist/index.cjs.js
var require_index_cjs2 = __commonJS({
  "node_modules/ng-fire-admin/node_modules/@firebase/component/dist/index.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var util = require_index_cjs();
    var Component3 = (
      /** @class */
      function() {
        function Component4(name4, instanceFactory, type) {
          this.name = name4;
          this.instanceFactory = instanceFactory;
          this.type = type;
          this.multipleInstances = false;
          this.serviceProps = {};
          this.instantiationMode = "LAZY";
        }
        Component4.prototype.setInstantiationMode = function(mode) {
          this.instantiationMode = mode;
          return this;
        };
        Component4.prototype.setMultipleInstances = function(multipleInstances) {
          this.multipleInstances = multipleInstances;
          return this;
        };
        Component4.prototype.setServiceProps = function(props) {
          this.serviceProps = props;
          return this;
        };
        return Component4;
      }()
    );
    var DEFAULT_ENTRY_NAME2 = "[DEFAULT]";
    var Provider2 = (
      /** @class */
      function() {
        function Provider3(name4, container) {
          this.name = name4;
          this.container = container;
          this.component = null;
          this.instances = /* @__PURE__ */ new Map();
          this.instancesDeferred = /* @__PURE__ */ new Map();
        }
        Provider3.prototype.get = function(identifier) {
          if (identifier === void 0) {
            identifier = DEFAULT_ENTRY_NAME2;
          }
          var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
          if (!this.instancesDeferred.has(normalizedIdentifier)) {
            var deferred = new util.Deferred();
            this.instancesDeferred.set(normalizedIdentifier, deferred);
            try {
              var instance = this.getOrInitializeService(normalizedIdentifier);
              if (instance) {
                deferred.resolve(instance);
              }
            } catch (e) {
            }
          }
          return this.instancesDeferred.get(normalizedIdentifier).promise;
        };
        Provider3.prototype.getImmediate = function(options) {
          var _a3 = tslib.__assign({ identifier: DEFAULT_ENTRY_NAME2, optional: false }, options), identifier = _a3.identifier, optional = _a3.optional;
          var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
          try {
            var instance = this.getOrInitializeService(normalizedIdentifier);
            if (!instance) {
              if (optional) {
                return null;
              }
              throw Error("Service " + this.name + " is not available");
            }
            return instance;
          } catch (e) {
            if (optional) {
              return null;
            } else {
              throw e;
            }
          }
        };
        Provider3.prototype.getComponent = function() {
          return this.component;
        };
        Provider3.prototype.setComponent = function(component) {
          var e_1, _a3;
          if (component.name !== this.name) {
            throw Error("Mismatching Component " + component.name + " for Provider " + this.name + ".");
          }
          if (this.component) {
            throw Error("Component for " + this.name + " has already been provided");
          }
          this.component = component;
          if (isComponentEager2(component)) {
            try {
              this.getOrInitializeService(DEFAULT_ENTRY_NAME2);
            } catch (e) {
            }
          }
          try {
            for (var _b = tslib.__values(this.instancesDeferred.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
              var _d = tslib.__read(_c.value, 2), instanceIdentifier = _d[0], instanceDeferred = _d[1];
              var normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
              try {
                var instance = this.getOrInitializeService(normalizedIdentifier);
                instanceDeferred.resolve(instance);
              } catch (e) {
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a3 = _b.return))
                _a3.call(_b);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        };
        Provider3.prototype.clearInstance = function(identifier) {
          if (identifier === void 0) {
            identifier = DEFAULT_ENTRY_NAME2;
          }
          this.instancesDeferred.delete(identifier);
          this.instances.delete(identifier);
        };
        Provider3.prototype.delete = function() {
          return tslib.__awaiter(this, void 0, void 0, function() {
            var services;
            return tslib.__generator(this, function(_a3) {
              switch (_a3.label) {
                case 0:
                  services = Array.from(this.instances.values());
                  return [4, Promise.all(tslib.__spread(services.filter(function(service) {
                    return "INTERNAL" in service;
                  }).map(function(service) {
                    return service.INTERNAL.delete();
                  }), services.filter(function(service) {
                    return "_delete" in service;
                  }).map(function(service) {
                    return service._delete();
                  })))];
                case 1:
                  _a3.sent();
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        Provider3.prototype.isComponentSet = function() {
          return this.component != null;
        };
        Provider3.prototype.getOrInitializeService = function(identifier) {
          var instance = this.instances.get(identifier);
          if (!instance && this.component) {
            instance = this.component.instanceFactory(this.container, normalizeIdentifierForFactory2(identifier));
            this.instances.set(identifier, instance);
          }
          return instance || null;
        };
        Provider3.prototype.normalizeInstanceIdentifier = function(identifier) {
          if (this.component) {
            return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME2;
          } else {
            return identifier;
          }
        };
        return Provider3;
      }()
    );
    function normalizeIdentifierForFactory2(identifier) {
      return identifier === DEFAULT_ENTRY_NAME2 ? void 0 : identifier;
    }
    function isComponentEager2(component) {
      return component.instantiationMode === "EAGER";
    }
    var ComponentContainer2 = (
      /** @class */
      function() {
        function ComponentContainer3(name4) {
          this.name = name4;
          this.providers = /* @__PURE__ */ new Map();
        }
        ComponentContainer3.prototype.addComponent = function(component) {
          var provider = this.getProvider(component.name);
          if (provider.isComponentSet()) {
            throw new Error("Component " + component.name + " has already been registered with " + this.name);
          }
          provider.setComponent(component);
        };
        ComponentContainer3.prototype.addOrOverwriteComponent = function(component) {
          var provider = this.getProvider(component.name);
          if (provider.isComponentSet()) {
            this.providers.delete(component.name);
          }
          this.addComponent(component);
        };
        ComponentContainer3.prototype.getProvider = function(name4) {
          if (this.providers.has(name4)) {
            return this.providers.get(name4);
          }
          var provider = new Provider2(name4, this);
          this.providers.set(name4, provider);
          return provider;
        };
        ComponentContainer3.prototype.getProviders = function() {
          return Array.from(this.providers.values());
        };
        return ComponentContainer3;
      }()
    );
    exports.Component = Component3;
    exports.ComponentContainer = ComponentContainer2;
    exports.Provider = Provider2;
  }
});

// node_modules/ng-fire-admin/node_modules/@firebase/logger/dist/index.esm.js
var index_esm_exports = {};
__export(index_esm_exports, {
  LogLevel: () => LogLevel,
  Logger: () => Logger,
  setLogLevel: () => setLogLevel,
  setUserLogHandler: () => setUserLogHandler
});
function __spreadArrays2() {
  for (var s = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
    s += arguments[i2].length;
  for (var r2 = Array(s), k3 = 0, i2 = 0; i2 < il; i2++)
    for (var a = arguments[i2], j2 = 0, jl = a.length; j2 < jl; j2++, k3++)
      r2[k3] = a[j2];
  return r2;
}
function setLogLevel(level) {
  instances.forEach(function(inst) {
    inst.setLogLevel(level);
  });
}
function setUserLogHandler(logCallback, options) {
  var _loop_1 = function(instance2) {
    var customLogLevel = null;
    if (options && options.level) {
      customLogLevel = levelStringToEnum[options.level];
    }
    if (logCallback === null) {
      instance2.userLogHandler = null;
    } else {
      instance2.userLogHandler = function(instance3, level) {
        var args = [];
        for (var _i3 = 2; _i3 < arguments.length; _i3++) {
          args[_i3 - 2] = arguments[_i3];
        }
        var message = args.map(function(arg) {
          if (arg == null) {
            return null;
          } else if (typeof arg === "string") {
            return arg;
          } else if (typeof arg === "number" || typeof arg === "boolean") {
            return arg.toString();
          } else if (arg instanceof Error) {
            return arg.message;
          } else {
            try {
              return JSON.stringify(arg);
            } catch (ignored) {
              return null;
            }
          }
        }).filter(function(arg) {
          return arg;
        }).join(" ");
        if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance3.logLevel)) {
          logCallback({
            level: LogLevel[level].toLowerCase(),
            message,
            args,
            type: instance3.name
          });
        }
      };
    }
  };
  for (var _i2 = 0, instances_1 = instances; _i2 < instances_1.length; _i2++) {
    var instance = instances_1[_i2];
    _loop_1(instance);
  }
}
var _a, instances, LogLevel, levelStringToEnum, defaultLogLevel, ConsoleMethod, defaultLogHandler, Logger;
var init_index_esm = __esm({
  "node_modules/ng-fire-admin/node_modules/@firebase/logger/dist/index.esm.js"() {
    instances = [];
    (function(LogLevel2) {
      LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
      LogLevel2[LogLevel2["VERBOSE"] = 1] = "VERBOSE";
      LogLevel2[LogLevel2["INFO"] = 2] = "INFO";
      LogLevel2[LogLevel2["WARN"] = 3] = "WARN";
      LogLevel2[LogLevel2["ERROR"] = 4] = "ERROR";
      LogLevel2[LogLevel2["SILENT"] = 5] = "SILENT";
    })(LogLevel || (LogLevel = {}));
    levelStringToEnum = {
      "debug": LogLevel.DEBUG,
      "verbose": LogLevel.VERBOSE,
      "info": LogLevel.INFO,
      "warn": LogLevel.WARN,
      "error": LogLevel.ERROR,
      "silent": LogLevel.SILENT
    };
    defaultLogLevel = LogLevel.INFO;
    ConsoleMethod = (_a = {}, _a[LogLevel.DEBUG] = "log", _a[LogLevel.VERBOSE] = "log", _a[LogLevel.INFO] = "info", _a[LogLevel.WARN] = "warn", _a[LogLevel.ERROR] = "error", _a);
    defaultLogHandler = function(instance, logType) {
      var args = [];
      for (var _i2 = 2; _i2 < arguments.length; _i2++) {
        args[_i2 - 2] = arguments[_i2];
      }
      if (logType < instance.logLevel) {
        return;
      }
      var now2 = (/* @__PURE__ */ new Date()).toISOString();
      var method = ConsoleMethod[logType];
      if (method) {
        console[method].apply(console, __spreadArrays2(["[" + now2 + "]  " + instance.name + ":"], args));
      } else {
        throw new Error("Attempted to log a message with an invalid logType (value: " + logType + ")");
      }
    };
    Logger = /** @class */
    function() {
      function Logger2(name4) {
        this.name = name4;
        this._logLevel = defaultLogLevel;
        this._logHandler = defaultLogHandler;
        this._userLogHandler = null;
        instances.push(this);
      }
      Object.defineProperty(Logger2.prototype, "logLevel", {
        get: function() {
          return this._logLevel;
        },
        set: function(val) {
          if (!(val in LogLevel)) {
            throw new TypeError('Invalid value "' + val + '" assigned to `logLevel`');
          }
          this._logLevel = val;
        },
        enumerable: false,
        configurable: true
      });
      Logger2.prototype.setLogLevel = function(val) {
        this._logLevel = typeof val === "string" ? levelStringToEnum[val] : val;
      };
      Object.defineProperty(Logger2.prototype, "logHandler", {
        get: function() {
          return this._logHandler;
        },
        set: function(val) {
          if (typeof val !== "function") {
            throw new TypeError("Value assigned to `logHandler` must be a function");
          }
          this._logHandler = val;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Logger2.prototype, "userLogHandler", {
        get: function() {
          return this._userLogHandler;
        },
        set: function(val) {
          this._userLogHandler = val;
        },
        enumerable: false,
        configurable: true
      });
      Logger2.prototype.debug = function() {
        var args = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          args[_i2] = arguments[_i2];
        }
        this._userLogHandler && this._userLogHandler.apply(this, __spreadArrays2([this, LogLevel.DEBUG], args));
        this._logHandler.apply(this, __spreadArrays2([this, LogLevel.DEBUG], args));
      };
      Logger2.prototype.log = function() {
        var args = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          args[_i2] = arguments[_i2];
        }
        this._userLogHandler && this._userLogHandler.apply(this, __spreadArrays2([this, LogLevel.VERBOSE], args));
        this._logHandler.apply(this, __spreadArrays2([this, LogLevel.VERBOSE], args));
      };
      Logger2.prototype.info = function() {
        var args = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          args[_i2] = arguments[_i2];
        }
        this._userLogHandler && this._userLogHandler.apply(this, __spreadArrays2([this, LogLevel.INFO], args));
        this._logHandler.apply(this, __spreadArrays2([this, LogLevel.INFO], args));
      };
      Logger2.prototype.warn = function() {
        var args = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          args[_i2] = arguments[_i2];
        }
        this._userLogHandler && this._userLogHandler.apply(this, __spreadArrays2([this, LogLevel.WARN], args));
        this._logHandler.apply(this, __spreadArrays2([this, LogLevel.WARN], args));
      };
      Logger2.prototype.error = function() {
        var args = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          args[_i2] = arguments[_i2];
        }
        this._userLogHandler && this._userLogHandler.apply(this, __spreadArrays2([this, LogLevel.ERROR], args));
        this._logHandler.apply(this, __spreadArrays2([this, LogLevel.ERROR], args));
      };
      return Logger2;
    }();
  }
});

// node_modules/ng-fire-admin/node_modules/@firebase/app/dist/index.cjs.js
var require_index_cjs3 = __commonJS({
  "node_modules/ng-fire-admin/node_modules/@firebase/app/dist/index.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var util = require_index_cjs();
    var component = require_index_cjs2();
    var logger$1 = (init_index_esm(), __toCommonJS(index_esm_exports));
    var _a3;
    var ERRORS = (_a3 = {}, _a3[
      "no-app"
      /* NO_APP */
    ] = "No Firebase App '{$appName}' has been created - call Firebase App.initializeApp()", _a3[
      "bad-app-name"
      /* BAD_APP_NAME */
    ] = "Illegal App name: '{$appName}", _a3[
      "duplicate-app"
      /* DUPLICATE_APP */
    ] = "Firebase App named '{$appName}' already exists", _a3[
      "app-deleted"
      /* APP_DELETED */
    ] = "Firebase App named '{$appName}' already deleted", _a3[
      "invalid-app-argument"
      /* INVALID_APP_ARGUMENT */
    ] = "firebase.{$appName}() takes either no argument or a Firebase App instance.", _a3[
      "invalid-log-argument"
      /* INVALID_LOG_ARGUMENT */
    ] = "First argument to `onLog` must be null or a function.", _a3);
    var ERROR_FACTORY = new util.ErrorFactory("app", "Firebase", ERRORS);
    var name$1 = "@firebase/app";
    var version3 = "0.6.11";
    var name$2 = "@firebase/analytics";
    var name$3 = "@firebase/auth";
    var name$4 = "@firebase/database";
    var name$5 = "@firebase/functions";
    var name$6 = "@firebase/installations";
    var name$7 = "@firebase/messaging";
    var name$8 = "@firebase/performance";
    var name$9 = "@firebase/remote-config";
    var name$a = "@firebase/storage";
    var name$b = "@firebase/firestore";
    var name$c = "firebase-wrapper";
    var _a$1;
    var DEFAULT_ENTRY_NAME2 = "[DEFAULT]";
    var PLATFORM_LOG_STRING = (_a$1 = {}, _a$1[name$1] = "fire-core", _a$1[name$2] = "fire-analytics", _a$1[name$3] = "fire-auth", _a$1[name$4] = "fire-rtdb", _a$1[name$5] = "fire-fn", _a$1[name$6] = "fire-iid", _a$1[name$7] = "fire-fcm", _a$1[name$8] = "fire-perf", _a$1[name$9] = "fire-rc", _a$1[name$a] = "fire-gcs", _a$1[name$b] = "fire-fst", _a$1["fire-js"] = "fire-js", _a$1[name$c] = "fire-js-all", _a$1);
    var logger = new logger$1.Logger("@firebase/app");
    var FirebaseAppImpl = (
      /** @class */
      function() {
        function FirebaseAppImpl2(options, config2, firebase_) {
          var e_1, _a4;
          var _this = this;
          this.firebase_ = firebase_;
          this.isDeleted_ = false;
          this.name_ = config2.name;
          this.automaticDataCollectionEnabled_ = config2.automaticDataCollectionEnabled || false;
          this.options_ = util.deepCopy(options);
          this.container = new component.ComponentContainer(config2.name);
          this._addComponent(new component.Component(
            "app",
            function() {
              return _this;
            },
            "PUBLIC"
            /* PUBLIC */
          ));
          try {
            for (var _b = tslib.__values(this.firebase_.INTERNAL.components.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
              var component$1 = _c.value;
              this._addComponent(component$1);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a4 = _b.return))
                _a4.call(_b);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }
        Object.defineProperty(FirebaseAppImpl2.prototype, "automaticDataCollectionEnabled", {
          get: function() {
            this.checkDestroyed_();
            return this.automaticDataCollectionEnabled_;
          },
          set: function(val) {
            this.checkDestroyed_();
            this.automaticDataCollectionEnabled_ = val;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(FirebaseAppImpl2.prototype, "name", {
          get: function() {
            this.checkDestroyed_();
            return this.name_;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(FirebaseAppImpl2.prototype, "options", {
          get: function() {
            this.checkDestroyed_();
            return this.options_;
          },
          enumerable: false,
          configurable: true
        });
        FirebaseAppImpl2.prototype.delete = function() {
          var _this = this;
          return new Promise(function(resolve2) {
            _this.checkDestroyed_();
            resolve2();
          }).then(function() {
            _this.firebase_.INTERNAL.removeApp(_this.name_);
            return Promise.all(_this.container.getProviders().map(function(provider) {
              return provider.delete();
            }));
          }).then(function() {
            _this.isDeleted_ = true;
          });
        };
        FirebaseAppImpl2.prototype._getService = function(name4, instanceIdentifier) {
          if (instanceIdentifier === void 0) {
            instanceIdentifier = DEFAULT_ENTRY_NAME2;
          }
          this.checkDestroyed_();
          return this.container.getProvider(name4).getImmediate({
            identifier: instanceIdentifier
          });
        };
        FirebaseAppImpl2.prototype._removeServiceInstance = function(name4, instanceIdentifier) {
          if (instanceIdentifier === void 0) {
            instanceIdentifier = DEFAULT_ENTRY_NAME2;
          }
          this.container.getProvider(name4).clearInstance(instanceIdentifier);
        };
        FirebaseAppImpl2.prototype._addComponent = function(component2) {
          try {
            this.container.addComponent(component2);
          } catch (e) {
            logger.debug("Component " + component2.name + " failed to register with FirebaseApp " + this.name, e);
          }
        };
        FirebaseAppImpl2.prototype._addOrOverwriteComponent = function(component2) {
          this.container.addOrOverwriteComponent(component2);
        };
        FirebaseAppImpl2.prototype.checkDestroyed_ = function() {
          if (this.isDeleted_) {
            throw ERROR_FACTORY.create("app-deleted", { appName: this.name_ });
          }
        };
        return FirebaseAppImpl2;
      }()
    );
    FirebaseAppImpl.prototype.name && FirebaseAppImpl.prototype.options || FirebaseAppImpl.prototype.delete || console.log("dc");
    var version$1 = "7.20.0";
    function createFirebaseNamespaceCore(firebaseAppImpl) {
      var apps = {};
      var components = /* @__PURE__ */ new Map();
      var namespace = {
        // Hack to prevent Babel from modifying the object returned
        // as the firebase namespace.
        // @ts-ignore
        __esModule: true,
        initializeApp: initializeApp3,
        // @ts-ignore
        app,
        registerVersion,
        setLogLevel: logger$1.setLogLevel,
        onLog,
        // @ts-ignore
        apps: null,
        SDK_VERSION: version$1,
        INTERNAL: {
          registerComponent,
          removeApp,
          components,
          useAsService
        }
      };
      namespace["default"] = namespace;
      Object.defineProperty(namespace, "apps", {
        get: getApps2
      });
      function removeApp(name4) {
        delete apps[name4];
      }
      function app(name4) {
        name4 = name4 || DEFAULT_ENTRY_NAME2;
        if (!util.contains(apps, name4)) {
          throw ERROR_FACTORY.create("no-app", { appName: name4 });
        }
        return apps[name4];
      }
      app["App"] = firebaseAppImpl;
      function initializeApp3(options, rawConfig) {
        if (rawConfig === void 0) {
          rawConfig = {};
        }
        if (typeof rawConfig !== "object" || rawConfig === null) {
          var name_1 = rawConfig;
          rawConfig = { name: name_1 };
        }
        var config2 = rawConfig;
        if (config2.name === void 0) {
          config2.name = DEFAULT_ENTRY_NAME2;
        }
        var name4 = config2.name;
        if (typeof name4 !== "string" || !name4) {
          throw ERROR_FACTORY.create("bad-app-name", {
            appName: String(name4)
          });
        }
        if (util.contains(apps, name4)) {
          throw ERROR_FACTORY.create("duplicate-app", { appName: name4 });
        }
        var app2 = new firebaseAppImpl(options, config2, namespace);
        apps[name4] = app2;
        return app2;
      }
      function getApps2() {
        return Object.keys(apps).map(function(name4) {
          return apps[name4];
        });
      }
      function registerComponent(component2) {
        var e_1, _a4;
        var componentName = component2.name;
        if (components.has(componentName)) {
          logger.debug("There were multiple attempts to register component " + componentName + ".");
          return component2.type === "PUBLIC" ? (
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            namespace[componentName]
          ) : null;
        }
        components.set(componentName, component2);
        if (component2.type === "PUBLIC") {
          var serviceNamespace = function(appArg) {
            if (appArg === void 0) {
              appArg = app();
            }
            if (typeof appArg[componentName] !== "function") {
              throw ERROR_FACTORY.create("invalid-app-argument", {
                appName: componentName
              });
            }
            return appArg[componentName]();
          };
          if (component2.serviceProps !== void 0) {
            util.deepExtend(serviceNamespace, component2.serviceProps);
          }
          namespace[componentName] = serviceNamespace;
          firebaseAppImpl.prototype[componentName] = // TODO: The eslint disable can be removed and the 'ignoreRestArgs'
          // option added to the no-explicit-any rule when ESlint releases it.
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          function() {
            var args = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              args[_i2] = arguments[_i2];
            }
            var serviceFxn = this._getService.bind(this, componentName);
            return serviceFxn.apply(this, component2.multipleInstances ? args : []);
          };
        }
        try {
          for (var _b = tslib.__values(Object.keys(apps)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var appName = _c.value;
            apps[appName]._addComponent(component2);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a4 = _b.return))
              _a4.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return component2.type === "PUBLIC" ? (
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          namespace[componentName]
        ) : null;
      }
      function registerVersion(libraryKeyOrName, version4, variant) {
        var _a4;
        var library = (_a4 = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a4 !== void 0 ? _a4 : libraryKeyOrName;
        if (variant) {
          library += "-" + variant;
        }
        var libraryMismatch = library.match(/\s|\//);
        var versionMismatch = version4.match(/\s|\//);
        if (libraryMismatch || versionMismatch) {
          var warning = [
            'Unable to register library "' + library + '" with version "' + version4 + '":'
          ];
          if (libraryMismatch) {
            warning.push('library name "' + library + '" contains illegal characters (whitespace or "/")');
          }
          if (libraryMismatch && versionMismatch) {
            warning.push("and");
          }
          if (versionMismatch) {
            warning.push('version name "' + version4 + '" contains illegal characters (whitespace or "/")');
          }
          logger.warn(warning.join(" "));
          return;
        }
        registerComponent(new component.Component(
          library + "-version",
          function() {
            return { library, version: version4 };
          },
          "VERSION"
          /* VERSION */
        ));
      }
      function onLog(logCallback, options) {
        if (logCallback !== null && typeof logCallback !== "function") {
          throw ERROR_FACTORY.create("invalid-log-argument", {
            appName: name
          });
        }
        logger$1.setUserLogHandler(logCallback, options);
      }
      function useAsService(app2, name4) {
        if (name4 === "serverAuth") {
          return null;
        }
        var useService = name4;
        return useService;
      }
      return namespace;
    }
    function createFirebaseNamespace() {
      var namespace = createFirebaseNamespaceCore(FirebaseAppImpl);
      namespace.INTERNAL = tslib.__assign(tslib.__assign({}, namespace.INTERNAL), {
        createFirebaseNamespace,
        extendNamespace,
        createSubscribe: util.createSubscribe,
        ErrorFactory: util.ErrorFactory,
        deepExtend: util.deepExtend
      });
      function extendNamespace(props) {
        util.deepExtend(namespace, props);
      }
      return namespace;
    }
    var firebase5 = createFirebaseNamespace();
    var PlatformLoggerService = (
      /** @class */
      function() {
        function PlatformLoggerService2(container) {
          this.container = container;
        }
        PlatformLoggerService2.prototype.getPlatformInfoString = function() {
          var providers = this.container.getProviders();
          return providers.map(function(provider) {
            if (isVersionServiceProvider(provider)) {
              var service = provider.getImmediate();
              return service.library + "/" + service.version;
            } else {
              return null;
            }
          }).filter(function(logString) {
            return logString;
          }).join(" ");
        };
        return PlatformLoggerService2;
      }()
    );
    function isVersionServiceProvider(provider) {
      var component2 = provider.getComponent();
      return (component2 === null || component2 === void 0 ? void 0 : component2.type) === "VERSION";
    }
    function registerCoreComponents(firebase6, variant) {
      firebase6.INTERNAL.registerComponent(new component.Component(
        "platform-logger",
        function(container) {
          return new PlatformLoggerService(container);
        },
        "PRIVATE"
        /* PRIVATE */
      ));
      firebase6.registerVersion(name$1, version3, variant);
      firebase6.registerVersion("fire-js", "");
    }
    if (util.isBrowser() && self.firebase !== void 0) {
      logger.warn("\n    Warning: Firebase is already defined in the global scope. Please make sure\n    Firebase library is only loaded once.\n  ");
      sdkVersion = self.firebase.SDK_VERSION;
      if (sdkVersion && sdkVersion.indexOf("LITE") >= 0) {
        logger.warn("\n    Warning: You are trying to load Firebase while using Firebase Performance standalone script.\n    You should load Firebase Performance with this instance of Firebase to avoid loading duplicate code.\n    ");
      }
    }
    var sdkVersion;
    var initializeApp2 = firebase5.initializeApp;
    firebase5.initializeApp = function() {
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      if (util.isNode()) {
        logger.warn(`
      Warning: This is a browser-targeted Firebase bundle but it appears it is being
      run in a Node environment.  If running in a Node environment, make sure you
      are using the bundle specified by the "main" field in package.json.
      
      If you are using Webpack, you can specify "main" as the first item in
      "resolve.mainFields":
      https://webpack.js.org/configuration/resolve/#resolvemainfields
      
      If using Rollup, use the rollup-plugin-node-resolve plugin and specify "main"
      as the first item in "mainFields", e.g. ['main', 'module'].
      https://github.com/rollup/rollup-plugin-node-resolve
      `);
      }
      return initializeApp2.apply(void 0, args);
    };
    var firebase$1 = firebase5;
    registerCoreComponents(firebase$1);
    exports.default = firebase$1;
    exports.firebase = firebase$1;
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:os
var require_os = __commonJS({
  "browser-external:os"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "os" has been externalized for browser compatibility. Cannot access "os.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:path
var require_path = __commonJS({
  "browser-external:path"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/firebase-admin/lib/utils/deep-copy.js
var require_deep_copy = __commonJS({
  "node_modules/firebase-admin/lib/utils/deep-copy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deepExtend = exports.deepCopy = void 0;
    function deepCopy(value) {
      return deepExtend(void 0, value);
    }
    exports.deepCopy = deepCopy;
    function deepExtend(target, source) {
      if (!(source instanceof Object)) {
        return source;
      }
      switch (source.constructor) {
        case Date: {
          const dateValue = source;
          return new Date(dateValue.getTime());
        }
        case Object:
          if (target === void 0) {
            target = {};
          }
          break;
        case Array:
          target = [];
          break;
        default:
          return source;
      }
      for (const prop in source) {
        if (!Object.prototype.hasOwnProperty.call(source, prop)) {
          continue;
        }
        target[prop] = deepExtend(target[prop], source[prop]);
      }
      return target;
    }
    exports.deepExtend = deepExtend;
  }
});

// node_modules/firebase-admin/lib/utils/error.js
var require_error = __commonJS({
  "node_modules/firebase-admin/lib/utils/error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InstanceIdClientErrorCode = exports.InstallationsClientErrorCode = exports.MessagingClientErrorCode = exports.AuthClientErrorCode = exports.AppErrorCodes = exports.FirebaseProjectManagementError = exports.FirebaseMessagingError = exports.FirebaseInstallationsError = exports.FirebaseInstanceIdError = exports.FirebaseFirestoreError = exports.FirebaseDatabaseError = exports.FirebaseAuthError = exports.FirebaseAppError = exports.PrefixedFirebaseError = exports.FirebaseError = void 0;
    var deep_copy_1 = require_deep_copy();
    var FirebaseError2 = class _FirebaseError extends Error {
      constructor(errorInfo) {
        super(errorInfo.message);
        this.errorInfo = errorInfo;
        this.__proto__ = _FirebaseError.prototype;
      }
      /** @returns The error code. */
      get code() {
        return this.errorInfo.code;
      }
      /** @returns The error message. */
      get message() {
        return this.errorInfo.message;
      }
      /** @returns The object representation of the error. */
      toJSON() {
        return {
          code: this.code,
          message: this.message
        };
      }
    };
    exports.FirebaseError = FirebaseError2;
    var PrefixedFirebaseError = class _PrefixedFirebaseError extends FirebaseError2 {
      constructor(codePrefix, code, message) {
        super({
          code: `${codePrefix}/${code}`,
          message
        });
        this.codePrefix = codePrefix;
        this.__proto__ = _PrefixedFirebaseError.prototype;
      }
      /**
       * Allows the error type to be checked without needing to know implementation details
       * of the code prefixing.
       *
       * @param code - The non-prefixed error code to test against.
       * @returns True if the code matches, false otherwise.
       */
      hasCode(code) {
        return `${this.codePrefix}/${code}` === this.code;
      }
    };
    exports.PrefixedFirebaseError = PrefixedFirebaseError;
    var FirebaseAppError = class _FirebaseAppError extends PrefixedFirebaseError {
      constructor(code, message) {
        super("app", code, message);
        this.__proto__ = _FirebaseAppError.prototype;
      }
    };
    exports.FirebaseAppError = FirebaseAppError;
    var FirebaseAuthError = class _FirebaseAuthError extends PrefixedFirebaseError {
      /**
       * Creates the developer-facing error corresponding to the backend error code.
       *
       * @param serverErrorCode - The server error code.
       * @param [message] The error message. The default message is used
       *     if not provided.
       * @param [rawServerResponse] The error's raw server response.
       * @returns The corresponding developer-facing error.
       */
      static fromServerError(serverErrorCode, message, rawServerResponse) {
        const colonSeparator = (serverErrorCode || "").indexOf(":");
        let customMessage = null;
        if (colonSeparator !== -1) {
          customMessage = serverErrorCode.substring(colonSeparator + 1).trim();
          serverErrorCode = serverErrorCode.substring(0, colonSeparator).trim();
        }
        const clientCodeKey = AUTH_SERVER_TO_CLIENT_CODE[serverErrorCode] || "INTERNAL_ERROR";
        const error = (0, deep_copy_1.deepCopy)(AuthClientErrorCode[clientCodeKey]);
        error.message = customMessage || message || error.message;
        if (clientCodeKey === "INTERNAL_ERROR" && typeof rawServerResponse !== "undefined") {
          try {
            error.message += ` Raw server response: "${JSON.stringify(rawServerResponse)}"`;
          } catch (e) {
          }
        }
        return new _FirebaseAuthError(error);
      }
      constructor(info, message) {
        super("auth", info.code, message || info.message);
        this.__proto__ = _FirebaseAuthError.prototype;
      }
    };
    exports.FirebaseAuthError = FirebaseAuthError;
    var FirebaseDatabaseError = class extends FirebaseError2 {
      constructor(info, message) {
        super({ code: "database/" + info.code, message: message || info.message });
      }
    };
    exports.FirebaseDatabaseError = FirebaseDatabaseError;
    var FirebaseFirestoreError = class extends FirebaseError2 {
      constructor(info, message) {
        super({ code: "firestore/" + info.code, message: message || info.message });
      }
    };
    exports.FirebaseFirestoreError = FirebaseFirestoreError;
    var FirebaseInstanceIdError = class _FirebaseInstanceIdError extends FirebaseError2 {
      constructor(info, message) {
        super({ code: "instance-id/" + info.code, message: message || info.message });
        this.__proto__ = _FirebaseInstanceIdError.prototype;
      }
    };
    exports.FirebaseInstanceIdError = FirebaseInstanceIdError;
    var FirebaseInstallationsError = class _FirebaseInstallationsError extends FirebaseError2 {
      constructor(info, message) {
        super({ code: "installations/" + info.code, message: message || info.message });
        this.__proto__ = _FirebaseInstallationsError.prototype;
      }
    };
    exports.FirebaseInstallationsError = FirebaseInstallationsError;
    var FirebaseMessagingError = class _FirebaseMessagingError extends PrefixedFirebaseError {
      /**
       * Creates the developer-facing error corresponding to the backend error code.
       *
       * @param serverErrorCode - The server error code.
       * @param [message] The error message. The default message is used
       *     if not provided.
       * @param [rawServerResponse] The error's raw server response.
       * @returns The corresponding developer-facing error.
       */
      static fromServerError(serverErrorCode, message, rawServerResponse) {
        let clientCodeKey = "UNKNOWN_ERROR";
        if (serverErrorCode && serverErrorCode in MESSAGING_SERVER_TO_CLIENT_CODE) {
          clientCodeKey = MESSAGING_SERVER_TO_CLIENT_CODE[serverErrorCode];
        }
        const error = (0, deep_copy_1.deepCopy)(MessagingClientErrorCode[clientCodeKey]);
        error.message = message || error.message;
        if (clientCodeKey === "UNKNOWN_ERROR" && typeof rawServerResponse !== "undefined") {
          try {
            error.message += ` Raw server response: "${JSON.stringify(rawServerResponse)}"`;
          } catch (e) {
          }
        }
        return new _FirebaseMessagingError(error);
      }
      static fromTopicManagementServerError(serverErrorCode, message, rawServerResponse) {
        const clientCodeKey = TOPIC_MGT_SERVER_TO_CLIENT_CODE[serverErrorCode] || "UNKNOWN_ERROR";
        const error = (0, deep_copy_1.deepCopy)(MessagingClientErrorCode[clientCodeKey]);
        error.message = message || error.message;
        if (clientCodeKey === "UNKNOWN_ERROR" && typeof rawServerResponse !== "undefined") {
          try {
            error.message += ` Raw server response: "${JSON.stringify(rawServerResponse)}"`;
          } catch (e) {
          }
        }
        return new _FirebaseMessagingError(error);
      }
      constructor(info, message) {
        super("messaging", info.code, message || info.message);
        this.__proto__ = _FirebaseMessagingError.prototype;
      }
    };
    exports.FirebaseMessagingError = FirebaseMessagingError;
    var FirebaseProjectManagementError = class _FirebaseProjectManagementError extends PrefixedFirebaseError {
      constructor(code, message) {
        super("project-management", code, message);
        this.__proto__ = _FirebaseProjectManagementError.prototype;
      }
    };
    exports.FirebaseProjectManagementError = FirebaseProjectManagementError;
    var AppErrorCodes = class {
    };
    exports.AppErrorCodes = AppErrorCodes;
    AppErrorCodes.APP_DELETED = "app-deleted";
    AppErrorCodes.DUPLICATE_APP = "duplicate-app";
    AppErrorCodes.INVALID_ARGUMENT = "invalid-argument";
    AppErrorCodes.INTERNAL_ERROR = "internal-error";
    AppErrorCodes.INVALID_APP_NAME = "invalid-app-name";
    AppErrorCodes.INVALID_APP_OPTIONS = "invalid-app-options";
    AppErrorCodes.INVALID_CREDENTIAL = "invalid-credential";
    AppErrorCodes.NETWORK_ERROR = "network-error";
    AppErrorCodes.NETWORK_TIMEOUT = "network-timeout";
    AppErrorCodes.NO_APP = "no-app";
    AppErrorCodes.UNABLE_TO_PARSE_RESPONSE = "unable-to-parse-response";
    var AuthClientErrorCode = class {
    };
    exports.AuthClientErrorCode = AuthClientErrorCode;
    AuthClientErrorCode.AUTH_BLOCKING_TOKEN_EXPIRED = {
      code: "auth-blocking-token-expired",
      message: "The provided Firebase Auth Blocking token is expired."
    };
    AuthClientErrorCode.BILLING_NOT_ENABLED = {
      code: "billing-not-enabled",
      message: "Feature requires billing to be enabled."
    };
    AuthClientErrorCode.CLAIMS_TOO_LARGE = {
      code: "claims-too-large",
      message: "Developer claims maximum payload size exceeded."
    };
    AuthClientErrorCode.CONFIGURATION_EXISTS = {
      code: "configuration-exists",
      message: "A configuration already exists with the provided identifier."
    };
    AuthClientErrorCode.CONFIGURATION_NOT_FOUND = {
      code: "configuration-not-found",
      message: "There is no configuration corresponding to the provided identifier."
    };
    AuthClientErrorCode.ID_TOKEN_EXPIRED = {
      code: "id-token-expired",
      message: "The provided Firebase ID token is expired."
    };
    AuthClientErrorCode.INVALID_ARGUMENT = {
      code: "argument-error",
      message: "Invalid argument provided."
    };
    AuthClientErrorCode.INVALID_CONFIG = {
      code: "invalid-config",
      message: "The provided configuration is invalid."
    };
    AuthClientErrorCode.EMAIL_ALREADY_EXISTS = {
      code: "email-already-exists",
      message: "The email address is already in use by another account."
    };
    AuthClientErrorCode.EMAIL_NOT_FOUND = {
      code: "email-not-found",
      message: "There is no user record corresponding to the provided email."
    };
    AuthClientErrorCode.FORBIDDEN_CLAIM = {
      code: "reserved-claim",
      message: "The specified developer claim is reserved and cannot be specified."
    };
    AuthClientErrorCode.INVALID_ID_TOKEN = {
      code: "invalid-id-token",
      message: "The provided ID token is not a valid Firebase ID token."
    };
    AuthClientErrorCode.ID_TOKEN_REVOKED = {
      code: "id-token-revoked",
      message: "The Firebase ID token has been revoked."
    };
    AuthClientErrorCode.INTERNAL_ERROR = {
      code: "internal-error",
      message: "An internal error has occurred."
    };
    AuthClientErrorCode.INVALID_CLAIMS = {
      code: "invalid-claims",
      message: "The provided custom claim attributes are invalid."
    };
    AuthClientErrorCode.INVALID_CONTINUE_URI = {
      code: "invalid-continue-uri",
      message: "The continue URL must be a valid URL string."
    };
    AuthClientErrorCode.INVALID_CREATION_TIME = {
      code: "invalid-creation-time",
      message: "The creation time must be a valid UTC date string."
    };
    AuthClientErrorCode.INVALID_CREDENTIAL = {
      code: "invalid-credential",
      message: "Invalid credential object provided."
    };
    AuthClientErrorCode.INVALID_DISABLED_FIELD = {
      code: "invalid-disabled-field",
      message: "The disabled field must be a boolean."
    };
    AuthClientErrorCode.INVALID_DISPLAY_NAME = {
      code: "invalid-display-name",
      message: "The displayName field must be a valid string."
    };
    AuthClientErrorCode.INVALID_DYNAMIC_LINK_DOMAIN = {
      code: "invalid-dynamic-link-domain",
      message: "The provided dynamic link domain is not configured or authorized for the current project."
    };
    AuthClientErrorCode.INVALID_EMAIL_VERIFIED = {
      code: "invalid-email-verified",
      message: "The emailVerified field must be a boolean."
    };
    AuthClientErrorCode.INVALID_EMAIL = {
      code: "invalid-email",
      message: "The email address is improperly formatted."
    };
    AuthClientErrorCode.INVALID_NEW_EMAIL = {
      code: "invalid-new-email",
      message: "The new email address is improperly formatted."
    };
    AuthClientErrorCode.INVALID_ENROLLED_FACTORS = {
      code: "invalid-enrolled-factors",
      message: "The enrolled factors must be a valid array of MultiFactorInfo objects."
    };
    AuthClientErrorCode.INVALID_ENROLLMENT_TIME = {
      code: "invalid-enrollment-time",
      message: "The second factor enrollment time must be a valid UTC date string."
    };
    AuthClientErrorCode.INVALID_HASH_ALGORITHM = {
      code: "invalid-hash-algorithm",
      message: "The hash algorithm must match one of the strings in the list of supported algorithms."
    };
    AuthClientErrorCode.INVALID_HASH_BLOCK_SIZE = {
      code: "invalid-hash-block-size",
      message: "The hash block size must be a valid number."
    };
    AuthClientErrorCode.INVALID_HASH_DERIVED_KEY_LENGTH = {
      code: "invalid-hash-derived-key-length",
      message: "The hash derived key length must be a valid number."
    };
    AuthClientErrorCode.INVALID_HASH_KEY = {
      code: "invalid-hash-key",
      message: "The hash key must a valid byte buffer."
    };
    AuthClientErrorCode.INVALID_HASH_MEMORY_COST = {
      code: "invalid-hash-memory-cost",
      message: "The hash memory cost must be a valid number."
    };
    AuthClientErrorCode.INVALID_HASH_PARALLELIZATION = {
      code: "invalid-hash-parallelization",
      message: "The hash parallelization must be a valid number."
    };
    AuthClientErrorCode.INVALID_HASH_ROUNDS = {
      code: "invalid-hash-rounds",
      message: "The hash rounds must be a valid number."
    };
    AuthClientErrorCode.INVALID_HASH_SALT_SEPARATOR = {
      code: "invalid-hash-salt-separator",
      message: "The hashing algorithm salt separator field must be a valid byte buffer."
    };
    AuthClientErrorCode.INVALID_LAST_SIGN_IN_TIME = {
      code: "invalid-last-sign-in-time",
      message: "The last sign-in time must be a valid UTC date string."
    };
    AuthClientErrorCode.INVALID_NAME = {
      code: "invalid-name",
      message: "The resource name provided is invalid."
    };
    AuthClientErrorCode.INVALID_OAUTH_CLIENT_ID = {
      code: "invalid-oauth-client-id",
      message: "The provided OAuth client ID is invalid."
    };
    AuthClientErrorCode.INVALID_PAGE_TOKEN = {
      code: "invalid-page-token",
      message: "The page token must be a valid non-empty string."
    };
    AuthClientErrorCode.INVALID_PASSWORD = {
      code: "invalid-password",
      message: "The password must be a string with at least 6 characters."
    };
    AuthClientErrorCode.INVALID_PASSWORD_HASH = {
      code: "invalid-password-hash",
      message: "The password hash must be a valid byte buffer."
    };
    AuthClientErrorCode.INVALID_PASSWORD_SALT = {
      code: "invalid-password-salt",
      message: "The password salt must be a valid byte buffer."
    };
    AuthClientErrorCode.INVALID_PHONE_NUMBER = {
      code: "invalid-phone-number",
      message: "The phone number must be a non-empty E.164 standard compliant identifier string."
    };
    AuthClientErrorCode.INVALID_PHOTO_URL = {
      code: "invalid-photo-url",
      message: "The photoURL field must be a valid URL."
    };
    AuthClientErrorCode.INVALID_PROJECT_ID = {
      code: "invalid-project-id",
      message: "Invalid parent project. Either parent project doesn't exist or didn't enable multi-tenancy."
    };
    AuthClientErrorCode.INVALID_PROVIDER_DATA = {
      code: "invalid-provider-data",
      message: "The providerData must be a valid array of UserInfo objects."
    };
    AuthClientErrorCode.INVALID_PROVIDER_ID = {
      code: "invalid-provider-id",
      message: "The providerId must be a valid supported provider identifier string."
    };
    AuthClientErrorCode.INVALID_PROVIDER_UID = {
      code: "invalid-provider-uid",
      message: "The providerUid must be a valid provider uid string."
    };
    AuthClientErrorCode.INVALID_OAUTH_RESPONSETYPE = {
      code: "invalid-oauth-responsetype",
      message: "Only exactly one OAuth responseType should be set to true."
    };
    AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION = {
      code: "invalid-session-cookie-duration",
      message: "The session cookie duration must be a valid number in milliseconds between 5 minutes and 2 weeks."
    };
    AuthClientErrorCode.INVALID_TENANT_ID = {
      code: "invalid-tenant-id",
      message: "The tenant ID must be a valid non-empty string."
    };
    AuthClientErrorCode.INVALID_TENANT_TYPE = {
      code: "invalid-tenant-type",
      message: 'Tenant type must be either "full_service" or "lightweight".'
    };
    AuthClientErrorCode.INVALID_TESTING_PHONE_NUMBER = {
      code: "invalid-testing-phone-number",
      message: "Invalid testing phone number or invalid test code provided."
    };
    AuthClientErrorCode.INVALID_UID = {
      code: "invalid-uid",
      message: "The uid must be a non-empty string with at most 128 characters."
    };
    AuthClientErrorCode.INVALID_USER_IMPORT = {
      code: "invalid-user-import",
      message: "The user record to import is invalid."
    };
    AuthClientErrorCode.INVALID_TOKENS_VALID_AFTER_TIME = {
      code: "invalid-tokens-valid-after-time",
      message: "The tokensValidAfterTime must be a valid UTC number in seconds."
    };
    AuthClientErrorCode.MISMATCHING_TENANT_ID = {
      code: "mismatching-tenant-id",
      message: "User tenant ID does not match with the current TenantAwareAuth tenant ID."
    };
    AuthClientErrorCode.MISSING_ANDROID_PACKAGE_NAME = {
      code: "missing-android-pkg-name",
      message: "An Android Package Name must be provided if the Android App is required to be installed."
    };
    AuthClientErrorCode.MISSING_CONFIG = {
      code: "missing-config",
      message: "The provided configuration is missing required attributes."
    };
    AuthClientErrorCode.MISSING_CONTINUE_URI = {
      code: "missing-continue-uri",
      message: "A valid continue URL must be provided in the request."
    };
    AuthClientErrorCode.MISSING_DISPLAY_NAME = {
      code: "missing-display-name",
      message: "The resource being created or edited is missing a valid display name."
    };
    AuthClientErrorCode.MISSING_EMAIL = {
      code: "missing-email",
      message: "The email is required for the specified action. For example, a multi-factor user requires a verified email."
    };
    AuthClientErrorCode.MISSING_IOS_BUNDLE_ID = {
      code: "missing-ios-bundle-id",
      message: "The request is missing an iOS Bundle ID."
    };
    AuthClientErrorCode.MISSING_ISSUER = {
      code: "missing-issuer",
      message: "The OAuth/OIDC configuration issuer must not be empty."
    };
    AuthClientErrorCode.MISSING_HASH_ALGORITHM = {
      code: "missing-hash-algorithm",
      message: "Importing users with password hashes requires that the hashing algorithm and its parameters be provided."
    };
    AuthClientErrorCode.MISSING_OAUTH_CLIENT_ID = {
      code: "missing-oauth-client-id",
      message: "The OAuth/OIDC configuration client ID must not be empty."
    };
    AuthClientErrorCode.MISSING_OAUTH_CLIENT_SECRET = {
      code: "missing-oauth-client-secret",
      message: "The OAuth configuration client secret is required to enable OIDC code flow."
    };
    AuthClientErrorCode.MISSING_PROVIDER_ID = {
      code: "missing-provider-id",
      message: "A valid provider ID must be provided in the request."
    };
    AuthClientErrorCode.MISSING_SAML_RELYING_PARTY_CONFIG = {
      code: "missing-saml-relying-party-config",
      message: "The SAML configuration provided is missing a relying party configuration."
    };
    AuthClientErrorCode.MAXIMUM_TEST_PHONE_NUMBER_EXCEEDED = {
      code: "test-phone-number-limit-exceeded",
      message: "The maximum allowed number of test phone number / code pairs has been exceeded."
    };
    AuthClientErrorCode.MAXIMUM_USER_COUNT_EXCEEDED = {
      code: "maximum-user-count-exceeded",
      message: "The maximum allowed number of users to import has been exceeded."
    };
    AuthClientErrorCode.MISSING_UID = {
      code: "missing-uid",
      message: "A uid identifier is required for the current operation."
    };
    AuthClientErrorCode.OPERATION_NOT_ALLOWED = {
      code: "operation-not-allowed",
      message: "The given sign-in provider is disabled for this Firebase project. Enable it in the Firebase console, under the sign-in method tab of the Auth section."
    };
    AuthClientErrorCode.PHONE_NUMBER_ALREADY_EXISTS = {
      code: "phone-number-already-exists",
      message: "The user with the provided phone number already exists."
    };
    AuthClientErrorCode.PROJECT_NOT_FOUND = {
      code: "project-not-found",
      message: "No Firebase project was found for the provided credential."
    };
    AuthClientErrorCode.INSUFFICIENT_PERMISSION = {
      code: "insufficient-permission",
      message: 'Credential implementation provided to initializeApp() via the "credential" property has insufficient permission to access the requested resource. See https://firebase.google.com/docs/admin/setup for details on how to authenticate this SDK with appropriate permissions.'
    };
    AuthClientErrorCode.QUOTA_EXCEEDED = {
      code: "quota-exceeded",
      message: "The project quota for the specified operation has been exceeded."
    };
    AuthClientErrorCode.SECOND_FACTOR_LIMIT_EXCEEDED = {
      code: "second-factor-limit-exceeded",
      message: "The maximum number of allowed second factors on a user has been exceeded."
    };
    AuthClientErrorCode.SECOND_FACTOR_UID_ALREADY_EXISTS = {
      code: "second-factor-uid-already-exists",
      message: 'The specified second factor "uid" already exists.'
    };
    AuthClientErrorCode.SESSION_COOKIE_EXPIRED = {
      code: "session-cookie-expired",
      message: "The Firebase session cookie is expired."
    };
    AuthClientErrorCode.SESSION_COOKIE_REVOKED = {
      code: "session-cookie-revoked",
      message: "The Firebase session cookie has been revoked."
    };
    AuthClientErrorCode.TENANT_NOT_FOUND = {
      code: "tenant-not-found",
      message: "There is no tenant corresponding to the provided identifier."
    };
    AuthClientErrorCode.UID_ALREADY_EXISTS = {
      code: "uid-already-exists",
      message: "The user with the provided uid already exists."
    };
    AuthClientErrorCode.UNAUTHORIZED_DOMAIN = {
      code: "unauthorized-continue-uri",
      message: "The domain of the continue URL is not whitelisted. Whitelist the domain in the Firebase console."
    };
    AuthClientErrorCode.UNSUPPORTED_FIRST_FACTOR = {
      code: "unsupported-first-factor",
      message: "A multi-factor user requires a supported first factor."
    };
    AuthClientErrorCode.UNSUPPORTED_SECOND_FACTOR = {
      code: "unsupported-second-factor",
      message: "The request specified an unsupported type of second factor."
    };
    AuthClientErrorCode.UNSUPPORTED_TENANT_OPERATION = {
      code: "unsupported-tenant-operation",
      message: "This operation is not supported in a multi-tenant context."
    };
    AuthClientErrorCode.UNVERIFIED_EMAIL = {
      code: "unverified-email",
      message: "A verified email is required for the specified action. For example, a multi-factor user requires a verified email."
    };
    AuthClientErrorCode.USER_NOT_FOUND = {
      code: "user-not-found",
      message: "There is no user record corresponding to the provided identifier."
    };
    AuthClientErrorCode.NOT_FOUND = {
      code: "not-found",
      message: "The requested resource was not found."
    };
    AuthClientErrorCode.USER_DISABLED = {
      code: "user-disabled",
      message: "The user record is disabled."
    };
    AuthClientErrorCode.USER_NOT_DISABLED = {
      code: "user-not-disabled",
      message: "The user must be disabled in order to bulk delete it (or you must pass force=true)."
    };
    AuthClientErrorCode.INVALID_RECAPTCHA_ACTION = {
      code: "invalid-recaptcha-action",
      message: 'reCAPTCHA action must be "BLOCK".'
    };
    AuthClientErrorCode.INVALID_RECAPTCHA_ENFORCEMENT_STATE = {
      code: "invalid-recaptcha-enforcement-state",
      message: 'reCAPTCHA enforcement state must be either "OFF", "AUDIT" or "ENFORCE".'
    };
    AuthClientErrorCode.RECAPTCHA_NOT_ENABLED = {
      code: "racaptcha-not-enabled",
      message: "reCAPTCHA enterprise is not enabled."
    };
    var MessagingClientErrorCode = class {
    };
    exports.MessagingClientErrorCode = MessagingClientErrorCode;
    MessagingClientErrorCode.INVALID_ARGUMENT = {
      code: "invalid-argument",
      message: "Invalid argument provided."
    };
    MessagingClientErrorCode.INVALID_RECIPIENT = {
      code: "invalid-recipient",
      message: "Invalid message recipient provided."
    };
    MessagingClientErrorCode.INVALID_PAYLOAD = {
      code: "invalid-payload",
      message: "Invalid message payload provided."
    };
    MessagingClientErrorCode.INVALID_DATA_PAYLOAD_KEY = {
      code: "invalid-data-payload-key",
      message: "The data message payload contains an invalid key. See the reference documentation for the DataMessagePayload type for restricted keys."
    };
    MessagingClientErrorCode.PAYLOAD_SIZE_LIMIT_EXCEEDED = {
      code: "payload-size-limit-exceeded",
      message: "The provided message payload exceeds the FCM size limits. See the error documentation for more details."
    };
    MessagingClientErrorCode.INVALID_OPTIONS = {
      code: "invalid-options",
      message: "Invalid message options provided."
    };
    MessagingClientErrorCode.INVALID_REGISTRATION_TOKEN = {
      code: "invalid-registration-token",
      message: "Invalid registration token provided. Make sure it matches the registration token the client app receives from registering with FCM."
    };
    MessagingClientErrorCode.REGISTRATION_TOKEN_NOT_REGISTERED = {
      code: "registration-token-not-registered",
      message: "The provided registration token is not registered. A previously valid registration token can be unregistered for a variety of reasons. See the error documentation for more details. Remove this registration token and stop using it to send messages."
    };
    MessagingClientErrorCode.MISMATCHED_CREDENTIAL = {
      code: "mismatched-credential",
      message: "The credential used to authenticate this SDK does not have permission to send messages to the device corresponding to the provided registration token. Make sure the credential and registration token both belong to the same Firebase project."
    };
    MessagingClientErrorCode.INVALID_PACKAGE_NAME = {
      code: "invalid-package-name",
      message: 'The message was addressed to a registration token whose package name does not match the provided "restrictedPackageName" option.'
    };
    MessagingClientErrorCode.DEVICE_MESSAGE_RATE_EXCEEDED = {
      code: "device-message-rate-exceeded",
      message: "The rate of messages to a particular device is too high. Reduce the number of messages sent to this device and do not immediately retry sending to this device."
    };
    MessagingClientErrorCode.TOPICS_MESSAGE_RATE_EXCEEDED = {
      code: "topics-message-rate-exceeded",
      message: "The rate of messages to subscribers to a particular topic is too high. Reduce the number of messages sent for this topic, and do not immediately retry sending to this topic."
    };
    MessagingClientErrorCode.MESSAGE_RATE_EXCEEDED = {
      code: "message-rate-exceeded",
      message: "Sending limit exceeded for the message target."
    };
    MessagingClientErrorCode.THIRD_PARTY_AUTH_ERROR = {
      code: "third-party-auth-error",
      message: "A message targeted to an iOS device could not be sent because the required APNs SSL certificate was not uploaded or has expired. Check the validity of your development and production certificates."
    };
    MessagingClientErrorCode.TOO_MANY_TOPICS = {
      code: "too-many-topics",
      message: "The maximum number of topics the provided registration token can be subscribed to has been exceeded."
    };
    MessagingClientErrorCode.AUTHENTICATION_ERROR = {
      code: "authentication-error",
      message: "An error occurred when trying to authenticate to the FCM servers. Make sure the credential used to authenticate this SDK has the proper permissions. See https://firebase.google.com/docs/admin/setup for setup instructions."
    };
    MessagingClientErrorCode.SERVER_UNAVAILABLE = {
      code: "server-unavailable",
      message: "The FCM server could not process the request in time. See the error documentation for more details."
    };
    MessagingClientErrorCode.INTERNAL_ERROR = {
      code: "internal-error",
      message: "An internal error has occurred. Please retry the request."
    };
    MessagingClientErrorCode.UNKNOWN_ERROR = {
      code: "unknown-error",
      message: "An unknown server error was returned."
    };
    var InstallationsClientErrorCode = class {
    };
    exports.InstallationsClientErrorCode = InstallationsClientErrorCode;
    InstallationsClientErrorCode.INVALID_ARGUMENT = {
      code: "invalid-argument",
      message: "Invalid argument provided."
    };
    InstallationsClientErrorCode.INVALID_PROJECT_ID = {
      code: "invalid-project-id",
      message: "Invalid project ID provided."
    };
    InstallationsClientErrorCode.INVALID_INSTALLATION_ID = {
      code: "invalid-installation-id",
      message: "Invalid installation ID provided."
    };
    InstallationsClientErrorCode.API_ERROR = {
      code: "api-error",
      message: "Installation ID API call failed."
    };
    var InstanceIdClientErrorCode = class extends InstallationsClientErrorCode {
    };
    exports.InstanceIdClientErrorCode = InstanceIdClientErrorCode;
    InstanceIdClientErrorCode.INVALID_INSTANCE_ID = {
      code: "invalid-instance-id",
      message: "Invalid instance ID provided."
    };
    var AUTH_SERVER_TO_CLIENT_CODE = {
      // Feature being configured or used requires a billing account.
      BILLING_NOT_ENABLED: "BILLING_NOT_ENABLED",
      // Claims payload is too large.
      CLAIMS_TOO_LARGE: "CLAIMS_TOO_LARGE",
      // Configuration being added already exists.
      CONFIGURATION_EXISTS: "CONFIGURATION_EXISTS",
      // Configuration not found.
      CONFIGURATION_NOT_FOUND: "CONFIGURATION_NOT_FOUND",
      // Provided credential has insufficient permissions.
      INSUFFICIENT_PERMISSION: "INSUFFICIENT_PERMISSION",
      // Provided configuration has invalid fields.
      INVALID_CONFIG: "INVALID_CONFIG",
      // Provided configuration identifier is invalid.
      INVALID_CONFIG_ID: "INVALID_PROVIDER_ID",
      // ActionCodeSettings missing continue URL.
      INVALID_CONTINUE_URI: "INVALID_CONTINUE_URI",
      // Dynamic link domain in provided ActionCodeSettings is not authorized.
      INVALID_DYNAMIC_LINK_DOMAIN: "INVALID_DYNAMIC_LINK_DOMAIN",
      // uploadAccount provides an email that already exists.
      DUPLICATE_EMAIL: "EMAIL_ALREADY_EXISTS",
      // uploadAccount provides a localId that already exists.
      DUPLICATE_LOCAL_ID: "UID_ALREADY_EXISTS",
      // Request specified a multi-factor enrollment ID that already exists.
      DUPLICATE_MFA_ENROLLMENT_ID: "SECOND_FACTOR_UID_ALREADY_EXISTS",
      // setAccountInfo email already exists.
      EMAIL_EXISTS: "EMAIL_ALREADY_EXISTS",
      // /accounts:sendOobCode for password reset when user is not found.
      EMAIL_NOT_FOUND: "EMAIL_NOT_FOUND",
      // Reserved claim name.
      FORBIDDEN_CLAIM: "FORBIDDEN_CLAIM",
      // Invalid claims provided.
      INVALID_CLAIMS: "INVALID_CLAIMS",
      // Invalid session cookie duration.
      INVALID_DURATION: "INVALID_SESSION_COOKIE_DURATION",
      // Invalid email provided.
      INVALID_EMAIL: "INVALID_EMAIL",
      // Invalid new email provided.
      INVALID_NEW_EMAIL: "INVALID_NEW_EMAIL",
      // Invalid tenant display name. This can be thrown on CreateTenant and UpdateTenant.
      INVALID_DISPLAY_NAME: "INVALID_DISPLAY_NAME",
      // Invalid ID token provided.
      INVALID_ID_TOKEN: "INVALID_ID_TOKEN",
      // Invalid tenant/parent resource name.
      INVALID_NAME: "INVALID_NAME",
      // OIDC configuration has an invalid OAuth client ID.
      INVALID_OAUTH_CLIENT_ID: "INVALID_OAUTH_CLIENT_ID",
      // Invalid page token.
      INVALID_PAGE_SELECTION: "INVALID_PAGE_TOKEN",
      // Invalid phone number.
      INVALID_PHONE_NUMBER: "INVALID_PHONE_NUMBER",
      // Invalid agent project. Either agent project doesn't exist or didn't enable multi-tenancy.
      INVALID_PROJECT_ID: "INVALID_PROJECT_ID",
      // Invalid provider ID.
      INVALID_PROVIDER_ID: "INVALID_PROVIDER_ID",
      // Invalid service account.
      INVALID_SERVICE_ACCOUNT: "INVALID_SERVICE_ACCOUNT",
      // Invalid testing phone number.
      INVALID_TESTING_PHONE_NUMBER: "INVALID_TESTING_PHONE_NUMBER",
      // Invalid tenant type.
      INVALID_TENANT_TYPE: "INVALID_TENANT_TYPE",
      // Missing Android package name.
      MISSING_ANDROID_PACKAGE_NAME: "MISSING_ANDROID_PACKAGE_NAME",
      // Missing configuration.
      MISSING_CONFIG: "MISSING_CONFIG",
      // Missing configuration identifier.
      MISSING_CONFIG_ID: "MISSING_PROVIDER_ID",
      // Missing tenant display name: This can be thrown on CreateTenant and UpdateTenant.
      MISSING_DISPLAY_NAME: "MISSING_DISPLAY_NAME",
      // Email is required for the specified action. For example a multi-factor user requires
      // a verified email.
      MISSING_EMAIL: "MISSING_EMAIL",
      // Missing iOS bundle ID.
      MISSING_IOS_BUNDLE_ID: "MISSING_IOS_BUNDLE_ID",
      // Missing OIDC issuer.
      MISSING_ISSUER: "MISSING_ISSUER",
      // No localId provided (deleteAccount missing localId).
      MISSING_LOCAL_ID: "MISSING_UID",
      // OIDC configuration is missing an OAuth client ID.
      MISSING_OAUTH_CLIENT_ID: "MISSING_OAUTH_CLIENT_ID",
      // Missing provider ID.
      MISSING_PROVIDER_ID: "MISSING_PROVIDER_ID",
      // Missing SAML RP config.
      MISSING_SAML_RELYING_PARTY_CONFIG: "MISSING_SAML_RELYING_PARTY_CONFIG",
      // Empty user list in uploadAccount.
      MISSING_USER_ACCOUNT: "MISSING_UID",
      // Password auth disabled in console.
      OPERATION_NOT_ALLOWED: "OPERATION_NOT_ALLOWED",
      // Provided credential has insufficient permissions.
      PERMISSION_DENIED: "INSUFFICIENT_PERMISSION",
      // Phone number already exists.
      PHONE_NUMBER_EXISTS: "PHONE_NUMBER_ALREADY_EXISTS",
      // Project not found.
      PROJECT_NOT_FOUND: "PROJECT_NOT_FOUND",
      // In multi-tenancy context: project creation quota exceeded.
      QUOTA_EXCEEDED: "QUOTA_EXCEEDED",
      // Currently only 5 second factors can be set on the same user.
      SECOND_FACTOR_LIMIT_EXCEEDED: "SECOND_FACTOR_LIMIT_EXCEEDED",
      // Tenant not found.
      TENANT_NOT_FOUND: "TENANT_NOT_FOUND",
      // Tenant ID mismatch.
      TENANT_ID_MISMATCH: "MISMATCHING_TENANT_ID",
      // Token expired error.
      TOKEN_EXPIRED: "ID_TOKEN_EXPIRED",
      // Continue URL provided in ActionCodeSettings has a domain that is not whitelisted.
      UNAUTHORIZED_DOMAIN: "UNAUTHORIZED_DOMAIN",
      // A multi-factor user requires a supported first factor.
      UNSUPPORTED_FIRST_FACTOR: "UNSUPPORTED_FIRST_FACTOR",
      // The request specified an unsupported type of second factor.
      UNSUPPORTED_SECOND_FACTOR: "UNSUPPORTED_SECOND_FACTOR",
      // Operation is not supported in a multi-tenant context.
      UNSUPPORTED_TENANT_OPERATION: "UNSUPPORTED_TENANT_OPERATION",
      // A verified email is required for the specified action. For example a multi-factor user
      // requires a verified email.
      UNVERIFIED_EMAIL: "UNVERIFIED_EMAIL",
      // User on which action is to be performed is not found.
      USER_NOT_FOUND: "USER_NOT_FOUND",
      // User record is disabled.
      USER_DISABLED: "USER_DISABLED",
      // Password provided is too weak.
      WEAK_PASSWORD: "INVALID_PASSWORD",
      // Unrecognized reCAPTCHA action.
      INVALID_RECAPTCHA_ACTION: "INVALID_RECAPTCHA_ACTION",
      // Unrecognized reCAPTCHA enforcement state.
      INVALID_RECAPTCHA_ENFORCEMENT_STATE: "INVALID_RECAPTCHA_ENFORCEMENT_STATE",
      // reCAPTCHA is not enabled for account defender.
      RECAPTCHA_NOT_ENABLED: "RECAPTCHA_NOT_ENABLED"
    };
    var MESSAGING_SERVER_TO_CLIENT_CODE = {
      /* GENERIC ERRORS */
      // Generic invalid message parameter provided.
      InvalidParameters: "INVALID_ARGUMENT",
      // Mismatched sender ID.
      MismatchSenderId: "MISMATCHED_CREDENTIAL",
      // FCM server unavailable.
      Unavailable: "SERVER_UNAVAILABLE",
      // FCM server internal error.
      InternalServerError: "INTERNAL_ERROR",
      /* SEND ERRORS */
      // Invalid registration token format.
      InvalidRegistration: "INVALID_REGISTRATION_TOKEN",
      // Registration token is not registered.
      NotRegistered: "REGISTRATION_TOKEN_NOT_REGISTERED",
      // Registration token does not match restricted package name.
      InvalidPackageName: "INVALID_PACKAGE_NAME",
      // Message payload size limit exceeded.
      MessageTooBig: "PAYLOAD_SIZE_LIMIT_EXCEEDED",
      // Invalid key in the data message payload.
      InvalidDataKey: "INVALID_DATA_PAYLOAD_KEY",
      // Invalid time to live option.
      InvalidTtl: "INVALID_OPTIONS",
      // Device message rate exceeded.
      DeviceMessageRateExceeded: "DEVICE_MESSAGE_RATE_EXCEEDED",
      // Topics message rate exceeded.
      TopicsMessageRateExceeded: "TOPICS_MESSAGE_RATE_EXCEEDED",
      // Invalid APNs credentials.
      InvalidApnsCredential: "THIRD_PARTY_AUTH_ERROR",
      /* FCM v1 canonical error codes */
      NOT_FOUND: "REGISTRATION_TOKEN_NOT_REGISTERED",
      PERMISSION_DENIED: "MISMATCHED_CREDENTIAL",
      RESOURCE_EXHAUSTED: "MESSAGE_RATE_EXCEEDED",
      UNAUTHENTICATED: "THIRD_PARTY_AUTH_ERROR",
      /* FCM v1 new error codes */
      APNS_AUTH_ERROR: "THIRD_PARTY_AUTH_ERROR",
      INTERNAL: "INTERNAL_ERROR",
      INVALID_ARGUMENT: "INVALID_ARGUMENT",
      QUOTA_EXCEEDED: "MESSAGE_RATE_EXCEEDED",
      SENDER_ID_MISMATCH: "MISMATCHED_CREDENTIAL",
      THIRD_PARTY_AUTH_ERROR: "THIRD_PARTY_AUTH_ERROR",
      UNAVAILABLE: "SERVER_UNAVAILABLE",
      UNREGISTERED: "REGISTRATION_TOKEN_NOT_REGISTERED",
      UNSPECIFIED_ERROR: "UNKNOWN_ERROR"
    };
    var TOPIC_MGT_SERVER_TO_CLIENT_CODE = {
      /* TOPIC SUBSCRIPTION MANAGEMENT ERRORS */
      NOT_FOUND: "REGISTRATION_TOKEN_NOT_REGISTERED",
      INVALID_ARGUMENT: "INVALID_REGISTRATION_TOKEN",
      TOO_MANY_TOPICS: "TOO_MANY_TOPICS",
      RESOURCE_EXHAUSTED: "TOO_MANY_TOPICS",
      PERMISSION_DENIED: "AUTHENTICATION_ERROR",
      DEADLINE_EXCEEDED: "SERVER_UNAVAILABLE",
      INTERNAL: "INTERNAL_ERROR",
      UNKNOWN: "UNKNOWN_ERROR"
    };
  }
});

// browser-external:url
var require_url = __commonJS({
  "browser-external:url"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "url" has been externalized for browser compatibility. Cannot access "url.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/firebase-admin/lib/utils/validator.js
var require_validator = __commonJS({
  "node_modules/firebase-admin/lib/utils/validator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isTaskId = exports.isTopic = exports.isURL = exports.isUTCDateString = exports.isISODateString = exports.isPhoneNumber = exports.isEmail = exports.isPassword = exports.isUid = exports.isNonNullObject = exports.isObject = exports.isNonEmptyString = exports.isBase64String = exports.isString = exports.isNumber = exports.isBoolean = exports.isNonEmptyArray = exports.isArray = exports.isBuffer = void 0;
    var url = require_url();
    function isBuffer(value) {
      return value instanceof Buffer;
    }
    exports.isBuffer = isBuffer;
    function isArray2(value) {
      return Array.isArray(value);
    }
    exports.isArray = isArray2;
    function isNonEmptyArray(value) {
      return isArray2(value) && value.length !== 0;
    }
    exports.isNonEmptyArray = isNonEmptyArray;
    function isBoolean(value) {
      return typeof value === "boolean";
    }
    exports.isBoolean = isBoolean;
    function isNumber2(value) {
      return typeof value === "number" && !isNaN(value);
    }
    exports.isNumber = isNumber2;
    function isString2(value) {
      return typeof value === "string";
    }
    exports.isString = isString2;
    function isBase64String(value) {
      if (!isString2(value)) {
        return false;
      }
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(value);
    }
    exports.isBase64String = isBase64String;
    function isNonEmptyString(value) {
      return isString2(value) && value !== "";
    }
    exports.isNonEmptyString = isNonEmptyString;
    function isObject3(value) {
      return typeof value === "object" && !isArray2(value);
    }
    exports.isObject = isObject3;
    function isNonNullObject2(value) {
      return isObject3(value) && value !== null;
    }
    exports.isNonNullObject = isNonNullObject2;
    function isUid(uid) {
      return typeof uid === "string" && uid.length > 0 && uid.length <= 128;
    }
    exports.isUid = isUid;
    function isPassword(password) {
      return typeof password === "string" && password.length >= 6;
    }
    exports.isPassword = isPassword;
    function isEmail(email) {
      if (typeof email !== "string") {
        return false;
      }
      const re2 = /^[^@]+@[^@]+$/;
      return re2.test(email);
    }
    exports.isEmail = isEmail;
    function isPhoneNumber(phoneNumber) {
      if (typeof phoneNumber !== "string") {
        return false;
      }
      const re1 = /^\+/;
      const re2 = /[\da-zA-Z]+/;
      return re1.test(phoneNumber) && re2.test(phoneNumber);
    }
    exports.isPhoneNumber = isPhoneNumber;
    function isISODateString(dateString) {
      try {
        return isNonEmptyString(dateString) && new Date(dateString).toISOString() === dateString;
      } catch (e) {
        return false;
      }
    }
    exports.isISODateString = isISODateString;
    function isUTCDateString(dateString) {
      try {
        return isNonEmptyString(dateString) && new Date(dateString).toUTCString() === dateString;
      } catch (e) {
        return false;
      }
    }
    exports.isUTCDateString = isUTCDateString;
    function isURL(urlStr) {
      if (typeof urlStr !== "string") {
        return false;
      }
      const re2 = /[^a-z0-9:/?#[\]@!$&'()*+,;=.\-_~%]/i;
      if (re2.test(urlStr)) {
        return false;
      }
      try {
        const uri = url.parse(urlStr);
        const scheme = uri.protocol;
        const slashes = uri.slashes;
        const hostname = uri.hostname;
        const pathname = uri.pathname;
        if (scheme !== "http:" && scheme !== "https:" || !slashes) {
          return false;
        }
        if (!hostname || !/^[a-zA-Z0-9]+[\w-]*([.]?[a-zA-Z0-9]+[\w-]*)*$/.test(hostname)) {
          return false;
        }
        const pathnameRe = /^(\/[\w\-.~!$'()*+,;=:@%]+)*\/?$/;
        if (pathname && pathname !== "/" && !pathnameRe.test(pathname)) {
          return false;
        }
      } catch (e) {
        return false;
      }
      return true;
    }
    exports.isURL = isURL;
    function isTopic(topic) {
      if (typeof topic !== "string") {
        return false;
      }
      const VALID_TOPIC_REGEX = /^(\/topics\/)?(private\/)?[a-zA-Z0-9-_.~%]+$/;
      return VALID_TOPIC_REGEX.test(topic);
    }
    exports.isTopic = isTopic;
    function isTaskId(taskId) {
      if (typeof taskId !== "string") {
        return false;
      }
      const VALID_TASK_ID_REGEX = /^[A-Za-z0-9_-]+$/;
      return VALID_TASK_ID_REGEX.test(taskId);
    }
    exports.isTaskId = isTaskId;
  }
});

// browser-external:http
var require_http = __commonJS({
  "browser-external:http"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "http" has been externalized for browser compatibility. Cannot access "http.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:https
var require_https = __commonJS({
  "browser-external:https"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "https" has been externalized for browser compatibility. Cannot access "https.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports, module) {
    "use strict";
    var R3 = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R3 && typeof R3.apply === "function" ? R3.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R3 && typeof R3.ownKeys === "function") {
      ReflectOwnKeys = R3.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn)
        console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter2() {
      EventEmitter2.init.call(this);
    }
    module.exports = EventEmitter2;
    module.exports.once = once;
    EventEmitter2.EventEmitter = EventEmitter2;
    EventEmitter2.prototype._events = void 0;
    EventEmitter2.prototype._eventsCount = 0;
    EventEmitter2.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter2, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter2.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter2.prototype.setMaxListeners = function setMaxListeners(n2) {
      if (typeof n2 !== "number" || n2 < 0 || NumberIsNaN(n2)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n2 + ".");
      }
      this._maxListeners = n2;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter2.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter2.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter2.prototype.emit = function emit(type) {
      var args = [];
      for (var i2 = 1; i2 < arguments.length; i2++)
        args.push(arguments[i2]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er2;
        if (args.length > 0)
          er2 = args[0];
        if (er2 instanceof Error) {
          throw er2;
        }
        var err = new Error("Unhandled error." + (er2 ? " (" + er2.message + ")" : ""));
        err.context = er2;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i2 = 0; i2 < len; ++i2)
          ReflectApply(listeners[i2], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w2.name = "MaxListenersExceededWarning";
          w2.emitter = target;
          w2.type = type;
          w2.count = existing.length;
          ProcessEmitWarning(w2);
        }
      }
      return target;
    }
    EventEmitter2.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter2.prototype.on = EventEmitter2.prototype.addListener;
    EventEmitter2.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter2.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter2.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter2.prototype.removeListener = function removeListener(type, listener) {
      var list2, events, position, i2, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list2 = events[type];
      if (list2 === void 0)
        return this;
      if (list2 === listener || list2.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list2.listener || listener);
        }
      } else if (typeof list2 !== "function") {
        position = -1;
        for (i2 = list2.length - 1; i2 >= 0; i2--) {
          if (list2[i2] === listener || list2[i2].listener === listener) {
            originalListener = list2[i2].listener;
            position = i2;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list2.shift();
        else {
          spliceOne(list2, position);
        }
        if (list2.length === 1)
          events[type] = list2[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i2;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i2 = 0; i2 < keys.length; ++i2) {
          key = keys[i2];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i2 = listeners.length - 1; i2 >= 0; i2--) {
          this.removeListener(type, listeners[i2]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter2.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter2.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter2.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter2.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n2) {
      var copy = new Array(n2);
      for (var i2 = 0; i2 < n2; ++i2)
        copy[i2] = arr[i2];
      return copy;
    }
    function spliceOne(list2, index) {
      for (; index + 1 < list2.length; index++)
        list2[index] = list2[index + 1];
      list2.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i2 = 0; i2 < ret.length; ++i2) {
        ret[i2] = arr[i2].listener || arr[i2];
      }
      return ret;
    }
    function once(emitter, name4) {
      return new Promise(function(resolve2, reject) {
        function errorListener(err) {
          emitter.removeListener(name4, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve2([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name4, resolver, { once: true });
        if (name4 !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name4, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name4, listener);
        } else {
          emitter.on(name4, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name4, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name4, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// browser-external:zlib
var require_zlib = __commonJS({
  "browser-external:zlib"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "zlib" has been externalized for browser compatibility. Cannot access "zlib.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:stream
var require_node_stream = __commonJS({
  "browser-external:node:stream"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:stream" has been externalized for browser compatibility. Cannot access "node:stream.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:util
var require_node_util = __commonJS({
  "browser-external:node:util"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:util" has been externalized for browser compatibility. Cannot access "node:util.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:events
var require_node_events = __commonJS({
  "browser-external:node:events"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:events" has been externalized for browser compatibility. Cannot access "node:events.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@fastify/busboy/deps/streamsearch/sbmh.js
var require_sbmh = __commonJS({
  "node_modules/@fastify/busboy/deps/streamsearch/sbmh.js"(exports, module) {
    "use strict";
    var EventEmitter2 = require_node_events().EventEmitter;
    var inherits = require_node_util().inherits;
    function SBMH(needle) {
      if (typeof needle === "string") {
        needle = Buffer.from(needle);
      }
      if (!Buffer.isBuffer(needle)) {
        throw new TypeError("The needle has to be a String or a Buffer.");
      }
      const needleLength = needle.length;
      if (needleLength === 0) {
        throw new Error("The needle cannot be an empty String/Buffer.");
      }
      if (needleLength > 256) {
        throw new Error("The needle cannot have a length bigger than 256.");
      }
      this.maxMatches = Infinity;
      this.matches = 0;
      this._occ = new Array(256).fill(needleLength);
      this._lookbehind_size = 0;
      this._needle = needle;
      this._bufpos = 0;
      this._lookbehind = Buffer.alloc(needleLength);
      for (var i2 = 0; i2 < needleLength - 1; ++i2) {
        this._occ[needle[i2]] = needleLength - 1 - i2;
      }
    }
    inherits(SBMH, EventEmitter2);
    SBMH.prototype.reset = function() {
      this._lookbehind_size = 0;
      this.matches = 0;
      this._bufpos = 0;
    };
    SBMH.prototype.push = function(chunk, pos) {
      if (!Buffer.isBuffer(chunk)) {
        chunk = Buffer.from(chunk, "binary");
      }
      const chlen = chunk.length;
      this._bufpos = pos || 0;
      let r2;
      while (r2 !== chlen && this.matches < this.maxMatches) {
        r2 = this._sbmh_feed(chunk);
      }
      return r2;
    };
    SBMH.prototype._sbmh_feed = function(data) {
      const len = data.length;
      const needle = this._needle;
      const needleLength = needle.length;
      const lastNeedleChar = needle[needleLength - 1];
      let pos = -this._lookbehind_size;
      let ch;
      if (pos < 0) {
        while (pos < 0 && pos <= len - needleLength) {
          ch = this._sbmh_lookup_char(data, pos + needleLength - 1);
          if (ch === lastNeedleChar && this._sbmh_memcmp(data, pos, needleLength - 1)) {
            this._lookbehind_size = 0;
            ++this.matches;
            this.emit("info", true);
            return this._bufpos = pos + needleLength;
          }
          pos += this._occ[ch];
        }
        if (pos < 0) {
          while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)) {
            ++pos;
          }
        }
        if (pos >= 0) {
          this.emit("info", false, this._lookbehind, 0, this._lookbehind_size);
          this._lookbehind_size = 0;
        } else {
          const bytesToCutOff = this._lookbehind_size + pos;
          if (bytesToCutOff > 0) {
            this.emit("info", false, this._lookbehind, 0, bytesToCutOff);
          }
          this._lookbehind.copy(
            this._lookbehind,
            0,
            bytesToCutOff,
            this._lookbehind_size - bytesToCutOff
          );
          this._lookbehind_size -= bytesToCutOff;
          data.copy(this._lookbehind, this._lookbehind_size);
          this._lookbehind_size += len;
          this._bufpos = len;
          return len;
        }
      }
      pos += (pos >= 0) * this._bufpos;
      if (data.indexOf(needle, pos) !== -1) {
        pos = data.indexOf(needle, pos);
        ++this.matches;
        if (pos > 0) {
          this.emit("info", true, data, this._bufpos, pos);
        } else {
          this.emit("info", true);
        }
        return this._bufpos = pos + needleLength;
      } else {
        pos = len - needleLength;
      }
      while (pos < len && (data[pos] !== needle[0] || Buffer.compare(
        data.subarray(pos, pos + len - pos),
        needle.subarray(0, len - pos)
      ) !== 0)) {
        ++pos;
      }
      if (pos < len) {
        data.copy(this._lookbehind, 0, pos, pos + (len - pos));
        this._lookbehind_size = len - pos;
      }
      if (pos > 0) {
        this.emit("info", false, data, this._bufpos, pos < len ? pos : len);
      }
      this._bufpos = len;
      return len;
    };
    SBMH.prototype._sbmh_lookup_char = function(data, pos) {
      return pos < 0 ? this._lookbehind[this._lookbehind_size + pos] : data[pos];
    };
    SBMH.prototype._sbmh_memcmp = function(data, pos, len) {
      for (var i2 = 0; i2 < len; ++i2) {
        if (this._sbmh_lookup_char(data, pos + i2) !== this._needle[i2]) {
          return false;
        }
      }
      return true;
    };
    module.exports = SBMH;
  }
});

// node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js
var require_PartStream = __commonJS({
  "node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js"(exports, module) {
    "use strict";
    var inherits = require_node_util().inherits;
    var ReadableStream = require_node_stream().Readable;
    function PartStream(opts) {
      ReadableStream.call(this, opts);
    }
    inherits(PartStream, ReadableStream);
    PartStream.prototype._read = function(n2) {
    };
    module.exports = PartStream;
  }
});

// node_modules/@fastify/busboy/lib/utils/getLimit.js
var require_getLimit = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/getLimit.js"(exports, module) {
    "use strict";
    module.exports = function getLimit(limits, name4, defaultLimit) {
      if (!limits || limits[name4] === void 0 || limits[name4] === null) {
        return defaultLimit;
      }
      if (typeof limits[name4] !== "number" || isNaN(limits[name4])) {
        throw new TypeError("Limit " + name4 + " is not a valid number");
      }
      return limits[name4];
    };
  }
});

// node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js
var require_HeaderParser = __commonJS({
  "node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js"(exports, module) {
    "use strict";
    var EventEmitter2 = require_node_events().EventEmitter;
    var inherits = require_node_util().inherits;
    var getLimit = require_getLimit();
    var StreamSearch = require_sbmh();
    var B_DCRLF = Buffer.from("\r\n\r\n");
    var RE_CRLF = /\r\n/g;
    var RE_HDR = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/;
    function HeaderParser(cfg) {
      EventEmitter2.call(this);
      cfg = cfg || {};
      const self2 = this;
      this.nread = 0;
      this.maxed = false;
      this.npairs = 0;
      this.maxHeaderPairs = getLimit(cfg, "maxHeaderPairs", 2e3);
      this.maxHeaderSize = getLimit(cfg, "maxHeaderSize", 80 * 1024);
      this.buffer = "";
      this.header = {};
      this.finished = false;
      this.ss = new StreamSearch(B_DCRLF);
      this.ss.on("info", function(isMatch, data, start2, end) {
        if (data && !self2.maxed) {
          if (self2.nread + end - start2 >= self2.maxHeaderSize) {
            end = self2.maxHeaderSize - self2.nread + start2;
            self2.nread = self2.maxHeaderSize;
            self2.maxed = true;
          } else {
            self2.nread += end - start2;
          }
          self2.buffer += data.toString("binary", start2, end);
        }
        if (isMatch) {
          self2._finish();
        }
      });
    }
    inherits(HeaderParser, EventEmitter2);
    HeaderParser.prototype.push = function(data) {
      const r2 = this.ss.push(data);
      if (this.finished) {
        return r2;
      }
    };
    HeaderParser.prototype.reset = function() {
      this.finished = false;
      this.buffer = "";
      this.header = {};
      this.ss.reset();
    };
    HeaderParser.prototype._finish = function() {
      if (this.buffer) {
        this._parseHeader();
      }
      this.ss.matches = this.ss.maxMatches;
      const header = this.header;
      this.header = {};
      this.buffer = "";
      this.finished = true;
      this.nread = this.npairs = 0;
      this.maxed = false;
      this.emit("header", header);
    };
    HeaderParser.prototype._parseHeader = function() {
      if (this.npairs === this.maxHeaderPairs) {
        return;
      }
      const lines = this.buffer.split(RE_CRLF);
      const len = lines.length;
      let m, h;
      for (var i2 = 0; i2 < len; ++i2) {
        if (lines[i2].length === 0) {
          continue;
        }
        if (lines[i2][0] === "	" || lines[i2][0] === " ") {
          if (h) {
            this.header[h][this.header[h].length - 1] += lines[i2];
            continue;
          }
        }
        const posColon = lines[i2].indexOf(":");
        if (posColon === -1 || posColon === 0) {
          return;
        }
        m = RE_HDR.exec(lines[i2]);
        h = m[1].toLowerCase();
        this.header[h] = this.header[h] || [];
        this.header[h].push(m[2] || "");
        if (++this.npairs === this.maxHeaderPairs) {
          break;
        }
      }
    };
    module.exports = HeaderParser;
  }
});

// node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js
var require_Dicer = __commonJS({
  "node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js"(exports, module) {
    "use strict";
    var WritableStream = require_node_stream().Writable;
    var inherits = require_node_util().inherits;
    var StreamSearch = require_sbmh();
    var PartStream = require_PartStream();
    var HeaderParser = require_HeaderParser();
    var DASH = 45;
    var B_ONEDASH = Buffer.from("-");
    var B_CRLF = Buffer.from("\r\n");
    var EMPTY_FN = function() {
    };
    function Dicer(cfg) {
      if (!(this instanceof Dicer)) {
        return new Dicer(cfg);
      }
      WritableStream.call(this, cfg);
      if (!cfg || !cfg.headerFirst && typeof cfg.boundary !== "string") {
        throw new TypeError("Boundary required");
      }
      if (typeof cfg.boundary === "string") {
        this.setBoundary(cfg.boundary);
      } else {
        this._bparser = void 0;
      }
      this._headerFirst = cfg.headerFirst;
      this._dashes = 0;
      this._parts = 0;
      this._finished = false;
      this._realFinish = false;
      this._isPreamble = true;
      this._justMatched = false;
      this._firstWrite = true;
      this._inHeader = true;
      this._part = void 0;
      this._cb = void 0;
      this._ignoreData = false;
      this._partOpts = { highWaterMark: cfg.partHwm };
      this._pause = false;
      const self2 = this;
      this._hparser = new HeaderParser(cfg);
      this._hparser.on("header", function(header) {
        self2._inHeader = false;
        self2._part.emit("header", header);
      });
    }
    inherits(Dicer, WritableStream);
    Dicer.prototype.emit = function(ev) {
      if (ev === "finish" && !this._realFinish) {
        if (!this._finished) {
          const self2 = this;
          process.nextTick(function() {
            self2.emit("error", new Error("Unexpected end of multipart data"));
            if (self2._part && !self2._ignoreData) {
              const type = self2._isPreamble ? "Preamble" : "Part";
              self2._part.emit("error", new Error(type + " terminated early due to unexpected end of multipart data"));
              self2._part.push(null);
              process.nextTick(function() {
                self2._realFinish = true;
                self2.emit("finish");
                self2._realFinish = false;
              });
              return;
            }
            self2._realFinish = true;
            self2.emit("finish");
            self2._realFinish = false;
          });
        }
      } else {
        WritableStream.prototype.emit.apply(this, arguments);
      }
    };
    Dicer.prototype._write = function(data, encoding, cb2) {
      if (!this._hparser && !this._bparser) {
        return cb2();
      }
      if (this._headerFirst && this._isPreamble) {
        if (!this._part) {
          this._part = new PartStream(this._partOpts);
          if (this.listenerCount("preamble") !== 0) {
            this.emit("preamble", this._part);
          } else {
            this._ignore();
          }
        }
        const r2 = this._hparser.push(data);
        if (!this._inHeader && r2 !== void 0 && r2 < data.length) {
          data = data.slice(r2);
        } else {
          return cb2();
        }
      }
      if (this._firstWrite) {
        this._bparser.push(B_CRLF);
        this._firstWrite = false;
      }
      this._bparser.push(data);
      if (this._pause) {
        this._cb = cb2;
      } else {
        cb2();
      }
    };
    Dicer.prototype.reset = function() {
      this._part = void 0;
      this._bparser = void 0;
      this._hparser = void 0;
    };
    Dicer.prototype.setBoundary = function(boundary) {
      const self2 = this;
      this._bparser = new StreamSearch("\r\n--" + boundary);
      this._bparser.on("info", function(isMatch, data, start2, end) {
        self2._oninfo(isMatch, data, start2, end);
      });
    };
    Dicer.prototype._ignore = function() {
      if (this._part && !this._ignoreData) {
        this._ignoreData = true;
        this._part.on("error", EMPTY_FN);
        this._part.resume();
      }
    };
    Dicer.prototype._oninfo = function(isMatch, data, start2, end) {
      let buf;
      const self2 = this;
      let i2 = 0;
      let r2;
      let shouldWriteMore = true;
      if (!this._part && this._justMatched && data) {
        while (this._dashes < 2 && start2 + i2 < end) {
          if (data[start2 + i2] === DASH) {
            ++i2;
            ++this._dashes;
          } else {
            if (this._dashes) {
              buf = B_ONEDASH;
            }
            this._dashes = 0;
            break;
          }
        }
        if (this._dashes === 2) {
          if (start2 + i2 < end && this.listenerCount("trailer") !== 0) {
            this.emit("trailer", data.slice(start2 + i2, end));
          }
          this.reset();
          this._finished = true;
          if (self2._parts === 0) {
            self2._realFinish = true;
            self2.emit("finish");
            self2._realFinish = false;
          }
        }
        if (this._dashes) {
          return;
        }
      }
      if (this._justMatched) {
        this._justMatched = false;
      }
      if (!this._part) {
        this._part = new PartStream(this._partOpts);
        this._part._read = function(n2) {
          self2._unpause();
        };
        if (this._isPreamble && this.listenerCount("preamble") !== 0) {
          this.emit("preamble", this._part);
        } else if (this._isPreamble !== true && this.listenerCount("part") !== 0) {
          this.emit("part", this._part);
        } else {
          this._ignore();
        }
        if (!this._isPreamble) {
          this._inHeader = true;
        }
      }
      if (data && start2 < end && !this._ignoreData) {
        if (this._isPreamble || !this._inHeader) {
          if (buf) {
            shouldWriteMore = this._part.push(buf);
          }
          shouldWriteMore = this._part.push(data.slice(start2, end));
          if (!shouldWriteMore) {
            this._pause = true;
          }
        } else if (!this._isPreamble && this._inHeader) {
          if (buf) {
            this._hparser.push(buf);
          }
          r2 = this._hparser.push(data.slice(start2, end));
          if (!this._inHeader && r2 !== void 0 && r2 < end) {
            this._oninfo(false, data, start2 + r2, end);
          }
        }
      }
      if (isMatch) {
        this._hparser.reset();
        if (this._isPreamble) {
          this._isPreamble = false;
        } else {
          if (start2 !== end) {
            ++this._parts;
            this._part.on("end", function() {
              if (--self2._parts === 0) {
                if (self2._finished) {
                  self2._realFinish = true;
                  self2.emit("finish");
                  self2._realFinish = false;
                } else {
                  self2._unpause();
                }
              }
            });
          }
        }
        this._part.push(null);
        this._part = void 0;
        this._ignoreData = false;
        this._justMatched = true;
        this._dashes = 0;
      }
    };
    Dicer.prototype._unpause = function() {
      if (!this._pause) {
        return;
      }
      this._pause = false;
      if (this._cb) {
        const cb2 = this._cb;
        this._cb = void 0;
        cb2();
      }
    };
    module.exports = Dicer;
  }
});

// node_modules/@fastify/busboy/lib/utils/decodeText.js
var require_decodeText = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/decodeText.js"(exports, module) {
    "use strict";
    var utf8Decoder = new TextDecoder("utf-8");
    var textDecoders = /* @__PURE__ */ new Map([
      ["utf-8", utf8Decoder],
      ["utf8", utf8Decoder]
    ]);
    function getDecoder(charset) {
      let lc2;
      while (true) {
        switch (charset) {
          case "utf-8":
          case "utf8":
            return decoders.utf8;
          case "latin1":
          case "ascii":
          case "us-ascii":
          case "iso-8859-1":
          case "iso8859-1":
          case "iso88591":
          case "iso_8859-1":
          case "windows-1252":
          case "iso_8859-1:1987":
          case "cp1252":
          case "x-cp1252":
            return decoders.latin1;
          case "utf16le":
          case "utf-16le":
          case "ucs2":
          case "ucs-2":
            return decoders.utf16le;
          case "base64":
            return decoders.base64;
          default:
            if (lc2 === void 0) {
              lc2 = true;
              charset = charset.toLowerCase();
              continue;
            }
            return decoders.other.bind(charset);
        }
      }
    }
    var decoders = {
      utf8: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        return data.utf8Slice(0, data.length);
      },
      latin1: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          return data;
        }
        return data.latin1Slice(0, data.length);
      },
      utf16le: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        return data.ucs2Slice(0, data.length);
      },
      base64: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        return data.base64Slice(0, data.length);
      },
      other: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        if (textDecoders.has(exports.toString())) {
          try {
            return textDecoders.get(exports).decode(data);
          } catch {
          }
        }
        return typeof data === "string" ? data : data.toString();
      }
    };
    function decodeText(text, sourceEncoding, destEncoding) {
      if (text) {
        return getDecoder(destEncoding)(text, sourceEncoding);
      }
      return text;
    }
    module.exports = decodeText;
  }
});

// node_modules/@fastify/busboy/lib/utils/parseParams.js
var require_parseParams = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/parseParams.js"(exports, module) {
    "use strict";
    var decodeText = require_decodeText();
    var RE_ENCODED = /%[a-fA-F0-9][a-fA-F0-9]/g;
    var EncodedLookup = {
      "%00": "\0",
      "%01": "",
      "%02": "",
      "%03": "",
      "%04": "",
      "%05": "",
      "%06": "",
      "%07": "\x07",
      "%08": "\b",
      "%09": "	",
      "%0a": "\n",
      "%0A": "\n",
      "%0b": "\v",
      "%0B": "\v",
      "%0c": "\f",
      "%0C": "\f",
      "%0d": "\r",
      "%0D": "\r",
      "%0e": "",
      "%0E": "",
      "%0f": "",
      "%0F": "",
      "%10": "",
      "%11": "",
      "%12": "",
      "%13": "",
      "%14": "",
      "%15": "",
      "%16": "",
      "%17": "",
      "%18": "",
      "%19": "",
      "%1a": "",
      "%1A": "",
      "%1b": "\x1B",
      "%1B": "\x1B",
      "%1c": "",
      "%1C": "",
      "%1d": "",
      "%1D": "",
      "%1e": "",
      "%1E": "",
      "%1f": "",
      "%1F": "",
      "%20": " ",
      "%21": "!",
      "%22": '"',
      "%23": "#",
      "%24": "$",
      "%25": "%",
      "%26": "&",
      "%27": "'",
      "%28": "(",
      "%29": ")",
      "%2a": "*",
      "%2A": "*",
      "%2b": "+",
      "%2B": "+",
      "%2c": ",",
      "%2C": ",",
      "%2d": "-",
      "%2D": "-",
      "%2e": ".",
      "%2E": ".",
      "%2f": "/",
      "%2F": "/",
      "%30": "0",
      "%31": "1",
      "%32": "2",
      "%33": "3",
      "%34": "4",
      "%35": "5",
      "%36": "6",
      "%37": "7",
      "%38": "8",
      "%39": "9",
      "%3a": ":",
      "%3A": ":",
      "%3b": ";",
      "%3B": ";",
      "%3c": "<",
      "%3C": "<",
      "%3d": "=",
      "%3D": "=",
      "%3e": ">",
      "%3E": ">",
      "%3f": "?",
      "%3F": "?",
      "%40": "@",
      "%41": "A",
      "%42": "B",
      "%43": "C",
      "%44": "D",
      "%45": "E",
      "%46": "F",
      "%47": "G",
      "%48": "H",
      "%49": "I",
      "%4a": "J",
      "%4A": "J",
      "%4b": "K",
      "%4B": "K",
      "%4c": "L",
      "%4C": "L",
      "%4d": "M",
      "%4D": "M",
      "%4e": "N",
      "%4E": "N",
      "%4f": "O",
      "%4F": "O",
      "%50": "P",
      "%51": "Q",
      "%52": "R",
      "%53": "S",
      "%54": "T",
      "%55": "U",
      "%56": "V",
      "%57": "W",
      "%58": "X",
      "%59": "Y",
      "%5a": "Z",
      "%5A": "Z",
      "%5b": "[",
      "%5B": "[",
      "%5c": "\\",
      "%5C": "\\",
      "%5d": "]",
      "%5D": "]",
      "%5e": "^",
      "%5E": "^",
      "%5f": "_",
      "%5F": "_",
      "%60": "`",
      "%61": "a",
      "%62": "b",
      "%63": "c",
      "%64": "d",
      "%65": "e",
      "%66": "f",
      "%67": "g",
      "%68": "h",
      "%69": "i",
      "%6a": "j",
      "%6A": "j",
      "%6b": "k",
      "%6B": "k",
      "%6c": "l",
      "%6C": "l",
      "%6d": "m",
      "%6D": "m",
      "%6e": "n",
      "%6E": "n",
      "%6f": "o",
      "%6F": "o",
      "%70": "p",
      "%71": "q",
      "%72": "r",
      "%73": "s",
      "%74": "t",
      "%75": "u",
      "%76": "v",
      "%77": "w",
      "%78": "x",
      "%79": "y",
      "%7a": "z",
      "%7A": "z",
      "%7b": "{",
      "%7B": "{",
      "%7c": "|",
      "%7C": "|",
      "%7d": "}",
      "%7D": "}",
      "%7e": "~",
      "%7E": "~",
      "%7f": "",
      "%7F": "",
      "%80": "",
      "%81": "",
      "%82": "",
      "%83": "",
      "%84": "",
      "%85": "",
      "%86": "",
      "%87": "",
      "%88": "",
      "%89": "",
      "%8a": "",
      "%8A": "",
      "%8b": "",
      "%8B": "",
      "%8c": "",
      "%8C": "",
      "%8d": "",
      "%8D": "",
      "%8e": "",
      "%8E": "",
      "%8f": "",
      "%8F": "",
      "%90": "",
      "%91": "",
      "%92": "",
      "%93": "",
      "%94": "",
      "%95": "",
      "%96": "",
      "%97": "",
      "%98": "",
      "%99": "",
      "%9a": "",
      "%9A": "",
      "%9b": "",
      "%9B": "",
      "%9c": "",
      "%9C": "",
      "%9d": "",
      "%9D": "",
      "%9e": "",
      "%9E": "",
      "%9f": "",
      "%9F": "",
      "%a0": " ",
      "%A0": " ",
      "%a1": "¡",
      "%A1": "¡",
      "%a2": "¢",
      "%A2": "¢",
      "%a3": "£",
      "%A3": "£",
      "%a4": "¤",
      "%A4": "¤",
      "%a5": "¥",
      "%A5": "¥",
      "%a6": "¦",
      "%A6": "¦",
      "%a7": "§",
      "%A7": "§",
      "%a8": "¨",
      "%A8": "¨",
      "%a9": "©",
      "%A9": "©",
      "%aa": "ª",
      "%Aa": "ª",
      "%aA": "ª",
      "%AA": "ª",
      "%ab": "«",
      "%Ab": "«",
      "%aB": "«",
      "%AB": "«",
      "%ac": "¬",
      "%Ac": "¬",
      "%aC": "¬",
      "%AC": "¬",
      "%ad": "­",
      "%Ad": "­",
      "%aD": "­",
      "%AD": "­",
      "%ae": "®",
      "%Ae": "®",
      "%aE": "®",
      "%AE": "®",
      "%af": "¯",
      "%Af": "¯",
      "%aF": "¯",
      "%AF": "¯",
      "%b0": "°",
      "%B0": "°",
      "%b1": "±",
      "%B1": "±",
      "%b2": "²",
      "%B2": "²",
      "%b3": "³",
      "%B3": "³",
      "%b4": "´",
      "%B4": "´",
      "%b5": "µ",
      "%B5": "µ",
      "%b6": "¶",
      "%B6": "¶",
      "%b7": "·",
      "%B7": "·",
      "%b8": "¸",
      "%B8": "¸",
      "%b9": "¹",
      "%B9": "¹",
      "%ba": "º",
      "%Ba": "º",
      "%bA": "º",
      "%BA": "º",
      "%bb": "»",
      "%Bb": "»",
      "%bB": "»",
      "%BB": "»",
      "%bc": "¼",
      "%Bc": "¼",
      "%bC": "¼",
      "%BC": "¼",
      "%bd": "½",
      "%Bd": "½",
      "%bD": "½",
      "%BD": "½",
      "%be": "¾",
      "%Be": "¾",
      "%bE": "¾",
      "%BE": "¾",
      "%bf": "¿",
      "%Bf": "¿",
      "%bF": "¿",
      "%BF": "¿",
      "%c0": "À",
      "%C0": "À",
      "%c1": "Á",
      "%C1": "Á",
      "%c2": "Â",
      "%C2": "Â",
      "%c3": "Ã",
      "%C3": "Ã",
      "%c4": "Ä",
      "%C4": "Ä",
      "%c5": "Å",
      "%C5": "Å",
      "%c6": "Æ",
      "%C6": "Æ",
      "%c7": "Ç",
      "%C7": "Ç",
      "%c8": "È",
      "%C8": "È",
      "%c9": "É",
      "%C9": "É",
      "%ca": "Ê",
      "%Ca": "Ê",
      "%cA": "Ê",
      "%CA": "Ê",
      "%cb": "Ë",
      "%Cb": "Ë",
      "%cB": "Ë",
      "%CB": "Ë",
      "%cc": "Ì",
      "%Cc": "Ì",
      "%cC": "Ì",
      "%CC": "Ì",
      "%cd": "Í",
      "%Cd": "Í",
      "%cD": "Í",
      "%CD": "Í",
      "%ce": "Î",
      "%Ce": "Î",
      "%cE": "Î",
      "%CE": "Î",
      "%cf": "Ï",
      "%Cf": "Ï",
      "%cF": "Ï",
      "%CF": "Ï",
      "%d0": "Ð",
      "%D0": "Ð",
      "%d1": "Ñ",
      "%D1": "Ñ",
      "%d2": "Ò",
      "%D2": "Ò",
      "%d3": "Ó",
      "%D3": "Ó",
      "%d4": "Ô",
      "%D4": "Ô",
      "%d5": "Õ",
      "%D5": "Õ",
      "%d6": "Ö",
      "%D6": "Ö",
      "%d7": "×",
      "%D7": "×",
      "%d8": "Ø",
      "%D8": "Ø",
      "%d9": "Ù",
      "%D9": "Ù",
      "%da": "Ú",
      "%Da": "Ú",
      "%dA": "Ú",
      "%DA": "Ú",
      "%db": "Û",
      "%Db": "Û",
      "%dB": "Û",
      "%DB": "Û",
      "%dc": "Ü",
      "%Dc": "Ü",
      "%dC": "Ü",
      "%DC": "Ü",
      "%dd": "Ý",
      "%Dd": "Ý",
      "%dD": "Ý",
      "%DD": "Ý",
      "%de": "Þ",
      "%De": "Þ",
      "%dE": "Þ",
      "%DE": "Þ",
      "%df": "ß",
      "%Df": "ß",
      "%dF": "ß",
      "%DF": "ß",
      "%e0": "à",
      "%E0": "à",
      "%e1": "á",
      "%E1": "á",
      "%e2": "â",
      "%E2": "â",
      "%e3": "ã",
      "%E3": "ã",
      "%e4": "ä",
      "%E4": "ä",
      "%e5": "å",
      "%E5": "å",
      "%e6": "æ",
      "%E6": "æ",
      "%e7": "ç",
      "%E7": "ç",
      "%e8": "è",
      "%E8": "è",
      "%e9": "é",
      "%E9": "é",
      "%ea": "ê",
      "%Ea": "ê",
      "%eA": "ê",
      "%EA": "ê",
      "%eb": "ë",
      "%Eb": "ë",
      "%eB": "ë",
      "%EB": "ë",
      "%ec": "ì",
      "%Ec": "ì",
      "%eC": "ì",
      "%EC": "ì",
      "%ed": "í",
      "%Ed": "í",
      "%eD": "í",
      "%ED": "í",
      "%ee": "î",
      "%Ee": "î",
      "%eE": "î",
      "%EE": "î",
      "%ef": "ï",
      "%Ef": "ï",
      "%eF": "ï",
      "%EF": "ï",
      "%f0": "ð",
      "%F0": "ð",
      "%f1": "ñ",
      "%F1": "ñ",
      "%f2": "ò",
      "%F2": "ò",
      "%f3": "ó",
      "%F3": "ó",
      "%f4": "ô",
      "%F4": "ô",
      "%f5": "õ",
      "%F5": "õ",
      "%f6": "ö",
      "%F6": "ö",
      "%f7": "÷",
      "%F7": "÷",
      "%f8": "ø",
      "%F8": "ø",
      "%f9": "ù",
      "%F9": "ù",
      "%fa": "ú",
      "%Fa": "ú",
      "%fA": "ú",
      "%FA": "ú",
      "%fb": "û",
      "%Fb": "û",
      "%fB": "û",
      "%FB": "û",
      "%fc": "ü",
      "%Fc": "ü",
      "%fC": "ü",
      "%FC": "ü",
      "%fd": "ý",
      "%Fd": "ý",
      "%fD": "ý",
      "%FD": "ý",
      "%fe": "þ",
      "%Fe": "þ",
      "%fE": "þ",
      "%FE": "þ",
      "%ff": "ÿ",
      "%Ff": "ÿ",
      "%fF": "ÿ",
      "%FF": "ÿ"
    };
    function encodedReplacer(match) {
      return EncodedLookup[match];
    }
    var STATE_KEY = 0;
    var STATE_VALUE = 1;
    var STATE_CHARSET = 2;
    var STATE_LANG = 3;
    function parseParams(str) {
      const res = [];
      let state = STATE_KEY;
      let charset = "";
      let inquote = false;
      let escaping = false;
      let p2 = 0;
      let tmp = "";
      const len = str.length;
      for (var i2 = 0; i2 < len; ++i2) {
        const char = str[i2];
        if (char === "\\" && inquote) {
          if (escaping) {
            escaping = false;
          } else {
            escaping = true;
            continue;
          }
        } else if (char === '"') {
          if (!escaping) {
            if (inquote) {
              inquote = false;
              state = STATE_KEY;
            } else {
              inquote = true;
            }
            continue;
          } else {
            escaping = false;
          }
        } else {
          if (escaping && inquote) {
            tmp += "\\";
          }
          escaping = false;
          if ((state === STATE_CHARSET || state === STATE_LANG) && char === "'") {
            if (state === STATE_CHARSET) {
              state = STATE_LANG;
              charset = tmp.substring(1);
            } else {
              state = STATE_VALUE;
            }
            tmp = "";
            continue;
          } else if (state === STATE_KEY && (char === "*" || char === "=") && res.length) {
            state = char === "*" ? STATE_CHARSET : STATE_VALUE;
            res[p2] = [tmp, void 0];
            tmp = "";
            continue;
          } else if (!inquote && char === ";") {
            state = STATE_KEY;
            if (charset) {
              if (tmp.length) {
                tmp = decodeText(
                  tmp.replace(RE_ENCODED, encodedReplacer),
                  "binary",
                  charset
                );
              }
              charset = "";
            } else if (tmp.length) {
              tmp = decodeText(tmp, "binary", "utf8");
            }
            if (res[p2] === void 0) {
              res[p2] = tmp;
            } else {
              res[p2][1] = tmp;
            }
            tmp = "";
            ++p2;
            continue;
          } else if (!inquote && (char === " " || char === "	")) {
            continue;
          }
        }
        tmp += char;
      }
      if (charset && tmp.length) {
        tmp = decodeText(
          tmp.replace(RE_ENCODED, encodedReplacer),
          "binary",
          charset
        );
      } else if (tmp) {
        tmp = decodeText(tmp, "binary", "utf8");
      }
      if (res[p2] === void 0) {
        if (tmp) {
          res[p2] = tmp;
        }
      } else {
        res[p2][1] = tmp;
      }
      return res;
    }
    module.exports = parseParams;
  }
});

// node_modules/@fastify/busboy/lib/utils/basename.js
var require_basename = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/basename.js"(exports, module) {
    "use strict";
    module.exports = function basename(path) {
      if (typeof path !== "string") {
        return "";
      }
      for (var i2 = path.length - 1; i2 >= 0; --i2) {
        switch (path.charCodeAt(i2)) {
          case 47:
          case 92:
            path = path.slice(i2 + 1);
            return path === ".." || path === "." ? "" : path;
        }
      }
      return path === ".." || path === "." ? "" : path;
    };
  }
});

// node_modules/@fastify/busboy/lib/types/multipart.js
var require_multipart = __commonJS({
  "node_modules/@fastify/busboy/lib/types/multipart.js"(exports, module) {
    "use strict";
    var { Readable } = require_node_stream();
    var { inherits } = require_node_util();
    var Dicer = require_Dicer();
    var parseParams = require_parseParams();
    var decodeText = require_decodeText();
    var basename = require_basename();
    var getLimit = require_getLimit();
    var RE_BOUNDARY = /^boundary$/i;
    var RE_FIELD = /^form-data$/i;
    var RE_CHARSET = /^charset$/i;
    var RE_FILENAME = /^filename$/i;
    var RE_NAME = /^name$/i;
    Multipart.detect = /^multipart\/form-data/i;
    function Multipart(boy, cfg) {
      let i2;
      let len;
      const self2 = this;
      let boundary;
      const limits = cfg.limits;
      const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName) => contentType === "application/octet-stream" || fileName !== void 0);
      const parsedConType = cfg.parsedConType || [];
      const defCharset = cfg.defCharset || "utf8";
      const preservePath = cfg.preservePath;
      const fileOpts = { highWaterMark: cfg.fileHwm };
      for (i2 = 0, len = parsedConType.length; i2 < len; ++i2) {
        if (Array.isArray(parsedConType[i2]) && RE_BOUNDARY.test(parsedConType[i2][0])) {
          boundary = parsedConType[i2][1];
          break;
        }
      }
      function checkFinished() {
        if (nends === 0 && finished && !boy._done) {
          finished = false;
          self2.end();
        }
      }
      if (typeof boundary !== "string") {
        throw new Error("Multipart: Boundary not found");
      }
      const fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
      const fileSizeLimit = getLimit(limits, "fileSize", Infinity);
      const filesLimit = getLimit(limits, "files", Infinity);
      const fieldsLimit = getLimit(limits, "fields", Infinity);
      const partsLimit = getLimit(limits, "parts", Infinity);
      const headerPairsLimit = getLimit(limits, "headerPairs", 2e3);
      const headerSizeLimit = getLimit(limits, "headerSize", 80 * 1024);
      let nfiles = 0;
      let nfields = 0;
      let nends = 0;
      let curFile;
      let curField;
      let finished = false;
      this._needDrain = false;
      this._pause = false;
      this._cb = void 0;
      this._nparts = 0;
      this._boy = boy;
      const parserCfg = {
        boundary,
        maxHeaderPairs: headerPairsLimit,
        maxHeaderSize: headerSizeLimit,
        partHwm: fileOpts.highWaterMark,
        highWaterMark: cfg.highWaterMark
      };
      this.parser = new Dicer(parserCfg);
      this.parser.on("drain", function() {
        self2._needDrain = false;
        if (self2._cb && !self2._pause) {
          const cb2 = self2._cb;
          self2._cb = void 0;
          cb2();
        }
      }).on("part", function onPart(part) {
        if (++self2._nparts > partsLimit) {
          self2.parser.removeListener("part", onPart);
          self2.parser.on("part", skipPart);
          boy.hitPartsLimit = true;
          boy.emit("partsLimit");
          return skipPart(part);
        }
        if (curField) {
          const field = curField;
          field.emit("end");
          field.removeAllListeners("end");
        }
        part.on("header", function(header) {
          let contype;
          let fieldname;
          let parsed;
          let charset;
          let encoding;
          let filename;
          let nsize = 0;
          if (header["content-type"]) {
            parsed = parseParams(header["content-type"][0]);
            if (parsed[0]) {
              contype = parsed[0].toLowerCase();
              for (i2 = 0, len = parsed.length; i2 < len; ++i2) {
                if (RE_CHARSET.test(parsed[i2][0])) {
                  charset = parsed[i2][1].toLowerCase();
                  break;
                }
              }
            }
          }
          if (contype === void 0) {
            contype = "text/plain";
          }
          if (charset === void 0) {
            charset = defCharset;
          }
          if (header["content-disposition"]) {
            parsed = parseParams(header["content-disposition"][0]);
            if (!RE_FIELD.test(parsed[0])) {
              return skipPart(part);
            }
            for (i2 = 0, len = parsed.length; i2 < len; ++i2) {
              if (RE_NAME.test(parsed[i2][0])) {
                fieldname = parsed[i2][1];
              } else if (RE_FILENAME.test(parsed[i2][0])) {
                filename = parsed[i2][1];
                if (!preservePath) {
                  filename = basename(filename);
                }
              }
            }
          } else {
            return skipPart(part);
          }
          if (header["content-transfer-encoding"]) {
            encoding = header["content-transfer-encoding"][0].toLowerCase();
          } else {
            encoding = "7bit";
          }
          let onData, onEnd;
          if (isPartAFile(fieldname, contype, filename)) {
            if (nfiles === filesLimit) {
              if (!boy.hitFilesLimit) {
                boy.hitFilesLimit = true;
                boy.emit("filesLimit");
              }
              return skipPart(part);
            }
            ++nfiles;
            if (boy.listenerCount("file") === 0) {
              self2.parser._ignore();
              return;
            }
            ++nends;
            const file = new FileStream(fileOpts);
            curFile = file;
            file.on("end", function() {
              --nends;
              self2._pause = false;
              checkFinished();
              if (self2._cb && !self2._needDrain) {
                const cb2 = self2._cb;
                self2._cb = void 0;
                cb2();
              }
            });
            file._read = function(n2) {
              if (!self2._pause) {
                return;
              }
              self2._pause = false;
              if (self2._cb && !self2._needDrain) {
                const cb2 = self2._cb;
                self2._cb = void 0;
                cb2();
              }
            };
            boy.emit("file", fieldname, file, filename, encoding, contype);
            onData = function(data) {
              if ((nsize += data.length) > fileSizeLimit) {
                const extralen = fileSizeLimit - nsize + data.length;
                if (extralen > 0) {
                  file.push(data.slice(0, extralen));
                }
                file.truncated = true;
                file.bytesRead = fileSizeLimit;
                part.removeAllListeners("data");
                file.emit("limit");
                return;
              } else if (!file.push(data)) {
                self2._pause = true;
              }
              file.bytesRead = nsize;
            };
            onEnd = function() {
              curFile = void 0;
              file.push(null);
            };
          } else {
            if (nfields === fieldsLimit) {
              if (!boy.hitFieldsLimit) {
                boy.hitFieldsLimit = true;
                boy.emit("fieldsLimit");
              }
              return skipPart(part);
            }
            ++nfields;
            ++nends;
            let buffer = "";
            let truncated = false;
            curField = part;
            onData = function(data) {
              if ((nsize += data.length) > fieldSizeLimit) {
                const extralen = fieldSizeLimit - (nsize - data.length);
                buffer += data.toString("binary", 0, extralen);
                truncated = true;
                part.removeAllListeners("data");
              } else {
                buffer += data.toString("binary");
              }
            };
            onEnd = function() {
              curField = void 0;
              if (buffer.length) {
                buffer = decodeText(buffer, "binary", charset);
              }
              boy.emit("field", fieldname, buffer, false, truncated, encoding, contype);
              --nends;
              checkFinished();
            };
          }
          part._readableState.sync = false;
          part.on("data", onData);
          part.on("end", onEnd);
        }).on("error", function(err) {
          if (curFile) {
            curFile.emit("error", err);
          }
        });
      }).on("error", function(err) {
        boy.emit("error", err);
      }).on("finish", function() {
        finished = true;
        checkFinished();
      });
    }
    Multipart.prototype.write = function(chunk, cb2) {
      const r2 = this.parser.write(chunk);
      if (r2 && !this._pause) {
        cb2();
      } else {
        this._needDrain = !r2;
        this._cb = cb2;
      }
    };
    Multipart.prototype.end = function() {
      const self2 = this;
      if (self2.parser.writable) {
        self2.parser.end();
      } else if (!self2._boy._done) {
        process.nextTick(function() {
          self2._boy._done = true;
          self2._boy.emit("finish");
        });
      }
    };
    function skipPart(part) {
      part.resume();
    }
    function FileStream(opts) {
      Readable.call(this, opts);
      this.bytesRead = 0;
      this.truncated = false;
    }
    inherits(FileStream, Readable);
    FileStream.prototype._read = function(n2) {
    };
    module.exports = Multipart;
  }
});

// node_modules/@fastify/busboy/lib/utils/Decoder.js
var require_Decoder = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/Decoder.js"(exports, module) {
    "use strict";
    var RE_PLUS = /\+/g;
    var HEX = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ];
    function Decoder() {
      this.buffer = void 0;
    }
    Decoder.prototype.write = function(str) {
      str = str.replace(RE_PLUS, " ");
      let res = "";
      let i2 = 0;
      let p2 = 0;
      const len = str.length;
      for (; i2 < len; ++i2) {
        if (this.buffer !== void 0) {
          if (!HEX[str.charCodeAt(i2)]) {
            res += "%" + this.buffer;
            this.buffer = void 0;
            --i2;
          } else {
            this.buffer += str[i2];
            ++p2;
            if (this.buffer.length === 2) {
              res += String.fromCharCode(parseInt(this.buffer, 16));
              this.buffer = void 0;
            }
          }
        } else if (str[i2] === "%") {
          if (i2 > p2) {
            res += str.substring(p2, i2);
            p2 = i2;
          }
          this.buffer = "";
          ++p2;
        }
      }
      if (p2 < len && this.buffer === void 0) {
        res += str.substring(p2);
      }
      return res;
    };
    Decoder.prototype.reset = function() {
      this.buffer = void 0;
    };
    module.exports = Decoder;
  }
});

// node_modules/@fastify/busboy/lib/types/urlencoded.js
var require_urlencoded = __commonJS({
  "node_modules/@fastify/busboy/lib/types/urlencoded.js"(exports, module) {
    "use strict";
    var Decoder = require_Decoder();
    var decodeText = require_decodeText();
    var getLimit = require_getLimit();
    var RE_CHARSET = /^charset$/i;
    UrlEncoded.detect = /^application\/x-www-form-urlencoded/i;
    function UrlEncoded(boy, cfg) {
      const limits = cfg.limits;
      const parsedConType = cfg.parsedConType;
      this.boy = boy;
      this.fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
      this.fieldNameSizeLimit = getLimit(limits, "fieldNameSize", 100);
      this.fieldsLimit = getLimit(limits, "fields", Infinity);
      let charset;
      for (var i2 = 0, len = parsedConType.length; i2 < len; ++i2) {
        if (Array.isArray(parsedConType[i2]) && RE_CHARSET.test(parsedConType[i2][0])) {
          charset = parsedConType[i2][1].toLowerCase();
          break;
        }
      }
      if (charset === void 0) {
        charset = cfg.defCharset || "utf8";
      }
      this.decoder = new Decoder();
      this.charset = charset;
      this._fields = 0;
      this._state = "key";
      this._checkingBytes = true;
      this._bytesKey = 0;
      this._bytesVal = 0;
      this._key = "";
      this._val = "";
      this._keyTrunc = false;
      this._valTrunc = false;
      this._hitLimit = false;
    }
    UrlEncoded.prototype.write = function(data, cb2) {
      if (this._fields === this.fieldsLimit) {
        if (!this.boy.hitFieldsLimit) {
          this.boy.hitFieldsLimit = true;
          this.boy.emit("fieldsLimit");
        }
        return cb2();
      }
      let idxeq;
      let idxamp;
      let i2;
      let p2 = 0;
      const len = data.length;
      while (p2 < len) {
        if (this._state === "key") {
          idxeq = idxamp = void 0;
          for (i2 = p2; i2 < len; ++i2) {
            if (!this._checkingBytes) {
              ++p2;
            }
            if (data[i2] === 61) {
              idxeq = i2;
              break;
            } else if (data[i2] === 38) {
              idxamp = i2;
              break;
            }
            if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {
              this._hitLimit = true;
              break;
            } else if (this._checkingBytes) {
              ++this._bytesKey;
            }
          }
          if (idxeq !== void 0) {
            if (idxeq > p2) {
              this._key += this.decoder.write(data.toString("binary", p2, idxeq));
            }
            this._state = "val";
            this._hitLimit = false;
            this._checkingBytes = true;
            this._val = "";
            this._bytesVal = 0;
            this._valTrunc = false;
            this.decoder.reset();
            p2 = idxeq + 1;
          } else if (idxamp !== void 0) {
            ++this._fields;
            let key;
            const keyTrunc = this._keyTrunc;
            if (idxamp > p2) {
              key = this._key += this.decoder.write(data.toString("binary", p2, idxamp));
            } else {
              key = this._key;
            }
            this._hitLimit = false;
            this._checkingBytes = true;
            this._key = "";
            this._bytesKey = 0;
            this._keyTrunc = false;
            this.decoder.reset();
            if (key.length) {
              this.boy.emit(
                "field",
                decodeText(key, "binary", this.charset),
                "",
                keyTrunc,
                false
              );
            }
            p2 = idxamp + 1;
            if (this._fields === this.fieldsLimit) {
              return cb2();
            }
          } else if (this._hitLimit) {
            if (i2 > p2) {
              this._key += this.decoder.write(data.toString("binary", p2, i2));
            }
            p2 = i2;
            if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {
              this._checkingBytes = false;
              this._keyTrunc = true;
            }
          } else {
            if (p2 < len) {
              this._key += this.decoder.write(data.toString("binary", p2));
            }
            p2 = len;
          }
        } else {
          idxamp = void 0;
          for (i2 = p2; i2 < len; ++i2) {
            if (!this._checkingBytes) {
              ++p2;
            }
            if (data[i2] === 38) {
              idxamp = i2;
              break;
            }
            if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
              this._hitLimit = true;
              break;
            } else if (this._checkingBytes) {
              ++this._bytesVal;
            }
          }
          if (idxamp !== void 0) {
            ++this._fields;
            if (idxamp > p2) {
              this._val += this.decoder.write(data.toString("binary", p2, idxamp));
            }
            this.boy.emit(
              "field",
              decodeText(this._key, "binary", this.charset),
              decodeText(this._val, "binary", this.charset),
              this._keyTrunc,
              this._valTrunc
            );
            this._state = "key";
            this._hitLimit = false;
            this._checkingBytes = true;
            this._key = "";
            this._bytesKey = 0;
            this._keyTrunc = false;
            this.decoder.reset();
            p2 = idxamp + 1;
            if (this._fields === this.fieldsLimit) {
              return cb2();
            }
          } else if (this._hitLimit) {
            if (i2 > p2) {
              this._val += this.decoder.write(data.toString("binary", p2, i2));
            }
            p2 = i2;
            if (this._val === "" && this.fieldSizeLimit === 0 || (this._bytesVal = this._val.length) === this.fieldSizeLimit) {
              this._checkingBytes = false;
              this._valTrunc = true;
            }
          } else {
            if (p2 < len) {
              this._val += this.decoder.write(data.toString("binary", p2));
            }
            p2 = len;
          }
        }
      }
      cb2();
    };
    UrlEncoded.prototype.end = function() {
      if (this.boy._done) {
        return;
      }
      if (this._state === "key" && this._key.length > 0) {
        this.boy.emit(
          "field",
          decodeText(this._key, "binary", this.charset),
          "",
          this._keyTrunc,
          false
        );
      } else if (this._state === "val") {
        this.boy.emit(
          "field",
          decodeText(this._key, "binary", this.charset),
          decodeText(this._val, "binary", this.charset),
          this._keyTrunc,
          this._valTrunc
        );
      }
      this.boy._done = true;
      this.boy.emit("finish");
    };
    module.exports = UrlEncoded;
  }
});

// node_modules/@fastify/busboy/lib/main.js
var require_main = __commonJS({
  "node_modules/@fastify/busboy/lib/main.js"(exports, module) {
    "use strict";
    var WritableStream = require_node_stream().Writable;
    var { inherits } = require_node_util();
    var Dicer = require_Dicer();
    var MultipartParser = require_multipart();
    var UrlencodedParser = require_urlencoded();
    var parseParams = require_parseParams();
    function Busboy(opts) {
      if (!(this instanceof Busboy)) {
        return new Busboy(opts);
      }
      if (typeof opts !== "object") {
        throw new TypeError("Busboy expected an options-Object.");
      }
      if (typeof opts.headers !== "object") {
        throw new TypeError("Busboy expected an options-Object with headers-attribute.");
      }
      if (typeof opts.headers["content-type"] !== "string") {
        throw new TypeError("Missing Content-Type-header.");
      }
      const _a3 = opts, {
        headers
      } = _a3, streamOptions = __objRest(_a3, [
        "headers"
      ]);
      this.opts = __spreadValues({
        autoDestroy: false
      }, streamOptions);
      WritableStream.call(this, this.opts);
      this._done = false;
      this._parser = this.getParserByHeaders(headers);
      this._finished = false;
    }
    inherits(Busboy, WritableStream);
    Busboy.prototype.emit = function(ev) {
      if (ev === "finish") {
        if (!this._done) {
          this._parser?.end();
          return;
        } else if (this._finished) {
          return;
        }
        this._finished = true;
      }
      WritableStream.prototype.emit.apply(this, arguments);
    };
    Busboy.prototype.getParserByHeaders = function(headers) {
      const parsed = parseParams(headers["content-type"]);
      const cfg = {
        defCharset: this.opts.defCharset,
        fileHwm: this.opts.fileHwm,
        headers,
        highWaterMark: this.opts.highWaterMark,
        isPartAFile: this.opts.isPartAFile,
        limits: this.opts.limits,
        parsedConType: parsed,
        preservePath: this.opts.preservePath
      };
      if (MultipartParser.detect.test(parsed[0])) {
        return new MultipartParser(this, cfg);
      }
      if (UrlencodedParser.detect.test(parsed[0])) {
        return new UrlencodedParser(this, cfg);
      }
      throw new Error("Unsupported Content-Type.");
    };
    Busboy.prototype._write = function(chunk, encoding, cb2) {
      this._parser.write(chunk, cb2);
    };
    module.exports = Busboy;
    module.exports.default = Busboy;
    module.exports.Busboy = Busboy;
    module.exports.Dicer = Dicer;
  }
});

// node_modules/firebase-admin/lib/utils/api-request.js
var require_api_request = __commonJS({
  "node_modules/firebase-admin/lib/utils/api-request.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExponentialBackoffPoller = exports.ApiSettings = exports.AuthorizedHttpClient = exports.parseHttpResponse = exports.HttpClient = exports.defaultRetryConfig = exports.HttpError = void 0;
    var error_1 = require_error();
    var validator = require_validator();
    var http = require_http();
    var https = require_https();
    var url = require_url();
    var events_1 = require_events();
    var DefaultHttpResponse = class {
      /**
       * Constructs a new HttpResponse from the given LowLevelResponse.
       */
      constructor(resp) {
        this.status = resp.status;
        this.headers = resp.headers;
        this.text = resp.data;
        try {
          if (!resp.data) {
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, "HTTP response missing data.");
          }
          this.parsedData = JSON.parse(resp.data);
        } catch (err) {
          this.parsedData = void 0;
          this.parseError = err;
        }
        this.request = `${resp.config.method} ${resp.config.url}`;
      }
      get data() {
        if (this.isJson()) {
          return this.parsedData;
        }
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.UNABLE_TO_PARSE_RESPONSE, `Error while parsing response data: "${this.parseError.toString()}". Raw server response: "${this.text}". Status code: "${this.status}". Outgoing request: "${this.request}."`);
      }
      isJson() {
        return typeof this.parsedData !== "undefined";
      }
    };
    var MultipartHttpResponse = class {
      constructor(resp) {
        this.status = resp.status;
        this.headers = resp.headers;
        this.multipart = resp.multipart;
      }
      get text() {
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.UNABLE_TO_PARSE_RESPONSE, "Unable to parse multipart payload as text");
      }
      get data() {
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.UNABLE_TO_PARSE_RESPONSE, "Unable to parse multipart payload as JSON");
      }
      isJson() {
        return false;
      }
    };
    var HttpError = class _HttpError extends Error {
      constructor(response) {
        super(`Server responded with status ${response.status}.`);
        this.response = response;
        Object.setPrototypeOf(this, _HttpError.prototype);
      }
    };
    exports.HttpError = HttpError;
    function defaultRetryConfig() {
      return {
        maxRetries: 4,
        statusCodes: [503],
        ioErrorCodes: ["ECONNRESET", "ETIMEDOUT"],
        backOffFactor: 0.5,
        maxDelayInMillis: 60 * 1e3
      };
    }
    exports.defaultRetryConfig = defaultRetryConfig;
    function validateRetryConfig(retry) {
      if (!validator.isNumber(retry.maxRetries) || retry.maxRetries < 0) {
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, "maxRetries must be a non-negative integer");
      }
      if (typeof retry.backOffFactor !== "undefined") {
        if (!validator.isNumber(retry.backOffFactor) || retry.backOffFactor < 0) {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, "backOffFactor must be a non-negative number");
        }
      }
      if (!validator.isNumber(retry.maxDelayInMillis) || retry.maxDelayInMillis < 0) {
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, "maxDelayInMillis must be a non-negative integer");
      }
      if (typeof retry.statusCodes !== "undefined" && !validator.isArray(retry.statusCodes)) {
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, "statusCodes must be an array");
      }
      if (typeof retry.ioErrorCodes !== "undefined" && !validator.isArray(retry.ioErrorCodes)) {
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, "ioErrorCodes must be an array");
      }
    }
    var HttpClient = class {
      constructor(retry = defaultRetryConfig()) {
        this.retry = retry;
        if (this.retry) {
          validateRetryConfig(this.retry);
        }
      }
      /**
       * Sends an HTTP request to a remote server. If the server responds with a successful response (2xx), the returned
       * promise resolves with an HttpResponse. If the server responds with an error (3xx, 4xx, 5xx), the promise rejects
       * with an HttpError. In case of all other errors, the promise rejects with a FirebaseAppError. If a request fails
       * due to a low-level network error, transparently retries the request once before rejecting the promise.
       *
       * If the request data is specified as an object, it will be serialized into a JSON string. The application/json
       * content-type header will also be automatically set in this case. For all other payload types, the content-type
       * header should be explicitly set by the caller. To send a JSON leaf value (e.g. "foo", 5), parse it into JSON,
       * and pass as a string or a Buffer along with the appropriate content-type header.
       *
       * @param config - HTTP request to be sent.
       * @returns A promise that resolves with the response details.
       */
      send(config2) {
        return this.sendWithRetry(config2);
      }
      /**
       * Sends an HTTP request. In the event of an error, retries the HTTP request according to the
       * RetryConfig set on the HttpClient.
       *
       * @param config - HTTP request to be sent.
       * @param retryAttempts - Number of retries performed up to now.
       * @returns A promise that resolves with the response details.
       */
      sendWithRetry(config2, retryAttempts = 0) {
        return AsyncHttpCall.invoke(config2).then((resp) => {
          return this.createHttpResponse(resp);
        }).catch((err) => {
          const [delayMillis, canRetry] = this.getRetryDelayMillis(retryAttempts, err);
          if (canRetry && this.retry && delayMillis <= this.retry.maxDelayInMillis) {
            return this.waitForRetry(delayMillis).then(() => {
              return this.sendWithRetry(config2, retryAttempts + 1);
            });
          }
          if (err.response) {
            throw new HttpError(this.createHttpResponse(err.response));
          }
          if (err.code === "ETIMEDOUT") {
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NETWORK_TIMEOUT, `Error while making request: ${err.message}.`);
          }
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NETWORK_ERROR, `Error while making request: ${err.message}. Error code: ${err.code}`);
        });
      }
      createHttpResponse(resp) {
        if (resp.multipart) {
          return new MultipartHttpResponse(resp);
        }
        return new DefaultHttpResponse(resp);
      }
      waitForRetry(delayMillis) {
        if (delayMillis > 0) {
          return new Promise((resolve2) => {
            setTimeout(resolve2, delayMillis);
          });
        }
        return Promise.resolve();
      }
      /**
       * Checks if a failed request is eligible for a retry, and if so returns the duration to wait before initiating
       * the retry.
       *
       * @param retryAttempts - Number of retries completed up to now.
       * @param err - The last encountered error.
       * @returns A 2-tuple where the 1st element is the duration to wait before another retry, and the
       *     2nd element is a boolean indicating whether the request is eligible for a retry or not.
       */
      getRetryDelayMillis(retryAttempts, err) {
        if (!this.isRetryEligible(retryAttempts, err)) {
          return [0, false];
        }
        const response = err.response;
        if (response && response.headers["retry-after"]) {
          const delayMillis = this.parseRetryAfterIntoMillis(response.headers["retry-after"]);
          if (delayMillis > 0) {
            return [delayMillis, true];
          }
        }
        return [this.backOffDelayMillis(retryAttempts), true];
      }
      isRetryEligible(retryAttempts, err) {
        if (!this.retry) {
          return false;
        }
        if (retryAttempts >= this.retry.maxRetries) {
          return false;
        }
        if (err.response) {
          const statusCodes = this.retry.statusCodes || [];
          return statusCodes.indexOf(err.response.status) !== -1;
        }
        if (err.code) {
          const retryCodes = this.retry.ioErrorCodes || [];
          return retryCodes.indexOf(err.code) !== -1;
        }
        return false;
      }
      /**
       * Parses the Retry-After HTTP header as a milliseconds value. Return value is negative if the Retry-After header
       * contains an expired timestamp or otherwise malformed.
       */
      parseRetryAfterIntoMillis(retryAfter) {
        const delaySeconds = parseInt(retryAfter, 10);
        if (!isNaN(delaySeconds)) {
          return delaySeconds * 1e3;
        }
        const date = new Date(retryAfter);
        if (!isNaN(date.getTime())) {
          return date.getTime() - Date.now();
        }
        return -1;
      }
      backOffDelayMillis(retryAttempts) {
        if (retryAttempts === 0) {
          return 0;
        }
        if (!this.retry) {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, "Expected this.retry to exist.");
        }
        const backOffFactor = this.retry.backOffFactor || 0;
        const delayInSeconds = 2 ** retryAttempts * backOffFactor;
        return Math.min(delayInSeconds * 1e3, this.retry.maxDelayInMillis);
      }
    };
    exports.HttpClient = HttpClient;
    function parseHttpResponse(response, config2) {
      const responseText = validator.isBuffer(response) ? response.toString("utf-8") : response;
      const endOfHeaderPos = responseText.indexOf("\r\n\r\n");
      const headerLines = responseText.substring(0, endOfHeaderPos).split("\r\n");
      const statusLine = headerLines[0];
      const status = statusLine.trim().split(/\s/)[1];
      const headers = {};
      headerLines.slice(1).forEach((line) => {
        const colonPos = line.indexOf(":");
        const name4 = line.substring(0, colonPos).trim().toLowerCase();
        const value = line.substring(colonPos + 1).trim();
        headers[name4] = value;
      });
      let data = responseText.substring(endOfHeaderPos + 4);
      if (data.endsWith("\n")) {
        data = data.slice(0, -1);
      }
      if (data.endsWith("\r")) {
        data = data.slice(0, -1);
      }
      const lowLevelResponse = {
        status: parseInt(status, 10),
        headers,
        data,
        config: config2,
        request: null
      };
      if (!validator.isNumber(lowLevelResponse.status)) {
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, "Malformed HTTP status line.");
      }
      return new DefaultHttpResponse(lowLevelResponse);
    }
    exports.parseHttpResponse = parseHttpResponse;
    var AsyncHttpCall = class _AsyncHttpCall {
      /**
       * Sends an HTTP request based on the provided configuration.
       */
      static invoke(config2) {
        return new _AsyncHttpCall(config2).promise;
      }
      constructor(config2) {
        try {
          this.config = new HttpRequestConfigImpl(config2);
          this.options = this.config.buildRequestOptions();
          this.entity = this.config.buildEntity(this.options.headers);
          this.promise = new Promise((resolve2, reject) => {
            this.resolve = resolve2;
            this.reject = reject;
            this.execute();
          });
        } catch (err) {
          this.promise = Promise.reject(this.enhanceError(err, null));
        }
      }
      execute() {
        const transport = this.options.protocol === "https:" ? https : http;
        const req = transport.request(this.options, (res) => {
          this.handleResponse(res, req);
        });
        req.on("error", (err) => {
          if (req.aborted) {
            return;
          }
          this.enhanceAndReject(err, null, req);
        });
        const timeout = this.config.timeout;
        const timeoutCallback = () => {
          req.abort();
          this.rejectWithError(`timeout of ${timeout}ms exceeded`, "ETIMEDOUT", req);
        };
        if (timeout) {
          req.setTimeout(timeout, timeoutCallback);
        }
        req.end(this.entity);
      }
      handleResponse(res, req) {
        if (req.aborted) {
          return;
        }
        if (!res.statusCode) {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, "Expected a statusCode on the response from a ClientRequest");
        }
        const response = {
          status: res.statusCode,
          headers: res.headers,
          request: req,
          data: void 0,
          config: this.config
        };
        const boundary = this.getMultipartBoundary(res.headers);
        const respStream = this.uncompressResponse(res);
        if (boundary) {
          this.handleMultipartResponse(response, respStream, boundary);
        } else {
          this.handleRegularResponse(response, respStream);
        }
      }
      /**
       * Extracts multipart boundary from the HTTP header. The content-type header of a multipart
       * response has the form 'multipart/subtype; boundary=string'.
       *
       * If the content-type header does not exist, or does not start with
       * 'multipart/', then null will be returned.
       */
      getMultipartBoundary(headers) {
        const contentType = headers["content-type"];
        if (!contentType || !contentType.startsWith("multipart/")) {
          return null;
        }
        const segments = contentType.split(";");
        const emptyObject = {};
        const headerParams = segments.slice(1).map((segment) => segment.trim().split("=")).reduce((curr, params) => {
          if (params.length === 2) {
            const keyValuePair = {};
            keyValuePair[params[0]] = params[1];
            return Object.assign(curr, keyValuePair);
          }
          return curr;
        }, emptyObject);
        return headerParams.boundary;
      }
      uncompressResponse(res) {
        let respStream = res;
        const encodings = ["gzip", "compress", "deflate"];
        if (res.headers["content-encoding"] && encodings.indexOf(res.headers["content-encoding"]) !== -1) {
          const zlib = require_zlib();
          respStream = respStream.pipe(zlib.createUnzip());
          delete res.headers["content-encoding"];
        }
        return respStream;
      }
      handleMultipartResponse(response, respStream, boundary) {
        const busboy = require_main();
        const multipartParser = new busboy.Dicer({ boundary });
        const responseBuffer = [];
        multipartParser.on("part", (part) => {
          const tempBuffers = [];
          part.on("data", (partData) => {
            tempBuffers.push(partData);
          });
          part.on("end", () => {
            responseBuffer.push(Buffer.concat(tempBuffers));
          });
        });
        multipartParser.on("finish", () => {
          response.data = void 0;
          response.multipart = responseBuffer;
          this.finalizeResponse(response);
        });
        respStream.pipe(multipartParser);
      }
      handleRegularResponse(response, respStream) {
        const responseBuffer = [];
        respStream.on("data", (chunk) => {
          responseBuffer.push(chunk);
        });
        respStream.on("error", (err) => {
          const req = response.request;
          if (req && req.aborted) {
            return;
          }
          this.enhanceAndReject(err, null, req);
        });
        respStream.on("end", () => {
          response.data = Buffer.concat(responseBuffer).toString();
          this.finalizeResponse(response);
        });
      }
      /**
       * Finalizes the current HTTP call in-flight by either resolving or rejecting the associated
       * promise. In the event of an error, adds additional useful information to the returned error.
       */
      finalizeResponse(response) {
        if (response.status >= 200 && response.status < 300) {
          this.resolve(response);
        } else {
          this.rejectWithError("Request failed with status code " + response.status, null, response.request, response);
        }
      }
      /**
       * Creates a new error from the given message, and enhances it with other information available.
       * Then the promise associated with this HTTP call is rejected with the resulting error.
       */
      rejectWithError(message, code, request, response) {
        const error = new Error(message);
        this.enhanceAndReject(error, code, request, response);
      }
      enhanceAndReject(error, code, request, response) {
        this.reject(this.enhanceError(error, code, request, response));
      }
      /**
       * Enhances the given error by adding more information to it. Specifically, the HttpRequestConfig,
       * the underlying request and response will be attached to the error.
       */
      enhanceError(error, code, request, response) {
        error.config = this.config;
        if (code) {
          error.code = code;
        }
        error.request = request;
        error.response = response;
        return error;
      }
    };
    var HttpRequestConfigImpl = class {
      constructor(config2) {
        this.config = config2;
      }
      get method() {
        return this.config.method;
      }
      get url() {
        return this.config.url;
      }
      get headers() {
        return this.config.headers;
      }
      get data() {
        return this.config.data;
      }
      get timeout() {
        return this.config.timeout;
      }
      get httpAgent() {
        return this.config.httpAgent;
      }
      buildRequestOptions() {
        const parsed = this.buildUrl();
        const protocol = parsed.protocol;
        let port = parsed.port;
        if (!port) {
          const isHttps = protocol === "https:";
          port = isHttps ? "443" : "80";
        }
        return {
          protocol,
          hostname: parsed.hostname,
          port,
          path: parsed.path,
          method: this.method,
          agent: this.httpAgent,
          headers: Object.assign({}, this.headers)
        };
      }
      buildEntity(headers) {
        let data;
        if (!this.hasEntity() || !this.isEntityEnclosingRequest()) {
          return data;
        }
        if (validator.isBuffer(this.data)) {
          data = this.data;
        } else if (validator.isObject(this.data)) {
          data = Buffer.from(JSON.stringify(this.data), "utf-8");
          if (typeof headers["content-type"] === "undefined") {
            headers["content-type"] = "application/json;charset=utf-8";
          }
        } else if (validator.isString(this.data)) {
          data = Buffer.from(this.data, "utf-8");
        } else {
          throw new Error("Request data must be a string, a Buffer or a json serializable object");
        }
        headers["Content-Length"] = data.length.toString();
        return data;
      }
      buildUrl() {
        const fullUrl = this.urlWithProtocol();
        if (!this.hasEntity() || this.isEntityEnclosingRequest()) {
          return url.parse(fullUrl);
        }
        if (!validator.isObject(this.data)) {
          throw new Error(`${this.method} requests cannot have a body`);
        }
        const parsedUrl = new url.URL(fullUrl);
        const dataObj = this.data;
        for (const key in dataObj) {
          if (Object.prototype.hasOwnProperty.call(dataObj, key)) {
            parsedUrl.searchParams.append(key, dataObj[key]);
          }
        }
        return url.parse(parsedUrl.toString());
      }
      urlWithProtocol() {
        const fullUrl = this.url;
        if (fullUrl.startsWith("http://") || fullUrl.startsWith("https://")) {
          return fullUrl;
        }
        return `https://${fullUrl}`;
      }
      hasEntity() {
        return !!this.data;
      }
      isEntityEnclosingRequest() {
        return this.method !== "GET" && this.method !== "HEAD";
      }
    };
    var AuthorizedHttpClient = class extends HttpClient {
      constructor(app) {
        super();
        this.app = app;
      }
      send(request) {
        return this.getToken().then((token) => {
          const requestCopy = Object.assign({}, request);
          requestCopy.headers = Object.assign({}, request.headers);
          const authHeader = "Authorization";
          requestCopy.headers[authHeader] = `Bearer ${token}`;
          if (!requestCopy.httpAgent && this.app.options.httpAgent) {
            requestCopy.httpAgent = this.app.options.httpAgent;
          }
          return super.send(requestCopy);
        });
      }
      getToken() {
        return this.app.INTERNAL.getToken().then((accessTokenObj) => {
          return accessTokenObj.accessToken;
        });
      }
    };
    exports.AuthorizedHttpClient = AuthorizedHttpClient;
    var ApiSettings = class {
      constructor(endpoint, httpMethod = "POST") {
        this.endpoint = endpoint;
        this.httpMethod = httpMethod;
        this.setRequestValidator(null).setResponseValidator(null);
      }
      /** @returns The backend API endpoint. */
      getEndpoint() {
        return this.endpoint;
      }
      /** @returns The request HTTP method. */
      getHttpMethod() {
        return this.httpMethod;
      }
      /**
       * @param requestValidator - The request validator.
       * @returns The current API settings instance.
       */
      setRequestValidator(requestValidator) {
        const nullFunction = () => void 0;
        this.requestValidator = requestValidator || nullFunction;
        return this;
      }
      /** @returns The request validator. */
      getRequestValidator() {
        return this.requestValidator;
      }
      /**
       * @param responseValidator - The response validator.
       * @returns The current API settings instance.
       */
      setResponseValidator(responseValidator) {
        const nullFunction = () => void 0;
        this.responseValidator = responseValidator || nullFunction;
        return this;
      }
      /** @returns The response validator. */
      getResponseValidator() {
        return this.responseValidator;
      }
    };
    exports.ApiSettings = ApiSettings;
    var ExponentialBackoffPoller = class extends events_1.EventEmitter {
      constructor(initialPollingDelayMillis = 1e3, maxPollingDelayMillis = 1e4, masterTimeoutMillis = 6e4) {
        super();
        this.initialPollingDelayMillis = initialPollingDelayMillis;
        this.maxPollingDelayMillis = maxPollingDelayMillis;
        this.masterTimeoutMillis = masterTimeoutMillis;
        this.numTries = 0;
        this.completed = false;
      }
      /**
       * Poll the provided callback with exponential backoff.
       *
       * @param callback - The callback to be called for each poll. If the
       *     callback resolves to a falsey value, polling will continue. Otherwise, the truthy
       *     resolution will be used to resolve the promise returned by this method.
       * @returns A Promise which resolves to the truthy value returned by the provided
       *     callback when polling is complete.
       */
      poll(callback) {
        if (this.pollCallback) {
          throw new Error("poll() can only be called once per instance of ExponentialBackoffPoller");
        }
        this.pollCallback = callback;
        this.on("poll", this.repoll);
        this.masterTimer = setTimeout(() => {
          if (this.completed) {
            return;
          }
          this.markCompleted();
          this.reject(new Error("ExponentialBackoffPoller deadline exceeded - Master timeout reached"));
        }, this.masterTimeoutMillis);
        return new Promise((resolve2, reject) => {
          this.resolve = resolve2;
          this.reject = reject;
          this.repoll();
        });
      }
      repoll() {
        this.pollCallback().then((result) => {
          if (this.completed) {
            return;
          }
          if (!result) {
            this.repollTimer = setTimeout(() => this.emit("poll"), this.getPollingDelayMillis());
            this.numTries++;
            return;
          }
          this.markCompleted();
          this.resolve(result);
        }).catch((err) => {
          if (this.completed) {
            return;
          }
          this.markCompleted();
          this.reject(err);
        });
      }
      getPollingDelayMillis() {
        const increasedPollingDelay = Math.pow(2, this.numTries) * this.initialPollingDelayMillis;
        return Math.min(increasedPollingDelay, this.maxPollingDelayMillis);
      }
      markCompleted() {
        this.completed = true;
        if (this.masterTimer) {
          clearTimeout(this.masterTimer);
        }
        if (this.repollTimer) {
          clearTimeout(this.repollTimer);
        }
      }
    };
    exports.ExponentialBackoffPoller = ExponentialBackoffPoller;
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i2 = 0, len = code.length; i2 < len; ++i2) {
      lookup[i2] = code[i2];
      revLookup[code.charCodeAt(i2)] = i2;
    }
    var i2;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i3;
      for (i3 = 0; i3 < len2; i3 += 4) {
        tmp = revLookup[b64.charCodeAt(i3)] << 18 | revLookup[b64.charCodeAt(i3 + 1)] << 12 | revLookup[b64.charCodeAt(i3 + 2)] << 6 | revLookup[b64.charCodeAt(i3 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i3)] << 2 | revLookup[b64.charCodeAt(i3 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i3)] << 10 | revLookup[b64.charCodeAt(i3 + 1)] << 4 | revLookup[b64.charCodeAt(i3 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start2, end) {
      var tmp;
      var output = [];
      for (var i3 = start2; i3 < end; i3 += 3) {
        tmp = (uint8[i3] << 16 & 16711680) + (uint8[i3 + 1] << 8 & 65280) + (uint8[i3 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i3 = 0, len22 = len2 - extraBytes; i3 < len22; i3 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i3, i3 + maxChunkLength > len22 ? len22 : i3 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset2, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i2 = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset2 + i2];
      i2 += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset2 + i2], i2 += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset2 + i2], i2 += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset2, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i2 = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt2 / c;
        } else {
          value += rt2 * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset2 + i2] = m & 255, i2 += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset2 + i2] = e & 255, i2 += d, e /= 256, eLen -= 8) {
      }
      buffer[offset2 + i2 - d] |= s * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer2;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        var proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      var buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from3(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from3(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      var valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      var b2 = fromObject(value);
      if (b2)
        return b2;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(
          value[Symbol.toPrimitive]("string"),
          encodingOrOffset,
          length
        );
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from3(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      var length = byteLength(string, encoding) | 0;
      var buf = createBuffer(length);
      var actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length);
      for (var i2 = 0; i2 < length; i2 += 1) {
        buf[i2] = array[i2] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      var buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer(b2) {
      return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
    };
    Buffer2.compare = function compare(a, b2) {
      if (isInstance(a, Uint8Array))
        a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b2, Uint8Array))
        b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b2)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b2)
        return 0;
      var x3 = a.length;
      var y2 = b2.length;
      for (var i2 = 0, len = Math.min(x3, y2); i2 < len; ++i2) {
        if (a[i2] !== b2[i2]) {
          x3 = a[i2];
          y2 = b2[i2];
          break;
        }
      }
      if (x3 < y2)
        return -1;
      if (y2 < x3)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat2(list2, length) {
      if (!Array.isArray(list2)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list2.length === 0) {
        return Buffer2.alloc(0);
      }
      var i2;
      if (length === void 0) {
        length = 0;
        for (i2 = 0; i2 < list2.length; ++i2) {
          length += list2[i2].length;
        }
      }
      var buffer = Buffer2.allocUnsafe(length);
      var pos = 0;
      for (i2 = 0; i2 < list2.length; ++i2) {
        var buf = list2[i2];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            Buffer2.from(buf).copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      var len = string.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start2, end) {
      var loweredCase = false;
      if (start2 === void 0 || start2 < 0) {
        start2 = 0;
      }
      if (start2 > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start2 >>>= 0;
      if (end <= start2) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start2, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start2, end);
          case "ascii":
            return asciiSlice(this, start2, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start2, end);
          case "base64":
            return base64Slice(this, start2, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start2, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b2, n2, m) {
      var i2 = b2[n2];
      b2[n2] = b2[m];
      b2[m] = i2;
    }
    Buffer2.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i2 = 0; i2 < len; i2 += 2) {
        swap(this, i2, i2 + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i2 = 0; i2 < len; i2 += 4) {
        swap(this, i2, i2 + 3);
        swap(this, i2 + 1, i2 + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i2 = 0; i2 < len; i2 += 8) {
        swap(this, i2, i2 + 7);
        swap(this, i2 + 1, i2 + 6);
        swap(this, i2 + 2, i2 + 5);
        swap(this, i2 + 3, i2 + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      var length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b2) {
      if (!Buffer2.isBuffer(b2))
        throw new TypeError("Argument must be a Buffer");
      if (this === b2)
        return true;
      return Buffer2.compare(this, b2) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      var str = "";
      var max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare(target, start2, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start2 === void 0) {
        start2 = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start2 < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start2 >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start2 >= end) {
        return 1;
      }
      start2 >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x3 = thisEnd - thisStart;
      var y2 = end - start2;
      var len = Math.min(x3, y2);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start2, end);
      for (var i2 = 0; i2 < len; ++i2) {
        if (thisCopy[i2] !== targetCopy[i2]) {
          x3 = thisCopy[i2];
          y2 = targetCopy[i2];
          break;
        }
      }
      if (x3 < y2)
        return -1;
      if (y2 < x3)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i3) {
        if (indexSize === 1) {
          return buf[i3];
        } else {
          return buf.readUInt16BE(i3 * indexSize);
        }
      }
      var i2;
      if (dir) {
        var foundIndex = -1;
        for (i2 = byteOffset; i2 < arrLength; i2++) {
          if (read(arr, i2) === read(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i2;
            if (i2 - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i2 -= i2 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i2 = byteOffset; i2 >= 0; i2--) {
          var found = true;
          for (var j2 = 0; j2 < valLength; j2++) {
            if (read(arr, i2 + j2) !== read(val, j2)) {
              found = false;
              break;
            }
          }
          if (found)
            return i2;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset2, length) {
      offset2 = Number(offset2) || 0;
      var remaining = buf.length - offset2;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      var strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i2 = 0; i2 < length; ++i2) {
        var parsed = parseInt(string.substr(i2 * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i2;
        buf[offset2 + i2] = parsed;
      }
      return i2;
    }
    function utf8Write(buf, string, offset2, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset2), buf, offset2, length);
    }
    function asciiWrite(buf, string, offset2, length) {
      return blitBuffer(asciiToBytes(string), buf, offset2, length);
    }
    function base64Write(buf, string, offset2, length) {
      return blitBuffer(base64ToBytes(string), buf, offset2, length);
    }
    function ucs2Write(buf, string, offset2, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset2), buf, offset2, length);
    }
    Buffer2.prototype.write = function write(string, offset2, length, encoding) {
      if (offset2 === void 0) {
        encoding = "utf8";
        length = this.length;
        offset2 = 0;
      } else if (length === void 0 && typeof offset2 === "string") {
        encoding = offset2;
        length = this.length;
        offset2 = 0;
      } else if (isFinite(offset2)) {
        offset2 = offset2 >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset2;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset2 < 0) || offset2 > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset2, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset2, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset2, length);
          case "base64":
            return base64Write(this, string, offset2, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset2, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start2, end) {
      if (start2 === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start2, end));
      }
    }
    function utf8Slice(buf, start2, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i2 = start2;
      while (i2 < end) {
        var firstByte = buf[i2];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i2 + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i2 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i2 + 1];
              thirdByte = buf[i2 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i2 + 1];
              thirdByte = buf[i2 + 2];
              fourthByte = buf[i2 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i2 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = "";
      var i2 = 0;
      while (i2 < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start2, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i2 = start2; i2 < end; ++i2) {
        ret += String.fromCharCode(buf[i2] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start2, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i2 = start2; i2 < end; ++i2) {
        ret += String.fromCharCode(buf[i2]);
      }
      return ret;
    }
    function hexSlice(buf, start2, end) {
      var len = buf.length;
      if (!start2 || start2 < 0)
        start2 = 0;
      if (!end || end < 0 || end > len)
        end = len;
      var out = "";
      for (var i2 = start2; i2 < end; ++i2) {
        out += hexSliceLookupTable[buf[i2]];
      }
      return out;
    }
    function utf16leSlice(buf, start2, end) {
      var bytes = buf.slice(start2, end);
      var res = "";
      for (var i2 = 0; i2 < bytes.length - 1; i2 += 2) {
        res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start2, end) {
      var len = this.length;
      start2 = ~~start2;
      end = end === void 0 ? len : ~~end;
      if (start2 < 0) {
        start2 += len;
        if (start2 < 0)
          start2 = 0;
      } else if (start2 > len) {
        start2 = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start2)
        end = start2;
      var newBuf = this.subarray(start2, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset2, ext, length) {
      if (offset2 % 1 !== 0 || offset2 < 0)
        throw new RangeError("offset is not uint");
      if (offset2 + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset2, byteLength2, noAssert) {
      offset2 = offset2 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, byteLength2, this.length);
      var val = this[offset2];
      var mul = 1;
      var i2 = 0;
      while (++i2 < byteLength2 && (mul *= 256)) {
        val += this[offset2 + i2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset2, byteLength2, noAssert) {
      offset2 = offset2 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset2, byteLength2, this.length);
      }
      var val = this[offset2 + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset2 + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 1, this.length);
      return this[offset2];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 2, this.length);
      return this[offset2] | this[offset2 + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 2, this.length);
      return this[offset2] << 8 | this[offset2 + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 4, this.length);
      return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 4, this.length);
      return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
    };
    Buffer2.prototype.readIntLE = function readIntLE(offset2, byteLength2, noAssert) {
      offset2 = offset2 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, byteLength2, this.length);
      var val = this[offset2];
      var mul = 1;
      var i2 = 0;
      while (++i2 < byteLength2 && (mul *= 256)) {
        val += this[offset2 + i2] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset2, byteLength2, noAssert) {
      offset2 = offset2 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, byteLength2, this.length);
      var i2 = byteLength2;
      var mul = 1;
      var val = this[offset2 + --i2];
      while (i2 > 0 && (mul *= 256)) {
        val += this[offset2 + --i2] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 1, this.length);
      if (!(this[offset2] & 128))
        return this[offset2];
      return (255 - this[offset2] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 2, this.length);
      var val = this[offset2] | this[offset2 + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 2, this.length);
      var val = this[offset2 + 1] | this[offset2] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 4, this.length);
      return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 4, this.length);
      return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
    };
    Buffer2.prototype.readFloatLE = function readFloatLE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 4, this.length);
      return ieee754.read(this, offset2, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 4, this.length);
      return ieee754.read(this, offset2, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 8, this.length);
      return ieee754.read(this, offset2, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 8, this.length);
      return ieee754.read(this, offset2, false, 52, 8);
    };
    function checkInt(buf, value, offset2, ext, max, min) {
      if (!Buffer2.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset2 + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset2, byteLength2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset2, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i2 = 0;
      this[offset2] = value & 255;
      while (++i2 < byteLength2 && (mul *= 256)) {
        this[offset2 + i2] = value / mul & 255;
      }
      return offset2 + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset2, byteLength2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset2, byteLength2, maxBytes, 0);
      }
      var i2 = byteLength2 - 1;
      var mul = 1;
      this[offset2 + i2] = value & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        this[offset2 + i2] = value / mul & 255;
      }
      return offset2 + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset2, 1, 255, 0);
      this[offset2] = value & 255;
      return offset2 + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset2, 2, 65535, 0);
      this[offset2] = value & 255;
      this[offset2 + 1] = value >>> 8;
      return offset2 + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset2, 2, 65535, 0);
      this[offset2] = value >>> 8;
      this[offset2 + 1] = value & 255;
      return offset2 + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset2, 4, 4294967295, 0);
      this[offset2 + 3] = value >>> 24;
      this[offset2 + 2] = value >>> 16;
      this[offset2 + 1] = value >>> 8;
      this[offset2] = value & 255;
      return offset2 + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset2, 4, 4294967295, 0);
      this[offset2] = value >>> 24;
      this[offset2 + 1] = value >>> 16;
      this[offset2 + 2] = value >>> 8;
      this[offset2 + 3] = value & 255;
      return offset2 + 4;
    };
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset2, byteLength2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset2, byteLength2, limit - 1, -limit);
      }
      var i2 = 0;
      var mul = 1;
      var sub = 0;
      this[offset2] = value & 255;
      while (++i2 < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset2 + i2 - 1] !== 0) {
          sub = 1;
        }
        this[offset2 + i2] = (value / mul >> 0) - sub & 255;
      }
      return offset2 + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset2, byteLength2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset2, byteLength2, limit - 1, -limit);
      }
      var i2 = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset2 + i2] = value & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset2 + i2 + 1] !== 0) {
          sub = 1;
        }
        this[offset2 + i2] = (value / mul >> 0) - sub & 255;
      }
      return offset2 + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset2, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset2] = value & 255;
      return offset2 + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset2, 2, 32767, -32768);
      this[offset2] = value & 255;
      this[offset2 + 1] = value >>> 8;
      return offset2 + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset2, 2, 32767, -32768);
      this[offset2] = value >>> 8;
      this[offset2 + 1] = value & 255;
      return offset2 + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset2, 4, 2147483647, -2147483648);
      this[offset2] = value & 255;
      this[offset2 + 1] = value >>> 8;
      this[offset2 + 2] = value >>> 16;
      this[offset2 + 3] = value >>> 24;
      return offset2 + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset2, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset2] = value >>> 24;
      this[offset2 + 1] = value >>> 16;
      this[offset2 + 2] = value >>> 8;
      this[offset2 + 3] = value & 255;
      return offset2 + 4;
    };
    function checkIEEE754(buf, value, offset2, ext, max, min) {
      if (offset2 + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset2 < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset2, littleEndian, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset2, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset2, littleEndian, 23, 4);
      return offset2 + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset2, noAssert) {
      return writeFloat(this, value, offset2, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset2, noAssert) {
      return writeFloat(this, value, offset2, false, noAssert);
    };
    function writeDouble(buf, value, offset2, littleEndian, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset2, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset2, littleEndian, 52, 8);
      return offset2 + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset2, noAssert) {
      return writeDouble(this, value, offset2, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset2, noAssert) {
      return writeDouble(this, value, offset2, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start2, end) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start2)
        start2 = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start2)
        end = start2;
      if (end === start2)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start2 < 0 || start2 >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start2) {
        end = target.length - targetStart + start2;
      }
      var len = end - start2;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start2, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start2, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start2, end, encoding) {
      if (typeof val === "string") {
        if (typeof start2 === "string") {
          encoding = start2;
          start2 = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start2 < 0 || this.length < start2 || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start2) {
        return this;
      }
      start2 = start2 >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i2;
      if (typeof val === "number") {
        for (i2 = start2; i2 < end; ++i2) {
          this[i2] = val;
        }
      } else {
        var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        var len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i2 = 0; i2 < end - start2; ++i2) {
          this[i2 + start2] = bytes[i2 % len];
        }
      }
      return this;
    };
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i2 = 0; i2 < length; ++i2) {
        codePoint = string.charCodeAt(i2);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i2 + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i2 = 0; i2 < str.length; ++i2) {
        byteArray.push(str.charCodeAt(i2) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      var c, hi2, lo2;
      var byteArray = [];
      for (var i2 = 0; i2 < str.length; ++i2) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i2);
        hi2 = c >> 8;
        lo2 = c % 256;
        byteArray.push(lo2);
        byteArray.push(hi2);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset2, length) {
      for (var i2 = 0; i2 < length; ++i2) {
        if (i2 + offset2 >= dst.length || i2 >= src.length)
          break;
        dst[i2 + offset2] = src[i2];
      }
      return i2;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      var alphabet = "0123456789abcdef";
      var table = new Array(256);
      for (var i2 = 0; i2 < 16; ++i2) {
        var i16 = i2 * 16;
        for (var j2 = 0; j2 < 16; ++j2) {
          table[i16 + j2] = alphabet[i2] + alphabet[j2];
        }
      }
      return table;
    }();
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports, module) {
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// browser-external:stream
var require_stream = __commonJS({
  "browser-external:stream"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "stream" has been externalized for browser compatibility. Cannot access "stream.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:util
var require_util = __commonJS({
  "browser-external:util"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/jws/lib/data-stream.js
var require_data_stream = __commonJS({
  "node_modules/jws/lib/data-stream.js"(exports, module) {
    var Buffer2 = require_safe_buffer().Buffer;
    var Stream = require_stream();
    var util = require_util();
    function DataStream(data) {
      this.buffer = null;
      this.writable = true;
      this.readable = true;
      if (!data) {
        this.buffer = Buffer2.alloc(0);
        return this;
      }
      if (typeof data.pipe === "function") {
        this.buffer = Buffer2.alloc(0);
        data.pipe(this);
        return this;
      }
      if (data.length || typeof data === "object") {
        this.buffer = data;
        this.writable = false;
        process.nextTick((function() {
          this.emit("end", data);
          this.readable = false;
          this.emit("close");
        }).bind(this));
        return this;
      }
      throw new TypeError("Unexpected data type (" + typeof data + ")");
    }
    util.inherits(DataStream, Stream);
    DataStream.prototype.write = function write(data) {
      this.buffer = Buffer2.concat([this.buffer, Buffer2.from(data)]);
      this.emit("data", data);
    };
    DataStream.prototype.end = function end(data) {
      if (data)
        this.write(data);
      this.emit("end", data);
      this.emit("close");
      this.writable = false;
      this.readable = false;
    };
    module.exports = DataStream;
  }
});

// node_modules/buffer-equal-constant-time/index.js
var require_buffer_equal_constant_time = __commonJS({
  "node_modules/buffer-equal-constant-time/index.js"(exports, module) {
    "use strict";
    var Buffer2 = require_buffer().Buffer;
    var SlowBuffer = require_buffer().SlowBuffer;
    module.exports = bufferEq;
    function bufferEq(a, b2) {
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b2)) {
        return false;
      }
      if (a.length !== b2.length) {
        return false;
      }
      var c = 0;
      for (var i2 = 0; i2 < a.length; i2++) {
        c |= a[i2] ^ b2[i2];
      }
      return c === 0;
    }
    bufferEq.install = function() {
      Buffer2.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
        return bufferEq(this, that);
      };
    };
    var origBufEqual = Buffer2.prototype.equal;
    var origSlowBufEqual = SlowBuffer.prototype.equal;
    bufferEq.restore = function() {
      Buffer2.prototype.equal = origBufEqual;
      SlowBuffer.prototype.equal = origSlowBufEqual;
    };
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js
var require_param_bytes_for_alg = __commonJS({
  "node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js"(exports, module) {
    "use strict";
    function getParamSize(keySize) {
      var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
      return result;
    }
    var paramBytesForAlg = {
      ES256: getParamSize(256),
      ES384: getParamSize(384),
      ES512: getParamSize(521)
    };
    function getParamBytesForAlg(alg) {
      var paramBytes = paramBytesForAlg[alg];
      if (paramBytes) {
        return paramBytes;
      }
      throw new Error('Unknown algorithm "' + alg + '"');
    }
    module.exports = getParamBytesForAlg;
  }
});

// node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js
var require_ecdsa_sig_formatter = __commonJS({
  "node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js"(exports, module) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var getParamBytesForAlg = require_param_bytes_for_alg();
    var MAX_OCTET = 128;
    var CLASS_UNIVERSAL = 0;
    var PRIMITIVE_BIT = 32;
    var TAG_SEQ = 16;
    var TAG_INT = 2;
    var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;
    var ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
    function base64Url(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function signatureAsBuffer(signature) {
      if (Buffer2.isBuffer(signature)) {
        return signature;
      } else if ("string" === typeof signature) {
        return Buffer2.from(signature, "base64");
      }
      throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
    }
    function derToJose(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var maxEncodedParamLength = paramBytes + 1;
      var inputLength = signature.length;
      var offset2 = 0;
      if (signature[offset2++] !== ENCODED_TAG_SEQ) {
        throw new Error('Could not find expected "seq"');
      }
      var seqLength = signature[offset2++];
      if (seqLength === (MAX_OCTET | 1)) {
        seqLength = signature[offset2++];
      }
      if (inputLength - offset2 < seqLength) {
        throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset2) + '" remaining');
      }
      if (signature[offset2++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "r"');
      }
      var rLength = signature[offset2++];
      if (inputLength - offset2 - 2 < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset2 - 2) + '" available');
      }
      if (maxEncodedParamLength < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var rOffset = offset2;
      offset2 += rLength;
      if (signature[offset2++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "s"');
      }
      var sLength = signature[offset2++];
      if (inputLength - offset2 !== sLength) {
        throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset2) + '"');
      }
      if (maxEncodedParamLength < sLength) {
        throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var sOffset = offset2;
      offset2 += sLength;
      if (offset2 !== inputLength) {
        throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset2) + '" bytes remain');
      }
      var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
      var dst = Buffer2.allocUnsafe(rPadding + rLength + sPadding + sLength);
      for (offset2 = 0; offset2 < rPadding; ++offset2) {
        dst[offset2] = 0;
      }
      signature.copy(dst, offset2, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
      offset2 = paramBytes;
      for (var o = offset2; offset2 < o + sPadding; ++offset2) {
        dst[offset2] = 0;
      }
      signature.copy(dst, offset2, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
      dst = dst.toString("base64");
      dst = base64Url(dst);
      return dst;
    }
    function countPadding(buf, start2, stop2) {
      var padding = 0;
      while (start2 + padding < stop2 && buf[start2 + padding] === 0) {
        ++padding;
      }
      var needsSign = buf[start2 + padding] >= MAX_OCTET;
      if (needsSign) {
        --padding;
      }
      return padding;
    }
    function joseToDer(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var signatureBytes = signature.length;
      if (signatureBytes !== paramBytes * 2) {
        throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
      }
      var rPadding = countPadding(signature, 0, paramBytes);
      var sPadding = countPadding(signature, paramBytes, signature.length);
      var rLength = paramBytes - rPadding;
      var sLength = paramBytes - sPadding;
      var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
      var shortLength = rsBytes < MAX_OCTET;
      var dst = Buffer2.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
      var offset2 = 0;
      dst[offset2++] = ENCODED_TAG_SEQ;
      if (shortLength) {
        dst[offset2++] = rsBytes;
      } else {
        dst[offset2++] = MAX_OCTET | 1;
        dst[offset2++] = rsBytes & 255;
      }
      dst[offset2++] = ENCODED_TAG_INT;
      dst[offset2++] = rLength;
      if (rPadding < 0) {
        dst[offset2++] = 0;
        offset2 += signature.copy(dst, offset2, 0, paramBytes);
      } else {
        offset2 += signature.copy(dst, offset2, rPadding, paramBytes);
      }
      dst[offset2++] = ENCODED_TAG_INT;
      dst[offset2++] = sLength;
      if (sPadding < 0) {
        dst[offset2++] = 0;
        signature.copy(dst, offset2, paramBytes);
      } else {
        signature.copy(dst, offset2, paramBytes + sPadding);
      }
      return dst;
    }
    module.exports = {
      derToJose,
      joseToDer
    };
  }
});

// node_modules/jwa/index.js
var require_jwa = __commonJS({
  "node_modules/jwa/index.js"(exports, module) {
    var bufferEqual = require_buffer_equal_constant_time();
    var Buffer2 = require_safe_buffer().Buffer;
    var crypto = require_crypto();
    var formatEcdsa = require_ecdsa_sig_formatter();
    var util = require_util();
    var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
    var MSG_INVALID_SECRET = "secret must be a string or buffer";
    var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
    var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
    var supportsKeyObjects = typeof crypto.createPublicKey === "function";
    if (supportsKeyObjects) {
      MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
      MSG_INVALID_SECRET += "or a KeyObject";
    }
    function checkIsPublicKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.type !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.asymmetricKeyType !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
    }
    function checkIsPrivateKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (typeof key === "object") {
        return;
      }
      throw typeError(MSG_INVALID_SIGNER_KEY);
    }
    function checkIsSecretKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return key;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (key.type !== "secret") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_SECRET);
      }
    }
    function fromBase64(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function toBase64(base64url) {
      base64url = base64url.toString();
      var padding = 4 - base64url.length % 4;
      if (padding !== 4) {
        for (var i2 = 0; i2 < padding; ++i2) {
          base64url += "=";
        }
      }
      return base64url.replace(/\-/g, "+").replace(/_/g, "/");
    }
    function typeError(template) {
      var args = [].slice.call(arguments, 1);
      var errMsg = util.format.bind(util, template).apply(null, args);
      return new TypeError(errMsg);
    }
    function bufferOrString(obj) {
      return Buffer2.isBuffer(obj) || typeof obj === "string";
    }
    function normalizeInput(thing) {
      if (!bufferOrString(thing))
        thing = JSON.stringify(thing);
      return thing;
    }
    function createHmacSigner(bits) {
      return function sign(thing, secret) {
        checkIsSecretKey(secret);
        thing = normalizeInput(thing);
        var hmac = crypto.createHmac("sha" + bits, secret);
        var sig = (hmac.update(thing), hmac.digest("base64"));
        return fromBase64(sig);
      };
    }
    function createHmacVerifier(bits) {
      return function verify(thing, signature, secret) {
        var computedSig = createHmacSigner(bits)(thing, secret);
        return bufferEqual(Buffer2.from(signature), Buffer2.from(computedSig));
      };
    }
    function createKeySigner(bits) {
      return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
        return fromBase64(sig);
      };
    }
    function createKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify(publicKey, signature, "base64");
      };
    }
    function createPSSKeySigner(bits) {
      return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign({
          key: privateKey,
          padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
        }, "base64"));
        return fromBase64(sig);
      };
    }
    function createPSSKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify({
          key: publicKey,
          padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
        }, signature, "base64");
      };
    }
    function createECDSASigner(bits) {
      var inner2 = createKeySigner(bits);
      return function sign() {
        var signature = inner2.apply(null, arguments);
        signature = formatEcdsa.derToJose(signature, "ES" + bits);
        return signature;
      };
    }
    function createECDSAVerifer(bits) {
      var inner2 = createKeyVerifier(bits);
      return function verify(thing, signature, publicKey) {
        signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
        var result = inner2(thing, signature, publicKey);
        return result;
      };
    }
    function createNoneSigner() {
      return function sign() {
        return "";
      };
    }
    function createNoneVerifier() {
      return function verify(thing, signature) {
        return signature === "";
      };
    }
    module.exports = function jwa(algorithm) {
      var signerFactories = {
        hs: createHmacSigner,
        rs: createKeySigner,
        ps: createPSSKeySigner,
        es: createECDSASigner,
        none: createNoneSigner
      };
      var verifierFactories = {
        hs: createHmacVerifier,
        rs: createKeyVerifier,
        ps: createPSSKeyVerifier,
        es: createECDSAVerifer,
        none: createNoneVerifier
      };
      var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
      if (!match)
        throw typeError(MSG_INVALID_ALGORITHM, algorithm);
      var algo = (match[1] || match[3]).toLowerCase();
      var bits = match[2];
      return {
        sign: signerFactories[algo](bits),
        verify: verifierFactories[algo](bits)
      };
    };
  }
});

// node_modules/jws/lib/tostring.js
var require_tostring = __commonJS({
  "node_modules/jws/lib/tostring.js"(exports, module) {
    var Buffer2 = require_buffer().Buffer;
    module.exports = function toString(obj) {
      if (typeof obj === "string")
        return obj;
      if (typeof obj === "number" || Buffer2.isBuffer(obj))
        return obj.toString();
      return JSON.stringify(obj);
    };
  }
});

// node_modules/jws/lib/sign-stream.js
var require_sign_stream = __commonJS({
  "node_modules/jws/lib/sign-stream.js"(exports, module) {
    var Buffer2 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream = require_stream();
    var toString = require_tostring();
    var util = require_util();
    function base64url(string, encoding) {
      return Buffer2.from(string, encoding).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function jwsSecuredInput(header, payload, encoding) {
      encoding = encoding || "utf8";
      var encodedHeader = base64url(toString(header), "binary");
      var encodedPayload = base64url(toString(payload), encoding);
      return util.format("%s.%s", encodedHeader, encodedPayload);
    }
    function jwsSign(opts) {
      var header = opts.header;
      var payload = opts.payload;
      var secretOrKey = opts.secret || opts.privateKey;
      var encoding = opts.encoding;
      var algo = jwa(header.alg);
      var securedInput = jwsSecuredInput(header, payload, encoding);
      var signature = algo.sign(securedInput, secretOrKey);
      return util.format("%s.%s", securedInput, signature);
    }
    function SignStream(opts) {
      var secret = opts.secret || opts.privateKey || opts.key;
      var secretStream = new DataStream(secret);
      this.readable = true;
      this.header = opts.header;
      this.encoding = opts.encoding;
      this.secret = this.privateKey = this.key = secretStream;
      this.payload = new DataStream(opts.payload);
      this.secret.once("close", (function() {
        if (!this.payload.writable && this.readable)
          this.sign();
      }).bind(this));
      this.payload.once("close", (function() {
        if (!this.secret.writable && this.readable)
          this.sign();
      }).bind(this));
    }
    util.inherits(SignStream, Stream);
    SignStream.prototype.sign = function sign() {
      try {
        var signature = jwsSign({
          header: this.header,
          payload: this.payload.buffer,
          secret: this.secret.buffer,
          encoding: this.encoding
        });
        this.emit("done", signature);
        this.emit("data", signature);
        this.emit("end");
        this.readable = false;
        return signature;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    };
    SignStream.sign = jwsSign;
    module.exports = SignStream;
  }
});

// node_modules/jws/lib/verify-stream.js
var require_verify_stream = __commonJS({
  "node_modules/jws/lib/verify-stream.js"(exports, module) {
    var Buffer2 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream = require_stream();
    var toString = require_tostring();
    var util = require_util();
    var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
    function isObject3(thing) {
      return Object.prototype.toString.call(thing) === "[object Object]";
    }
    function safeJsonParse(thing) {
      if (isObject3(thing))
        return thing;
      try {
        return JSON.parse(thing);
      } catch (e) {
        return void 0;
      }
    }
    function headerFromJWS(jwsSig) {
      var encodedHeader = jwsSig.split(".", 1)[0];
      return safeJsonParse(Buffer2.from(encodedHeader, "base64").toString("binary"));
    }
    function securedInputFromJWS(jwsSig) {
      return jwsSig.split(".", 2).join(".");
    }
    function signatureFromJWS(jwsSig) {
      return jwsSig.split(".")[2];
    }
    function payloadFromJWS(jwsSig, encoding) {
      encoding = encoding || "utf8";
      var payload = jwsSig.split(".")[1];
      return Buffer2.from(payload, "base64").toString(encoding);
    }
    function isValidJws(string) {
      return JWS_REGEX.test(string) && !!headerFromJWS(string);
    }
    function jwsVerify(jwsSig, algorithm, secretOrKey) {
      if (!algorithm) {
        var err = new Error("Missing algorithm parameter for jws.verify");
        err.code = "MISSING_ALGORITHM";
        throw err;
      }
      jwsSig = toString(jwsSig);
      var signature = signatureFromJWS(jwsSig);
      var securedInput = securedInputFromJWS(jwsSig);
      var algo = jwa(algorithm);
      return algo.verify(securedInput, signature, secretOrKey);
    }
    function jwsDecode(jwsSig, opts) {
      opts = opts || {};
      jwsSig = toString(jwsSig);
      if (!isValidJws(jwsSig))
        return null;
      var header = headerFromJWS(jwsSig);
      if (!header)
        return null;
      var payload = payloadFromJWS(jwsSig);
      if (header.typ === "JWT" || opts.json)
        payload = JSON.parse(payload, opts.encoding);
      return {
        header,
        payload,
        signature: signatureFromJWS(jwsSig)
      };
    }
    function VerifyStream(opts) {
      opts = opts || {};
      var secretOrKey = opts.secret || opts.publicKey || opts.key;
      var secretStream = new DataStream(secretOrKey);
      this.readable = true;
      this.algorithm = opts.algorithm;
      this.encoding = opts.encoding;
      this.secret = this.publicKey = this.key = secretStream;
      this.signature = new DataStream(opts.signature);
      this.secret.once("close", (function() {
        if (!this.signature.writable && this.readable)
          this.verify();
      }).bind(this));
      this.signature.once("close", (function() {
        if (!this.secret.writable && this.readable)
          this.verify();
      }).bind(this));
    }
    util.inherits(VerifyStream, Stream);
    VerifyStream.prototype.verify = function verify() {
      try {
        var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
        var obj = jwsDecode(this.signature.buffer, this.encoding);
        this.emit("done", valid, obj);
        this.emit("data", valid);
        this.emit("end");
        this.readable = false;
        return valid;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    };
    VerifyStream.decode = jwsDecode;
    VerifyStream.isValid = isValidJws;
    VerifyStream.verify = jwsVerify;
    module.exports = VerifyStream;
  }
});

// node_modules/jws/index.js
var require_jws = __commonJS({
  "node_modules/jws/index.js"(exports) {
    var SignStream = require_sign_stream();
    var VerifyStream = require_verify_stream();
    var ALGORITHMS = [
      "HS256",
      "HS384",
      "HS512",
      "RS256",
      "RS384",
      "RS512",
      "PS256",
      "PS384",
      "PS512",
      "ES256",
      "ES384",
      "ES512"
    ];
    exports.ALGORITHMS = ALGORITHMS;
    exports.sign = SignStream.sign;
    exports.verify = VerifyStream.verify;
    exports.decode = VerifyStream.decode;
    exports.isValid = VerifyStream.isValid;
    exports.createSign = function createSign(opts) {
      return new SignStream(opts);
    };
    exports.createVerify = function createVerify(opts) {
      return new VerifyStream(opts);
    };
  }
});

// node_modules/jsonwebtoken/decode.js
var require_decode = __commonJS({
  "node_modules/jsonwebtoken/decode.js"(exports, module) {
    var jws = require_jws();
    module.exports = function(jwt, options) {
      options = options || {};
      var decoded = jws.decode(jwt, options);
      if (!decoded) {
        return null;
      }
      var payload = decoded.payload;
      if (typeof payload === "string") {
        try {
          var obj = JSON.parse(payload);
          if (obj !== null && typeof obj === "object") {
            payload = obj;
          }
        } catch (e) {
        }
      }
      if (options.complete === true) {
        return {
          header: decoded.header,
          payload,
          signature: decoded.signature
        };
      }
      return payload;
    };
  }
});

// node_modules/jsonwebtoken/lib/JsonWebTokenError.js
var require_JsonWebTokenError = __commonJS({
  "node_modules/jsonwebtoken/lib/JsonWebTokenError.js"(exports, module) {
    var JsonWebTokenError = function(message, error) {
      Error.call(this, message);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = "JsonWebTokenError";
      this.message = message;
      if (error)
        this.inner = error;
    };
    JsonWebTokenError.prototype = Object.create(Error.prototype);
    JsonWebTokenError.prototype.constructor = JsonWebTokenError;
    module.exports = JsonWebTokenError;
  }
});

// node_modules/jsonwebtoken/lib/NotBeforeError.js
var require_NotBeforeError = __commonJS({
  "node_modules/jsonwebtoken/lib/NotBeforeError.js"(exports, module) {
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = function(message, date) {
      JsonWebTokenError.call(this, message);
      this.name = "NotBeforeError";
      this.date = date;
    };
    NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);
    NotBeforeError.prototype.constructor = NotBeforeError;
    module.exports = NotBeforeError;
  }
});

// node_modules/jsonwebtoken/lib/TokenExpiredError.js
var require_TokenExpiredError = __commonJS({
  "node_modules/jsonwebtoken/lib/TokenExpiredError.js"(exports, module) {
    var JsonWebTokenError = require_JsonWebTokenError();
    var TokenExpiredError = function(message, expiredAt) {
      JsonWebTokenError.call(this, message);
      this.name = "TokenExpiredError";
      this.expiredAt = expiredAt;
    };
    TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);
    TokenExpiredError.prototype.constructor = TokenExpiredError;
    module.exports = TokenExpiredError;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w2 = d * 7;
    var y2 = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n2 = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n2 * y2;
        case "weeks":
        case "week":
        case "w":
          return n2 * w2;
        case "days":
        case "day":
        case "d":
          return n2 * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n2 * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n2 * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n2 * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n2;
        default:
          return void 0;
      }
    }
    function fmtShort(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d) {
        return Math.round(ms2 / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms2 / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms2 / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms2 / s) + "s";
      }
      return ms2 + "ms";
    }
    function fmtLong(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d) {
        return plural3(ms2, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural3(ms2, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural3(ms2, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural3(ms2, msAbs, s, "second");
      }
      return ms2 + " ms";
    }
    function plural3(ms2, msAbs, n2, name4) {
      var isPlural = msAbs >= n2 * 1.5;
      return Math.round(ms2 / n2) + " " + name4 + (isPlural ? "s" : "");
    }
  }
});

// node_modules/jsonwebtoken/lib/timespan.js
var require_timespan = __commonJS({
  "node_modules/jsonwebtoken/lib/timespan.js"(exports, module) {
    var ms2 = require_ms();
    module.exports = function(time, iat) {
      var timestamp = iat || Math.floor(Date.now() / 1e3);
      if (typeof time === "string") {
        var milliseconds = ms2(time);
        if (typeof milliseconds === "undefined") {
          return;
        }
        return Math.floor(timestamp + milliseconds / 1e3);
      } else if (typeof time === "number") {
        return timestamp + time;
      } else {
        return;
      }
    };
  }
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/semver/internal/constants.js"(exports, module) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/semver/internal/debug.js"(exports, module) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module.exports = debug;
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports, module) {
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug();
    exports = module.exports = {};
    var re2 = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var t = exports.t = {};
    var R3 = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name4, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R3++;
      debug(name4, index, value);
      t[name4] = index;
      src[index] = value;
      re2[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports, module) {
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports, module) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b2) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b2);
      if (anum && bnum) {
        a = +a;
        b2 = +b2;
      }
      return a === b2 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b2 ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b2) => compareIdentifiers(b2, a);
    module.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports, module) {
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re2, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version3, options) {
        options = parseOptions(options);
        if (version3 instanceof _SemVer) {
          if (version3.loose === !!options.loose && version3.includePrerelease === !!options.includePrerelease) {
            return version3;
          } else {
            version3 = version3.version;
          }
        } else if (typeof version3 !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version3}".`);
        }
        if (version3.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version3, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version3.trim().match(options.loose ? re2[t.LOOSE] : re2[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version3}`);
        }
        this.raw = version3;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id2) => {
            if (/^[0-9]+$/.test(id2)) {
              const num = +id2;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id2;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i2 = 0;
        do {
          const a = this.prerelease[i2];
          const b2 = other.prerelease[i2];
          debug("prerelease compare", i2, a, b2);
          if (a === void 0 && b2 === void 0) {
            return 0;
          } else if (b2 === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b2) {
            continue;
          } else {
            return compareIdentifiers(a, b2);
          }
        } while (++i2);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i2 = 0;
        do {
          const a = this.build[i2];
          const b2 = other.build[i2];
          debug("prerelease compare", i2, a, b2);
          if (a === void 0 && b2 === void 0) {
            return 0;
          } else if (b2 === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b2) {
            continue;
          } else {
            return compareIdentifiers(a, b2);
          }
        } while (++i2);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (!identifier && identifierBase === false) {
              throw new Error("invalid increment argument: identifier is empty");
            }
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i2 = this.prerelease.length;
              while (--i2 >= 0) {
                if (typeof this.prerelease[i2] === "number") {
                  this.prerelease[i2]++;
                  i2 = -2;
                }
              }
              if (i2 === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module.exports = SemVer;
  }
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/semver/functions/parse.js"(exports, module) {
    var SemVer = require_semver();
    var parse = (version3, options, throwErrors = false) => {
      if (version3 instanceof SemVer) {
        return version3;
      }
      try {
        return new SemVer(version3, options);
      } catch (er2) {
        if (!throwErrors) {
          return null;
        }
        throw er2;
      }
    };
    module.exports = parse;
  }
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/semver/functions/valid.js"(exports, module) {
    var parse = require_parse();
    var valid = (version3, options) => {
      const v2 = parse(version3, options);
      return v2 ? v2.version : null;
    };
    module.exports = valid;
  }
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/semver/functions/clean.js"(exports, module) {
    var parse = require_parse();
    var clean = (version3, options) => {
      const s = parse(version3.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module.exports = clean;
  }
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/semver/functions/inc.js"(exports, module) {
    var SemVer = require_semver();
    var inc = (version3, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version3 instanceof SemVer ? version3.version : version3,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er2) {
        return null;
      }
    };
    module.exports = inc;
  }
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/semver/functions/diff.js"(exports, module) {
    var parse = require_parse();
    var diff = (version1, version22) => {
      const v1 = parse(version1, null, true);
      const v2 = parse(version22, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (highVersion.patch) {
          return "patch";
        }
        if (highVersion.minor) {
          return "minor";
        }
        return "major";
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module.exports = diff;
  }
});

// node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/semver/functions/major.js"(exports, module) {
    var SemVer = require_semver();
    var major2 = (a, loose) => new SemVer(a, loose).major;
    module.exports = major2;
  }
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/semver/functions/minor.js"(exports, module) {
    var SemVer = require_semver();
    var minor2 = (a, loose) => new SemVer(a, loose).minor;
    module.exports = minor2;
  }
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/semver/functions/patch.js"(exports, module) {
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module.exports = patch;
  }
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/semver/functions/prerelease.js"(exports, module) {
    var parse = require_parse();
    var prerelease = (version3, options) => {
      const parsed = parse(version3, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module.exports = prerelease;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports, module) {
    var SemVer = require_semver();
    var compare = (a, b2, loose) => new SemVer(a, loose).compare(new SemVer(b2, loose));
    module.exports = compare;
  }
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/semver/functions/rcompare.js"(exports, module) {
    var compare = require_compare();
    var rcompare = (a, b2, loose) => compare(b2, a, loose);
    module.exports = rcompare;
  }
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/semver/functions/compare-loose.js"(exports, module) {
    var compare = require_compare();
    var compareLoose = (a, b2) => compare(a, b2, true);
    module.exports = compareLoose;
  }
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/semver/functions/compare-build.js"(exports, module) {
    var SemVer = require_semver();
    var compareBuild = (a, b2, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b2, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module.exports = compareBuild;
  }
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/semver/functions/sort.js"(exports, module) {
    var compareBuild = require_compare_build();
    var sort = (list2, loose) => list2.sort((a, b2) => compareBuild(a, b2, loose));
    module.exports = sort;
  }
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/semver/functions/rsort.js"(exports, module) {
    var compareBuild = require_compare_build();
    var rsort = (list2, loose) => list2.sort((a, b2) => compareBuild(b2, a, loose));
    module.exports = rsort;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports, module) {
    var compare = require_compare();
    var gt2 = (a, b2, loose) => compare(a, b2, loose) > 0;
    module.exports = gt2;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports, module) {
    var compare = require_compare();
    var lt2 = (a, b2, loose) => compare(a, b2, loose) < 0;
    module.exports = lt2;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports, module) {
    var compare = require_compare();
    var eq = (a, b2, loose) => compare(a, b2, loose) === 0;
    module.exports = eq;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports, module) {
    var compare = require_compare();
    var neq = (a, b2, loose) => compare(a, b2, loose) !== 0;
    module.exports = neq;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports, module) {
    var compare = require_compare();
    var gte = (a, b2, loose) => compare(a, b2, loose) >= 0;
    module.exports = gte;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports, module) {
    var compare = require_compare();
    var lte = (a, b2, loose) => compare(a, b2, loose) <= 0;
    module.exports = lte;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports, module) {
    var eq = require_eq();
    var neq = require_neq();
    var gt2 = require_gt();
    var gte = require_gte();
    var lt2 = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b2, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b2 === "object") {
            b2 = b2.version;
          }
          return a === b2;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b2 === "object") {
            b2 = b2.version;
          }
          return a !== b2;
        case "":
        case "=":
        case "==":
          return eq(a, b2, loose);
        case "!=":
          return neq(a, b2, loose);
        case ">":
          return gt2(a, b2, loose);
        case ">=":
          return gte(a, b2, loose);
        case "<":
          return lt2(a, b2, loose);
        case "<=":
          return lte(a, b2, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module.exports = cmp;
  }
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/semver/functions/coerce.js"(exports, module) {
    var SemVer = require_semver();
    var parse = require_parse();
    var { safeRe: re2, t } = require_re();
    var coerce = (version3, options) => {
      if (version3 instanceof SemVer) {
        return version3;
      }
      if (typeof version3 === "number") {
        version3 = String(version3);
      }
      if (typeof version3 !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version3.match(re2[t.COERCE]);
      } else {
        let next;
        while ((next = re2[t.COERCERTL].exec(version3)) && (!match || match.index + match[0].length !== version3.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          re2[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        re2[t.COERCERTL].lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      return parse(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
    };
    module.exports = coerce;
  }
});

// node_modules/semver/node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "node_modules/semver/node_modules/yallist/iterator.js"(exports, module) {
    "use strict";
    module.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// node_modules/semver/node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/semver/node_modules/yallist/yallist.js"(exports, module) {
    "use strict";
    module.exports = Yallist;
    Yallist.Node = Node2;
    Yallist.create = Yallist;
    function Yallist(list2) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list2 && typeof list2.forEach === "function") {
        list2.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
          self2.push(arguments[i2]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
        push(this, arguments[i2]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
        unshift(this, arguments[i2]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn2, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i2 = 0; walker !== null; i2++) {
        fn2.call(thisp, walker.value, i2, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn2, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i2 = this.length - 1; walker !== null; i2--) {
        fn2.call(thisp, walker.value, i2, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n2) {
      for (var i2 = 0, walker = this.head; walker !== null && i2 < n2; i2++) {
        walker = walker.next;
      }
      if (i2 === n2 && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n2) {
      for (var i2 = 0, walker = this.tail; walker !== null && i2 < n2; i2++) {
        walker = walker.prev;
      }
      if (i2 === n2 && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn2, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn2.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn2, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn2.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn2, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i2 = 0; walker !== null; i2++) {
        acc = fn2(acc, walker.value, i2);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn2, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i2 = this.length - 1; walker !== null; i2--) {
        acc = fn2(acc, walker.value, i2);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i2 = 0, walker = this.head; walker !== null; i2++) {
        arr[i2] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i2 = 0, walker = this.tail; walker !== null; i2++) {
        arr[i2] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from3, to2) {
      to2 = to2 || this.length;
      if (to2 < 0) {
        to2 += this.length;
      }
      from3 = from3 || 0;
      if (from3 < 0) {
        from3 += this.length;
      }
      var ret = new Yallist();
      if (to2 < from3 || to2 < 0) {
        return ret;
      }
      if (from3 < 0) {
        from3 = 0;
      }
      if (to2 > this.length) {
        to2 = this.length;
      }
      for (var i2 = 0, walker = this.head; walker !== null && i2 < from3; i2++) {
        walker = walker.next;
      }
      for (; walker !== null && i2 < to2; i2++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from3, to2) {
      to2 = to2 || this.length;
      if (to2 < 0) {
        to2 += this.length;
      }
      from3 = from3 || 0;
      if (from3 < 0) {
        from3 += this.length;
      }
      var ret = new Yallist();
      if (to2 < from3 || to2 < 0) {
        return ret;
      }
      if (from3 < 0) {
        from3 = 0;
      }
      if (to2 > this.length) {
        to2 = this.length;
      }
      for (var i2 = this.length, walker = this.tail; walker !== null && i2 > to2; i2--) {
        walker = walker.prev;
      }
      for (; walker !== null && i2 > from3; i2--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start2, deleteCount, ...nodes) {
      if (start2 > this.length) {
        start2 = this.length - 1;
      }
      if (start2 < 0) {
        start2 = this.length + start2;
      }
      for (var i2 = 0, walker = this.head; walker !== null && i2 < start2; i2++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i2 = 0; walker && i2 < deleteCount; i2++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i2 = 0; i2 < nodes.length; i2++) {
        walker = insert(this, walker, nodes[i2]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p2 = walker.prev;
        walker.prev = walker.next;
        walker.next = p2;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node2(value, null, node, self2) : new Node2(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push(self2, item) {
      self2.tail = new Node2(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node2(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node2(value, prev, next, list2) {
      if (!(this instanceof Node2)) {
        return new Node2(value, prev, next, list2);
      }
      this.list = list2;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er2) {
    }
  }
});

// node_modules/semver/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/semver/node_modules/lru-cache/index.js"(exports, module) {
    "use strict";
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options) {
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max = this[MAX] = options.max || Infinity;
        const lc2 = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc2 !== "function" ? naiveLength : lc2;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      // resize the cache when the max changes.
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      // resize the cache when the lengthCalculator changes.
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn2, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn2, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn2, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn2, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k3) => k3.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k3) => k3.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now2 = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now2;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value, len, now2, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key))
          return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get(this, key, true);
      }
      peek(key) {
        return get(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now2 = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now2;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get(this, key, false));
      }
    };
    var get = (self2, key, doUse) => {
      const node = self2[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
    };
    var trim = (self2) => {
      if (self2[LENGTH] > self2[MAX]) {
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    };
    var del = (self2, node) => {
      if (node) {
        const hit = node.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value, length, now2, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now2;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self2, fn2, node, thisp) => {
      let hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn2.call(thisp, hit.value, hit.key, self2);
    };
    module.exports = LRUCache;
  }
});

// node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/semver/classes/range.js"(exports, module) {
    var Range = class _Range {
      constructor(range2, options) {
        options = parseOptions(options);
        if (range2 instanceof _Range) {
          if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
            return range2;
          } else {
            return new _Range(range2.raw, options);
          }
        }
        if (range2 instanceof Comparator) {
          this.raw = range2.value;
          this.set = [[range2]];
          this.format();
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range2.trim().split(/\s+/).join(" ");
        this.set = this.raw.split("||").map((r2) => this.parseRange(r2.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first2 = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first2];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range2) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range2;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr2 = loose ? re2[t.HYPHENRANGELOOSE] : re2[t.HYPHENRANGE];
        range2 = range2.replace(hr2, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range2);
        range2 = range2.replace(re2[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range2);
        range2 = range2.replace(re2[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range2);
        range2 = range2.replace(re2[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range2);
        let rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re2[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range2, options) {
        if (!(range2 instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version3) {
        if (!version3) {
          return false;
        }
        if (typeof version3 === "string") {
          try {
            version3 = new SemVer(version3, this.options);
          } catch (er2) {
            return false;
          }
        }
        for (let i2 = 0; i2 < this.set.length; i2++) {
          if (testSet(this.set[i2], version3, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module.exports = Range;
    var LRU = require_lru_cache();
    var cache = new LRU({ max: 1e3 });
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re2,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id2) => !id2 || id2.toLowerCase() === "x" || id2 === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r2 = options.loose ? re2[t.TILDELOOSE] : re2[t.TILDE];
      return comp.replace(r2, (_2, M3, m, p2, pr2) => {
        debug("tilde", comp, _2, M3, m, p2, pr2);
        let ret;
        if (isX(M3)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M3}.0.0 <${+M3 + 1}.0.0-0`;
        } else if (isX(p2)) {
          ret = `>=${M3}.${m}.0 <${M3}.${+m + 1}.0-0`;
        } else if (pr2) {
          debug("replaceTilde pr", pr2);
          ret = `>=${M3}.${m}.${p2}-${pr2} <${M3}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M3}.${m}.${p2} <${M3}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r2 = options.loose ? re2[t.CARETLOOSE] : re2[t.CARET];
      const z2 = options.includePrerelease ? "-0" : "";
      return comp.replace(r2, (_2, M3, m, p2, pr2) => {
        debug("caret", comp, _2, M3, m, p2, pr2);
        let ret;
        if (isX(M3)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M3}.0.0${z2} <${+M3 + 1}.0.0-0`;
        } else if (isX(p2)) {
          if (M3 === "0") {
            ret = `>=${M3}.${m}.0${z2} <${M3}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M3}.${m}.0${z2} <${+M3 + 1}.0.0-0`;
          }
        } else if (pr2) {
          debug("replaceCaret pr", pr2);
          if (M3 === "0") {
            if (m === "0") {
              ret = `>=${M3}.${m}.${p2}-${pr2} <${M3}.${m}.${+p2 + 1}-0`;
            } else {
              ret = `>=${M3}.${m}.${p2}-${pr2} <${M3}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M3}.${m}.${p2}-${pr2} <${+M3 + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M3 === "0") {
            if (m === "0") {
              ret = `>=${M3}.${m}.${p2}${z2} <${M3}.${m}.${+p2 + 1}-0`;
            } else {
              ret = `>=${M3}.${m}.${p2}${z2} <${M3}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M3}.${m}.${p2} <${+M3 + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r2 = options.loose ? re2[t.XRANGELOOSE] : re2[t.XRANGE];
      return comp.replace(r2, (ret, gtlt, M3, m, p2, pr2) => {
        debug("xRange", comp, ret, gtlt, M3, m, p2, pr2);
        const xM = isX(M3);
        const xm = xM || isX(m);
        const xp = xm || isX(p2);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr2 = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p2 = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M3 = +M3 + 1;
              m = 0;
              p2 = 0;
            } else {
              m = +m + 1;
              p2 = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M3 = +M3 + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr2 = "-0";
          }
          ret = `${gtlt + M3}.${m}.${p2}${pr2}`;
        } else if (xm) {
          ret = `>=${M3}.0.0${pr2} <${+M3 + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M3}.${m}.0${pr2} <${M3}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re2[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re2[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from3, fM, fm, fp, fpr, fb2, to2, tM, tm, tp, tpr, tb2) => {
      if (isX(fM)) {
        from3 = "";
      } else if (isX(fm)) {
        from3 = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from3 = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from3 = `>=${from3}`;
      } else {
        from3 = `>=${from3}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to2 = "";
      } else if (isX(tm)) {
        to2 = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to2 = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to2 = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to2 = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to2 = `<=${to2}`;
      }
      return `${from3} ${to2}`.trim();
    };
    var testSet = (set, version3, options) => {
      for (let i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version3)) {
          return false;
        }
      }
      if (version3.prerelease.length && !options.includePrerelease) {
        for (let i2 = 0; i2 < set.length; i2++) {
          debug(set[i2].semver);
          if (set[i2].semver === Comparator.ANY) {
            continue;
          }
          if (set[i2].semver.prerelease.length > 0) {
            const allowed = set[i2].semver;
            if (allowed.major === version3.major && allowed.minor === version3.minor && allowed.patch === version3.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports, module) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r2 = this.options.loose ? re2[t.COMPARATORLOOSE] : re2[t.COMPARATOR];
        const m = comp.match(r2);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version3) {
        debug("Comparator.test", version3, this.options.loose);
        if (this.semver === ANY || version3 === ANY) {
          return true;
        }
        if (typeof version3 === "string") {
          try {
            version3 = new SemVer(version3, this.options);
          } catch (er2) {
            return false;
          }
        }
        return cmp(version3, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re2, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports, module) {
    var Range = require_range();
    var satisfies = (version3, range2, options) => {
      try {
        range2 = new Range(range2, options);
      } catch (er2) {
        return false;
      }
      return range2.test(version3);
    };
    module.exports = satisfies;
  }
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/semver/ranges/to-comparators.js"(exports, module) {
    var Range = require_range();
    var toComparators = (range2, options) => new Range(range2, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module.exports = toComparators;
  }
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/semver/ranges/max-satisfying.js"(exports, module) {
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range2, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range2, options);
      } catch (er2) {
        return null;
      }
      versions.forEach((v2) => {
        if (rangeObj.test(v2)) {
          if (!max || maxSV.compare(v2) === -1) {
            max = v2;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module.exports = maxSatisfying;
  }
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/semver/ranges/min-satisfying.js"(exports, module) {
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range2, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range2, options);
      } catch (er2) {
        return null;
      }
      versions.forEach((v2) => {
        if (rangeObj.test(v2)) {
          if (!min || minSV.compare(v2) === 1) {
            min = v2;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module.exports = minSatisfying;
  }
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/semver/ranges/min-version.js"(exports, module) {
    var SemVer = require_semver();
    var Range = require_range();
    var gt2 = require_gt();
    var minVersion = (range2, loose) => {
      range2 = new Range(range2, loose);
      let minver = new SemVer("0.0.0");
      if (range2.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range2.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i2 = 0; i2 < range2.set.length; ++i2) {
        const comparators = range2.set[i2];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!setMin || gt2(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt2(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range2.test(minver)) {
        return minver;
      }
      return null;
    };
    module.exports = minVersion;
  }
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/semver/ranges/valid.js"(exports, module) {
    var Range = require_range();
    var validRange = (range2, options) => {
      try {
        return new Range(range2, options).range || "*";
      } catch (er2) {
        return null;
      }
    };
    module.exports = validRange;
  }
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/semver/ranges/outside.js"(exports, module) {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt2 = require_gt();
    var lt2 = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version3, range2, hilo, options) => {
      version3 = new SemVer(version3, options);
      range2 = new Range(range2, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt2;
          ltefn = lte;
          ltfn = lt2;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt2;
          ltefn = gte;
          ltfn = gt2;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version3, range2, options)) {
        return false;
      }
      for (let i2 = 0; i2 < range2.set.length; ++i2) {
        const comparators = range2.set[i2];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version3, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version3, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module.exports = outside;
  }
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/semver/ranges/gtr.js"(exports, module) {
    var outside = require_outside();
    var gtr = (version3, range2, options) => outside(version3, range2, ">", options);
    module.exports = gtr;
  }
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/semver/ranges/ltr.js"(exports, module) {
    var outside = require_outside();
    var ltr = (version3, range2, options) => outside(version3, range2, "<", options);
    module.exports = ltr;
  }
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/semver/ranges/intersects.js"(exports, module) {
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module.exports = intersects;
  }
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/semver/ranges/simplify.js"(exports, module) {
    var satisfies = require_satisfies();
    var compare = require_compare();
    module.exports = (versions, range2, options) => {
      const set = [];
      let first2 = null;
      let prev = null;
      const v2 = versions.sort((a, b2) => compare(a, b2, options));
      for (const version3 of v2) {
        const included = satisfies(version3, range2, options);
        if (included) {
          prev = version3;
          if (!first2) {
            first2 = version3;
          }
        } else {
          if (prev) {
            set.push([first2, prev]);
          }
          prev = null;
          first2 = null;
        }
      }
      if (first2) {
        set.push([first2, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v2[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v2[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range2.raw === "string" ? range2.raw : String(range2);
      return simplified.length < original.length ? simplified : range2;
    };
  }
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/semver/ranges/subset.js"(exports, module) {
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER:
        for (const simpleSub of sub.set) {
          for (const simpleDom of dom.set) {
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub) {
              continue OUTER;
            }
          }
          if (sawNonNull) {
            return false;
          }
        }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt2, lt2;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt2 = higherGT(gt2, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt2 = lowerLT(lt2, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt2 && lt2) {
        gtltComp = compare(gt2.semver, lt2.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt2.operator !== ">=" || lt2.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt2 && !satisfies(eq, String(gt2), options)) {
          return null;
        }
        if (lt2 && !satisfies(eq, String(lt2), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt2 && !options.includePrerelease && lt2.semver.prerelease.length ? lt2.semver : false;
      let needDomGTPre = gt2 && !options.includePrerelease && gt2.semver.prerelease.length ? gt2.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt2.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt2) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt2, c, options);
            if (higher === c && higher !== gt2) {
              return false;
            }
          } else if (gt2.operator === ">=" && !satisfies(gt2.semver, String(c), options)) {
            return false;
          }
        }
        if (lt2) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt2, c, options);
            if (lower === c && lower !== lt2) {
              return false;
            }
          } else if (lt2.operator === "<=" && !satisfies(lt2.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt2 || gt2) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt2 && hasDomLT && !lt2 && gtltComp !== 0) {
        return false;
      }
      if (lt2 && hasDomGT && !gt2 && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b2, options) => {
      if (!a) {
        return b2;
      }
      const comp = compare(a.semver, b2.semver, options);
      return comp > 0 ? a : comp < 0 ? b2 : b2.operator === ">" && a.operator === ">=" ? b2 : a;
    };
    var lowerLT = (a, b2, options) => {
      if (!a) {
        return b2;
      }
      const comp = compare(a.semver, b2.semver, options);
      return comp < 0 ? a : comp > 0 ? b2 : b2.operator === "<" && a.operator === "<=" ? b2 : a;
    };
    module.exports = subset;
  }
});

// node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/semver/index.js"(exports, module) {
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major2 = require_major();
    var minor2 = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt2 = require_gt();
    var lt2 = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module.exports = {
      parse,
      valid,
      clean,
      inc,
      diff,
      major: major2,
      minor: minor2,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt: gt2,
      lt: lt2,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/jsonwebtoken/lib/asymmetricKeyDetailsSupported.js
var require_asymmetricKeyDetailsSupported = __commonJS({
  "node_modules/jsonwebtoken/lib/asymmetricKeyDetailsSupported.js"(exports, module) {
    var semver = require_semver2();
    module.exports = semver.satisfies(process.version, ">=15.7.0");
  }
});

// node_modules/jsonwebtoken/lib/rsaPssKeyDetailsSupported.js
var require_rsaPssKeyDetailsSupported = __commonJS({
  "node_modules/jsonwebtoken/lib/rsaPssKeyDetailsSupported.js"(exports, module) {
    var semver = require_semver2();
    module.exports = semver.satisfies(process.version, ">=16.9.0");
  }
});

// node_modules/jsonwebtoken/lib/validateAsymmetricKey.js
var require_validateAsymmetricKey = __commonJS({
  "node_modules/jsonwebtoken/lib/validateAsymmetricKey.js"(exports, module) {
    var ASYMMETRIC_KEY_DETAILS_SUPPORTED = require_asymmetricKeyDetailsSupported();
    var RSA_PSS_KEY_DETAILS_SUPPORTED = require_rsaPssKeyDetailsSupported();
    var allowedAlgorithmsForKeys = {
      "ec": ["ES256", "ES384", "ES512"],
      "rsa": ["RS256", "PS256", "RS384", "PS384", "RS512", "PS512"],
      "rsa-pss": ["PS256", "PS384", "PS512"]
    };
    var allowedCurves = {
      ES256: "prime256v1",
      ES384: "secp384r1",
      ES512: "secp521r1"
    };
    module.exports = function(algorithm, key) {
      if (!algorithm || !key)
        return;
      const keyType = key.asymmetricKeyType;
      if (!keyType)
        return;
      const allowedAlgorithms = allowedAlgorithmsForKeys[keyType];
      if (!allowedAlgorithms) {
        throw new Error(`Unknown key type "${keyType}".`);
      }
      if (!allowedAlgorithms.includes(algorithm)) {
        throw new Error(`"alg" parameter for "${keyType}" key type must be one of: ${allowedAlgorithms.join(", ")}.`);
      }
      if (ASYMMETRIC_KEY_DETAILS_SUPPORTED) {
        switch (keyType) {
          case "ec":
            const keyCurve = key.asymmetricKeyDetails.namedCurve;
            const allowedCurve = allowedCurves[algorithm];
            if (keyCurve !== allowedCurve) {
              throw new Error(`"alg" parameter "${algorithm}" requires curve "${allowedCurve}".`);
            }
            break;
          case "rsa-pss":
            if (RSA_PSS_KEY_DETAILS_SUPPORTED) {
              const length = parseInt(algorithm.slice(-3), 10);
              const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;
              if (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm) {
                throw new Error(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${algorithm}.`);
              }
              if (saltLength !== void 0 && saltLength > length >> 3) {
                throw new Error(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${algorithm}.`);
              }
            }
            break;
        }
      }
    };
  }
});

// node_modules/jsonwebtoken/lib/psSupported.js
var require_psSupported = __commonJS({
  "node_modules/jsonwebtoken/lib/psSupported.js"(exports, module) {
    var semver = require_semver2();
    module.exports = semver.satisfies(process.version, "^6.12.0 || >=8.0.0");
  }
});

// node_modules/jsonwebtoken/verify.js
var require_verify = __commonJS({
  "node_modules/jsonwebtoken/verify.js"(exports, module) {
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = require_NotBeforeError();
    var TokenExpiredError = require_TokenExpiredError();
    var decode = require_decode();
    var timespan = require_timespan();
    var validateAsymmetricKey = require_validateAsymmetricKey();
    var PS_SUPPORTED = require_psSupported();
    var jws = require_jws();
    var { KeyObject, createSecretKey, createPublicKey } = require_crypto();
    var PUB_KEY_ALGS = ["RS256", "RS384", "RS512"];
    var EC_KEY_ALGS = ["ES256", "ES384", "ES512"];
    var RSA_KEY_ALGS = ["RS256", "RS384", "RS512"];
    var HS_ALGS = ["HS256", "HS384", "HS512"];
    if (PS_SUPPORTED) {
      PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
      RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
    }
    module.exports = function(jwtString, secretOrPublicKey, options, callback) {
      if (typeof options === "function" && !callback) {
        callback = options;
        options = {};
      }
      if (!options) {
        options = {};
      }
      options = Object.assign({}, options);
      let done;
      if (callback) {
        done = callback;
      } else {
        done = function(err, data) {
          if (err)
            throw err;
          return data;
        };
      }
      if (options.clockTimestamp && typeof options.clockTimestamp !== "number") {
        return done(new JsonWebTokenError("clockTimestamp must be a number"));
      }
      if (options.nonce !== void 0 && (typeof options.nonce !== "string" || options.nonce.trim() === "")) {
        return done(new JsonWebTokenError("nonce must be a non-empty string"));
      }
      if (options.allowInvalidAsymmetricKeyTypes !== void 0 && typeof options.allowInvalidAsymmetricKeyTypes !== "boolean") {
        return done(new JsonWebTokenError("allowInvalidAsymmetricKeyTypes must be a boolean"));
      }
      const clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1e3);
      if (!jwtString) {
        return done(new JsonWebTokenError("jwt must be provided"));
      }
      if (typeof jwtString !== "string") {
        return done(new JsonWebTokenError("jwt must be a string"));
      }
      const parts = jwtString.split(".");
      if (parts.length !== 3) {
        return done(new JsonWebTokenError("jwt malformed"));
      }
      let decodedToken;
      try {
        decodedToken = decode(jwtString, { complete: true });
      } catch (err) {
        return done(err);
      }
      if (!decodedToken) {
        return done(new JsonWebTokenError("invalid token"));
      }
      const header = decodedToken.header;
      let getSecret;
      if (typeof secretOrPublicKey === "function") {
        if (!callback) {
          return done(new JsonWebTokenError("verify must be called asynchronous if secret or public key is provided as a callback"));
        }
        getSecret = secretOrPublicKey;
      } else {
        getSecret = function(header2, secretCallback) {
          return secretCallback(null, secretOrPublicKey);
        };
      }
      return getSecret(header, function(err, secretOrPublicKey2) {
        if (err) {
          return done(new JsonWebTokenError("error in secret or public key callback: " + err.message));
        }
        const hasSignature = parts[2].trim() !== "";
        if (!hasSignature && secretOrPublicKey2) {
          return done(new JsonWebTokenError("jwt signature is required"));
        }
        if (hasSignature && !secretOrPublicKey2) {
          return done(new JsonWebTokenError("secret or public key must be provided"));
        }
        if (!hasSignature && !options.algorithms) {
          return done(new JsonWebTokenError('please specify "none" in "algorithms" to verify unsigned tokens'));
        }
        if (secretOrPublicKey2 != null && !(secretOrPublicKey2 instanceof KeyObject)) {
          try {
            secretOrPublicKey2 = createPublicKey(secretOrPublicKey2);
          } catch (_2) {
            try {
              secretOrPublicKey2 = createSecretKey(typeof secretOrPublicKey2 === "string" ? Buffer.from(secretOrPublicKey2) : secretOrPublicKey2);
            } catch (_3) {
              return done(new JsonWebTokenError("secretOrPublicKey is not valid key material"));
            }
          }
        }
        if (!options.algorithms) {
          if (secretOrPublicKey2.type === "secret") {
            options.algorithms = HS_ALGS;
          } else if (["rsa", "rsa-pss"].includes(secretOrPublicKey2.asymmetricKeyType)) {
            options.algorithms = RSA_KEY_ALGS;
          } else if (secretOrPublicKey2.asymmetricKeyType === "ec") {
            options.algorithms = EC_KEY_ALGS;
          } else {
            options.algorithms = PUB_KEY_ALGS;
          }
        }
        if (options.algorithms.indexOf(decodedToken.header.alg) === -1) {
          return done(new JsonWebTokenError("invalid algorithm"));
        }
        if (header.alg.startsWith("HS") && secretOrPublicKey2.type !== "secret") {
          return done(new JsonWebTokenError(`secretOrPublicKey must be a symmetric key when using ${header.alg}`));
        } else if (/^(?:RS|PS|ES)/.test(header.alg) && secretOrPublicKey2.type !== "public") {
          return done(new JsonWebTokenError(`secretOrPublicKey must be an asymmetric key when using ${header.alg}`));
        }
        if (!options.allowInvalidAsymmetricKeyTypes) {
          try {
            validateAsymmetricKey(header.alg, secretOrPublicKey2);
          } catch (e) {
            return done(e);
          }
        }
        let valid;
        try {
          valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey2);
        } catch (e) {
          return done(e);
        }
        if (!valid) {
          return done(new JsonWebTokenError("invalid signature"));
        }
        const payload = decodedToken.payload;
        if (typeof payload.nbf !== "undefined" && !options.ignoreNotBefore) {
          if (typeof payload.nbf !== "number") {
            return done(new JsonWebTokenError("invalid nbf value"));
          }
          if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {
            return done(new NotBeforeError("jwt not active", new Date(payload.nbf * 1e3)));
          }
        }
        if (typeof payload.exp !== "undefined" && !options.ignoreExpiration) {
          if (typeof payload.exp !== "number") {
            return done(new JsonWebTokenError("invalid exp value"));
          }
          if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {
            return done(new TokenExpiredError("jwt expired", new Date(payload.exp * 1e3)));
          }
        }
        if (options.audience) {
          const audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
          const target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];
          const match = target.some(function(targetAudience) {
            return audiences.some(function(audience) {
              return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
            });
          });
          if (!match) {
            return done(new JsonWebTokenError("jwt audience invalid. expected: " + audiences.join(" or ")));
          }
        }
        if (options.issuer) {
          const invalid_issuer = typeof options.issuer === "string" && payload.iss !== options.issuer || Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1;
          if (invalid_issuer) {
            return done(new JsonWebTokenError("jwt issuer invalid. expected: " + options.issuer));
          }
        }
        if (options.subject) {
          if (payload.sub !== options.subject) {
            return done(new JsonWebTokenError("jwt subject invalid. expected: " + options.subject));
          }
        }
        if (options.jwtid) {
          if (payload.jti !== options.jwtid) {
            return done(new JsonWebTokenError("jwt jwtid invalid. expected: " + options.jwtid));
          }
        }
        if (options.nonce) {
          if (payload.nonce !== options.nonce) {
            return done(new JsonWebTokenError("jwt nonce invalid. expected: " + options.nonce));
          }
        }
        if (options.maxAge) {
          if (typeof payload.iat !== "number") {
            return done(new JsonWebTokenError("iat required when maxAge is specified"));
          }
          const maxAgeTimestamp = timespan(options.maxAge, payload.iat);
          if (typeof maxAgeTimestamp === "undefined") {
            return done(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
          }
          if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {
            return done(new TokenExpiredError("maxAge exceeded", new Date(maxAgeTimestamp * 1e3)));
          }
        }
        if (options.complete === true) {
          const signature = decodedToken.signature;
          return done(null, {
            header,
            payload,
            signature
          });
        }
        return done(null, payload);
      });
    };
  }
});

// node_modules/lodash.includes/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.includes/index.js"(exports, module) {
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var freeParseInt = parseInt;
    function arrayMap(array, iteratee) {
      var index = -1, length = array ? array.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseTimes(n2, iteratee) {
      var index = -1, result = Array(n2);
      while (++index < n2) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeKeys = overArg(Object.keys, Object);
    var nativeMax = Math.max;
    function arrayLikeKeys(value, inherited) {
      var result = isArray2(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike2(collection) ? collection : values(collection);
      fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray2 = Array.isArray;
    function isArrayLike2(value) {
      return value != null && isLength(value.length) && !isFunction4(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike2(value);
    }
    function isFunction4(value) {
      var tag = isObject3(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject3(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isString2(value) {
      return typeof value == "string" || !isArray2(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject3(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject3(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    function keys(object) {
      return isArrayLike2(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function values(object) {
      return object ? baseValues(object, keys(object)) : [];
    }
    module.exports = includes;
  }
});

// node_modules/lodash.isboolean/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.isboolean/index.js"(exports, module) {
    var boolTag = "[object Boolean]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isBoolean(value) {
      return value === true || value === false || isObjectLike(value) && objectToString.call(value) == boolTag;
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    module.exports = isBoolean;
  }
});

// node_modules/lodash.isinteger/index.js
var require_lodash3 = __commonJS({
  "node_modules/lodash.isinteger/index.js"(exports, module) {
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isInteger2(value) {
      return typeof value == "number" && value == toInteger(value);
    }
    function isObject3(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject3(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject3(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = isInteger2;
  }
});

// node_modules/lodash.isnumber/index.js
var require_lodash4 = __commonJS({
  "node_modules/lodash.isnumber/index.js"(exports, module) {
    var numberTag = "[object Number]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isNumber2(value) {
      return typeof value == "number" || isObjectLike(value) && objectToString.call(value) == numberTag;
    }
    module.exports = isNumber2;
  }
});

// node_modules/lodash.isplainobject/index.js
var require_lodash5 = __commonJS({
  "node_modules/lodash.isplainobject/index.js"(exports, module) {
    var objectTag = "[object Object]";
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    var objectToString = objectProto.toString;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module.exports = isPlainObject;
  }
});

// node_modules/lodash.isstring/index.js
var require_lodash6 = __commonJS({
  "node_modules/lodash.isstring/index.js"(exports, module) {
    var stringTag = "[object String]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var isArray2 = Array.isArray;
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isString2(value) {
      return typeof value == "string" || !isArray2(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
    }
    module.exports = isString2;
  }
});

// node_modules/lodash.once/index.js
var require_lodash7 = __commonJS({
  "node_modules/lodash.once/index.js"(exports, module) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function before(n2, func) {
      var result;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n2 = toInteger(n2);
      return function() {
        if (--n2 > 0) {
          result = func.apply(this, arguments);
        }
        if (n2 <= 1) {
          func = void 0;
        }
        return result;
      };
    }
    function once(func) {
      return before(2, func);
    }
    function isObject3(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject3(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject3(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = once;
  }
});

// node_modules/jsonwebtoken/sign.js
var require_sign = __commonJS({
  "node_modules/jsonwebtoken/sign.js"(exports, module) {
    var timespan = require_timespan();
    var PS_SUPPORTED = require_psSupported();
    var validateAsymmetricKey = require_validateAsymmetricKey();
    var jws = require_jws();
    var includes = require_lodash();
    var isBoolean = require_lodash2();
    var isInteger2 = require_lodash3();
    var isNumber2 = require_lodash4();
    var isPlainObject = require_lodash5();
    var isString2 = require_lodash6();
    var once = require_lodash7();
    var { KeyObject, createSecretKey, createPrivateKey } = require_crypto();
    var SUPPORTED_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "HS256", "HS384", "HS512", "none"];
    if (PS_SUPPORTED) {
      SUPPORTED_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
    }
    var sign_options_schema = {
      expiresIn: { isValid: function(value) {
        return isInteger2(value) || isString2(value) && value;
      }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
      notBefore: { isValid: function(value) {
        return isInteger2(value) || isString2(value) && value;
      }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
      audience: { isValid: function(value) {
        return isString2(value) || Array.isArray(value);
      }, message: '"audience" must be a string or array' },
      algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
      header: { isValid: isPlainObject, message: '"header" must be an object' },
      encoding: { isValid: isString2, message: '"encoding" must be a string' },
      issuer: { isValid: isString2, message: '"issuer" must be a string' },
      subject: { isValid: isString2, message: '"subject" must be a string' },
      jwtid: { isValid: isString2, message: '"jwtid" must be a string' },
      noTimestamp: { isValid: isBoolean, message: '"noTimestamp" must be a boolean' },
      keyid: { isValid: isString2, message: '"keyid" must be a string' },
      mutatePayload: { isValid: isBoolean, message: '"mutatePayload" must be a boolean' },
      allowInsecureKeySizes: { isValid: isBoolean, message: '"allowInsecureKeySizes" must be a boolean' },
      allowInvalidAsymmetricKeyTypes: { isValid: isBoolean, message: '"allowInvalidAsymmetricKeyTypes" must be a boolean' }
    };
    var registered_claims_schema = {
      iat: { isValid: isNumber2, message: '"iat" should be a number of seconds' },
      exp: { isValid: isNumber2, message: '"exp" should be a number of seconds' },
      nbf: { isValid: isNumber2, message: '"nbf" should be a number of seconds' }
    };
    function validate2(schema, allowUnknown, object, parameterName) {
      if (!isPlainObject(object)) {
        throw new Error('Expected "' + parameterName + '" to be a plain object.');
      }
      Object.keys(object).forEach(function(key) {
        const validator = schema[key];
        if (!validator) {
          if (!allowUnknown) {
            throw new Error('"' + key + '" is not allowed in "' + parameterName + '"');
          }
          return;
        }
        if (!validator.isValid(object[key])) {
          throw new Error(validator.message);
        }
      });
    }
    function validateOptions(options) {
      return validate2(sign_options_schema, false, options, "options");
    }
    function validatePayload(payload) {
      return validate2(registered_claims_schema, true, payload, "payload");
    }
    var options_to_payload = {
      "audience": "aud",
      "issuer": "iss",
      "subject": "sub",
      "jwtid": "jti"
    };
    var options_for_objects = [
      "expiresIn",
      "notBefore",
      "noTimestamp",
      "audience",
      "issuer",
      "subject",
      "jwtid"
    ];
    module.exports = function(payload, secretOrPrivateKey, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      } else {
        options = options || {};
      }
      const isObjectPayload = typeof payload === "object" && !Buffer.isBuffer(payload);
      const header = Object.assign({
        alg: options.algorithm || "HS256",
        typ: isObjectPayload ? "JWT" : void 0,
        kid: options.keyid
      }, options.header);
      function failure(err) {
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      if (!secretOrPrivateKey && options.algorithm !== "none") {
        return failure(new Error("secretOrPrivateKey must have a value"));
      }
      if (secretOrPrivateKey != null && !(secretOrPrivateKey instanceof KeyObject)) {
        try {
          secretOrPrivateKey = createPrivateKey(secretOrPrivateKey);
        } catch (_2) {
          try {
            secretOrPrivateKey = createSecretKey(typeof secretOrPrivateKey === "string" ? Buffer.from(secretOrPrivateKey) : secretOrPrivateKey);
          } catch (_3) {
            return failure(new Error("secretOrPrivateKey is not valid key material"));
          }
        }
      }
      if (header.alg.startsWith("HS") && secretOrPrivateKey.type !== "secret") {
        return failure(new Error(`secretOrPrivateKey must be a symmetric key when using ${header.alg}`));
      } else if (/^(?:RS|PS|ES)/.test(header.alg)) {
        if (secretOrPrivateKey.type !== "private") {
          return failure(new Error(`secretOrPrivateKey must be an asymmetric key when using ${header.alg}`));
        }
        if (!options.allowInsecureKeySizes && !header.alg.startsWith("ES") && secretOrPrivateKey.asymmetricKeyDetails !== void 0 && //KeyObject.asymmetricKeyDetails is supported in Node 15+
        secretOrPrivateKey.asymmetricKeyDetails.modulusLength < 2048) {
          return failure(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
        }
      }
      if (typeof payload === "undefined") {
        return failure(new Error("payload is required"));
      } else if (isObjectPayload) {
        try {
          validatePayload(payload);
        } catch (error) {
          return failure(error);
        }
        if (!options.mutatePayload) {
          payload = Object.assign({}, payload);
        }
      } else {
        const invalid_options = options_for_objects.filter(function(opt) {
          return typeof options[opt] !== "undefined";
        });
        if (invalid_options.length > 0) {
          return failure(new Error("invalid " + invalid_options.join(",") + " option for " + typeof payload + " payload"));
        }
      }
      if (typeof payload.exp !== "undefined" && typeof options.expiresIn !== "undefined") {
        return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
      }
      if (typeof payload.nbf !== "undefined" && typeof options.notBefore !== "undefined") {
        return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
      }
      try {
        validateOptions(options);
      } catch (error) {
        return failure(error);
      }
      if (!options.allowInvalidAsymmetricKeyTypes) {
        try {
          validateAsymmetricKey(header.alg, secretOrPrivateKey);
        } catch (error) {
          return failure(error);
        }
      }
      const timestamp = payload.iat || Math.floor(Date.now() / 1e3);
      if (options.noTimestamp) {
        delete payload.iat;
      } else if (isObjectPayload) {
        payload.iat = timestamp;
      }
      if (typeof options.notBefore !== "undefined") {
        try {
          payload.nbf = timespan(options.notBefore, timestamp);
        } catch (err) {
          return failure(err);
        }
        if (typeof payload.nbf === "undefined") {
          return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
      }
      if (typeof options.expiresIn !== "undefined" && typeof payload === "object") {
        try {
          payload.exp = timespan(options.expiresIn, timestamp);
        } catch (err) {
          return failure(err);
        }
        if (typeof payload.exp === "undefined") {
          return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
      }
      Object.keys(options_to_payload).forEach(function(key) {
        const claim = options_to_payload[key];
        if (typeof options[key] !== "undefined") {
          if (typeof payload[claim] !== "undefined") {
            return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
          }
          payload[claim] = options[key];
        }
      });
      const encoding = options.encoding || "utf8";
      if (typeof callback === "function") {
        callback = callback && once(callback);
        jws.createSign({
          header,
          privateKey: secretOrPrivateKey,
          payload,
          encoding
        }).once("error", callback).once("done", function(signature) {
          if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
            return callback(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
          }
          callback(null, signature);
        });
      } else {
        let signature = jws.sign({ header, payload, secret: secretOrPrivateKey, encoding });
        if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
          throw new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`);
        }
        return signature;
      }
    };
  }
});

// node_modules/jsonwebtoken/index.js
var require_jsonwebtoken = __commonJS({
  "node_modules/jsonwebtoken/index.js"(exports, module) {
    module.exports = {
      decode: require_decode(),
      verify: require_verify(),
      sign: require_sign(),
      JsonWebTokenError: require_JsonWebTokenError(),
      NotBeforeError: require_NotBeforeError(),
      TokenExpiredError: require_TokenExpiredError()
    };
  }
});

// node_modules/node-forge/lib/forge.js
var require_forge = __commonJS({
  "node_modules/node-forge/lib/forge.js"(exports, module) {
    module.exports = {
      // default options
      options: {
        usePureJavaScript: false
      }
    };
  }
});

// node_modules/node-forge/lib/baseN.js
var require_baseN = __commonJS({
  "node_modules/node-forge/lib/baseN.js"(exports, module) {
    var api = {};
    module.exports = api;
    var _reverseAlphabets = {};
    api.encode = function(input, alphabet, maxline) {
      if (typeof alphabet !== "string") {
        throw new TypeError('"alphabet" must be a string.');
      }
      if (maxline !== void 0 && typeof maxline !== "number") {
        throw new TypeError('"maxline" must be a number.');
      }
      var output = "";
      if (!(input instanceof Uint8Array)) {
        output = _encodeWithByteBuffer(input, alphabet);
      } else {
        var i2 = 0;
        var base = alphabet.length;
        var first2 = alphabet.charAt(0);
        var digits = [0];
        for (i2 = 0; i2 < input.length; ++i2) {
          for (var j2 = 0, carry = input[i2]; j2 < digits.length; ++j2) {
            carry += digits[j2] << 8;
            digits[j2] = carry % base;
            carry = carry / base | 0;
          }
          while (carry > 0) {
            digits.push(carry % base);
            carry = carry / base | 0;
          }
        }
        for (i2 = 0; input[i2] === 0 && i2 < input.length - 1; ++i2) {
          output += first2;
        }
        for (i2 = digits.length - 1; i2 >= 0; --i2) {
          output += alphabet[digits[i2]];
        }
      }
      if (maxline) {
        var regex = new RegExp(".{1," + maxline + "}", "g");
        output = output.match(regex).join("\r\n");
      }
      return output;
    };
    api.decode = function(input, alphabet) {
      if (typeof input !== "string") {
        throw new TypeError('"input" must be a string.');
      }
      if (typeof alphabet !== "string") {
        throw new TypeError('"alphabet" must be a string.');
      }
      var table = _reverseAlphabets[alphabet];
      if (!table) {
        table = _reverseAlphabets[alphabet] = [];
        for (var i2 = 0; i2 < alphabet.length; ++i2) {
          table[alphabet.charCodeAt(i2)] = i2;
        }
      }
      input = input.replace(/\s/g, "");
      var base = alphabet.length;
      var first2 = alphabet.charAt(0);
      var bytes = [0];
      for (var i2 = 0; i2 < input.length; i2++) {
        var value = table[input.charCodeAt(i2)];
        if (value === void 0) {
          return;
        }
        for (var j2 = 0, carry = value; j2 < bytes.length; ++j2) {
          carry += bytes[j2] * base;
          bytes[j2] = carry & 255;
          carry >>= 8;
        }
        while (carry > 0) {
          bytes.push(carry & 255);
          carry >>= 8;
        }
      }
      for (var k3 = 0; input[k3] === first2 && k3 < input.length - 1; ++k3) {
        bytes.push(0);
      }
      if (typeof Buffer !== "undefined") {
        return Buffer.from(bytes.reverse());
      }
      return new Uint8Array(bytes.reverse());
    };
    function _encodeWithByteBuffer(input, alphabet) {
      var i2 = 0;
      var base = alphabet.length;
      var first2 = alphabet.charAt(0);
      var digits = [0];
      for (i2 = 0; i2 < input.length(); ++i2) {
        for (var j2 = 0, carry = input.at(i2); j2 < digits.length; ++j2) {
          carry += digits[j2] << 8;
          digits[j2] = carry % base;
          carry = carry / base | 0;
        }
        while (carry > 0) {
          digits.push(carry % base);
          carry = carry / base | 0;
        }
      }
      var output = "";
      for (i2 = 0; input.at(i2) === 0 && i2 < input.length() - 1; ++i2) {
        output += first2;
      }
      for (i2 = digits.length - 1; i2 >= 0; --i2) {
        output += alphabet[digits[i2]];
      }
      return output;
    }
  }
});

// node_modules/node-forge/lib/util.js
var require_util2 = __commonJS({
  "node_modules/node-forge/lib/util.js"(exports, module) {
    var forge = require_forge();
    var baseN = require_baseN();
    var util = module.exports = forge.util = forge.util || {};
    (function() {
      if (typeof process !== "undefined" && process.nextTick && !process.browser) {
        util.nextTick = process.nextTick;
        if (typeof setImmediate === "function") {
          util.setImmediate = setImmediate;
        } else {
          util.setImmediate = util.nextTick;
        }
        return;
      }
      if (typeof setImmediate === "function") {
        util.setImmediate = function() {
          return setImmediate.apply(void 0, arguments);
        };
        util.nextTick = function(callback) {
          return setImmediate(callback);
        };
        return;
      }
      util.setImmediate = function(callback) {
        setTimeout(callback, 0);
      };
      if (typeof window !== "undefined" && typeof window.postMessage === "function") {
        let handler2 = function(event) {
          if (event.source === window && event.data === msg) {
            event.stopPropagation();
            var copy = callbacks.slice();
            callbacks.length = 0;
            copy.forEach(function(callback) {
              callback();
            });
          }
        };
        var handler = handler2;
        var msg = "forge.setImmediate";
        var callbacks = [];
        util.setImmediate = function(callback) {
          callbacks.push(callback);
          if (callbacks.length === 1) {
            window.postMessage(msg, "*");
          }
        };
        window.addEventListener("message", handler2, true);
      }
      if (typeof MutationObserver !== "undefined") {
        var now2 = Date.now();
        var attr = true;
        var div = document.createElement("div");
        var callbacks = [];
        new MutationObserver(function() {
          var copy = callbacks.slice();
          callbacks.length = 0;
          copy.forEach(function(callback) {
            callback();
          });
        }).observe(div, { attributes: true });
        var oldSetImmediate = util.setImmediate;
        util.setImmediate = function(callback) {
          if (Date.now() - now2 > 15) {
            now2 = Date.now();
            oldSetImmediate(callback);
          } else {
            callbacks.push(callback);
            if (callbacks.length === 1) {
              div.setAttribute("a", attr = !attr);
            }
          }
        };
      }
      util.nextTick = util.setImmediate;
    })();
    util.isNodejs = typeof process !== "undefined" && process.versions && process.versions.node;
    util.globalScope = function() {
      if (util.isNodejs) {
        return global;
      }
      return typeof self === "undefined" ? window : self;
    }();
    util.isArray = Array.isArray || function(x3) {
      return Object.prototype.toString.call(x3) === "[object Array]";
    };
    util.isArrayBuffer = function(x3) {
      return typeof ArrayBuffer !== "undefined" && x3 instanceof ArrayBuffer;
    };
    util.isArrayBufferView = function(x3) {
      return x3 && util.isArrayBuffer(x3.buffer) && x3.byteLength !== void 0;
    };
    function _checkBitsParam(n2) {
      if (!(n2 === 8 || n2 === 16 || n2 === 24 || n2 === 32)) {
        throw new Error("Only 8, 16, 24, or 32 bits supported: " + n2);
      }
    }
    util.ByteBuffer = ByteStringBuffer;
    function ByteStringBuffer(b2) {
      this.data = "";
      this.read = 0;
      if (typeof b2 === "string") {
        this.data = b2;
      } else if (util.isArrayBuffer(b2) || util.isArrayBufferView(b2)) {
        if (typeof Buffer !== "undefined" && b2 instanceof Buffer) {
          this.data = b2.toString("binary");
        } else {
          var arr = new Uint8Array(b2);
          try {
            this.data = String.fromCharCode.apply(null, arr);
          } catch (e) {
            for (var i2 = 0; i2 < arr.length; ++i2) {
              this.putByte(arr[i2]);
            }
          }
        }
      } else if (b2 instanceof ByteStringBuffer || typeof b2 === "object" && typeof b2.data === "string" && typeof b2.read === "number") {
        this.data = b2.data;
        this.read = b2.read;
      }
      this._constructedStringLength = 0;
    }
    util.ByteStringBuffer = ByteStringBuffer;
    var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
    util.ByteStringBuffer.prototype._optimizeConstructedString = function(x3) {
      this._constructedStringLength += x3;
      if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
        this.data.substr(0, 1);
        this._constructedStringLength = 0;
      }
    };
    util.ByteStringBuffer.prototype.length = function() {
      return this.data.length - this.read;
    };
    util.ByteStringBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util.ByteStringBuffer.prototype.putByte = function(b2) {
      return this.putBytes(String.fromCharCode(b2));
    };
    util.ByteStringBuffer.prototype.fillWithByte = function(b2, n2) {
      b2 = String.fromCharCode(b2);
      var d = this.data;
      while (n2 > 0) {
        if (n2 & 1) {
          d += b2;
        }
        n2 >>>= 1;
        if (n2 > 0) {
          b2 += b2;
        }
      }
      this.data = d;
      this._optimizeConstructedString(n2);
      return this;
    };
    util.ByteStringBuffer.prototype.putBytes = function(bytes) {
      this.data += bytes;
      this._optimizeConstructedString(bytes.length);
      return this;
    };
    util.ByteStringBuffer.prototype.putString = function(str) {
      return this.putBytes(util.encodeUtf8(str));
    };
    util.ByteStringBuffer.prototype.putInt16 = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt24 = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt32 = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 >> 24 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt16Le = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt24Le = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 >> 16 & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt32Le = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 24 & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt = function(i2, n2) {
      _checkBitsParam(n2);
      var bytes = "";
      do {
        n2 -= 8;
        bytes += String.fromCharCode(i2 >> n2 & 255);
      } while (n2 > 0);
      return this.putBytes(bytes);
    };
    util.ByteStringBuffer.prototype.putSignedInt = function(i2, n2) {
      if (i2 < 0) {
        i2 += 2 << n2 - 1;
      }
      return this.putInt(i2, n2);
    };
    util.ByteStringBuffer.prototype.putBuffer = function(buffer) {
      return this.putBytes(buffer.getBytes());
    };
    util.ByteStringBuffer.prototype.getByte = function() {
      return this.data.charCodeAt(this.read++);
    };
    util.ByteStringBuffer.prototype.getInt16 = function() {
      var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
      this.read += 2;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt24 = function() {
      var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
      this.read += 3;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt32 = function() {
      var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
      this.read += 4;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt16Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
      this.read += 2;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt24Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
      this.read += 3;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt32Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
      this.read += 4;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt = function(n2) {
      _checkBitsParam(n2);
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.charCodeAt(this.read++);
        n2 -= 8;
      } while (n2 > 0);
      return rval;
    };
    util.ByteStringBuffer.prototype.getSignedInt = function(n2) {
      var x3 = this.getInt(n2);
      var max = 2 << n2 - 2;
      if (x3 >= max) {
        x3 -= max << 1;
      }
      return x3;
    };
    util.ByteStringBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = "";
      } else {
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util.ByteStringBuffer.prototype.bytes = function(count) {
      return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
    };
    util.ByteStringBuffer.prototype.at = function(i2) {
      return this.data.charCodeAt(this.read + i2);
    };
    util.ByteStringBuffer.prototype.setAt = function(i2, b2) {
      this.data = this.data.substr(0, this.read + i2) + String.fromCharCode(b2) + this.data.substr(this.read + i2 + 1);
      return this;
    };
    util.ByteStringBuffer.prototype.last = function() {
      return this.data.charCodeAt(this.data.length - 1);
    };
    util.ByteStringBuffer.prototype.copy = function() {
      var c = util.createBuffer(this.data);
      c.read = this.read;
      return c;
    };
    util.ByteStringBuffer.prototype.compact = function() {
      if (this.read > 0) {
        this.data = this.data.slice(this.read);
        this.read = 0;
      }
      return this;
    };
    util.ByteStringBuffer.prototype.clear = function() {
      this.data = "";
      this.read = 0;
      return this;
    };
    util.ByteStringBuffer.prototype.truncate = function(count) {
      var len = Math.max(0, this.length() - count);
      this.data = this.data.substr(this.read, len);
      this.read = 0;
      return this;
    };
    util.ByteStringBuffer.prototype.toHex = function() {
      var rval = "";
      for (var i2 = this.read; i2 < this.data.length; ++i2) {
        var b2 = this.data.charCodeAt(i2);
        if (b2 < 16) {
          rval += "0";
        }
        rval += b2.toString(16);
      }
      return rval;
    };
    util.ByteStringBuffer.prototype.toString = function() {
      return util.decodeUtf8(this.bytes());
    };
    function DataBuffer(b2, options) {
      options = options || {};
      this.read = options.readOffset || 0;
      this.growSize = options.growSize || 1024;
      var isArrayBuffer = util.isArrayBuffer(b2);
      var isArrayBufferView = util.isArrayBufferView(b2);
      if (isArrayBuffer || isArrayBufferView) {
        if (isArrayBuffer) {
          this.data = new DataView(b2);
        } else {
          this.data = new DataView(b2.buffer, b2.byteOffset, b2.byteLength);
        }
        this.write = "writeOffset" in options ? options.writeOffset : this.data.byteLength;
        return;
      }
      this.data = new DataView(new ArrayBuffer(0));
      this.write = 0;
      if (b2 !== null && b2 !== void 0) {
        this.putBytes(b2);
      }
      if ("writeOffset" in options) {
        this.write = options.writeOffset;
      }
    }
    util.DataBuffer = DataBuffer;
    util.DataBuffer.prototype.length = function() {
      return this.write - this.read;
    };
    util.DataBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util.DataBuffer.prototype.accommodate = function(amount, growSize) {
      if (this.length() >= amount) {
        return this;
      }
      growSize = Math.max(growSize || this.growSize, amount);
      var src = new Uint8Array(
        this.data.buffer,
        this.data.byteOffset,
        this.data.byteLength
      );
      var dst = new Uint8Array(this.length() + growSize);
      dst.set(src);
      this.data = new DataView(dst.buffer);
      return this;
    };
    util.DataBuffer.prototype.putByte = function(b2) {
      this.accommodate(1);
      this.data.setUint8(this.write++, b2);
      return this;
    };
    util.DataBuffer.prototype.fillWithByte = function(b2, n2) {
      this.accommodate(n2);
      for (var i2 = 0; i2 < n2; ++i2) {
        this.data.setUint8(b2);
      }
      return this;
    };
    util.DataBuffer.prototype.putBytes = function(bytes, encoding) {
      if (util.isArrayBufferView(bytes)) {
        var src = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);
        var len = src.byteLength - src.byteOffset;
        this.accommodate(len);
        var dst = new Uint8Array(this.data.buffer, this.write);
        dst.set(src);
        this.write += len;
        return this;
      }
      if (util.isArrayBuffer(bytes)) {
        var src = new Uint8Array(bytes);
        this.accommodate(src.byteLength);
        var dst = new Uint8Array(this.data.buffer);
        dst.set(src, this.write);
        this.write += src.byteLength;
        return this;
      }
      if (bytes instanceof util.DataBuffer || typeof bytes === "object" && typeof bytes.read === "number" && typeof bytes.write === "number" && util.isArrayBufferView(bytes.data)) {
        var src = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());
        this.accommodate(src.byteLength);
        var dst = new Uint8Array(bytes.data.byteLength, this.write);
        dst.set(src);
        this.write += src.byteLength;
        return this;
      }
      if (bytes instanceof util.ByteStringBuffer) {
        bytes = bytes.data;
        encoding = "binary";
      }
      encoding = encoding || "binary";
      if (typeof bytes === "string") {
        var view;
        if (encoding === "hex") {
          this.accommodate(Math.ceil(bytes.length / 2));
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util.binary.hex.decode(bytes, view, this.write);
          return this;
        }
        if (encoding === "base64") {
          this.accommodate(Math.ceil(bytes.length / 4) * 3);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util.binary.base64.decode(bytes, view, this.write);
          return this;
        }
        if (encoding === "utf8") {
          bytes = util.encodeUtf8(bytes);
          encoding = "binary";
        }
        if (encoding === "binary" || encoding === "raw") {
          this.accommodate(bytes.length);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util.binary.raw.decode(view);
          return this;
        }
        if (encoding === "utf16") {
          this.accommodate(bytes.length * 2);
          view = new Uint16Array(this.data.buffer, this.write);
          this.write += util.text.utf16.encode(view);
          return this;
        }
        throw new Error("Invalid encoding: " + encoding);
      }
      throw Error("Invalid parameter: " + bytes);
    };
    util.DataBuffer.prototype.putBuffer = function(buffer) {
      this.putBytes(buffer);
      buffer.clear();
      return this;
    };
    util.DataBuffer.prototype.putString = function(str) {
      return this.putBytes(str, "utf16");
    };
    util.DataBuffer.prototype.putInt16 = function(i2) {
      this.accommodate(2);
      this.data.setInt16(this.write, i2);
      this.write += 2;
      return this;
    };
    util.DataBuffer.prototype.putInt24 = function(i2) {
      this.accommodate(3);
      this.data.setInt16(this.write, i2 >> 8 & 65535);
      this.data.setInt8(this.write, i2 >> 16 & 255);
      this.write += 3;
      return this;
    };
    util.DataBuffer.prototype.putInt32 = function(i2) {
      this.accommodate(4);
      this.data.setInt32(this.write, i2);
      this.write += 4;
      return this;
    };
    util.DataBuffer.prototype.putInt16Le = function(i2) {
      this.accommodate(2);
      this.data.setInt16(this.write, i2, true);
      this.write += 2;
      return this;
    };
    util.DataBuffer.prototype.putInt24Le = function(i2) {
      this.accommodate(3);
      this.data.setInt8(this.write, i2 >> 16 & 255);
      this.data.setInt16(this.write, i2 >> 8 & 65535, true);
      this.write += 3;
      return this;
    };
    util.DataBuffer.prototype.putInt32Le = function(i2) {
      this.accommodate(4);
      this.data.setInt32(this.write, i2, true);
      this.write += 4;
      return this;
    };
    util.DataBuffer.prototype.putInt = function(i2, n2) {
      _checkBitsParam(n2);
      this.accommodate(n2 / 8);
      do {
        n2 -= 8;
        this.data.setInt8(this.write++, i2 >> n2 & 255);
      } while (n2 > 0);
      return this;
    };
    util.DataBuffer.prototype.putSignedInt = function(i2, n2) {
      _checkBitsParam(n2);
      this.accommodate(n2 / 8);
      if (i2 < 0) {
        i2 += 2 << n2 - 1;
      }
      return this.putInt(i2, n2);
    };
    util.DataBuffer.prototype.getByte = function() {
      return this.data.getInt8(this.read++);
    };
    util.DataBuffer.prototype.getInt16 = function() {
      var rval = this.data.getInt16(this.read);
      this.read += 2;
      return rval;
    };
    util.DataBuffer.prototype.getInt24 = function() {
      var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
      this.read += 3;
      return rval;
    };
    util.DataBuffer.prototype.getInt32 = function() {
      var rval = this.data.getInt32(this.read);
      this.read += 4;
      return rval;
    };
    util.DataBuffer.prototype.getInt16Le = function() {
      var rval = this.data.getInt16(this.read, true);
      this.read += 2;
      return rval;
    };
    util.DataBuffer.prototype.getInt24Le = function() {
      var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
      this.read += 3;
      return rval;
    };
    util.DataBuffer.prototype.getInt32Le = function() {
      var rval = this.data.getInt32(this.read, true);
      this.read += 4;
      return rval;
    };
    util.DataBuffer.prototype.getInt = function(n2) {
      _checkBitsParam(n2);
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.getInt8(this.read++);
        n2 -= 8;
      } while (n2 > 0);
      return rval;
    };
    util.DataBuffer.prototype.getSignedInt = function(n2) {
      var x3 = this.getInt(n2);
      var max = 2 << n2 - 2;
      if (x3 >= max) {
        x3 -= max << 1;
      }
      return x3;
    };
    util.DataBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = "";
      } else {
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util.DataBuffer.prototype.bytes = function(count) {
      return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
    };
    util.DataBuffer.prototype.at = function(i2) {
      return this.data.getUint8(this.read + i2);
    };
    util.DataBuffer.prototype.setAt = function(i2, b2) {
      this.data.setUint8(i2, b2);
      return this;
    };
    util.DataBuffer.prototype.last = function() {
      return this.data.getUint8(this.write - 1);
    };
    util.DataBuffer.prototype.copy = function() {
      return new util.DataBuffer(this);
    };
    util.DataBuffer.prototype.compact = function() {
      if (this.read > 0) {
        var src = new Uint8Array(this.data.buffer, this.read);
        var dst = new Uint8Array(src.byteLength);
        dst.set(src);
        this.data = new DataView(dst);
        this.write -= this.read;
        this.read = 0;
      }
      return this;
    };
    util.DataBuffer.prototype.clear = function() {
      this.data = new DataView(new ArrayBuffer(0));
      this.read = this.write = 0;
      return this;
    };
    util.DataBuffer.prototype.truncate = function(count) {
      this.write = Math.max(0, this.length() - count);
      this.read = Math.min(this.read, this.write);
      return this;
    };
    util.DataBuffer.prototype.toHex = function() {
      var rval = "";
      for (var i2 = this.read; i2 < this.data.byteLength; ++i2) {
        var b2 = this.data.getUint8(i2);
        if (b2 < 16) {
          rval += "0";
        }
        rval += b2.toString(16);
      }
      return rval;
    };
    util.DataBuffer.prototype.toString = function(encoding) {
      var view = new Uint8Array(this.data, this.read, this.length());
      encoding = encoding || "utf8";
      if (encoding === "binary" || encoding === "raw") {
        return util.binary.raw.encode(view);
      }
      if (encoding === "hex") {
        return util.binary.hex.encode(view);
      }
      if (encoding === "base64") {
        return util.binary.base64.encode(view);
      }
      if (encoding === "utf8") {
        return util.text.utf8.decode(view);
      }
      if (encoding === "utf16") {
        return util.text.utf16.decode(view);
      }
      throw new Error("Invalid encoding: " + encoding);
    };
    util.createBuffer = function(input, encoding) {
      encoding = encoding || "raw";
      if (input !== void 0 && encoding === "utf8") {
        input = util.encodeUtf8(input);
      }
      return new util.ByteBuffer(input);
    };
    util.fillString = function(c, n2) {
      var s = "";
      while (n2 > 0) {
        if (n2 & 1) {
          s += c;
        }
        n2 >>>= 1;
        if (n2 > 0) {
          c += c;
        }
      }
      return s;
    };
    util.xorBytes = function(s1, s2, n2) {
      var s3 = "";
      var b2 = "";
      var t = "";
      var i2 = 0;
      var c = 0;
      for (; n2 > 0; --n2, ++i2) {
        b2 = s1.charCodeAt(i2) ^ s2.charCodeAt(i2);
        if (c >= 10) {
          s3 += t;
          t = "";
          c = 0;
        }
        t += String.fromCharCode(b2);
        ++c;
      }
      s3 += t;
      return s3;
    };
    util.hexToBytes = function(hex) {
      var rval = "";
      var i2 = 0;
      if (hex.length & true) {
        i2 = 1;
        rval += String.fromCharCode(parseInt(hex[0], 16));
      }
      for (; i2 < hex.length; i2 += 2) {
        rval += String.fromCharCode(parseInt(hex.substr(i2, 2), 16));
      }
      return rval;
    };
    util.bytesToHex = function(bytes) {
      return util.createBuffer(bytes).toHex();
    };
    util.int32ToBytes = function(i2) {
      return String.fromCharCode(i2 >> 24 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255);
    };
    var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var _base64Idx = [
      /*43 -43 = 0*/
      /*'+',  1,  2,  3,'/' */
      62,
      -1,
      -1,
      -1,
      63,
      /*'0','1','2','3','4','5','6','7','8','9' */
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      /*15, 16, 17,'=', 19, 20, 21 */
      -1,
      -1,
      -1,
      64,
      -1,
      -1,
      -1,
      /*65 - 43 = 22*/
      /*'A','B','C','D','E','F','G','H','I','J','K','L','M', */
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      /*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      /*91 - 43 = 48 */
      /*48, 49, 50, 51, 52, 53 */
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      /*97 - 43 = 54*/
      /*'a','b','c','d','e','f','g','h','i','j','k','l','m' */
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      /*'n','o','p','q','r','s','t','u','v','w','x','y','z' */
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51
    ];
    var _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    util.encode64 = function(input, maxline) {
      var line = "";
      var output = "";
      var chr1, chr2, chr3;
      var i2 = 0;
      while (i2 < input.length) {
        chr1 = input.charCodeAt(i2++);
        chr2 = input.charCodeAt(i2++);
        chr3 = input.charCodeAt(i2++);
        line += _base64.charAt(chr1 >> 2);
        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
        if (isNaN(chr2)) {
          line += "==";
        } else {
          line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
          line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
        }
        if (maxline && line.length > maxline) {
          output += line.substr(0, maxline) + "\r\n";
          line = line.substr(maxline);
        }
      }
      output += line;
      return output;
    };
    util.decode64 = function(input) {
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      var output = "";
      var enc1, enc2, enc3, enc4;
      var i2 = 0;
      while (i2 < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i2++) - 43];
        output += String.fromCharCode(enc1 << 2 | enc2 >> 4);
        if (enc3 !== 64) {
          output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);
          if (enc4 !== 64) {
            output += String.fromCharCode((enc3 & 3) << 6 | enc4);
          }
        }
      }
      return output;
    };
    util.encodeUtf8 = function(str) {
      return unescape(encodeURIComponent(str));
    };
    util.decodeUtf8 = function(str) {
      return decodeURIComponent(escape(str));
    };
    util.binary = {
      raw: {},
      hex: {},
      base64: {},
      base58: {},
      baseN: {
        encode: baseN.encode,
        decode: baseN.decode
      }
    };
    util.binary.raw.encode = function(bytes) {
      return String.fromCharCode.apply(null, bytes);
    };
    util.binary.raw.decode = function(str, output, offset2) {
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      offset2 = offset2 || 0;
      var j2 = offset2;
      for (var i2 = 0; i2 < str.length; ++i2) {
        out[j2++] = str.charCodeAt(i2);
      }
      return output ? j2 - offset2 : out;
    };
    util.binary.hex.encode = util.bytesToHex;
    util.binary.hex.decode = function(hex, output, offset2) {
      var out = output;
      if (!out) {
        out = new Uint8Array(Math.ceil(hex.length / 2));
      }
      offset2 = offset2 || 0;
      var i2 = 0, j2 = offset2;
      if (hex.length & 1) {
        i2 = 1;
        out[j2++] = parseInt(hex[0], 16);
      }
      for (; i2 < hex.length; i2 += 2) {
        out[j2++] = parseInt(hex.substr(i2, 2), 16);
      }
      return output ? j2 - offset2 : out;
    };
    util.binary.base64.encode = function(input, maxline) {
      var line = "";
      var output = "";
      var chr1, chr2, chr3;
      var i2 = 0;
      while (i2 < input.byteLength) {
        chr1 = input[i2++];
        chr2 = input[i2++];
        chr3 = input[i2++];
        line += _base64.charAt(chr1 >> 2);
        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
        if (isNaN(chr2)) {
          line += "==";
        } else {
          line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
          line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
        }
        if (maxline && line.length > maxline) {
          output += line.substr(0, maxline) + "\r\n";
          line = line.substr(maxline);
        }
      }
      output += line;
      return output;
    };
    util.binary.base64.decode = function(input, output, offset2) {
      var out = output;
      if (!out) {
        out = new Uint8Array(Math.ceil(input.length / 4) * 3);
      }
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      offset2 = offset2 || 0;
      var enc1, enc2, enc3, enc4;
      var i2 = 0, j2 = offset2;
      while (i2 < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i2++) - 43];
        out[j2++] = enc1 << 2 | enc2 >> 4;
        if (enc3 !== 64) {
          out[j2++] = (enc2 & 15) << 4 | enc3 >> 2;
          if (enc4 !== 64) {
            out[j2++] = (enc3 & 3) << 6 | enc4;
          }
        }
      }
      return output ? j2 - offset2 : out.subarray(0, j2);
    };
    util.binary.base58.encode = function(input, maxline) {
      return util.binary.baseN.encode(input, _base58, maxline);
    };
    util.binary.base58.decode = function(input, maxline) {
      return util.binary.baseN.decode(input, _base58, maxline);
    };
    util.text = {
      utf8: {},
      utf16: {}
    };
    util.text.utf8.encode = function(str, output, offset2) {
      str = util.encodeUtf8(str);
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      offset2 = offset2 || 0;
      var j2 = offset2;
      for (var i2 = 0; i2 < str.length; ++i2) {
        out[j2++] = str.charCodeAt(i2);
      }
      return output ? j2 - offset2 : out;
    };
    util.text.utf8.decode = function(bytes) {
      return util.decodeUtf8(String.fromCharCode.apply(null, bytes));
    };
    util.text.utf16.encode = function(str, output, offset2) {
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length * 2);
      }
      var view = new Uint16Array(out.buffer);
      offset2 = offset2 || 0;
      var j2 = offset2;
      var k3 = offset2;
      for (var i2 = 0; i2 < str.length; ++i2) {
        view[k3++] = str.charCodeAt(i2);
        j2 += 2;
      }
      return output ? j2 - offset2 : out;
    };
    util.text.utf16.decode = function(bytes) {
      return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
    };
    util.deflate = function(api, bytes, raw) {
      bytes = util.decode64(api.deflate(util.encode64(bytes)).rval);
      if (raw) {
        var start2 = 2;
        var flg = bytes.charCodeAt(1);
        if (flg & 32) {
          start2 = 6;
        }
        bytes = bytes.substring(start2, bytes.length - 4);
      }
      return bytes;
    };
    util.inflate = function(api, bytes, raw) {
      var rval = api.inflate(util.encode64(bytes)).rval;
      return rval === null ? null : util.decode64(rval);
    };
    var _setStorageObject = function(api, id2, obj) {
      if (!api) {
        throw new Error("WebStorage not available.");
      }
      var rval;
      if (obj === null) {
        rval = api.removeItem(id2);
      } else {
        obj = util.encode64(JSON.stringify(obj));
        rval = api.setItem(id2, obj);
      }
      if (typeof rval !== "undefined" && rval.rval !== true) {
        var error = new Error(rval.error.message);
        error.id = rval.error.id;
        error.name = rval.error.name;
        throw error;
      }
    };
    var _getStorageObject = function(api, id2) {
      if (!api) {
        throw new Error("WebStorage not available.");
      }
      var rval = api.getItem(id2);
      if (api.init) {
        if (rval.rval === null) {
          if (rval.error) {
            var error = new Error(rval.error.message);
            error.id = rval.error.id;
            error.name = rval.error.name;
            throw error;
          }
          rval = null;
        } else {
          rval = rval.rval;
        }
      }
      if (rval !== null) {
        rval = JSON.parse(util.decode64(rval));
      }
      return rval;
    };
    var _setItem = function(api, id2, key, data) {
      var obj = _getStorageObject(api, id2);
      if (obj === null) {
        obj = {};
      }
      obj[key] = data;
      _setStorageObject(api, id2, obj);
    };
    var _getItem = function(api, id2, key) {
      var rval = _getStorageObject(api, id2);
      if (rval !== null) {
        rval = key in rval ? rval[key] : null;
      }
      return rval;
    };
    var _removeItem = function(api, id2, key) {
      var obj = _getStorageObject(api, id2);
      if (obj !== null && key in obj) {
        delete obj[key];
        var empty3 = true;
        for (var prop in obj) {
          empty3 = false;
          break;
        }
        if (empty3) {
          obj = null;
        }
        _setStorageObject(api, id2, obj);
      }
    };
    var _clearItems = function(api, id2) {
      _setStorageObject(api, id2, null);
    };
    var _callStorageFunction = function(func, args, location) {
      var rval = null;
      if (typeof location === "undefined") {
        location = ["web", "flash"];
      }
      var type;
      var done = false;
      var exception = null;
      for (var idx in location) {
        type = location[idx];
        try {
          if (type === "flash" || type === "both") {
            if (args[0] === null) {
              throw new Error("Flash local storage not available.");
            }
            rval = func.apply(this, args);
            done = type === "flash";
          }
          if (type === "web" || type === "both") {
            args[0] = localStorage;
            rval = func.apply(this, args);
            done = true;
          }
        } catch (ex) {
          exception = ex;
        }
        if (done) {
          break;
        }
      }
      if (!done) {
        throw exception;
      }
      return rval;
    };
    util.setItem = function(api, id2, key, data, location) {
      _callStorageFunction(_setItem, arguments, location);
    };
    util.getItem = function(api, id2, key, location) {
      return _callStorageFunction(_getItem, arguments, location);
    };
    util.removeItem = function(api, id2, key, location) {
      _callStorageFunction(_removeItem, arguments, location);
    };
    util.clearItems = function(api, id2, location) {
      _callStorageFunction(_clearItems, arguments, location);
    };
    util.isEmpty = function(obj) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          return false;
        }
      }
      return true;
    };
    util.format = function(format) {
      var re2 = /%./g;
      var match;
      var part;
      var argi = 0;
      var parts = [];
      var last = 0;
      while (match = re2.exec(format)) {
        part = format.substring(last, re2.lastIndex - 2);
        if (part.length > 0) {
          parts.push(part);
        }
        last = re2.lastIndex;
        var code = match[0][1];
        switch (code) {
          case "s":
          case "o":
            if (argi < arguments.length) {
              parts.push(arguments[argi++ + 1]);
            } else {
              parts.push("<?>");
            }
            break;
          case "%":
            parts.push("%");
            break;
          default:
            parts.push("<%" + code + "?>");
        }
      }
      parts.push(format.substring(last));
      return parts.join("");
    };
    util.formatNumber = function(number, decimals, dec_point, thousands_sep) {
      var n2 = number, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
      var d = dec_point === void 0 ? "," : dec_point;
      var t = thousands_sep === void 0 ? "." : thousands_sep, s = n2 < 0 ? "-" : "";
      var i2 = parseInt(n2 = Math.abs(+n2 || 0).toFixed(c), 10) + "";
      var j2 = i2.length > 3 ? i2.length % 3 : 0;
      return s + (j2 ? i2.substr(0, j2) + t : "") + i2.substr(j2).replace(/(\d{3})(?=\d)/g, "$1" + t) + (c ? d + Math.abs(n2 - i2).toFixed(c).slice(2) : "");
    };
    util.formatSize = function(size) {
      if (size >= 1073741824) {
        size = util.formatNumber(size / 1073741824, 2, ".", "") + " GiB";
      } else if (size >= 1048576) {
        size = util.formatNumber(size / 1048576, 2, ".", "") + " MiB";
      } else if (size >= 1024) {
        size = util.formatNumber(size / 1024, 0) + " KiB";
      } else {
        size = util.formatNumber(size, 0) + " bytes";
      }
      return size;
    };
    util.bytesFromIP = function(ip) {
      if (ip.indexOf(".") !== -1) {
        return util.bytesFromIPv4(ip);
      }
      if (ip.indexOf(":") !== -1) {
        return util.bytesFromIPv6(ip);
      }
      return null;
    };
    util.bytesFromIPv4 = function(ip) {
      ip = ip.split(".");
      if (ip.length !== 4) {
        return null;
      }
      var b2 = util.createBuffer();
      for (var i2 = 0; i2 < ip.length; ++i2) {
        var num = parseInt(ip[i2], 10);
        if (isNaN(num)) {
          return null;
        }
        b2.putByte(num);
      }
      return b2.getBytes();
    };
    util.bytesFromIPv6 = function(ip) {
      var blanks = 0;
      ip = ip.split(":").filter(function(e) {
        if (e.length === 0)
          ++blanks;
        return true;
      });
      var zeros = (8 - ip.length + blanks) * 2;
      var b2 = util.createBuffer();
      for (var i2 = 0; i2 < 8; ++i2) {
        if (!ip[i2] || ip[i2].length === 0) {
          b2.fillWithByte(0, zeros);
          zeros = 0;
          continue;
        }
        var bytes = util.hexToBytes(ip[i2]);
        if (bytes.length < 2) {
          b2.putByte(0);
        }
        b2.putBytes(bytes);
      }
      return b2.getBytes();
    };
    util.bytesToIP = function(bytes) {
      if (bytes.length === 4) {
        return util.bytesToIPv4(bytes);
      }
      if (bytes.length === 16) {
        return util.bytesToIPv6(bytes);
      }
      return null;
    };
    util.bytesToIPv4 = function(bytes) {
      if (bytes.length !== 4) {
        return null;
      }
      var ip = [];
      for (var i2 = 0; i2 < bytes.length; ++i2) {
        ip.push(bytes.charCodeAt(i2));
      }
      return ip.join(".");
    };
    util.bytesToIPv6 = function(bytes) {
      if (bytes.length !== 16) {
        return null;
      }
      var ip = [];
      var zeroGroups = [];
      var zeroMaxGroup = 0;
      for (var i2 = 0; i2 < bytes.length; i2 += 2) {
        var hex = util.bytesToHex(bytes[i2] + bytes[i2 + 1]);
        while (hex[0] === "0" && hex !== "0") {
          hex = hex.substr(1);
        }
        if (hex === "0") {
          var last = zeroGroups[zeroGroups.length - 1];
          var idx = ip.length;
          if (!last || idx !== last.end + 1) {
            zeroGroups.push({ start: idx, end: idx });
          } else {
            last.end = idx;
            if (last.end - last.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {
              zeroMaxGroup = zeroGroups.length - 1;
            }
          }
        }
        ip.push(hex);
      }
      if (zeroGroups.length > 0) {
        var group = zeroGroups[zeroMaxGroup];
        if (group.end - group.start > 0) {
          ip.splice(group.start, group.end - group.start + 1, "");
          if (group.start === 0) {
            ip.unshift("");
          }
          if (group.end === 7) {
            ip.push("");
          }
        }
      }
      return ip.join(":");
    };
    util.estimateCores = function(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      if ("cores" in util && !options.update) {
        return callback(null, util.cores);
      }
      if (typeof navigator !== "undefined" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) {
        util.cores = navigator.hardwareConcurrency;
        return callback(null, util.cores);
      }
      if (typeof Worker === "undefined") {
        util.cores = 1;
        return callback(null, util.cores);
      }
      if (typeof Blob === "undefined") {
        util.cores = 2;
        return callback(null, util.cores);
      }
      var blobUrl = URL.createObjectURL(new Blob([
        "(",
        (function() {
          self.addEventListener("message", function(e) {
            var st2 = Date.now();
            var et2 = st2 + 4;
            while (Date.now() < et2)
              ;
            self.postMessage({ st: st2, et: et2 });
          });
        }).toString(),
        ")()"
      ], { type: "application/javascript" }));
      sample([], 5, 16);
      function sample(max, samples, numWorkers) {
        if (samples === 0) {
          var avg = Math.floor(max.reduce(function(avg2, x3) {
            return avg2 + x3;
          }, 0) / max.length);
          util.cores = Math.max(1, avg);
          URL.revokeObjectURL(blobUrl);
          return callback(null, util.cores);
        }
        map3(numWorkers, function(err, results) {
          max.push(reduce(numWorkers, results));
          sample(max, samples - 1, numWorkers);
        });
      }
      function map3(numWorkers, callback2) {
        var workers = [];
        var results = [];
        for (var i2 = 0; i2 < numWorkers; ++i2) {
          var worker = new Worker(blobUrl);
          worker.addEventListener("message", function(e) {
            results.push(e.data);
            if (results.length === numWorkers) {
              for (var i3 = 0; i3 < numWorkers; ++i3) {
                workers[i3].terminate();
              }
              callback2(null, results);
            }
          });
          workers.push(worker);
        }
        for (var i2 = 0; i2 < numWorkers; ++i2) {
          workers[i2].postMessage(i2);
        }
      }
      function reduce(numWorkers, results) {
        var overlaps = [];
        for (var n2 = 0; n2 < numWorkers; ++n2) {
          var r1 = results[n2];
          var overlap = overlaps[n2] = [];
          for (var i2 = 0; i2 < numWorkers; ++i2) {
            if (n2 === i2) {
              continue;
            }
            var r2 = results[i2];
            if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) {
              overlap.push(i2);
            }
          }
        }
        return overlaps.reduce(function(max, overlap2) {
          return Math.max(max, overlap2.length);
        }, 0);
      }
    };
  }
});

// node_modules/node-forge/lib/cipher.js
var require_cipher = __commonJS({
  "node_modules/node-forge/lib/cipher.js"(exports, module) {
    var forge = require_forge();
    require_util2();
    module.exports = forge.cipher = forge.cipher || {};
    forge.cipher.algorithms = forge.cipher.algorithms || {};
    forge.cipher.createCipher = function(algorithm, key) {
      var api = algorithm;
      if (typeof api === "string") {
        api = forge.cipher.getAlgorithm(api);
        if (api) {
          api = api();
        }
      }
      if (!api) {
        throw new Error("Unsupported algorithm: " + algorithm);
      }
      return new forge.cipher.BlockCipher({
        algorithm: api,
        key,
        decrypt: false
      });
    };
    forge.cipher.createDecipher = function(algorithm, key) {
      var api = algorithm;
      if (typeof api === "string") {
        api = forge.cipher.getAlgorithm(api);
        if (api) {
          api = api();
        }
      }
      if (!api) {
        throw new Error("Unsupported algorithm: " + algorithm);
      }
      return new forge.cipher.BlockCipher({
        algorithm: api,
        key,
        decrypt: true
      });
    };
    forge.cipher.registerAlgorithm = function(name4, algorithm) {
      name4 = name4.toUpperCase();
      forge.cipher.algorithms[name4] = algorithm;
    };
    forge.cipher.getAlgorithm = function(name4) {
      name4 = name4.toUpperCase();
      if (name4 in forge.cipher.algorithms) {
        return forge.cipher.algorithms[name4];
      }
      return null;
    };
    var BlockCipher = forge.cipher.BlockCipher = function(options) {
      this.algorithm = options.algorithm;
      this.mode = this.algorithm.mode;
      this.blockSize = this.mode.blockSize;
      this._finish = false;
      this._input = null;
      this.output = null;
      this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
      this._decrypt = options.decrypt;
      this.algorithm.initialize(options);
    };
    BlockCipher.prototype.start = function(options) {
      options = options || {};
      var opts = {};
      for (var key in options) {
        opts[key] = options[key];
      }
      opts.decrypt = this._decrypt;
      this._finish = false;
      this._input = forge.util.createBuffer();
      this.output = options.output || forge.util.createBuffer();
      this.mode.start(opts);
    };
    BlockCipher.prototype.update = function(input) {
      if (input) {
        this._input.putBuffer(input);
      }
      while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {
      }
      this._input.compact();
    };
    BlockCipher.prototype.finish = function(pad) {
      if (pad && (this.mode.name === "ECB" || this.mode.name === "CBC")) {
        this.mode.pad = function(input) {
          return pad(this.blockSize, input, false);
        };
        this.mode.unpad = function(output) {
          return pad(this.blockSize, output, true);
        };
      }
      var options = {};
      options.decrypt = this._decrypt;
      options.overflow = this._input.length() % this.blockSize;
      if (!this._decrypt && this.mode.pad) {
        if (!this.mode.pad(this._input, options)) {
          return false;
        }
      }
      this._finish = true;
      this.update();
      if (this._decrypt && this.mode.unpad) {
        if (!this.mode.unpad(this.output, options)) {
          return false;
        }
      }
      if (this.mode.afterFinish) {
        if (!this.mode.afterFinish(this.output, options)) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/node-forge/lib/cipherModes.js
var require_cipherModes = __commonJS({
  "node_modules/node-forge/lib/cipherModes.js"(exports, module) {
    var forge = require_forge();
    require_util2();
    forge.cipher = forge.cipher || {};
    var modes = module.exports = forge.cipher.modes = forge.cipher.modes || {};
    modes.ecb = function(options) {
      options = options || {};
      this.name = "ECB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.ecb.prototype.start = function(options) {
    };
    modes.ecb.prototype.encrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._inBlock[i2] = input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._outBlock[i2]);
      }
    };
    modes.ecb.prototype.decrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._inBlock[i2] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._outBlock[i2]);
      }
    };
    modes.ecb.prototype.pad = function(input, options) {
      var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
      input.fillWithByte(padding, padding);
      return true;
    };
    modes.ecb.prototype.unpad = function(output, options) {
      if (options.overflow > 0) {
        return false;
      }
      var len = output.length();
      var count = output.at(len - 1);
      if (count > this.blockSize << 2) {
        return false;
      }
      output.truncate(count);
      return true;
    };
    modes.cbc = function(options) {
      options = options || {};
      this.name = "CBC";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.cbc.prototype.start = function(options) {
      if (options.iv === null) {
        if (!this._prev) {
          throw new Error("Invalid IV parameter.");
        }
        this._iv = this._prev.slice(0);
      } else if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      } else {
        this._iv = transformIV(options.iv, this.blockSize);
        this._prev = this._iv.slice(0);
      }
    };
    modes.cbc.prototype.encrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._inBlock[i2] = this._prev[i2] ^ input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._outBlock[i2]);
      }
      this._prev = this._outBlock;
    };
    modes.cbc.prototype.decrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._inBlock[i2] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._prev[i2] ^ this._outBlock[i2]);
      }
      this._prev = this._inBlock.slice(0);
    };
    modes.cbc.prototype.pad = function(input, options) {
      var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
      input.fillWithByte(padding, padding);
      return true;
    };
    modes.cbc.prototype.unpad = function(output, options) {
      if (options.overflow > 0) {
        return false;
      }
      var len = output.length();
      var count = output.at(len - 1);
      if (count > this.blockSize << 2) {
        return false;
      }
      output.truncate(count);
      return true;
    };
    modes.cfb = function(options) {
      options = options || {};
      this.name = "CFB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialBlock = new Array(this._ints);
      this._partialOutput = forge.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.cfb.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.cfb.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = input.getInt32() ^ this._outBlock[i2];
          output.putInt32(this._inBlock[i2]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._partialBlock[i2] = input.getInt32() ^ this._outBlock[i2];
        this._partialOutput.putInt32(this._partialBlock[i2]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = this._partialBlock[i2];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.cfb.prototype.decrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = input.getInt32();
          output.putInt32(this._inBlock[i2] ^ this._outBlock[i2]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._partialBlock[i2] = input.getInt32();
        this._partialOutput.putInt32(this._partialBlock[i2] ^ this._outBlock[i2]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = this._partialBlock[i2];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.ofb = function(options) {
      options = options || {};
      this.name = "OFB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ofb.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ofb.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (input.length() === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          output.putInt32(input.getInt32() ^ this._outBlock[i2]);
          this._inBlock[i2] = this._outBlock[i2];
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = this._outBlock[i2];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
    modes.ctr = function(options) {
      options = options || {};
      this.name = "CTR";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ctr.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ctr.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          output.putInt32(input.getInt32() ^ this._outBlock[i2]);
        }
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
        }
        if (partialBytes > 0) {
          input.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          output.putBytes(this._partialOutput.getBytes(
            partialBytes - this._partialBytes
          ));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(
          inputLength - this._partialBytes
        ));
        this._partialBytes = 0;
      }
      inc32(this._inBlock);
    };
    modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
    modes.gcm = function(options) {
      options = options || {};
      this.name = "GCM";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge.util.createBuffer();
      this._partialBytes = 0;
      this._R = 3774873600;
    };
    modes.gcm.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      var iv = forge.util.createBuffer(options.iv);
      this._cipherLength = 0;
      var additionalData;
      if ("additionalData" in options) {
        additionalData = forge.util.createBuffer(options.additionalData);
      } else {
        additionalData = forge.util.createBuffer();
      }
      if ("tagLength" in options) {
        this._tagLength = options.tagLength;
      } else {
        this._tagLength = 128;
      }
      this._tag = null;
      if (options.decrypt) {
        this._tag = forge.util.createBuffer(options.tag).getBytes();
        if (this._tag.length !== this._tagLength / 8) {
          throw new Error("Authentication tag does not match tag length.");
        }
      }
      this._hashBlock = new Array(this._ints);
      this.tag = null;
      this._hashSubkey = new Array(this._ints);
      this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);
      this.componentBits = 4;
      this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
      var ivLength = iv.length();
      if (ivLength === 12) {
        this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];
      } else {
        this._j0 = [0, 0, 0, 0];
        while (iv.length() > 0) {
          this._j0 = this.ghash(
            this._hashSubkey,
            this._j0,
            [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]
          );
        }
        this._j0 = this.ghash(
          this._hashSubkey,
          this._j0,
          [0, 0].concat(from64To32(ivLength * 8))
        );
      }
      this._inBlock = this._j0.slice(0);
      inc32(this._inBlock);
      this._partialBytes = 0;
      additionalData = forge.util.createBuffer(additionalData);
      this._aDataLength = from64To32(additionalData.length() * 8);
      var overflow = additionalData.length() % this.blockSize;
      if (overflow) {
        additionalData.fillWithByte(0, this.blockSize - overflow);
      }
      this._s = [0, 0, 0, 0];
      while (additionalData.length() > 0) {
        this._s = this.ghash(this._hashSubkey, this._s, [
          additionalData.getInt32(),
          additionalData.getInt32(),
          additionalData.getInt32(),
          additionalData.getInt32()
        ]);
      }
    };
    modes.gcm.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          output.putInt32(this._outBlock[i2] ^= input.getInt32());
        }
        this._cipherLength += this.blockSize;
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
        }
        if (partialBytes <= 0 || finish) {
          if (finish) {
            var overflow = inputLength % this.blockSize;
            this._cipherLength += overflow;
            this._partialOutput.truncate(this.blockSize - overflow);
          } else {
            this._cipherLength += this.blockSize;
          }
          for (var i2 = 0; i2 < this._ints; ++i2) {
            this._outBlock[i2] = this._partialOutput.getInt32();
          }
          this._partialOutput.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          input.read -= this.blockSize;
          output.putBytes(this._partialOutput.getBytes(
            partialBytes - this._partialBytes
          ));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(
          inputLength - this._partialBytes
        ));
        this._partialBytes = 0;
      }
      this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);
      inc32(this._inBlock);
    };
    modes.gcm.prototype.decrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength < this.blockSize && !(finish && inputLength > 0)) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      inc32(this._inBlock);
      this._hashBlock[0] = input.getInt32();
      this._hashBlock[1] = input.getInt32();
      this._hashBlock[2] = input.getInt32();
      this._hashBlock[3] = input.getInt32();
      this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._outBlock[i2] ^ this._hashBlock[i2]);
      }
      if (inputLength < this.blockSize) {
        this._cipherLength += inputLength % this.blockSize;
      } else {
        this._cipherLength += this.blockSize;
      }
    };
    modes.gcm.prototype.afterFinish = function(output, options) {
      var rval = true;
      if (options.decrypt && options.overflow) {
        output.truncate(this.blockSize - options.overflow);
      }
      this.tag = forge.util.createBuffer();
      var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));
      this._s = this.ghash(this._hashSubkey, this._s, lengths);
      var tag = [];
      this.cipher.encrypt(this._j0, tag);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this.tag.putInt32(this._s[i2] ^ tag[i2]);
      }
      this.tag.truncate(this.tag.length() % (this._tagLength / 8));
      if (options.decrypt && this.tag.bytes() !== this._tag) {
        rval = false;
      }
      return rval;
    };
    modes.gcm.prototype.multiply = function(x3, y2) {
      var z_i = [0, 0, 0, 0];
      var v_i = y2.slice(0);
      for (var i2 = 0; i2 < 128; ++i2) {
        var x_i = x3[i2 / 32 | 0] & 1 << 31 - i2 % 32;
        if (x_i) {
          z_i[0] ^= v_i[0];
          z_i[1] ^= v_i[1];
          z_i[2] ^= v_i[2];
          z_i[3] ^= v_i[3];
        }
        this.pow(v_i, v_i);
      }
      return z_i;
    };
    modes.gcm.prototype.pow = function(x3, out) {
      var lsb = x3[3] & 1;
      for (var i2 = 3; i2 > 0; --i2) {
        out[i2] = x3[i2] >>> 1 | (x3[i2 - 1] & 1) << 31;
      }
      out[0] = x3[0] >>> 1;
      if (lsb) {
        out[0] ^= this._R;
      }
    };
    modes.gcm.prototype.tableMultiply = function(x3) {
      var z2 = [0, 0, 0, 0];
      for (var i2 = 0; i2 < 32; ++i2) {
        var idx = i2 / 8 | 0;
        var x_i = x3[idx] >>> (7 - i2 % 8) * 4 & 15;
        var ah = this._m[i2][x_i];
        z2[0] ^= ah[0];
        z2[1] ^= ah[1];
        z2[2] ^= ah[2];
        z2[3] ^= ah[3];
      }
      return z2;
    };
    modes.gcm.prototype.ghash = function(h, y2, x3) {
      y2[0] ^= x3[0];
      y2[1] ^= x3[1];
      y2[2] ^= x3[2];
      y2[3] ^= x3[3];
      return this.tableMultiply(y2);
    };
    modes.gcm.prototype.generateHashTable = function(h, bits) {
      var multiplier = 8 / bits;
      var perInt = 4 * multiplier;
      var size = 16 * multiplier;
      var m = new Array(size);
      for (var i2 = 0; i2 < size; ++i2) {
        var tmp = [0, 0, 0, 0];
        var idx = i2 / perInt | 0;
        var shft = (perInt - 1 - i2 % perInt) * bits;
        tmp[idx] = 1 << bits - 1 << shft;
        m[i2] = this.generateSubHashTable(this.multiply(tmp, h), bits);
      }
      return m;
    };
    modes.gcm.prototype.generateSubHashTable = function(mid, bits) {
      var size = 1 << bits;
      var half = size >>> 1;
      var m = new Array(size);
      m[half] = mid.slice(0);
      var i2 = half >>> 1;
      while (i2 > 0) {
        this.pow(m[2 * i2], m[i2] = []);
        i2 >>= 1;
      }
      i2 = 2;
      while (i2 < half) {
        for (var j2 = 1; j2 < i2; ++j2) {
          var m_i = m[i2];
          var m_j = m[j2];
          m[i2 + j2] = [
            m_i[0] ^ m_j[0],
            m_i[1] ^ m_j[1],
            m_i[2] ^ m_j[2],
            m_i[3] ^ m_j[3]
          ];
        }
        i2 *= 2;
      }
      m[0] = [0, 0, 0, 0];
      for (i2 = half + 1; i2 < size; ++i2) {
        var c = m[i2 ^ half];
        m[i2] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];
      }
      return m;
    };
    function transformIV(iv, blockSize) {
      if (typeof iv === "string") {
        iv = forge.util.createBuffer(iv);
      }
      if (forge.util.isArray(iv) && iv.length > 4) {
        var tmp = iv;
        iv = forge.util.createBuffer();
        for (var i2 = 0; i2 < tmp.length; ++i2) {
          iv.putByte(tmp[i2]);
        }
      }
      if (iv.length() < blockSize) {
        throw new Error(
          "Invalid IV length; got " + iv.length() + " bytes and expected " + blockSize + " bytes."
        );
      }
      if (!forge.util.isArray(iv)) {
        var ints = [];
        var blocks = blockSize / 4;
        for (var i2 = 0; i2 < blocks; ++i2) {
          ints.push(iv.getInt32());
        }
        iv = ints;
      }
      return iv;
    }
    function inc32(block) {
      block[block.length - 1] = block[block.length - 1] + 1 & 4294967295;
    }
    function from64To32(num) {
      return [num / 4294967296 | 0, num & 4294967295];
    }
  }
});

// node_modules/node-forge/lib/aes.js
var require_aes = __commonJS({
  "node_modules/node-forge/lib/aes.js"(exports, module) {
    var forge = require_forge();
    require_cipher();
    require_cipherModes();
    require_util2();
    module.exports = forge.aes = forge.aes || {};
    forge.aes.startEncrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: false,
        mode
      });
      cipher.start(iv);
      return cipher;
    };
    forge.aes.createEncryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: false,
        mode
      });
    };
    forge.aes.startDecrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: true,
        mode
      });
      cipher.start(iv);
      return cipher;
    };
    forge.aes.createDecryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: true,
        mode
      });
    };
    forge.aes.Algorithm = function(name4, mode) {
      if (!init) {
        initialize();
      }
      var self2 = this;
      self2.name = name4;
      self2.mode = new mode({
        blockSize: 16,
        cipher: {
          encrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._w, inBlock, outBlock, false);
          },
          decrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._w, inBlock, outBlock, true);
          }
        }
      });
      self2._init = false;
    };
    forge.aes.Algorithm.prototype.initialize = function(options) {
      if (this._init) {
        return;
      }
      var key = options.key;
      var tmp;
      if (typeof key === "string" && (key.length === 16 || key.length === 24 || key.length === 32)) {
        key = forge.util.createBuffer(key);
      } else if (forge.util.isArray(key) && (key.length === 16 || key.length === 24 || key.length === 32)) {
        tmp = key;
        key = forge.util.createBuffer();
        for (var i2 = 0; i2 < tmp.length; ++i2) {
          key.putByte(tmp[i2]);
        }
      }
      if (!forge.util.isArray(key)) {
        tmp = key;
        key = [];
        var len = tmp.length();
        if (len === 16 || len === 24 || len === 32) {
          len = len >>> 2;
          for (var i2 = 0; i2 < len; ++i2) {
            key.push(tmp.getInt32());
          }
        }
      }
      if (!forge.util.isArray(key) || !(key.length === 4 || key.length === 6 || key.length === 8)) {
        throw new Error("Invalid key parameter.");
      }
      var mode = this.mode.name;
      var encryptOp = ["CFB", "OFB", "CTR", "GCM"].indexOf(mode) !== -1;
      this._w = _expandKey(key, options.decrypt && !encryptOp);
      this._init = true;
    };
    forge.aes._expandKey = function(key, decrypt) {
      if (!init) {
        initialize();
      }
      return _expandKey(key, decrypt);
    };
    forge.aes._updateBlock = _updateBlock;
    registerAlgorithm("AES-ECB", forge.cipher.modes.ecb);
    registerAlgorithm("AES-CBC", forge.cipher.modes.cbc);
    registerAlgorithm("AES-CFB", forge.cipher.modes.cfb);
    registerAlgorithm("AES-OFB", forge.cipher.modes.ofb);
    registerAlgorithm("AES-CTR", forge.cipher.modes.ctr);
    registerAlgorithm("AES-GCM", forge.cipher.modes.gcm);
    function registerAlgorithm(name4, mode) {
      var factory2 = function() {
        return new forge.aes.Algorithm(name4, mode);
      };
      forge.cipher.registerAlgorithm(name4, factory2);
    }
    var init = false;
    var Nb2 = 4;
    var sbox;
    var isbox;
    var rcon;
    var mix;
    var imix;
    function initialize() {
      init = true;
      rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
      var xtime = new Array(256);
      for (var i2 = 0; i2 < 128; ++i2) {
        xtime[i2] = i2 << 1;
        xtime[i2 + 128] = i2 + 128 << 1 ^ 283;
      }
      sbox = new Array(256);
      isbox = new Array(256);
      mix = new Array(4);
      imix = new Array(4);
      for (var i2 = 0; i2 < 4; ++i2) {
        mix[i2] = new Array(256);
        imix[i2] = new Array(256);
      }
      var e = 0, ei2 = 0, e2, e4, e8, sx, sx2, me2, ime;
      for (var i2 = 0; i2 < 256; ++i2) {
        sx = ei2 ^ ei2 << 1 ^ ei2 << 2 ^ ei2 << 3 ^ ei2 << 4;
        sx = sx >> 8 ^ sx & 255 ^ 99;
        sbox[e] = sx;
        isbox[sx] = e;
        sx2 = xtime[sx];
        e2 = xtime[e];
        e4 = xtime[e2];
        e8 = xtime[e4];
        me2 = sx2 << 24 ^ // 2
        sx << 16 ^ // 1
        sx << 8 ^ // 1
        (sx ^ sx2);
        ime = (e2 ^ e4 ^ e8) << 24 ^ // E (14)
        (e ^ e8) << 16 ^ // 9
        (e ^ e4 ^ e8) << 8 ^ // D (13)
        (e ^ e2 ^ e8);
        for (var n2 = 0; n2 < 4; ++n2) {
          mix[n2][e] = me2;
          imix[n2][sx] = ime;
          me2 = me2 << 24 | me2 >>> 8;
          ime = ime << 24 | ime >>> 8;
        }
        if (e === 0) {
          e = ei2 = 1;
        } else {
          e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]];
          ei2 ^= xtime[xtime[ei2]];
        }
      }
    }
    function _expandKey(key, decrypt) {
      var w2 = key.slice(0);
      var temp, iNk = 1;
      var Nk = w2.length;
      var Nr1 = Nk + 6 + 1;
      var end = Nb2 * Nr1;
      for (var i2 = Nk; i2 < end; ++i2) {
        temp = w2[i2 - 1];
        if (i2 % Nk === 0) {
          temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24;
          iNk++;
        } else if (Nk > 6 && i2 % Nk === 4) {
          temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];
        }
        w2[i2] = w2[i2 - Nk] ^ temp;
      }
      if (decrypt) {
        var tmp;
        var m0 = imix[0];
        var m1 = imix[1];
        var m2 = imix[2];
        var m3 = imix[3];
        var wnew = w2.slice(0);
        end = w2.length;
        for (var i2 = 0, wi2 = end - Nb2; i2 < end; i2 += Nb2, wi2 -= Nb2) {
          if (i2 === 0 || i2 === end - Nb2) {
            wnew[i2] = w2[wi2];
            wnew[i2 + 1] = w2[wi2 + 3];
            wnew[i2 + 2] = w2[wi2 + 2];
            wnew[i2 + 3] = w2[wi2 + 1];
          } else {
            for (var n2 = 0; n2 < Nb2; ++n2) {
              tmp = w2[wi2 + n2];
              wnew[i2 + (3 & -n2)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m2[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];
            }
          }
        }
        w2 = wnew;
      }
      return w2;
    }
    function _updateBlock(w2, input, output, decrypt) {
      var Nr2 = w2.length / 4 - 1;
      var m0, m1, m2, m3, sub;
      if (decrypt) {
        m0 = imix[0];
        m1 = imix[1];
        m2 = imix[2];
        m3 = imix[3];
        sub = isbox;
      } else {
        m0 = mix[0];
        m1 = mix[1];
        m2 = mix[2];
        m3 = mix[3];
        sub = sbox;
      }
      var a, b2, c, d, a2, b22, c2;
      a = input[0] ^ w2[0];
      b2 = input[decrypt ? 3 : 1] ^ w2[1];
      c = input[2] ^ w2[2];
      d = input[decrypt ? 1 : 3] ^ w2[3];
      var i2 = 3;
      for (var round = 1; round < Nr2; ++round) {
        a2 = m0[a >>> 24] ^ m1[b2 >>> 16 & 255] ^ m2[c >>> 8 & 255] ^ m3[d & 255] ^ w2[++i2];
        b22 = m0[b2 >>> 24] ^ m1[c >>> 16 & 255] ^ m2[d >>> 8 & 255] ^ m3[a & 255] ^ w2[++i2];
        c2 = m0[c >>> 24] ^ m1[d >>> 16 & 255] ^ m2[a >>> 8 & 255] ^ m3[b2 & 255] ^ w2[++i2];
        d = m0[d >>> 24] ^ m1[a >>> 16 & 255] ^ m2[b2 >>> 8 & 255] ^ m3[c & 255] ^ w2[++i2];
        a = a2;
        b2 = b22;
        c = c2;
      }
      output[0] = sub[a >>> 24] << 24 ^ sub[b2 >>> 16 & 255] << 16 ^ sub[c >>> 8 & 255] << 8 ^ sub[d & 255] ^ w2[++i2];
      output[decrypt ? 3 : 1] = sub[b2 >>> 24] << 24 ^ sub[c >>> 16 & 255] << 16 ^ sub[d >>> 8 & 255] << 8 ^ sub[a & 255] ^ w2[++i2];
      output[2] = sub[c >>> 24] << 24 ^ sub[d >>> 16 & 255] << 16 ^ sub[a >>> 8 & 255] << 8 ^ sub[b2 & 255] ^ w2[++i2];
      output[decrypt ? 1 : 3] = sub[d >>> 24] << 24 ^ sub[a >>> 16 & 255] << 16 ^ sub[b2 >>> 8 & 255] << 8 ^ sub[c & 255] ^ w2[++i2];
    }
    function _createCipher(options) {
      options = options || {};
      var mode = (options.mode || "CBC").toUpperCase();
      var algorithm = "AES-" + mode;
      var cipher;
      if (options.decrypt) {
        cipher = forge.cipher.createDecipher(algorithm, options.key);
      } else {
        cipher = forge.cipher.createCipher(algorithm, options.key);
      }
      var start2 = cipher.start;
      cipher.start = function(iv, options2) {
        var output = null;
        if (options2 instanceof forge.util.ByteBuffer) {
          output = options2;
          options2 = {};
        }
        options2 = options2 || {};
        options2.output = output;
        options2.iv = iv;
        start2.call(cipher, options2);
      };
      return cipher;
    }
  }
});

// node_modules/node-forge/lib/oids.js
var require_oids = __commonJS({
  "node_modules/node-forge/lib/oids.js"(exports, module) {
    var forge = require_forge();
    forge.pki = forge.pki || {};
    var oids = module.exports = forge.pki.oids = forge.oids = forge.oids || {};
    function _IN(id2, name4) {
      oids[id2] = name4;
      oids[name4] = id2;
    }
    function _I_(id2, name4) {
      oids[id2] = name4;
    }
    _IN("1.2.840.113549.1.1.1", "rsaEncryption");
    _IN("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
    _IN("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
    _IN("1.2.840.113549.1.1.7", "RSAES-OAEP");
    _IN("1.2.840.113549.1.1.8", "mgf1");
    _IN("1.2.840.113549.1.1.9", "pSpecified");
    _IN("1.2.840.113549.1.1.10", "RSASSA-PSS");
    _IN("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
    _IN("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
    _IN("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
    _IN("1.3.101.112", "EdDSA25519");
    _IN("1.2.840.10040.4.3", "dsa-with-sha1");
    _IN("1.3.14.3.2.7", "desCBC");
    _IN("1.3.14.3.2.26", "sha1");
    _IN("1.3.14.3.2.29", "sha1WithRSASignature");
    _IN("2.16.840.1.101.3.4.2.1", "sha256");
    _IN("2.16.840.1.101.3.4.2.2", "sha384");
    _IN("2.16.840.1.101.3.4.2.3", "sha512");
    _IN("2.16.840.1.101.3.4.2.4", "sha224");
    _IN("2.16.840.1.101.3.4.2.5", "sha512-224");
    _IN("2.16.840.1.101.3.4.2.6", "sha512-256");
    _IN("1.2.840.113549.2.2", "md2");
    _IN("1.2.840.113549.2.5", "md5");
    _IN("1.2.840.113549.1.7.1", "data");
    _IN("1.2.840.113549.1.7.2", "signedData");
    _IN("1.2.840.113549.1.7.3", "envelopedData");
    _IN("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
    _IN("1.2.840.113549.1.7.5", "digestedData");
    _IN("1.2.840.113549.1.7.6", "encryptedData");
    _IN("1.2.840.113549.1.9.1", "emailAddress");
    _IN("1.2.840.113549.1.9.2", "unstructuredName");
    _IN("1.2.840.113549.1.9.3", "contentType");
    _IN("1.2.840.113549.1.9.4", "messageDigest");
    _IN("1.2.840.113549.1.9.5", "signingTime");
    _IN("1.2.840.113549.1.9.6", "counterSignature");
    _IN("1.2.840.113549.1.9.7", "challengePassword");
    _IN("1.2.840.113549.1.9.8", "unstructuredAddress");
    _IN("1.2.840.113549.1.9.14", "extensionRequest");
    _IN("1.2.840.113549.1.9.20", "friendlyName");
    _IN("1.2.840.113549.1.9.21", "localKeyId");
    _IN("1.2.840.113549.1.9.22.1", "x509Certificate");
    _IN("1.2.840.113549.1.12.10.1.1", "keyBag");
    _IN("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
    _IN("1.2.840.113549.1.12.10.1.3", "certBag");
    _IN("1.2.840.113549.1.12.10.1.4", "crlBag");
    _IN("1.2.840.113549.1.12.10.1.5", "secretBag");
    _IN("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
    _IN("1.2.840.113549.1.5.13", "pkcs5PBES2");
    _IN("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
    _IN("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
    _IN("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
    _IN("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
    _IN("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
    _IN("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
    _IN("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
    _IN("1.2.840.113549.2.7", "hmacWithSHA1");
    _IN("1.2.840.113549.2.8", "hmacWithSHA224");
    _IN("1.2.840.113549.2.9", "hmacWithSHA256");
    _IN("1.2.840.113549.2.10", "hmacWithSHA384");
    _IN("1.2.840.113549.2.11", "hmacWithSHA512");
    _IN("1.2.840.113549.3.7", "des-EDE3-CBC");
    _IN("2.16.840.1.101.3.4.1.2", "aes128-CBC");
    _IN("2.16.840.1.101.3.4.1.22", "aes192-CBC");
    _IN("2.16.840.1.101.3.4.1.42", "aes256-CBC");
    _IN("2.5.4.3", "commonName");
    _IN("2.5.4.4", "surname");
    _IN("2.5.4.5", "serialNumber");
    _IN("2.5.4.6", "countryName");
    _IN("2.5.4.7", "localityName");
    _IN("2.5.4.8", "stateOrProvinceName");
    _IN("2.5.4.9", "streetAddress");
    _IN("2.5.4.10", "organizationName");
    _IN("2.5.4.11", "organizationalUnitName");
    _IN("2.5.4.12", "title");
    _IN("2.5.4.13", "description");
    _IN("2.5.4.15", "businessCategory");
    _IN("2.5.4.17", "postalCode");
    _IN("2.5.4.42", "givenName");
    _IN("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
    _IN("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
    _IN("2.16.840.1.113730.1.1", "nsCertType");
    _IN("2.16.840.1.113730.1.13", "nsComment");
    _I_("2.5.29.1", "authorityKeyIdentifier");
    _I_("2.5.29.2", "keyAttributes");
    _I_("2.5.29.3", "certificatePolicies");
    _I_("2.5.29.4", "keyUsageRestriction");
    _I_("2.5.29.5", "policyMapping");
    _I_("2.5.29.6", "subtreesConstraint");
    _I_("2.5.29.7", "subjectAltName");
    _I_("2.5.29.8", "issuerAltName");
    _I_("2.5.29.9", "subjectDirectoryAttributes");
    _I_("2.5.29.10", "basicConstraints");
    _I_("2.5.29.11", "nameConstraints");
    _I_("2.5.29.12", "policyConstraints");
    _I_("2.5.29.13", "basicConstraints");
    _IN("2.5.29.14", "subjectKeyIdentifier");
    _IN("2.5.29.15", "keyUsage");
    _I_("2.5.29.16", "privateKeyUsagePeriod");
    _IN("2.5.29.17", "subjectAltName");
    _IN("2.5.29.18", "issuerAltName");
    _IN("2.5.29.19", "basicConstraints");
    _I_("2.5.29.20", "cRLNumber");
    _I_("2.5.29.21", "cRLReason");
    _I_("2.5.29.22", "expirationDate");
    _I_("2.5.29.23", "instructionCode");
    _I_("2.5.29.24", "invalidityDate");
    _I_("2.5.29.25", "cRLDistributionPoints");
    _I_("2.5.29.26", "issuingDistributionPoint");
    _I_("2.5.29.27", "deltaCRLIndicator");
    _I_("2.5.29.28", "issuingDistributionPoint");
    _I_("2.5.29.29", "certificateIssuer");
    _I_("2.5.29.30", "nameConstraints");
    _IN("2.5.29.31", "cRLDistributionPoints");
    _IN("2.5.29.32", "certificatePolicies");
    _I_("2.5.29.33", "policyMappings");
    _I_("2.5.29.34", "policyConstraints");
    _IN("2.5.29.35", "authorityKeyIdentifier");
    _I_("2.5.29.36", "policyConstraints");
    _IN("2.5.29.37", "extKeyUsage");
    _I_("2.5.29.46", "freshestCRL");
    _I_("2.5.29.54", "inhibitAnyPolicy");
    _IN("1.3.6.1.4.1.11129.2.4.2", "timestampList");
    _IN("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
    _IN("1.3.6.1.5.5.7.3.1", "serverAuth");
    _IN("1.3.6.1.5.5.7.3.2", "clientAuth");
    _IN("1.3.6.1.5.5.7.3.3", "codeSigning");
    _IN("1.3.6.1.5.5.7.3.4", "emailProtection");
    _IN("1.3.6.1.5.5.7.3.8", "timeStamping");
  }
});

// node_modules/node-forge/lib/asn1.js
var require_asn1 = __commonJS({
  "node_modules/node-forge/lib/asn1.js"(exports, module) {
    var forge = require_forge();
    require_util2();
    require_oids();
    var asn1 = module.exports = forge.asn1 = forge.asn1 || {};
    asn1.Class = {
      UNIVERSAL: 0,
      APPLICATION: 64,
      CONTEXT_SPECIFIC: 128,
      PRIVATE: 192
    };
    asn1.Type = {
      NONE: 0,
      BOOLEAN: 1,
      INTEGER: 2,
      BITSTRING: 3,
      OCTETSTRING: 4,
      NULL: 5,
      OID: 6,
      ODESC: 7,
      EXTERNAL: 8,
      REAL: 9,
      ENUMERATED: 10,
      EMBEDDED: 11,
      UTF8: 12,
      ROID: 13,
      SEQUENCE: 16,
      SET: 17,
      PRINTABLESTRING: 19,
      IA5STRING: 22,
      UTCTIME: 23,
      GENERALIZEDTIME: 24,
      BMPSTRING: 30
    };
    asn1.create = function(tagClass, type, constructed, value, options) {
      if (forge.util.isArray(value)) {
        var tmp = [];
        for (var i2 = 0; i2 < value.length; ++i2) {
          if (value[i2] !== void 0) {
            tmp.push(value[i2]);
          }
        }
        value = tmp;
      }
      var obj = {
        tagClass,
        type,
        constructed,
        composed: constructed || forge.util.isArray(value),
        value
      };
      if (options && "bitStringContents" in options) {
        obj.bitStringContents = options.bitStringContents;
        obj.original = asn1.copy(obj);
      }
      return obj;
    };
    asn1.copy = function(obj, options) {
      var copy;
      if (forge.util.isArray(obj)) {
        copy = [];
        for (var i2 = 0; i2 < obj.length; ++i2) {
          copy.push(asn1.copy(obj[i2], options));
        }
        return copy;
      }
      if (typeof obj === "string") {
        return obj;
      }
      copy = {
        tagClass: obj.tagClass,
        type: obj.type,
        constructed: obj.constructed,
        composed: obj.composed,
        value: asn1.copy(obj.value, options)
      };
      if (options && !options.excludeBitStringContents) {
        copy.bitStringContents = obj.bitStringContents;
      }
      return copy;
    };
    asn1.equals = function(obj1, obj2, options) {
      if (forge.util.isArray(obj1)) {
        if (!forge.util.isArray(obj2)) {
          return false;
        }
        if (obj1.length !== obj2.length) {
          return false;
        }
        for (var i2 = 0; i2 < obj1.length; ++i2) {
          if (!asn1.equals(obj1[i2], obj2[i2])) {
            return false;
          }
        }
        return true;
      }
      if (typeof obj1 !== typeof obj2) {
        return false;
      }
      if (typeof obj1 === "string") {
        return obj1 === obj2;
      }
      var equal = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn1.equals(obj1.value, obj2.value);
      if (options && options.includeBitStringContents) {
        equal = equal && obj1.bitStringContents === obj2.bitStringContents;
      }
      return equal;
    };
    asn1.getBerValueLength = function(b2) {
      var b22 = b2.getByte();
      if (b22 === 128) {
        return void 0;
      }
      var length;
      var longForm = b22 & 128;
      if (!longForm) {
        length = b22;
      } else {
        length = b2.getInt((b22 & 127) << 3);
      }
      return length;
    };
    function _checkBufferLength(bytes, remaining, n2) {
      if (n2 > remaining) {
        var error = new Error("Too few bytes to parse DER.");
        error.available = bytes.length();
        error.remaining = remaining;
        error.requested = n2;
        throw error;
      }
    }
    var _getValueLength = function(bytes, remaining) {
      var b2 = bytes.getByte();
      remaining--;
      if (b2 === 128) {
        return void 0;
      }
      var length;
      var longForm = b2 & 128;
      if (!longForm) {
        length = b2;
      } else {
        var longFormBytes = b2 & 127;
        _checkBufferLength(bytes, remaining, longFormBytes);
        length = bytes.getInt(longFormBytes << 3);
      }
      if (length < 0) {
        throw new Error("Negative length: " + length);
      }
      return length;
    };
    asn1.fromDer = function(bytes, options) {
      if (options === void 0) {
        options = {
          strict: true,
          parseAllBytes: true,
          decodeBitStrings: true
        };
      }
      if (typeof options === "boolean") {
        options = {
          strict: options,
          parseAllBytes: true,
          decodeBitStrings: true
        };
      }
      if (!("strict" in options)) {
        options.strict = true;
      }
      if (!("parseAllBytes" in options)) {
        options.parseAllBytes = true;
      }
      if (!("decodeBitStrings" in options)) {
        options.decodeBitStrings = true;
      }
      if (typeof bytes === "string") {
        bytes = forge.util.createBuffer(bytes);
      }
      var byteCount = bytes.length();
      var value = _fromDer(bytes, bytes.length(), 0, options);
      if (options.parseAllBytes && bytes.length() !== 0) {
        var error = new Error("Unparsed DER bytes remain after ASN.1 parsing.");
        error.byteCount = byteCount;
        error.remaining = bytes.length();
        throw error;
      }
      return value;
    };
    function _fromDer(bytes, remaining, depth, options) {
      var start2;
      _checkBufferLength(bytes, remaining, 2);
      var b1 = bytes.getByte();
      remaining--;
      var tagClass = b1 & 192;
      var type = b1 & 31;
      start2 = bytes.length();
      var length = _getValueLength(bytes, remaining);
      remaining -= start2 - bytes.length();
      if (length !== void 0 && length > remaining) {
        if (options.strict) {
          var error = new Error("Too few bytes to read ASN.1 value.");
          error.available = bytes.length();
          error.remaining = remaining;
          error.requested = length;
          throw error;
        }
        length = remaining;
      }
      var value;
      var bitStringContents;
      var constructed = (b1 & 32) === 32;
      if (constructed) {
        value = [];
        if (length === void 0) {
          for (; ; ) {
            _checkBufferLength(bytes, remaining, 2);
            if (bytes.bytes(2) === String.fromCharCode(0, 0)) {
              bytes.getBytes(2);
              remaining -= 2;
              break;
            }
            start2 = bytes.length();
            value.push(_fromDer(bytes, remaining, depth + 1, options));
            remaining -= start2 - bytes.length();
          }
        } else {
          while (length > 0) {
            start2 = bytes.length();
            value.push(_fromDer(bytes, length, depth + 1, options));
            remaining -= start2 - bytes.length();
            length -= start2 - bytes.length();
          }
        }
      }
      if (value === void 0 && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING) {
        bitStringContents = bytes.bytes(length);
      }
      if (value === void 0 && options.decodeBitStrings && tagClass === asn1.Class.UNIVERSAL && // FIXME: OCTET STRINGs not yet supported here
      // .. other parts of forge expect to decode OCTET STRINGs manually
      type === asn1.Type.BITSTRING && length > 1) {
        var savedRead = bytes.read;
        var savedRemaining = remaining;
        var unused = 0;
        if (type === asn1.Type.BITSTRING) {
          _checkBufferLength(bytes, remaining, 1);
          unused = bytes.getByte();
          remaining--;
        }
        if (unused === 0) {
          try {
            start2 = bytes.length();
            var subOptions = {
              // enforce strict mode to avoid parsing ASN.1 from plain data
              strict: true,
              decodeBitStrings: true
            };
            var composed = _fromDer(bytes, remaining, depth + 1, subOptions);
            var used = start2 - bytes.length();
            remaining -= used;
            if (type == asn1.Type.BITSTRING) {
              used++;
            }
            var tc2 = composed.tagClass;
            if (used === length && (tc2 === asn1.Class.UNIVERSAL || tc2 === asn1.Class.CONTEXT_SPECIFIC)) {
              value = [composed];
            }
          } catch (ex) {
          }
        }
        if (value === void 0) {
          bytes.read = savedRead;
          remaining = savedRemaining;
        }
      }
      if (value === void 0) {
        if (length === void 0) {
          if (options.strict) {
            throw new Error("Non-constructed ASN.1 object of indefinite length.");
          }
          length = remaining;
        }
        if (type === asn1.Type.BMPSTRING) {
          value = "";
          for (; length > 0; length -= 2) {
            _checkBufferLength(bytes, remaining, 2);
            value += String.fromCharCode(bytes.getInt16());
            remaining -= 2;
          }
        } else {
          value = bytes.getBytes(length);
          remaining -= length;
        }
      }
      var asn1Options = bitStringContents === void 0 ? null : {
        bitStringContents
      };
      return asn1.create(tagClass, type, constructed, value, asn1Options);
    }
    asn1.toDer = function(obj) {
      var bytes = forge.util.createBuffer();
      var b1 = obj.tagClass | obj.type;
      var value = forge.util.createBuffer();
      var useBitStringContents = false;
      if ("bitStringContents" in obj) {
        useBitStringContents = true;
        if (obj.original) {
          useBitStringContents = asn1.equals(obj, obj.original);
        }
      }
      if (useBitStringContents) {
        value.putBytes(obj.bitStringContents);
      } else if (obj.composed) {
        if (obj.constructed) {
          b1 |= 32;
        } else {
          value.putByte(0);
        }
        for (var i2 = 0; i2 < obj.value.length; ++i2) {
          if (obj.value[i2] !== void 0) {
            value.putBuffer(asn1.toDer(obj.value[i2]));
          }
        }
      } else {
        if (obj.type === asn1.Type.BMPSTRING) {
          for (var i2 = 0; i2 < obj.value.length; ++i2) {
            value.putInt16(obj.value.charCodeAt(i2));
          }
        } else {
          if (obj.type === asn1.Type.INTEGER && obj.value.length > 1 && // leading 0x00 for positive integer
          (obj.value.charCodeAt(0) === 0 && (obj.value.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer
          obj.value.charCodeAt(0) === 255 && (obj.value.charCodeAt(1) & 128) === 128)) {
            value.putBytes(obj.value.substr(1));
          } else {
            value.putBytes(obj.value);
          }
        }
      }
      bytes.putByte(b1);
      if (value.length() <= 127) {
        bytes.putByte(value.length() & 127);
      } else {
        var len = value.length();
        var lenBytes = "";
        do {
          lenBytes += String.fromCharCode(len & 255);
          len = len >>> 8;
        } while (len > 0);
        bytes.putByte(lenBytes.length | 128);
        for (var i2 = lenBytes.length - 1; i2 >= 0; --i2) {
          bytes.putByte(lenBytes.charCodeAt(i2));
        }
      }
      bytes.putBuffer(value);
      return bytes;
    };
    asn1.oidToDer = function(oid) {
      var values = oid.split(".");
      var bytes = forge.util.createBuffer();
      bytes.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
      var last, valueBytes, value, b2;
      for (var i2 = 2; i2 < values.length; ++i2) {
        last = true;
        valueBytes = [];
        value = parseInt(values[i2], 10);
        do {
          b2 = value & 127;
          value = value >>> 7;
          if (!last) {
            b2 |= 128;
          }
          valueBytes.push(b2);
          last = false;
        } while (value > 0);
        for (var n2 = valueBytes.length - 1; n2 >= 0; --n2) {
          bytes.putByte(valueBytes[n2]);
        }
      }
      return bytes;
    };
    asn1.derToOid = function(bytes) {
      var oid;
      if (typeof bytes === "string") {
        bytes = forge.util.createBuffer(bytes);
      }
      var b2 = bytes.getByte();
      oid = Math.floor(b2 / 40) + "." + b2 % 40;
      var value = 0;
      while (bytes.length() > 0) {
        b2 = bytes.getByte();
        value = value << 7;
        if (b2 & 128) {
          value += b2 & 127;
        } else {
          oid += "." + (value + b2);
          value = 0;
        }
      }
      return oid;
    };
    asn1.utcTimeToDate = function(utc) {
      var date = /* @__PURE__ */ new Date();
      var year = parseInt(utc.substr(0, 2), 10);
      year = year >= 50 ? 1900 + year : 2e3 + year;
      var MM = parseInt(utc.substr(2, 2), 10) - 1;
      var DD = parseInt(utc.substr(4, 2), 10);
      var hh = parseInt(utc.substr(6, 2), 10);
      var mm = parseInt(utc.substr(8, 2), 10);
      var ss2 = 0;
      if (utc.length > 11) {
        var c = utc.charAt(10);
        var end = 10;
        if (c !== "+" && c !== "-") {
          ss2 = parseInt(utc.substr(10, 2), 10);
          end += 2;
        }
      }
      date.setUTCFullYear(year, MM, DD);
      date.setUTCHours(hh, mm, ss2, 0);
      if (end) {
        c = utc.charAt(end);
        if (c === "+" || c === "-") {
          var hhoffset = parseInt(utc.substr(end + 1, 2), 10);
          var mmoffset = parseInt(utc.substr(end + 4, 2), 10);
          var offset2 = hhoffset * 60 + mmoffset;
          offset2 *= 6e4;
          if (c === "+") {
            date.setTime(+date - offset2);
          } else {
            date.setTime(+date + offset2);
          }
        }
      }
      return date;
    };
    asn1.generalizedTimeToDate = function(gentime) {
      var date = /* @__PURE__ */ new Date();
      var YYYY = parseInt(gentime.substr(0, 4), 10);
      var MM = parseInt(gentime.substr(4, 2), 10) - 1;
      var DD = parseInt(gentime.substr(6, 2), 10);
      var hh = parseInt(gentime.substr(8, 2), 10);
      var mm = parseInt(gentime.substr(10, 2), 10);
      var ss2 = parseInt(gentime.substr(12, 2), 10);
      var fff = 0;
      var offset2 = 0;
      var isUTC = false;
      if (gentime.charAt(gentime.length - 1) === "Z") {
        isUTC = true;
      }
      var end = gentime.length - 5, c = gentime.charAt(end);
      if (c === "+" || c === "-") {
        var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);
        var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);
        offset2 = hhoffset * 60 + mmoffset;
        offset2 *= 6e4;
        if (c === "+") {
          offset2 *= -1;
        }
        isUTC = true;
      }
      if (gentime.charAt(14) === ".") {
        fff = parseFloat(gentime.substr(14), 10) * 1e3;
      }
      if (isUTC) {
        date.setUTCFullYear(YYYY, MM, DD);
        date.setUTCHours(hh, mm, ss2, fff);
        date.setTime(+date + offset2);
      } else {
        date.setFullYear(YYYY, MM, DD);
        date.setHours(hh, mm, ss2, fff);
      }
      return date;
    };
    asn1.dateToUtcTime = function(date) {
      if (typeof date === "string") {
        return date;
      }
      var rval = "";
      var format = [];
      format.push(("" + date.getUTCFullYear()).substr(2));
      format.push("" + (date.getUTCMonth() + 1));
      format.push("" + date.getUTCDate());
      format.push("" + date.getUTCHours());
      format.push("" + date.getUTCMinutes());
      format.push("" + date.getUTCSeconds());
      for (var i2 = 0; i2 < format.length; ++i2) {
        if (format[i2].length < 2) {
          rval += "0";
        }
        rval += format[i2];
      }
      rval += "Z";
      return rval;
    };
    asn1.dateToGeneralizedTime = function(date) {
      if (typeof date === "string") {
        return date;
      }
      var rval = "";
      var format = [];
      format.push("" + date.getUTCFullYear());
      format.push("" + (date.getUTCMonth() + 1));
      format.push("" + date.getUTCDate());
      format.push("" + date.getUTCHours());
      format.push("" + date.getUTCMinutes());
      format.push("" + date.getUTCSeconds());
      for (var i2 = 0; i2 < format.length; ++i2) {
        if (format[i2].length < 2) {
          rval += "0";
        }
        rval += format[i2];
      }
      rval += "Z";
      return rval;
    };
    asn1.integerToDer = function(x3) {
      var rval = forge.util.createBuffer();
      if (x3 >= -128 && x3 < 128) {
        return rval.putSignedInt(x3, 8);
      }
      if (x3 >= -32768 && x3 < 32768) {
        return rval.putSignedInt(x3, 16);
      }
      if (x3 >= -8388608 && x3 < 8388608) {
        return rval.putSignedInt(x3, 24);
      }
      if (x3 >= -2147483648 && x3 < 2147483648) {
        return rval.putSignedInt(x3, 32);
      }
      var error = new Error("Integer too large; max is 32-bits.");
      error.integer = x3;
      throw error;
    };
    asn1.derToInteger = function(bytes) {
      if (typeof bytes === "string") {
        bytes = forge.util.createBuffer(bytes);
      }
      var n2 = bytes.length() * 8;
      if (n2 > 32) {
        throw new Error("Integer too large; max is 32-bits.");
      }
      return bytes.getSignedInt(n2);
    };
    asn1.validate = function(obj, v2, capture, errors) {
      var rval = false;
      if ((obj.tagClass === v2.tagClass || typeof v2.tagClass === "undefined") && (obj.type === v2.type || typeof v2.type === "undefined")) {
        if (obj.constructed === v2.constructed || typeof v2.constructed === "undefined") {
          rval = true;
          if (v2.value && forge.util.isArray(v2.value)) {
            var j2 = 0;
            for (var i2 = 0; rval && i2 < v2.value.length; ++i2) {
              rval = v2.value[i2].optional || false;
              if (obj.value[j2]) {
                rval = asn1.validate(obj.value[j2], v2.value[i2], capture, errors);
                if (rval) {
                  ++j2;
                } else if (v2.value[i2].optional) {
                  rval = true;
                }
              }
              if (!rval && errors) {
                errors.push(
                  "[" + v2.name + '] Tag class "' + v2.tagClass + '", type "' + v2.type + '" expected value length "' + v2.value.length + '", got "' + obj.value.length + '"'
                );
              }
            }
          }
          if (rval && capture) {
            if (v2.capture) {
              capture[v2.capture] = obj.value;
            }
            if (v2.captureAsn1) {
              capture[v2.captureAsn1] = obj;
            }
            if (v2.captureBitStringContents && "bitStringContents" in obj) {
              capture[v2.captureBitStringContents] = obj.bitStringContents;
            }
            if (v2.captureBitStringValue && "bitStringContents" in obj) {
              var value;
              if (obj.bitStringContents.length < 2) {
                capture[v2.captureBitStringValue] = "";
              } else {
                var unused = obj.bitStringContents.charCodeAt(0);
                if (unused !== 0) {
                  throw new Error(
                    "captureBitStringValue only supported for zero unused bits"
                  );
                }
                capture[v2.captureBitStringValue] = obj.bitStringContents.slice(1);
              }
            }
          }
        } else if (errors) {
          errors.push(
            "[" + v2.name + '] Expected constructed "' + v2.constructed + '", got "' + obj.constructed + '"'
          );
        }
      } else if (errors) {
        if (obj.tagClass !== v2.tagClass) {
          errors.push(
            "[" + v2.name + '] Expected tag class "' + v2.tagClass + '", got "' + obj.tagClass + '"'
          );
        }
        if (obj.type !== v2.type) {
          errors.push(
            "[" + v2.name + '] Expected type "' + v2.type + '", got "' + obj.type + '"'
          );
        }
      }
      return rval;
    };
    var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
    asn1.prettyPrint = function(obj, level, indentation) {
      var rval = "";
      level = level || 0;
      indentation = indentation || 2;
      if (level > 0) {
        rval += "\n";
      }
      var indent = "";
      for (var i2 = 0; i2 < level * indentation; ++i2) {
        indent += " ";
      }
      rval += indent + "Tag: ";
      switch (obj.tagClass) {
        case asn1.Class.UNIVERSAL:
          rval += "Universal:";
          break;
        case asn1.Class.APPLICATION:
          rval += "Application:";
          break;
        case asn1.Class.CONTEXT_SPECIFIC:
          rval += "Context-Specific:";
          break;
        case asn1.Class.PRIVATE:
          rval += "Private:";
          break;
      }
      if (obj.tagClass === asn1.Class.UNIVERSAL) {
        rval += obj.type;
        switch (obj.type) {
          case asn1.Type.NONE:
            rval += " (None)";
            break;
          case asn1.Type.BOOLEAN:
            rval += " (Boolean)";
            break;
          case asn1.Type.INTEGER:
            rval += " (Integer)";
            break;
          case asn1.Type.BITSTRING:
            rval += " (Bit string)";
            break;
          case asn1.Type.OCTETSTRING:
            rval += " (Octet string)";
            break;
          case asn1.Type.NULL:
            rval += " (Null)";
            break;
          case asn1.Type.OID:
            rval += " (Object Identifier)";
            break;
          case asn1.Type.ODESC:
            rval += " (Object Descriptor)";
            break;
          case asn1.Type.EXTERNAL:
            rval += " (External or Instance of)";
            break;
          case asn1.Type.REAL:
            rval += " (Real)";
            break;
          case asn1.Type.ENUMERATED:
            rval += " (Enumerated)";
            break;
          case asn1.Type.EMBEDDED:
            rval += " (Embedded PDV)";
            break;
          case asn1.Type.UTF8:
            rval += " (UTF8)";
            break;
          case asn1.Type.ROID:
            rval += " (Relative Object Identifier)";
            break;
          case asn1.Type.SEQUENCE:
            rval += " (Sequence)";
            break;
          case asn1.Type.SET:
            rval += " (Set)";
            break;
          case asn1.Type.PRINTABLESTRING:
            rval += " (Printable String)";
            break;
          case asn1.Type.IA5String:
            rval += " (IA5String (ASCII))";
            break;
          case asn1.Type.UTCTIME:
            rval += " (UTC time)";
            break;
          case asn1.Type.GENERALIZEDTIME:
            rval += " (Generalized time)";
            break;
          case asn1.Type.BMPSTRING:
            rval += " (BMP String)";
            break;
        }
      } else {
        rval += obj.type;
      }
      rval += "\n";
      rval += indent + "Constructed: " + obj.constructed + "\n";
      if (obj.composed) {
        var subvalues = 0;
        var sub = "";
        for (var i2 = 0; i2 < obj.value.length; ++i2) {
          if (obj.value[i2] !== void 0) {
            subvalues += 1;
            sub += asn1.prettyPrint(obj.value[i2], level + 1, indentation);
            if (i2 + 1 < obj.value.length) {
              sub += ",";
            }
          }
        }
        rval += indent + "Sub values: " + subvalues + sub;
      } else {
        rval += indent + "Value: ";
        if (obj.type === asn1.Type.OID) {
          var oid = asn1.derToOid(obj.value);
          rval += oid;
          if (forge.pki && forge.pki.oids) {
            if (oid in forge.pki.oids) {
              rval += " (" + forge.pki.oids[oid] + ") ";
            }
          }
        }
        if (obj.type === asn1.Type.INTEGER) {
          try {
            rval += asn1.derToInteger(obj.value);
          } catch (ex) {
            rval += "0x" + forge.util.bytesToHex(obj.value);
          }
        } else if (obj.type === asn1.Type.BITSTRING) {
          if (obj.value.length > 1) {
            rval += "0x" + forge.util.bytesToHex(obj.value.slice(1));
          } else {
            rval += "(none)";
          }
          if (obj.value.length > 0) {
            var unused = obj.value.charCodeAt(0);
            if (unused == 1) {
              rval += " (1 unused bit shown)";
            } else if (unused > 1) {
              rval += " (" + unused + " unused bits shown)";
            }
          }
        } else if (obj.type === asn1.Type.OCTETSTRING) {
          if (!_nonLatinRegex.test(obj.value)) {
            rval += "(" + obj.value + ") ";
          }
          rval += "0x" + forge.util.bytesToHex(obj.value);
        } else if (obj.type === asn1.Type.UTF8) {
          try {
            rval += forge.util.decodeUtf8(obj.value);
          } catch (e) {
            if (e.message === "URI malformed") {
              rval += "0x" + forge.util.bytesToHex(obj.value) + " (malformed UTF8)";
            } else {
              throw e;
            }
          }
        } else if (obj.type === asn1.Type.PRINTABLESTRING || obj.type === asn1.Type.IA5String) {
          rval += obj.value;
        } else if (_nonLatinRegex.test(obj.value)) {
          rval += "0x" + forge.util.bytesToHex(obj.value);
        } else if (obj.value.length === 0) {
          rval += "[null]";
        } else {
          rval += obj.value;
        }
      }
      return rval;
    };
  }
});

// node_modules/node-forge/lib/md.js
var require_md = __commonJS({
  "node_modules/node-forge/lib/md.js"(exports, module) {
    var forge = require_forge();
    module.exports = forge.md = forge.md || {};
    forge.md.algorithms = forge.md.algorithms || {};
  }
});

// node_modules/node-forge/lib/hmac.js
var require_hmac = __commonJS({
  "node_modules/node-forge/lib/hmac.js"(exports, module) {
    var forge = require_forge();
    require_md();
    require_util2();
    var hmac = module.exports = forge.hmac = forge.hmac || {};
    hmac.create = function() {
      var _key = null;
      var _md = null;
      var _ipadding = null;
      var _opadding = null;
      var ctx = {};
      ctx.start = function(md2, key) {
        if (md2 !== null) {
          if (typeof md2 === "string") {
            md2 = md2.toLowerCase();
            if (md2 in forge.md.algorithms) {
              _md = forge.md.algorithms[md2].create();
            } else {
              throw new Error('Unknown hash algorithm "' + md2 + '"');
            }
          } else {
            _md = md2;
          }
        }
        if (key === null) {
          key = _key;
        } else {
          if (typeof key === "string") {
            key = forge.util.createBuffer(key);
          } else if (forge.util.isArray(key)) {
            var tmp = key;
            key = forge.util.createBuffer();
            for (var i2 = 0; i2 < tmp.length; ++i2) {
              key.putByte(tmp[i2]);
            }
          }
          var keylen = key.length();
          if (keylen > _md.blockLength) {
            _md.start();
            _md.update(key.bytes());
            key = _md.digest();
          }
          _ipadding = forge.util.createBuffer();
          _opadding = forge.util.createBuffer();
          keylen = key.length();
          for (var i2 = 0; i2 < keylen; ++i2) {
            var tmp = key.at(i2);
            _ipadding.putByte(54 ^ tmp);
            _opadding.putByte(92 ^ tmp);
          }
          if (keylen < _md.blockLength) {
            var tmp = _md.blockLength - keylen;
            for (var i2 = 0; i2 < tmp; ++i2) {
              _ipadding.putByte(54);
              _opadding.putByte(92);
            }
          }
          _key = key;
          _ipadding = _ipadding.bytes();
          _opadding = _opadding.bytes();
        }
        _md.start();
        _md.update(_ipadding);
      };
      ctx.update = function(bytes) {
        _md.update(bytes);
      };
      ctx.getMac = function() {
        var inner2 = _md.digest().bytes();
        _md.start();
        _md.update(_opadding);
        _md.update(inner2);
        return _md.digest();
      };
      ctx.digest = ctx.getMac;
      return ctx;
    };
  }
});

// node_modules/node-forge/lib/md5.js
var require_md5 = __commonJS({
  "node_modules/node-forge/lib/md5.js"(exports, module) {
    var forge = require_forge();
    require_md();
    require_util2();
    var md5 = module.exports = forge.md5 = forge.md5 || {};
    forge.md.md5 = forge.md.algorithms.md5 = md5;
    md5.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge.util.createBuffer();
      var _w = new Array(16);
      var md2 = {
        algorithm: "md5",
        blockLength: 64,
        digestLength: 16,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 8
      };
      md2.start = function() {
        md2.messageLength = 0;
        md2.fullMessageLength = md2.messageLength64 = [];
        var int32s = md2.messageLengthSize / 4;
        for (var i2 = 0; i2 < int32s; ++i2) {
          md2.fullMessageLength.push(0);
        }
        _input = forge.util.createBuffer();
        _state = {
          h0: 1732584193,
          h1: 4023233417,
          h2: 2562383102,
          h3: 271733878
        };
        return md2;
      };
      md2.start();
      md2.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md2.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i2 = md2.fullMessageLength.length - 1; i2 >= 0; --i2) {
          md2.fullMessageLength[i2] += len[1];
          len[1] = len[0] + (md2.fullMessageLength[i2] / 4294967296 >>> 0);
          md2.fullMessageLength[i2] = md2.fullMessageLength[i2] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md2;
      };
      md2.digest = function() {
        var finalBlock = forge.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md2.fullMessageLength[md2.fullMessageLength.length - 1] + md2.messageLengthSize;
        var overflow = remaining & md2.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md2.blockLength - overflow));
        var bits, carry = 0;
        for (var i2 = md2.fullMessageLength.length - 1; i2 >= 0; --i2) {
          bits = md2.fullMessageLength[i2] * 8 + carry;
          carry = bits / 4294967296 >>> 0;
          finalBlock.putInt32Le(bits >>> 0);
        }
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3
        };
        _update(s2, _w, finalBlock);
        var rval = forge.util.createBuffer();
        rval.putInt32Le(s2.h0);
        rval.putInt32Le(s2.h1);
        rval.putInt32Le(s2.h2);
        rval.putInt32Le(s2.h3);
        return rval;
      };
      return md2;
    };
    var _padding = null;
    var _g = null;
    var _r2 = null;
    var _k = null;
    var _initialized = false;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge.util.fillString(String.fromCharCode(0), 64);
      _g = [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        1,
        6,
        11,
        0,
        5,
        10,
        15,
        4,
        9,
        14,
        3,
        8,
        13,
        2,
        7,
        12,
        5,
        8,
        11,
        14,
        1,
        4,
        7,
        10,
        13,
        0,
        3,
        6,
        9,
        12,
        15,
        2,
        0,
        7,
        14,
        5,
        12,
        3,
        10,
        1,
        8,
        15,
        6,
        13,
        4,
        11,
        2,
        9
      ];
      _r2 = [
        7,
        12,
        17,
        22,
        7,
        12,
        17,
        22,
        7,
        12,
        17,
        22,
        7,
        12,
        17,
        22,
        5,
        9,
        14,
        20,
        5,
        9,
        14,
        20,
        5,
        9,
        14,
        20,
        5,
        9,
        14,
        20,
        4,
        11,
        16,
        23,
        4,
        11,
        16,
        23,
        4,
        11,
        16,
        23,
        4,
        11,
        16,
        23,
        6,
        10,
        15,
        21,
        6,
        10,
        15,
        21,
        6,
        10,
        15,
        21,
        6,
        10,
        15,
        21
      ];
      _k = new Array(64);
      for (var i2 = 0; i2 < 64; ++i2) {
        _k[i2] = Math.floor(Math.abs(Math.sin(i2 + 1)) * 4294967296);
      }
      _initialized = true;
    }
    function _update(s, w2, bytes) {
      var t, a, b2, c, d, f, r2, i2;
      var len = bytes.length();
      while (len >= 64) {
        a = s.h0;
        b2 = s.h1;
        c = s.h2;
        d = s.h3;
        for (i2 = 0; i2 < 16; ++i2) {
          w2[i2] = bytes.getInt32Le();
          f = d ^ b2 & (c ^ d);
          t = a + f + _k[i2] + w2[i2];
          r2 = _r2[i2];
          a = d;
          d = c;
          c = b2;
          b2 += t << r2 | t >>> 32 - r2;
        }
        for (; i2 < 32; ++i2) {
          f = c ^ d & (b2 ^ c);
          t = a + f + _k[i2] + w2[_g[i2]];
          r2 = _r2[i2];
          a = d;
          d = c;
          c = b2;
          b2 += t << r2 | t >>> 32 - r2;
        }
        for (; i2 < 48; ++i2) {
          f = b2 ^ c ^ d;
          t = a + f + _k[i2] + w2[_g[i2]];
          r2 = _r2[i2];
          a = d;
          d = c;
          c = b2;
          b2 += t << r2 | t >>> 32 - r2;
        }
        for (; i2 < 64; ++i2) {
          f = c ^ (b2 | ~d);
          t = a + f + _k[i2] + w2[_g[i2]];
          r2 = _r2[i2];
          a = d;
          d = c;
          c = b2;
          b2 += t << r2 | t >>> 32 - r2;
        }
        s.h0 = s.h0 + a | 0;
        s.h1 = s.h1 + b2 | 0;
        s.h2 = s.h2 + c | 0;
        s.h3 = s.h3 + d | 0;
        len -= 64;
      }
    }
  }
});

// node_modules/node-forge/lib/pem.js
var require_pem = __commonJS({
  "node_modules/node-forge/lib/pem.js"(exports, module) {
    var forge = require_forge();
    require_util2();
    var pem = module.exports = forge.pem = forge.pem || {};
    pem.encode = function(msg, options) {
      options = options || {};
      var rval = "-----BEGIN " + msg.type + "-----\r\n";
      var header;
      if (msg.procType) {
        header = {
          name: "Proc-Type",
          values: [String(msg.procType.version), msg.procType.type]
        };
        rval += foldHeader(header);
      }
      if (msg.contentDomain) {
        header = { name: "Content-Domain", values: [msg.contentDomain] };
        rval += foldHeader(header);
      }
      if (msg.dekInfo) {
        header = { name: "DEK-Info", values: [msg.dekInfo.algorithm] };
        if (msg.dekInfo.parameters) {
          header.values.push(msg.dekInfo.parameters);
        }
        rval += foldHeader(header);
      }
      if (msg.headers) {
        for (var i2 = 0; i2 < msg.headers.length; ++i2) {
          rval += foldHeader(msg.headers[i2]);
        }
      }
      if (msg.procType) {
        rval += "\r\n";
      }
      rval += forge.util.encode64(msg.body, options.maxline || 64) + "\r\n";
      rval += "-----END " + msg.type + "-----\r\n";
      return rval;
    };
    pem.decode = function(str) {
      var rval = [];
      var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
      var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
      var rCRLF = /\r?\n/;
      var match;
      while (true) {
        match = rMessage.exec(str);
        if (!match) {
          break;
        }
        var type = match[1];
        if (type === "NEW CERTIFICATE REQUEST") {
          type = "CERTIFICATE REQUEST";
        }
        var msg = {
          type,
          procType: null,
          contentDomain: null,
          dekInfo: null,
          headers: [],
          body: forge.util.decode64(match[3])
        };
        rval.push(msg);
        if (!match[2]) {
          continue;
        }
        var lines = match[2].split(rCRLF);
        var li2 = 0;
        while (match && li2 < lines.length) {
          var line = lines[li2].replace(/\s+$/, "");
          for (var nl = li2 + 1; nl < lines.length; ++nl) {
            var next = lines[nl];
            if (!/\s/.test(next[0])) {
              break;
            }
            line += next;
            li2 = nl;
          }
          match = line.match(rHeader);
          if (match) {
            var header = { name: match[1], values: [] };
            var values = match[2].split(",");
            for (var vi2 = 0; vi2 < values.length; ++vi2) {
              header.values.push(ltrim(values[vi2]));
            }
            if (!msg.procType) {
              if (header.name !== "Proc-Type") {
                throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
              } else if (header.values.length !== 2) {
                throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
              }
              msg.procType = { version: values[0], type: values[1] };
            } else if (!msg.contentDomain && header.name === "Content-Domain") {
              msg.contentDomain = values[0] || "";
            } else if (!msg.dekInfo && header.name === "DEK-Info") {
              if (header.values.length === 0) {
                throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
              }
              msg.dekInfo = { algorithm: values[0], parameters: values[1] || null };
            } else {
              msg.headers.push(header);
            }
          }
          ++li2;
        }
        if (msg.procType === "ENCRYPTED" && !msg.dekInfo) {
          throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
        }
      }
      if (rval.length === 0) {
        throw new Error("Invalid PEM formatted message.");
      }
      return rval;
    };
    function foldHeader(header) {
      var rval = header.name + ": ";
      var values = [];
      var insertSpace = function(match, $1) {
        return " " + $1;
      };
      for (var i2 = 0; i2 < header.values.length; ++i2) {
        values.push(header.values[i2].replace(/^(\S+\r\n)/, insertSpace));
      }
      rval += values.join(",") + "\r\n";
      var length = 0;
      var candidate = -1;
      for (var i2 = 0; i2 < rval.length; ++i2, ++length) {
        if (length > 65 && candidate !== -1) {
          var insert = rval[candidate];
          if (insert === ",") {
            ++candidate;
            rval = rval.substr(0, candidate) + "\r\n " + rval.substr(candidate);
          } else {
            rval = rval.substr(0, candidate) + "\r\n" + insert + rval.substr(candidate + 1);
          }
          length = i2 - candidate - 1;
          candidate = -1;
          ++i2;
        } else if (rval[i2] === " " || rval[i2] === "	" || rval[i2] === ",") {
          candidate = i2;
        }
      }
      return rval;
    }
    function ltrim(str) {
      return str.replace(/^\s+/, "");
    }
  }
});

// node_modules/node-forge/lib/des.js
var require_des = __commonJS({
  "node_modules/node-forge/lib/des.js"(exports, module) {
    var forge = require_forge();
    require_cipher();
    require_cipherModes();
    require_util2();
    module.exports = forge.des = forge.des || {};
    forge.des.startEncrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: false,
        mode: mode || (iv === null ? "ECB" : "CBC")
      });
      cipher.start(iv);
      return cipher;
    };
    forge.des.createEncryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: false,
        mode
      });
    };
    forge.des.startDecrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: true,
        mode: mode || (iv === null ? "ECB" : "CBC")
      });
      cipher.start(iv);
      return cipher;
    };
    forge.des.createDecryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: true,
        mode
      });
    };
    forge.des.Algorithm = function(name4, mode) {
      var self2 = this;
      self2.name = name4;
      self2.mode = new mode({
        blockSize: 8,
        cipher: {
          encrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._keys, inBlock, outBlock, false);
          },
          decrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._keys, inBlock, outBlock, true);
          }
        }
      });
      self2._init = false;
    };
    forge.des.Algorithm.prototype.initialize = function(options) {
      if (this._init) {
        return;
      }
      var key = forge.util.createBuffer(options.key);
      if (this.name.indexOf("3DES") === 0) {
        if (key.length() !== 24) {
          throw new Error("Invalid Triple-DES key size: " + key.length() * 8);
        }
      }
      this._keys = _createKeys(key);
      this._init = true;
    };
    registerAlgorithm("DES-ECB", forge.cipher.modes.ecb);
    registerAlgorithm("DES-CBC", forge.cipher.modes.cbc);
    registerAlgorithm("DES-CFB", forge.cipher.modes.cfb);
    registerAlgorithm("DES-OFB", forge.cipher.modes.ofb);
    registerAlgorithm("DES-CTR", forge.cipher.modes.ctr);
    registerAlgorithm("3DES-ECB", forge.cipher.modes.ecb);
    registerAlgorithm("3DES-CBC", forge.cipher.modes.cbc);
    registerAlgorithm("3DES-CFB", forge.cipher.modes.cfb);
    registerAlgorithm("3DES-OFB", forge.cipher.modes.ofb);
    registerAlgorithm("3DES-CTR", forge.cipher.modes.ctr);
    function registerAlgorithm(name4, mode) {
      var factory2 = function() {
        return new forge.des.Algorithm(name4, mode);
      };
      forge.cipher.registerAlgorithm(name4, factory2);
    }
    var spfunction1 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756];
    var spfunction2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344];
    var spfunction3 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584];
    var spfunction4 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928];
    var spfunction5 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080];
    var spfunction6 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312];
    var spfunction7 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154];
    var spfunction8 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
    function _createKeys(key) {
      var pc2bytes0 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], pc2bytes1 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], pc2bytes2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], pc2bytes3 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], pc2bytes4 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], pc2bytes5 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], pc2bytes6 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], pc2bytes7 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], pc2bytes8 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], pc2bytes9 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], pc2bytes10 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], pc2bytes11 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], pc2bytes12 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], pc2bytes13 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261];
      var iterations = key.length() > 8 ? 3 : 1;
      var keys = [];
      var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
      var n2 = 0, tmp;
      for (var j2 = 0; j2 < iterations; j2++) {
        var left = key.getInt32();
        var right = key.getInt32();
        tmp = (left >>> 4 ^ right) & 252645135;
        right ^= tmp;
        left ^= tmp << 4;
        tmp = (right >>> -16 ^ left) & 65535;
        left ^= tmp;
        right ^= tmp << -16;
        tmp = (left >>> 2 ^ right) & 858993459;
        right ^= tmp;
        left ^= tmp << 2;
        tmp = (right >>> -16 ^ left) & 65535;
        left ^= tmp;
        right ^= tmp << -16;
        tmp = (left >>> 1 ^ right) & 1431655765;
        right ^= tmp;
        left ^= tmp << 1;
        tmp = (right >>> 8 ^ left) & 16711935;
        left ^= tmp;
        right ^= tmp << 8;
        tmp = (left >>> 1 ^ right) & 1431655765;
        right ^= tmp;
        left ^= tmp << 1;
        tmp = left << 8 | right >>> 20 & 240;
        left = right << 24 | right << 8 & 16711680 | right >>> 8 & 65280 | right >>> 24 & 240;
        right = tmp;
        for (var i2 = 0; i2 < shifts.length; ++i2) {
          if (shifts[i2]) {
            left = left << 2 | left >>> 26;
            right = right << 2 | right >>> 26;
          } else {
            left = left << 1 | left >>> 27;
            right = right << 1 | right >>> 27;
          }
          left &= -15;
          right &= -15;
          var lefttmp = pc2bytes0[left >>> 28] | pc2bytes1[left >>> 24 & 15] | pc2bytes2[left >>> 20 & 15] | pc2bytes3[left >>> 16 & 15] | pc2bytes4[left >>> 12 & 15] | pc2bytes5[left >>> 8 & 15] | pc2bytes6[left >>> 4 & 15];
          var righttmp = pc2bytes7[right >>> 28] | pc2bytes8[right >>> 24 & 15] | pc2bytes9[right >>> 20 & 15] | pc2bytes10[right >>> 16 & 15] | pc2bytes11[right >>> 12 & 15] | pc2bytes12[right >>> 8 & 15] | pc2bytes13[right >>> 4 & 15];
          tmp = (righttmp >>> 16 ^ lefttmp) & 65535;
          keys[n2++] = lefttmp ^ tmp;
          keys[n2++] = righttmp ^ tmp << 16;
        }
      }
      return keys;
    }
    function _updateBlock(keys, input, output, decrypt) {
      var iterations = keys.length === 32 ? 3 : 9;
      var looping;
      if (iterations === 3) {
        looping = decrypt ? [30, -2, -2] : [0, 32, 2];
      } else {
        looping = decrypt ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
      }
      var tmp;
      var left = input[0];
      var right = input[1];
      tmp = (left >>> 4 ^ right) & 252645135;
      right ^= tmp;
      left ^= tmp << 4;
      tmp = (left >>> 16 ^ right) & 65535;
      right ^= tmp;
      left ^= tmp << 16;
      tmp = (right >>> 2 ^ left) & 858993459;
      left ^= tmp;
      right ^= tmp << 2;
      tmp = (right >>> 8 ^ left) & 16711935;
      left ^= tmp;
      right ^= tmp << 8;
      tmp = (left >>> 1 ^ right) & 1431655765;
      right ^= tmp;
      left ^= tmp << 1;
      left = left << 1 | left >>> 31;
      right = right << 1 | right >>> 31;
      for (var j2 = 0; j2 < iterations; j2 += 3) {
        var endloop = looping[j2 + 1];
        var loopinc = looping[j2 + 2];
        for (var i2 = looping[j2]; i2 != endloop; i2 += loopinc) {
          var right1 = right ^ keys[i2];
          var right2 = (right >>> 4 | right << 28) ^ keys[i2 + 1];
          tmp = left;
          left = right;
          right = tmp ^ (spfunction2[right1 >>> 24 & 63] | spfunction4[right1 >>> 16 & 63] | spfunction6[right1 >>> 8 & 63] | spfunction8[right1 & 63] | spfunction1[right2 >>> 24 & 63] | spfunction3[right2 >>> 16 & 63] | spfunction5[right2 >>> 8 & 63] | spfunction7[right2 & 63]);
        }
        tmp = left;
        left = right;
        right = tmp;
      }
      left = left >>> 1 | left << 31;
      right = right >>> 1 | right << 31;
      tmp = (left >>> 1 ^ right) & 1431655765;
      right ^= tmp;
      left ^= tmp << 1;
      tmp = (right >>> 8 ^ left) & 16711935;
      left ^= tmp;
      right ^= tmp << 8;
      tmp = (right >>> 2 ^ left) & 858993459;
      left ^= tmp;
      right ^= tmp << 2;
      tmp = (left >>> 16 ^ right) & 65535;
      right ^= tmp;
      left ^= tmp << 16;
      tmp = (left >>> 4 ^ right) & 252645135;
      right ^= tmp;
      left ^= tmp << 4;
      output[0] = left;
      output[1] = right;
    }
    function _createCipher(options) {
      options = options || {};
      var mode = (options.mode || "CBC").toUpperCase();
      var algorithm = "DES-" + mode;
      var cipher;
      if (options.decrypt) {
        cipher = forge.cipher.createDecipher(algorithm, options.key);
      } else {
        cipher = forge.cipher.createCipher(algorithm, options.key);
      }
      var start2 = cipher.start;
      cipher.start = function(iv, options2) {
        var output = null;
        if (options2 instanceof forge.util.ByteBuffer) {
          output = options2;
          options2 = {};
        }
        options2 = options2 || {};
        options2.output = output;
        options2.iv = iv;
        start2.call(cipher, options2);
      };
      return cipher;
    }
  }
});

// node_modules/node-forge/lib/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/node-forge/lib/pbkdf2.js"(exports, module) {
    var forge = require_forge();
    require_hmac();
    require_md();
    require_util2();
    var pkcs5 = forge.pkcs5 = forge.pkcs5 || {};
    var crypto;
    if (forge.util.isNodejs && !forge.options.usePureJavaScript) {
      crypto = require_crypto();
    }
    module.exports = forge.pbkdf2 = pkcs5.pbkdf2 = function(p2, s, c, dkLen, md2, callback) {
      if (typeof md2 === "function") {
        callback = md2;
        md2 = null;
      }
      if (forge.util.isNodejs && !forge.options.usePureJavaScript && crypto.pbkdf2 && (md2 === null || typeof md2 !== "object") && (crypto.pbkdf2Sync.length > 4 || (!md2 || md2 === "sha1"))) {
        if (typeof md2 !== "string") {
          md2 = "sha1";
        }
        p2 = Buffer.from(p2, "binary");
        s = Buffer.from(s, "binary");
        if (!callback) {
          if (crypto.pbkdf2Sync.length === 4) {
            return crypto.pbkdf2Sync(p2, s, c, dkLen).toString("binary");
          }
          return crypto.pbkdf2Sync(p2, s, c, dkLen, md2).toString("binary");
        }
        if (crypto.pbkdf2Sync.length === 4) {
          return crypto.pbkdf2(p2, s, c, dkLen, function(err2, key) {
            if (err2) {
              return callback(err2);
            }
            callback(null, key.toString("binary"));
          });
        }
        return crypto.pbkdf2(p2, s, c, dkLen, md2, function(err2, key) {
          if (err2) {
            return callback(err2);
          }
          callback(null, key.toString("binary"));
        });
      }
      if (typeof md2 === "undefined" || md2 === null) {
        md2 = "sha1";
      }
      if (typeof md2 === "string") {
        if (!(md2 in forge.md.algorithms)) {
          throw new Error("Unknown hash algorithm: " + md2);
        }
        md2 = forge.md[md2].create();
      }
      var hLen = md2.digestLength;
      if (dkLen > 4294967295 * hLen) {
        var err = new Error("Derived key is too long.");
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      var len = Math.ceil(dkLen / hLen);
      var r2 = dkLen - (len - 1) * hLen;
      var prf = forge.hmac.create();
      prf.start(md2, p2);
      var dk = "";
      var xor, u_c, u_c1;
      if (!callback) {
        for (var i2 = 1; i2 <= len; ++i2) {
          prf.start(null, null);
          prf.update(s);
          prf.update(forge.util.int32ToBytes(i2));
          xor = u_c1 = prf.digest().getBytes();
          for (var j2 = 2; j2 <= c; ++j2) {
            prf.start(null, null);
            prf.update(u_c1);
            u_c = prf.digest().getBytes();
            xor = forge.util.xorBytes(xor, u_c, hLen);
            u_c1 = u_c;
          }
          dk += i2 < len ? xor : xor.substr(0, r2);
        }
        return dk;
      }
      var i2 = 1, j2;
      function outer() {
        if (i2 > len) {
          return callback(null, dk);
        }
        prf.start(null, null);
        prf.update(s);
        prf.update(forge.util.int32ToBytes(i2));
        xor = u_c1 = prf.digest().getBytes();
        j2 = 2;
        inner2();
      }
      function inner2() {
        if (j2 <= c) {
          prf.start(null, null);
          prf.update(u_c1);
          u_c = prf.digest().getBytes();
          xor = forge.util.xorBytes(xor, u_c, hLen);
          u_c1 = u_c;
          ++j2;
          return forge.util.setImmediate(inner2);
        }
        dk += i2 < len ? xor : xor.substr(0, r2);
        ++i2;
        outer();
      }
      outer();
    };
  }
});

// node_modules/node-forge/lib/sha256.js
var require_sha256 = __commonJS({
  "node_modules/node-forge/lib/sha256.js"(exports, module) {
    var forge = require_forge();
    require_md();
    require_util2();
    var sha256 = module.exports = forge.sha256 = forge.sha256 || {};
    forge.md.sha256 = forge.md.algorithms.sha256 = sha256;
    sha256.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge.util.createBuffer();
      var _w = new Array(64);
      var md2 = {
        algorithm: "sha256",
        blockLength: 64,
        digestLength: 32,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 8
      };
      md2.start = function() {
        md2.messageLength = 0;
        md2.fullMessageLength = md2.messageLength64 = [];
        var int32s = md2.messageLengthSize / 4;
        for (var i2 = 0; i2 < int32s; ++i2) {
          md2.fullMessageLength.push(0);
        }
        _input = forge.util.createBuffer();
        _state = {
          h0: 1779033703,
          h1: 3144134277,
          h2: 1013904242,
          h3: 2773480762,
          h4: 1359893119,
          h5: 2600822924,
          h6: 528734635,
          h7: 1541459225
        };
        return md2;
      };
      md2.start();
      md2.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md2.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i2 = md2.fullMessageLength.length - 1; i2 >= 0; --i2) {
          md2.fullMessageLength[i2] += len[1];
          len[1] = len[0] + (md2.fullMessageLength[i2] / 4294967296 >>> 0);
          md2.fullMessageLength[i2] = md2.fullMessageLength[i2] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md2;
      };
      md2.digest = function() {
        var finalBlock = forge.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md2.fullMessageLength[md2.fullMessageLength.length - 1] + md2.messageLengthSize;
        var overflow = remaining & md2.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md2.blockLength - overflow));
        var next, carry;
        var bits = md2.fullMessageLength[0] * 8;
        for (var i2 = 0; i2 < md2.fullMessageLength.length - 1; ++i2) {
          next = md2.fullMessageLength[i2 + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4,
          h5: _state.h5,
          h6: _state.h6,
          h7: _state.h7
        };
        _update(s2, _w, finalBlock);
        var rval = forge.util.createBuffer();
        rval.putInt32(s2.h0);
        rval.putInt32(s2.h1);
        rval.putInt32(s2.h2);
        rval.putInt32(s2.h3);
        rval.putInt32(s2.h4);
        rval.putInt32(s2.h5);
        rval.putInt32(s2.h6);
        rval.putInt32(s2.h7);
        return rval;
      };
      return md2;
    };
    var _padding = null;
    var _initialized = false;
    var _k = null;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge.util.fillString(String.fromCharCode(0), 64);
      _k = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      _initialized = true;
    }
    function _update(s, w2, bytes) {
      var t1, t2, s0, s1, ch, maj, i2, a, b2, c, d, e, f, g2, h;
      var len = bytes.length();
      while (len >= 64) {
        for (i2 = 0; i2 < 16; ++i2) {
          w2[i2] = bytes.getInt32();
        }
        for (; i2 < 64; ++i2) {
          t1 = w2[i2 - 2];
          t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
          t2 = w2[i2 - 15];
          t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;
          w2[i2] = t1 + w2[i2 - 7] + t2 + w2[i2 - 16] | 0;
        }
        a = s.h0;
        b2 = s.h1;
        c = s.h2;
        d = s.h3;
        e = s.h4;
        f = s.h5;
        g2 = s.h6;
        h = s.h7;
        for (i2 = 0; i2 < 64; ++i2) {
          s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
          ch = g2 ^ e & (f ^ g2);
          s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
          maj = a & b2 | c & (a ^ b2);
          t1 = h + s1 + ch + _k[i2] + w2[i2];
          t2 = s0 + maj;
          h = g2;
          g2 = f;
          f = e;
          e = d + t1 >>> 0;
          d = c;
          c = b2;
          b2 = a;
          a = t1 + t2 >>> 0;
        }
        s.h0 = s.h0 + a | 0;
        s.h1 = s.h1 + b2 | 0;
        s.h2 = s.h2 + c | 0;
        s.h3 = s.h3 + d | 0;
        s.h4 = s.h4 + e | 0;
        s.h5 = s.h5 + f | 0;
        s.h6 = s.h6 + g2 | 0;
        s.h7 = s.h7 + h | 0;
        len -= 64;
      }
    }
  }
});

// node_modules/node-forge/lib/prng.js
var require_prng = __commonJS({
  "node_modules/node-forge/lib/prng.js"(exports, module) {
    var forge = require_forge();
    require_util2();
    var _crypto = null;
    if (forge.util.isNodejs && !forge.options.usePureJavaScript && !process.versions["node-webkit"]) {
      _crypto = require_crypto();
    }
    var prng = module.exports = forge.prng = forge.prng || {};
    prng.create = function(plugin) {
      var ctx = {
        plugin,
        key: null,
        seed: null,
        time: null,
        // number of reseeds so far
        reseeds: 0,
        // amount of data generated so far
        generated: 0,
        // no initial key bytes
        keyBytes: ""
      };
      var md2 = plugin.md;
      var pools = new Array(32);
      for (var i2 = 0; i2 < 32; ++i2) {
        pools[i2] = md2.create();
      }
      ctx.pools = pools;
      ctx.pool = 0;
      ctx.generate = function(count, callback) {
        if (!callback) {
          return ctx.generateSync(count);
        }
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        var b2 = forge.util.createBuffer();
        ctx.key = null;
        generate2();
        function generate2(err) {
          if (err) {
            return callback(err);
          }
          if (b2.length() >= count) {
            return callback(null, b2.getBytes(count));
          }
          if (ctx.generated > 1048575) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            return forge.util.nextTick(function() {
              _reseed(generate2);
            });
          }
          var bytes = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes.length;
          b2.putBytes(bytes);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
          forge.util.setImmediate(generate2);
        }
      };
      ctx.generateSync = function(count) {
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        ctx.key = null;
        var b2 = forge.util.createBuffer();
        while (b2.length() < count) {
          if (ctx.generated > 1048575) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            _reseedSync();
          }
          var bytes = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes.length;
          b2.putBytes(bytes);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
        }
        return b2.getBytes(count);
      };
      function _reseed(callback) {
        if (ctx.pools[0].messageLength >= 32) {
          _seed();
          return callback();
        }
        var needed = 32 - ctx.pools[0].messageLength << 5;
        ctx.seedFile(needed, function(err, bytes) {
          if (err) {
            return callback(err);
          }
          ctx.collect(bytes);
          _seed();
          callback();
        });
      }
      function _reseedSync() {
        if (ctx.pools[0].messageLength >= 32) {
          return _seed();
        }
        var needed = 32 - ctx.pools[0].messageLength << 5;
        ctx.collect(ctx.seedFileSync(needed));
        _seed();
      }
      function _seed() {
        ctx.reseeds = ctx.reseeds === 4294967295 ? 0 : ctx.reseeds + 1;
        var md3 = ctx.plugin.md.create();
        md3.update(ctx.keyBytes);
        var _2powK = 1;
        for (var k3 = 0; k3 < 32; ++k3) {
          if (ctx.reseeds % _2powK === 0) {
            md3.update(ctx.pools[k3].digest().getBytes());
            ctx.pools[k3].start();
          }
          _2powK = _2powK << 1;
        }
        ctx.keyBytes = md3.digest().getBytes();
        md3.start();
        md3.update(ctx.keyBytes);
        var seedBytes = md3.digest().getBytes();
        ctx.key = ctx.plugin.formatKey(ctx.keyBytes);
        ctx.seed = ctx.plugin.formatSeed(seedBytes);
        ctx.generated = 0;
      }
      function defaultSeedFile(needed) {
        var getRandomValues = null;
        var globalScope = forge.util.globalScope;
        var _crypto2 = globalScope.crypto || globalScope.msCrypto;
        if (_crypto2 && _crypto2.getRandomValues) {
          getRandomValues = function(arr) {
            return _crypto2.getRandomValues(arr);
          };
        }
        var b2 = forge.util.createBuffer();
        if (getRandomValues) {
          while (b2.length() < needed) {
            var count = Math.max(1, Math.min(needed - b2.length(), 65536) / 4);
            var entropy = new Uint32Array(Math.floor(count));
            try {
              getRandomValues(entropy);
              for (var i3 = 0; i3 < entropy.length; ++i3) {
                b2.putInt32(entropy[i3]);
              }
            } catch (e) {
              if (!(typeof QuotaExceededError !== "undefined" && e instanceof QuotaExceededError)) {
                throw e;
              }
            }
          }
        }
        if (b2.length() < needed) {
          var hi2, lo2, next;
          var seed = Math.floor(Math.random() * 65536);
          while (b2.length() < needed) {
            lo2 = 16807 * (seed & 65535);
            hi2 = 16807 * (seed >> 16);
            lo2 += (hi2 & 32767) << 16;
            lo2 += hi2 >> 15;
            lo2 = (lo2 & 2147483647) + (lo2 >> 31);
            seed = lo2 & 4294967295;
            for (var i3 = 0; i3 < 3; ++i3) {
              next = seed >>> (i3 << 3);
              next ^= Math.floor(Math.random() * 256);
              b2.putByte(next & 255);
            }
          }
        }
        return b2.getBytes(needed);
      }
      if (_crypto) {
        ctx.seedFile = function(needed, callback) {
          _crypto.randomBytes(needed, function(err, bytes) {
            if (err) {
              return callback(err);
            }
            callback(null, bytes.toString());
          });
        };
        ctx.seedFileSync = function(needed) {
          return _crypto.randomBytes(needed).toString();
        };
      } else {
        ctx.seedFile = function(needed, callback) {
          try {
            callback(null, defaultSeedFile(needed));
          } catch (e) {
            callback(e);
          }
        };
        ctx.seedFileSync = defaultSeedFile;
      }
      ctx.collect = function(bytes) {
        var count = bytes.length;
        for (var i3 = 0; i3 < count; ++i3) {
          ctx.pools[ctx.pool].update(bytes.substr(i3, 1));
          ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;
        }
      };
      ctx.collectInt = function(i3, n2) {
        var bytes = "";
        for (var x3 = 0; x3 < n2; x3 += 8) {
          bytes += String.fromCharCode(i3 >> x3 & 255);
        }
        ctx.collect(bytes);
      };
      ctx.registerWorker = function(worker) {
        if (worker === self) {
          ctx.seedFile = function(needed, callback) {
            function listener2(e) {
              var data = e.data;
              if (data.forge && data.forge.prng) {
                self.removeEventListener("message", listener2);
                callback(data.forge.prng.err, data.forge.prng.bytes);
              }
            }
            self.addEventListener("message", listener2);
            self.postMessage({ forge: { prng: { needed } } });
          };
        } else {
          var listener = function(e) {
            var data = e.data;
            if (data.forge && data.forge.prng) {
              ctx.seedFile(data.forge.prng.needed, function(err, bytes) {
                worker.postMessage({ forge: { prng: { err, bytes } } });
              });
            }
          };
          worker.addEventListener("message", listener);
        }
      };
      return ctx;
    };
  }
});

// node_modules/node-forge/lib/random.js
var require_random = __commonJS({
  "node_modules/node-forge/lib/random.js"(exports, module) {
    var forge = require_forge();
    require_aes();
    require_sha256();
    require_prng();
    require_util2();
    (function() {
      if (forge.random && forge.random.getBytes) {
        module.exports = forge.random;
        return;
      }
      (function(jQuery2) {
        var prng_aes = {};
        var _prng_aes_output = new Array(4);
        var _prng_aes_buffer = forge.util.createBuffer();
        prng_aes.formatKey = function(key2) {
          var tmp = forge.util.createBuffer(key2);
          key2 = new Array(4);
          key2[0] = tmp.getInt32();
          key2[1] = tmp.getInt32();
          key2[2] = tmp.getInt32();
          key2[3] = tmp.getInt32();
          return forge.aes._expandKey(key2, false);
        };
        prng_aes.formatSeed = function(seed) {
          var tmp = forge.util.createBuffer(seed);
          seed = new Array(4);
          seed[0] = tmp.getInt32();
          seed[1] = tmp.getInt32();
          seed[2] = tmp.getInt32();
          seed[3] = tmp.getInt32();
          return seed;
        };
        prng_aes.cipher = function(key2, seed) {
          forge.aes._updateBlock(key2, seed, _prng_aes_output, false);
          _prng_aes_buffer.putInt32(_prng_aes_output[0]);
          _prng_aes_buffer.putInt32(_prng_aes_output[1]);
          _prng_aes_buffer.putInt32(_prng_aes_output[2]);
          _prng_aes_buffer.putInt32(_prng_aes_output[3]);
          return _prng_aes_buffer.getBytes();
        };
        prng_aes.increment = function(seed) {
          ++seed[3];
          return seed;
        };
        prng_aes.md = forge.md.sha256;
        function spawnPrng() {
          var ctx = forge.prng.create(prng_aes);
          ctx.getBytes = function(count, callback) {
            return ctx.generate(count, callback);
          };
          ctx.getBytesSync = function(count) {
            return ctx.generate(count);
          };
          return ctx;
        }
        var _ctx = spawnPrng();
        var getRandomValues = null;
        var globalScope = forge.util.globalScope;
        var _crypto = globalScope.crypto || globalScope.msCrypto;
        if (_crypto && _crypto.getRandomValues) {
          getRandomValues = function(arr) {
            return _crypto.getRandomValues(arr);
          };
        }
        if (forge.options.usePureJavaScript || !forge.util.isNodejs && !getRandomValues) {
          if (typeof window === "undefined" || window.document === void 0) {
          }
          _ctx.collectInt(+/* @__PURE__ */ new Date(), 32);
          if (typeof navigator !== "undefined") {
            var _navBytes = "";
            for (var key in navigator) {
              try {
                if (typeof navigator[key] == "string") {
                  _navBytes += navigator[key];
                }
              } catch (e) {
              }
            }
            _ctx.collect(_navBytes);
            _navBytes = null;
          }
          if (jQuery2) {
            jQuery2().mousemove(function(e) {
              _ctx.collectInt(e.clientX, 16);
              _ctx.collectInt(e.clientY, 16);
            });
            jQuery2().keypress(function(e) {
              _ctx.collectInt(e.charCode, 8);
            });
          }
        }
        if (!forge.random) {
          forge.random = _ctx;
        } else {
          for (var key in _ctx) {
            forge.random[key] = _ctx[key];
          }
        }
        forge.random.createInstance = spawnPrng;
        module.exports = forge.random;
      })(typeof jQuery !== "undefined" ? jQuery : null);
    })();
  }
});

// node_modules/node-forge/lib/rc2.js
var require_rc2 = __commonJS({
  "node_modules/node-forge/lib/rc2.js"(exports, module) {
    var forge = require_forge();
    require_util2();
    var piTable = [
      217,
      120,
      249,
      196,
      25,
      221,
      181,
      237,
      40,
      233,
      253,
      121,
      74,
      160,
      216,
      157,
      198,
      126,
      55,
      131,
      43,
      118,
      83,
      142,
      98,
      76,
      100,
      136,
      68,
      139,
      251,
      162,
      23,
      154,
      89,
      245,
      135,
      179,
      79,
      19,
      97,
      69,
      109,
      141,
      9,
      129,
      125,
      50,
      189,
      143,
      64,
      235,
      134,
      183,
      123,
      11,
      240,
      149,
      33,
      34,
      92,
      107,
      78,
      130,
      84,
      214,
      101,
      147,
      206,
      96,
      178,
      28,
      115,
      86,
      192,
      20,
      167,
      140,
      241,
      220,
      18,
      117,
      202,
      31,
      59,
      190,
      228,
      209,
      66,
      61,
      212,
      48,
      163,
      60,
      182,
      38,
      111,
      191,
      14,
      218,
      70,
      105,
      7,
      87,
      39,
      242,
      29,
      155,
      188,
      148,
      67,
      3,
      248,
      17,
      199,
      246,
      144,
      239,
      62,
      231,
      6,
      195,
      213,
      47,
      200,
      102,
      30,
      215,
      8,
      232,
      234,
      222,
      128,
      82,
      238,
      247,
      132,
      170,
      114,
      172,
      53,
      77,
      106,
      42,
      150,
      26,
      210,
      113,
      90,
      21,
      73,
      116,
      75,
      159,
      208,
      94,
      4,
      24,
      164,
      236,
      194,
      224,
      65,
      110,
      15,
      81,
      203,
      204,
      36,
      145,
      175,
      80,
      161,
      244,
      112,
      57,
      153,
      124,
      58,
      133,
      35,
      184,
      180,
      122,
      252,
      2,
      54,
      91,
      37,
      85,
      151,
      49,
      45,
      93,
      250,
      152,
      227,
      138,
      146,
      174,
      5,
      223,
      41,
      16,
      103,
      108,
      186,
      201,
      211,
      0,
      230,
      207,
      225,
      158,
      168,
      44,
      99,
      22,
      1,
      63,
      88,
      226,
      137,
      169,
      13,
      56,
      52,
      27,
      171,
      51,
      255,
      176,
      187,
      72,
      12,
      95,
      185,
      177,
      205,
      46,
      197,
      243,
      219,
      71,
      229,
      165,
      156,
      119,
      10,
      166,
      32,
      104,
      254,
      127,
      193,
      173
    ];
    var s = [1, 2, 3, 5];
    var rol = function(word, bits) {
      return word << bits & 65535 | (word & 65535) >> 16 - bits;
    };
    var ror = function(word, bits) {
      return (word & 65535) >> bits | word << 16 - bits & 65535;
    };
    module.exports = forge.rc2 = forge.rc2 || {};
    forge.rc2.expandKey = function(key, effKeyBits) {
      if (typeof key === "string") {
        key = forge.util.createBuffer(key);
      }
      effKeyBits = effKeyBits || 128;
      var L3 = key;
      var T3 = key.length();
      var T1 = effKeyBits;
      var T8 = Math.ceil(T1 / 8);
      var TM = 255 >> (T1 & 7);
      var i2;
      for (i2 = T3; i2 < 128; i2++) {
        L3.putByte(piTable[L3.at(i2 - 1) + L3.at(i2 - T3) & 255]);
      }
      L3.setAt(128 - T8, piTable[L3.at(128 - T8) & TM]);
      for (i2 = 127 - T8; i2 >= 0; i2--) {
        L3.setAt(i2, piTable[L3.at(i2 + 1) ^ L3.at(i2 + T8)]);
      }
      return L3;
    };
    var createCipher = function(key, bits, encrypt) {
      var _finish = false, _input = null, _output = null, _iv = null;
      var mixRound, mashRound;
      var i2, j2, K3 = [];
      key = forge.rc2.expandKey(key, bits);
      for (i2 = 0; i2 < 64; i2++) {
        K3.push(key.getInt16Le());
      }
      if (encrypt) {
        mixRound = function(R3) {
          for (i2 = 0; i2 < 4; i2++) {
            R3[i2] += K3[j2] + (R3[(i2 + 3) % 4] & R3[(i2 + 2) % 4]) + (~R3[(i2 + 3) % 4] & R3[(i2 + 1) % 4]);
            R3[i2] = rol(R3[i2], s[i2]);
            j2++;
          }
        };
        mashRound = function(R3) {
          for (i2 = 0; i2 < 4; i2++) {
            R3[i2] += K3[R3[(i2 + 3) % 4] & 63];
          }
        };
      } else {
        mixRound = function(R3) {
          for (i2 = 3; i2 >= 0; i2--) {
            R3[i2] = ror(R3[i2], s[i2]);
            R3[i2] -= K3[j2] + (R3[(i2 + 3) % 4] & R3[(i2 + 2) % 4]) + (~R3[(i2 + 3) % 4] & R3[(i2 + 1) % 4]);
            j2--;
          }
        };
        mashRound = function(R3) {
          for (i2 = 3; i2 >= 0; i2--) {
            R3[i2] -= K3[R3[(i2 + 3) % 4] & 63];
          }
        };
      }
      var runPlan = function(plan) {
        var R3 = [];
        for (i2 = 0; i2 < 4; i2++) {
          var val = _input.getInt16Le();
          if (_iv !== null) {
            if (encrypt) {
              val ^= _iv.getInt16Le();
            } else {
              _iv.putInt16Le(val);
            }
          }
          R3.push(val & 65535);
        }
        j2 = encrypt ? 0 : 63;
        for (var ptr = 0; ptr < plan.length; ptr++) {
          for (var ctr = 0; ctr < plan[ptr][0]; ctr++) {
            plan[ptr][1](R3);
          }
        }
        for (i2 = 0; i2 < 4; i2++) {
          if (_iv !== null) {
            if (encrypt) {
              _iv.putInt16Le(R3[i2]);
            } else {
              R3[i2] ^= _iv.getInt16Le();
            }
          }
          _output.putInt16Le(R3[i2]);
        }
      };
      var cipher = null;
      cipher = {
        /**
         * Starts or restarts the encryption or decryption process, whichever
         * was previously configured.
         *
         * To use the cipher in CBC mode, iv may be given either as a string
         * of bytes, or as a byte buffer.  For ECB mode, give null as iv.
         *
         * @param iv the initialization vector to use, null for ECB mode.
         * @param output the output the buffer to write to, null to create one.
         */
        start: function(iv, output) {
          if (iv) {
            if (typeof iv === "string") {
              iv = forge.util.createBuffer(iv);
            }
          }
          _finish = false;
          _input = forge.util.createBuffer();
          _output = output || new forge.util.createBuffer();
          _iv = iv;
          cipher.output = _output;
        },
        /**
         * Updates the next block.
         *
         * @param input the buffer to read from.
         */
        update: function(input) {
          if (!_finish) {
            _input.putBuffer(input);
          }
          while (_input.length() >= 8) {
            runPlan([
              [5, mixRound],
              [1, mashRound],
              [6, mixRound],
              [1, mashRound],
              [5, mixRound]
            ]);
          }
        },
        /**
         * Finishes encrypting or decrypting.
         *
         * @param pad a padding function to use, null for PKCS#7 padding,
         *           signature(blockSize, buffer, decrypt).
         *
         * @return true if successful, false on error.
         */
        finish: function(pad) {
          var rval = true;
          if (encrypt) {
            if (pad) {
              rval = pad(8, _input, !encrypt);
            } else {
              var padding = _input.length() === 8 ? 8 : 8 - _input.length();
              _input.fillWithByte(padding, padding);
            }
          }
          if (rval) {
            _finish = true;
            cipher.update();
          }
          if (!encrypt) {
            rval = _input.length() === 0;
            if (rval) {
              if (pad) {
                rval = pad(8, _output, !encrypt);
              } else {
                var len = _output.length();
                var count = _output.at(len - 1);
                if (count > len) {
                  rval = false;
                } else {
                  _output.truncate(count);
                }
              }
            }
          }
          return rval;
        }
      };
      return cipher;
    };
    forge.rc2.startEncrypting = function(key, iv, output) {
      var cipher = forge.rc2.createEncryptionCipher(key, 128);
      cipher.start(iv, output);
      return cipher;
    };
    forge.rc2.createEncryptionCipher = function(key, bits) {
      return createCipher(key, bits, true);
    };
    forge.rc2.startDecrypting = function(key, iv, output) {
      var cipher = forge.rc2.createDecryptionCipher(key, 128);
      cipher.start(iv, output);
      return cipher;
    };
    forge.rc2.createDecryptionCipher = function(key, bits) {
      return createCipher(key, bits, false);
    };
  }
});

// node_modules/node-forge/lib/jsbn.js
var require_jsbn = __commonJS({
  "node_modules/node-forge/lib/jsbn.js"(exports, module) {
    var forge = require_forge();
    module.exports = forge.jsbn = forge.jsbn || {};
    var dbits;
    var canary = 244837814094590;
    var j_lm = (canary & 16777215) == 15715070;
    function BigInteger(a, b2, c) {
      this.data = [];
      if (a != null)
        if ("number" == typeof a)
          this.fromNumber(a, b2, c);
        else if (b2 == null && "string" != typeof a)
          this.fromString(a, 256);
        else
          this.fromString(a, b2);
    }
    forge.jsbn.BigInteger = BigInteger;
    function nbi() {
      return new BigInteger(null);
    }
    function am1(i2, x3, w2, j2, c, n2) {
      while (--n2 >= 0) {
        var v2 = x3 * this.data[i2++] + w2.data[j2] + c;
        c = Math.floor(v2 / 67108864);
        w2.data[j2++] = v2 & 67108863;
      }
      return c;
    }
    function am2(i2, x3, w2, j2, c, n2) {
      var xl = x3 & 32767, xh = x3 >> 15;
      while (--n2 >= 0) {
        var l = this.data[i2] & 32767;
        var h = this.data[i2++] >> 15;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 32767) << 15) + w2.data[j2] + (c & 1073741823);
        c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
        w2.data[j2++] = l & 1073741823;
      }
      return c;
    }
    function am3(i2, x3, w2, j2, c, n2) {
      var xl = x3 & 16383, xh = x3 >> 14;
      while (--n2 >= 0) {
        var l = this.data[i2] & 16383;
        var h = this.data[i2++] >> 14;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 16383) << 14) + w2.data[j2] + c;
        c = (l >> 28) + (m >> 14) + xh * h;
        w2.data[j2++] = l & 268435455;
      }
      return c;
    }
    if (typeof navigator === "undefined") {
      BigInteger.prototype.am = am3;
      dbits = 28;
    } else if (j_lm && navigator.appName == "Microsoft Internet Explorer") {
      BigInteger.prototype.am = am2;
      dbits = 30;
    } else if (j_lm && navigator.appName != "Netscape") {
      BigInteger.prototype.am = am1;
      dbits = 26;
    } else {
      BigInteger.prototype.am = am3;
      dbits = 28;
    }
    BigInteger.prototype.DB = dbits;
    BigInteger.prototype.DM = (1 << dbits) - 1;
    BigInteger.prototype.DV = 1 << dbits;
    var BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2, BI_FP);
    BigInteger.prototype.F1 = BI_FP - dbits;
    BigInteger.prototype.F2 = 2 * dbits - BI_FP;
    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC = new Array();
    var rr2;
    var vv;
    rr2 = "0".charCodeAt(0);
    for (vv = 0; vv <= 9; ++vv)
      BI_RC[rr2++] = vv;
    rr2 = "a".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv)
      BI_RC[rr2++] = vv;
    rr2 = "A".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv)
      BI_RC[rr2++] = vv;
    function int2char(n2) {
      return BI_RM.charAt(n2);
    }
    function intAt(s, i2) {
      var c = BI_RC[s.charCodeAt(i2)];
      return c == null ? -1 : c;
    }
    function bnpCopyTo(r2) {
      for (var i2 = this.t - 1; i2 >= 0; --i2)
        r2.data[i2] = this.data[i2];
      r2.t = this.t;
      r2.s = this.s;
    }
    function bnpFromInt(x3) {
      this.t = 1;
      this.s = x3 < 0 ? -1 : 0;
      if (x3 > 0)
        this.data[0] = x3;
      else if (x3 < -1)
        this.data[0] = x3 + this.DV;
      else
        this.t = 0;
    }
    function nbv(i2) {
      var r2 = nbi();
      r2.fromInt(i2);
      return r2;
    }
    function bnpFromString(s, b2) {
      var k3;
      if (b2 == 16)
        k3 = 4;
      else if (b2 == 8)
        k3 = 3;
      else if (b2 == 256)
        k3 = 8;
      else if (b2 == 2)
        k3 = 1;
      else if (b2 == 32)
        k3 = 5;
      else if (b2 == 4)
        k3 = 2;
      else {
        this.fromRadix(s, b2);
        return;
      }
      this.t = 0;
      this.s = 0;
      var i2 = s.length, mi2 = false, sh = 0;
      while (--i2 >= 0) {
        var x3 = k3 == 8 ? s[i2] & 255 : intAt(s, i2);
        if (x3 < 0) {
          if (s.charAt(i2) == "-")
            mi2 = true;
          continue;
        }
        mi2 = false;
        if (sh == 0)
          this.data[this.t++] = x3;
        else if (sh + k3 > this.DB) {
          this.data[this.t - 1] |= (x3 & (1 << this.DB - sh) - 1) << sh;
          this.data[this.t++] = x3 >> this.DB - sh;
        } else
          this.data[this.t - 1] |= x3 << sh;
        sh += k3;
        if (sh >= this.DB)
          sh -= this.DB;
      }
      if (k3 == 8 && (s[0] & 128) != 0) {
        this.s = -1;
        if (sh > 0)
          this.data[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
      }
      this.clamp();
      if (mi2)
        BigInteger.ZERO.subTo(this, this);
    }
    function bnpClamp() {
      var c = this.s & this.DM;
      while (this.t > 0 && this.data[this.t - 1] == c)
        --this.t;
    }
    function bnToString(b2) {
      if (this.s < 0)
        return "-" + this.negate().toString(b2);
      var k3;
      if (b2 == 16)
        k3 = 4;
      else if (b2 == 8)
        k3 = 3;
      else if (b2 == 2)
        k3 = 1;
      else if (b2 == 32)
        k3 = 5;
      else if (b2 == 4)
        k3 = 2;
      else
        return this.toRadix(b2);
      var km = (1 << k3) - 1, d, m = false, r2 = "", i2 = this.t;
      var p2 = this.DB - i2 * this.DB % k3;
      if (i2-- > 0) {
        if (p2 < this.DB && (d = this.data[i2] >> p2) > 0) {
          m = true;
          r2 = int2char(d);
        }
        while (i2 >= 0) {
          if (p2 < k3) {
            d = (this.data[i2] & (1 << p2) - 1) << k3 - p2;
            d |= this.data[--i2] >> (p2 += this.DB - k3);
          } else {
            d = this.data[i2] >> (p2 -= k3) & km;
            if (p2 <= 0) {
              p2 += this.DB;
              --i2;
            }
          }
          if (d > 0)
            m = true;
          if (m)
            r2 += int2char(d);
        }
      }
      return m ? r2 : "0";
    }
    function bnNegate() {
      var r2 = nbi();
      BigInteger.ZERO.subTo(this, r2);
      return r2;
    }
    function bnAbs() {
      return this.s < 0 ? this.negate() : this;
    }
    function bnCompareTo(a) {
      var r2 = this.s - a.s;
      if (r2 != 0)
        return r2;
      var i2 = this.t;
      r2 = i2 - a.t;
      if (r2 != 0)
        return this.s < 0 ? -r2 : r2;
      while (--i2 >= 0)
        if ((r2 = this.data[i2] - a.data[i2]) != 0)
          return r2;
      return 0;
    }
    function nbits(x3) {
      var r2 = 1, t;
      if ((t = x3 >>> 16) != 0) {
        x3 = t;
        r2 += 16;
      }
      if ((t = x3 >> 8) != 0) {
        x3 = t;
        r2 += 8;
      }
      if ((t = x3 >> 4) != 0) {
        x3 = t;
        r2 += 4;
      }
      if ((t = x3 >> 2) != 0) {
        x3 = t;
        r2 += 2;
      }
      if ((t = x3 >> 1) != 0) {
        x3 = t;
        r2 += 1;
      }
      return r2;
    }
    function bnBitLength() {
      if (this.t <= 0)
        return 0;
      return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);
    }
    function bnpDLShiftTo(n2, r2) {
      var i2;
      for (i2 = this.t - 1; i2 >= 0; --i2)
        r2.data[i2 + n2] = this.data[i2];
      for (i2 = n2 - 1; i2 >= 0; --i2)
        r2.data[i2] = 0;
      r2.t = this.t + n2;
      r2.s = this.s;
    }
    function bnpDRShiftTo(n2, r2) {
      for (var i2 = n2; i2 < this.t; ++i2)
        r2.data[i2 - n2] = this.data[i2];
      r2.t = Math.max(this.t - n2, 0);
      r2.s = this.s;
    }
    function bnpLShiftTo(n2, r2) {
      var bs2 = n2 % this.DB;
      var cbs = this.DB - bs2;
      var bm = (1 << cbs) - 1;
      var ds2 = Math.floor(n2 / this.DB), c = this.s << bs2 & this.DM, i2;
      for (i2 = this.t - 1; i2 >= 0; --i2) {
        r2.data[i2 + ds2 + 1] = this.data[i2] >> cbs | c;
        c = (this.data[i2] & bm) << bs2;
      }
      for (i2 = ds2 - 1; i2 >= 0; --i2)
        r2.data[i2] = 0;
      r2.data[ds2] = c;
      r2.t = this.t + ds2 + 1;
      r2.s = this.s;
      r2.clamp();
    }
    function bnpRShiftTo(n2, r2) {
      r2.s = this.s;
      var ds2 = Math.floor(n2 / this.DB);
      if (ds2 >= this.t) {
        r2.t = 0;
        return;
      }
      var bs2 = n2 % this.DB;
      var cbs = this.DB - bs2;
      var bm = (1 << bs2) - 1;
      r2.data[0] = this.data[ds2] >> bs2;
      for (var i2 = ds2 + 1; i2 < this.t; ++i2) {
        r2.data[i2 - ds2 - 1] |= (this.data[i2] & bm) << cbs;
        r2.data[i2 - ds2] = this.data[i2] >> bs2;
      }
      if (bs2 > 0)
        r2.data[this.t - ds2 - 1] |= (this.s & bm) << cbs;
      r2.t = this.t - ds2;
      r2.clamp();
    }
    function bnpSubTo(a, r2) {
      var i2 = 0, c = 0, m = Math.min(a.t, this.t);
      while (i2 < m) {
        c += this.data[i2] - a.data[i2];
        r2.data[i2++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c -= a.s;
        while (i2 < this.t) {
          c += this.data[i2];
          r2.data[i2++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i2 < a.t) {
          c -= a.data[i2];
          r2.data[i2++] = c & this.DM;
          c >>= this.DB;
        }
        c -= a.s;
      }
      r2.s = c < 0 ? -1 : 0;
      if (c < -1)
        r2.data[i2++] = this.DV + c;
      else if (c > 0)
        r2.data[i2++] = c;
      r2.t = i2;
      r2.clamp();
    }
    function bnpMultiplyTo(a, r2) {
      var x3 = this.abs(), y2 = a.abs();
      var i2 = x3.t;
      r2.t = i2 + y2.t;
      while (--i2 >= 0)
        r2.data[i2] = 0;
      for (i2 = 0; i2 < y2.t; ++i2)
        r2.data[i2 + x3.t] = x3.am(0, y2.data[i2], r2, i2, 0, x3.t);
      r2.s = 0;
      r2.clamp();
      if (this.s != a.s)
        BigInteger.ZERO.subTo(r2, r2);
    }
    function bnpSquareTo(r2) {
      var x3 = this.abs();
      var i2 = r2.t = 2 * x3.t;
      while (--i2 >= 0)
        r2.data[i2] = 0;
      for (i2 = 0; i2 < x3.t - 1; ++i2) {
        var c = x3.am(i2, x3.data[i2], r2, 2 * i2, 0, 1);
        if ((r2.data[i2 + x3.t] += x3.am(i2 + 1, 2 * x3.data[i2], r2, 2 * i2 + 1, c, x3.t - i2 - 1)) >= x3.DV) {
          r2.data[i2 + x3.t] -= x3.DV;
          r2.data[i2 + x3.t + 1] = 1;
        }
      }
      if (r2.t > 0)
        r2.data[r2.t - 1] += x3.am(i2, x3.data[i2], r2, 2 * i2, 0, 1);
      r2.s = 0;
      r2.clamp();
    }
    function bnpDivRemTo(m, q3, r2) {
      var pm = m.abs();
      if (pm.t <= 0)
        return;
      var pt2 = this.abs();
      if (pt2.t < pm.t) {
        if (q3 != null)
          q3.fromInt(0);
        if (r2 != null)
          this.copyTo(r2);
        return;
      }
      if (r2 == null)
        r2 = nbi();
      var y2 = nbi(), ts2 = this.s, ms2 = m.s;
      var nsh = this.DB - nbits(pm.data[pm.t - 1]);
      if (nsh > 0) {
        pm.lShiftTo(nsh, y2);
        pt2.lShiftTo(nsh, r2);
      } else {
        pm.copyTo(y2);
        pt2.copyTo(r2);
      }
      var ys2 = y2.t;
      var y0 = y2.data[ys2 - 1];
      if (y0 == 0)
        return;
      var yt2 = y0 * (1 << this.F1) + (ys2 > 1 ? y2.data[ys2 - 2] >> this.F2 : 0);
      var d1 = this.FV / yt2, d2 = (1 << this.F1) / yt2, e = 1 << this.F2;
      var i2 = r2.t, j2 = i2 - ys2, t = q3 == null ? nbi() : q3;
      y2.dlShiftTo(j2, t);
      if (r2.compareTo(t) >= 0) {
        r2.data[r2.t++] = 1;
        r2.subTo(t, r2);
      }
      BigInteger.ONE.dlShiftTo(ys2, t);
      t.subTo(y2, y2);
      while (y2.t < ys2)
        y2.data[y2.t++] = 0;
      while (--j2 >= 0) {
        var qd2 = r2.data[--i2] == y0 ? this.DM : Math.floor(r2.data[i2] * d1 + (r2.data[i2 - 1] + e) * d2);
        if ((r2.data[i2] += y2.am(0, qd2, r2, j2, 0, ys2)) < qd2) {
          y2.dlShiftTo(j2, t);
          r2.subTo(t, r2);
          while (r2.data[i2] < --qd2)
            r2.subTo(t, r2);
        }
      }
      if (q3 != null) {
        r2.drShiftTo(ys2, q3);
        if (ts2 != ms2)
          BigInteger.ZERO.subTo(q3, q3);
      }
      r2.t = ys2;
      r2.clamp();
      if (nsh > 0)
        r2.rShiftTo(nsh, r2);
      if (ts2 < 0)
        BigInteger.ZERO.subTo(r2, r2);
    }
    function bnMod(a) {
      var r2 = nbi();
      this.abs().divRemTo(a, null, r2);
      if (this.s < 0 && r2.compareTo(BigInteger.ZERO) > 0)
        a.subTo(r2, r2);
      return r2;
    }
    function Classic(m) {
      this.m = m;
    }
    function cConvert(x3) {
      if (x3.s < 0 || x3.compareTo(this.m) >= 0)
        return x3.mod(this.m);
      else
        return x3;
    }
    function cRevert(x3) {
      return x3;
    }
    function cReduce(x3) {
      x3.divRemTo(this.m, null, x3);
    }
    function cMulTo(x3, y2, r2) {
      x3.multiplyTo(y2, r2);
      this.reduce(r2);
    }
    function cSqrTo(x3, r2) {
      x3.squareTo(r2);
      this.reduce(r2);
    }
    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;
    function bnpInvDigit() {
      if (this.t < 1)
        return 0;
      var x3 = this.data[0];
      if ((x3 & 1) == 0)
        return 0;
      var y2 = x3 & 3;
      y2 = y2 * (2 - (x3 & 15) * y2) & 15;
      y2 = y2 * (2 - (x3 & 255) * y2) & 255;
      y2 = y2 * (2 - ((x3 & 65535) * y2 & 65535)) & 65535;
      y2 = y2 * (2 - x3 * y2 % this.DV) % this.DV;
      return y2 > 0 ? this.DV - y2 : -y2;
    }
    function Montgomery(m) {
      this.m = m;
      this.mp = m.invDigit();
      this.mpl = this.mp & 32767;
      this.mph = this.mp >> 15;
      this.um = (1 << m.DB - 15) - 1;
      this.mt2 = 2 * m.t;
    }
    function montConvert(x3) {
      var r2 = nbi();
      x3.abs().dlShiftTo(this.m.t, r2);
      r2.divRemTo(this.m, null, r2);
      if (x3.s < 0 && r2.compareTo(BigInteger.ZERO) > 0)
        this.m.subTo(r2, r2);
      return r2;
    }
    function montRevert(x3) {
      var r2 = nbi();
      x3.copyTo(r2);
      this.reduce(r2);
      return r2;
    }
    function montReduce(x3) {
      while (x3.t <= this.mt2)
        x3.data[x3.t++] = 0;
      for (var i2 = 0; i2 < this.m.t; ++i2) {
        var j2 = x3.data[i2] & 32767;
        var u0 = j2 * this.mpl + ((j2 * this.mph + (x3.data[i2] >> 15) * this.mpl & this.um) << 15) & x3.DM;
        j2 = i2 + this.m.t;
        x3.data[j2] += this.m.am(0, u0, x3, i2, 0, this.m.t);
        while (x3.data[j2] >= x3.DV) {
          x3.data[j2] -= x3.DV;
          x3.data[++j2]++;
        }
      }
      x3.clamp();
      x3.drShiftTo(this.m.t, x3);
      if (x3.compareTo(this.m) >= 0)
        x3.subTo(this.m, x3);
    }
    function montSqrTo(x3, r2) {
      x3.squareTo(r2);
      this.reduce(r2);
    }
    function montMulTo(x3, y2, r2) {
      x3.multiplyTo(y2, r2);
      this.reduce(r2);
    }
    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;
    function bnpIsEven() {
      return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
    }
    function bnpExp(e, z2) {
      if (e > 4294967295 || e < 1)
        return BigInteger.ONE;
      var r2 = nbi(), r22 = nbi(), g2 = z2.convert(this), i2 = nbits(e) - 1;
      g2.copyTo(r2);
      while (--i2 >= 0) {
        z2.sqrTo(r2, r22);
        if ((e & 1 << i2) > 0)
          z2.mulTo(r22, g2, r2);
        else {
          var t = r2;
          r2 = r22;
          r22 = t;
        }
      }
      return z2.revert(r2);
    }
    function bnModPowInt(e, m) {
      var z2;
      if (e < 256 || m.isEven())
        z2 = new Classic(m);
      else
        z2 = new Montgomery(m);
      return this.exp(e, z2);
    }
    BigInteger.prototype.copyTo = bnpCopyTo;
    BigInteger.prototype.fromInt = bnpFromInt;
    BigInteger.prototype.fromString = bnpFromString;
    BigInteger.prototype.clamp = bnpClamp;
    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger.prototype.lShiftTo = bnpLShiftTo;
    BigInteger.prototype.rShiftTo = bnpRShiftTo;
    BigInteger.prototype.subTo = bnpSubTo;
    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger.prototype.squareTo = bnpSquareTo;
    BigInteger.prototype.divRemTo = bnpDivRemTo;
    BigInteger.prototype.invDigit = bnpInvDigit;
    BigInteger.prototype.isEven = bnpIsEven;
    BigInteger.prototype.exp = bnpExp;
    BigInteger.prototype.toString = bnToString;
    BigInteger.prototype.negate = bnNegate;
    BigInteger.prototype.abs = bnAbs;
    BigInteger.prototype.compareTo = bnCompareTo;
    BigInteger.prototype.bitLength = bnBitLength;
    BigInteger.prototype.mod = bnMod;
    BigInteger.prototype.modPowInt = bnModPowInt;
    BigInteger.ZERO = nbv(0);
    BigInteger.ONE = nbv(1);
    function bnClone() {
      var r2 = nbi();
      this.copyTo(r2);
      return r2;
    }
    function bnIntValue() {
      if (this.s < 0) {
        if (this.t == 1)
          return this.data[0] - this.DV;
        else if (this.t == 0)
          return -1;
      } else if (this.t == 1)
        return this.data[0];
      else if (this.t == 0)
        return 0;
      return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
    }
    function bnByteValue() {
      return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
    }
    function bnShortValue() {
      return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
    }
    function bnpChunkSize(r2) {
      return Math.floor(Math.LN2 * this.DB / Math.log(r2));
    }
    function bnSigNum() {
      if (this.s < 0)
        return -1;
      else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0)
        return 0;
      else
        return 1;
    }
    function bnpToRadix(b2) {
      if (b2 == null)
        b2 = 10;
      if (this.signum() == 0 || b2 < 2 || b2 > 36)
        return "0";
      var cs2 = this.chunkSize(b2);
      var a = Math.pow(b2, cs2);
      var d = nbv(a), y2 = nbi(), z2 = nbi(), r2 = "";
      this.divRemTo(d, y2, z2);
      while (y2.signum() > 0) {
        r2 = (a + z2.intValue()).toString(b2).substr(1) + r2;
        y2.divRemTo(d, y2, z2);
      }
      return z2.intValue().toString(b2) + r2;
    }
    function bnpFromRadix(s, b2) {
      this.fromInt(0);
      if (b2 == null)
        b2 = 10;
      var cs2 = this.chunkSize(b2);
      var d = Math.pow(b2, cs2), mi2 = false, j2 = 0, w2 = 0;
      for (var i2 = 0; i2 < s.length; ++i2) {
        var x3 = intAt(s, i2);
        if (x3 < 0) {
          if (s.charAt(i2) == "-" && this.signum() == 0)
            mi2 = true;
          continue;
        }
        w2 = b2 * w2 + x3;
        if (++j2 >= cs2) {
          this.dMultiply(d);
          this.dAddOffset(w2, 0);
          j2 = 0;
          w2 = 0;
        }
      }
      if (j2 > 0) {
        this.dMultiply(Math.pow(b2, j2));
        this.dAddOffset(w2, 0);
      }
      if (mi2)
        BigInteger.ZERO.subTo(this, this);
    }
    function bnpFromNumber(a, b2, c) {
      if ("number" == typeof b2) {
        if (a < 2)
          this.fromInt(1);
        else {
          this.fromNumber(a, c);
          if (!this.testBit(a - 1))
            this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
          if (this.isEven())
            this.dAddOffset(1, 0);
          while (!this.isProbablePrime(b2)) {
            this.dAddOffset(2, 0);
            if (this.bitLength() > a)
              this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
          }
        }
      } else {
        var x3 = new Array(), t = a & 7;
        x3.length = (a >> 3) + 1;
        b2.nextBytes(x3);
        if (t > 0)
          x3[0] &= (1 << t) - 1;
        else
          x3[0] = 0;
        this.fromString(x3, 256);
      }
    }
    function bnToByteArray() {
      var i2 = this.t, r2 = new Array();
      r2[0] = this.s;
      var p2 = this.DB - i2 * this.DB % 8, d, k3 = 0;
      if (i2-- > 0) {
        if (p2 < this.DB && (d = this.data[i2] >> p2) != (this.s & this.DM) >> p2)
          r2[k3++] = d | this.s << this.DB - p2;
        while (i2 >= 0) {
          if (p2 < 8) {
            d = (this.data[i2] & (1 << p2) - 1) << 8 - p2;
            d |= this.data[--i2] >> (p2 += this.DB - 8);
          } else {
            d = this.data[i2] >> (p2 -= 8) & 255;
            if (p2 <= 0) {
              p2 += this.DB;
              --i2;
            }
          }
          if ((d & 128) != 0)
            d |= -256;
          if (k3 == 0 && (this.s & 128) != (d & 128))
            ++k3;
          if (k3 > 0 || d != this.s)
            r2[k3++] = d;
        }
      }
      return r2;
    }
    function bnEquals(a) {
      return this.compareTo(a) == 0;
    }
    function bnMin(a) {
      return this.compareTo(a) < 0 ? this : a;
    }
    function bnMax(a) {
      return this.compareTo(a) > 0 ? this : a;
    }
    function bnpBitwiseTo(a, op, r2) {
      var i2, f, m = Math.min(a.t, this.t);
      for (i2 = 0; i2 < m; ++i2)
        r2.data[i2] = op(this.data[i2], a.data[i2]);
      if (a.t < this.t) {
        f = a.s & this.DM;
        for (i2 = m; i2 < this.t; ++i2)
          r2.data[i2] = op(this.data[i2], f);
        r2.t = this.t;
      } else {
        f = this.s & this.DM;
        for (i2 = m; i2 < a.t; ++i2)
          r2.data[i2] = op(f, a.data[i2]);
        r2.t = a.t;
      }
      r2.s = op(this.s, a.s);
      r2.clamp();
    }
    function op_and(x3, y2) {
      return x3 & y2;
    }
    function bnAnd(a) {
      var r2 = nbi();
      this.bitwiseTo(a, op_and, r2);
      return r2;
    }
    function op_or(x3, y2) {
      return x3 | y2;
    }
    function bnOr(a) {
      var r2 = nbi();
      this.bitwiseTo(a, op_or, r2);
      return r2;
    }
    function op_xor(x3, y2) {
      return x3 ^ y2;
    }
    function bnXor(a) {
      var r2 = nbi();
      this.bitwiseTo(a, op_xor, r2);
      return r2;
    }
    function op_andnot(x3, y2) {
      return x3 & ~y2;
    }
    function bnAndNot(a) {
      var r2 = nbi();
      this.bitwiseTo(a, op_andnot, r2);
      return r2;
    }
    function bnNot() {
      var r2 = nbi();
      for (var i2 = 0; i2 < this.t; ++i2)
        r2.data[i2] = this.DM & ~this.data[i2];
      r2.t = this.t;
      r2.s = ~this.s;
      return r2;
    }
    function bnShiftLeft(n2) {
      var r2 = nbi();
      if (n2 < 0)
        this.rShiftTo(-n2, r2);
      else
        this.lShiftTo(n2, r2);
      return r2;
    }
    function bnShiftRight(n2) {
      var r2 = nbi();
      if (n2 < 0)
        this.lShiftTo(-n2, r2);
      else
        this.rShiftTo(n2, r2);
      return r2;
    }
    function lbit(x3) {
      if (x3 == 0)
        return -1;
      var r2 = 0;
      if ((x3 & 65535) == 0) {
        x3 >>= 16;
        r2 += 16;
      }
      if ((x3 & 255) == 0) {
        x3 >>= 8;
        r2 += 8;
      }
      if ((x3 & 15) == 0) {
        x3 >>= 4;
        r2 += 4;
      }
      if ((x3 & 3) == 0) {
        x3 >>= 2;
        r2 += 2;
      }
      if ((x3 & 1) == 0)
        ++r2;
      return r2;
    }
    function bnGetLowestSetBit() {
      for (var i2 = 0; i2 < this.t; ++i2)
        if (this.data[i2] != 0)
          return i2 * this.DB + lbit(this.data[i2]);
      if (this.s < 0)
        return this.t * this.DB;
      return -1;
    }
    function cbit(x3) {
      var r2 = 0;
      while (x3 != 0) {
        x3 &= x3 - 1;
        ++r2;
      }
      return r2;
    }
    function bnBitCount() {
      var r2 = 0, x3 = this.s & this.DM;
      for (var i2 = 0; i2 < this.t; ++i2)
        r2 += cbit(this.data[i2] ^ x3);
      return r2;
    }
    function bnTestBit(n2) {
      var j2 = Math.floor(n2 / this.DB);
      if (j2 >= this.t)
        return this.s != 0;
      return (this.data[j2] & 1 << n2 % this.DB) != 0;
    }
    function bnpChangeBit(n2, op) {
      var r2 = BigInteger.ONE.shiftLeft(n2);
      this.bitwiseTo(r2, op, r2);
      return r2;
    }
    function bnSetBit(n2) {
      return this.changeBit(n2, op_or);
    }
    function bnClearBit(n2) {
      return this.changeBit(n2, op_andnot);
    }
    function bnFlipBit(n2) {
      return this.changeBit(n2, op_xor);
    }
    function bnpAddTo(a, r2) {
      var i2 = 0, c = 0, m = Math.min(a.t, this.t);
      while (i2 < m) {
        c += this.data[i2] + a.data[i2];
        r2.data[i2++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c += a.s;
        while (i2 < this.t) {
          c += this.data[i2];
          r2.data[i2++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i2 < a.t) {
          c += a.data[i2];
          r2.data[i2++] = c & this.DM;
          c >>= this.DB;
        }
        c += a.s;
      }
      r2.s = c < 0 ? -1 : 0;
      if (c > 0)
        r2.data[i2++] = c;
      else if (c < -1)
        r2.data[i2++] = this.DV + c;
      r2.t = i2;
      r2.clamp();
    }
    function bnAdd(a) {
      var r2 = nbi();
      this.addTo(a, r2);
      return r2;
    }
    function bnSubtract(a) {
      var r2 = nbi();
      this.subTo(a, r2);
      return r2;
    }
    function bnMultiply(a) {
      var r2 = nbi();
      this.multiplyTo(a, r2);
      return r2;
    }
    function bnDivide(a) {
      var r2 = nbi();
      this.divRemTo(a, r2, null);
      return r2;
    }
    function bnRemainder(a) {
      var r2 = nbi();
      this.divRemTo(a, null, r2);
      return r2;
    }
    function bnDivideAndRemainder(a) {
      var q3 = nbi(), r2 = nbi();
      this.divRemTo(a, q3, r2);
      return new Array(q3, r2);
    }
    function bnpDMultiply(n2) {
      this.data[this.t] = this.am(0, n2 - 1, this, 0, 0, this.t);
      ++this.t;
      this.clamp();
    }
    function bnpDAddOffset(n2, w2) {
      if (n2 == 0)
        return;
      while (this.t <= w2)
        this.data[this.t++] = 0;
      this.data[w2] += n2;
      while (this.data[w2] >= this.DV) {
        this.data[w2] -= this.DV;
        if (++w2 >= this.t)
          this.data[this.t++] = 0;
        ++this.data[w2];
      }
    }
    function NullExp() {
    }
    function nNop(x3) {
      return x3;
    }
    function nMulTo(x3, y2, r2) {
      x3.multiplyTo(y2, r2);
    }
    function nSqrTo(x3, r2) {
      x3.squareTo(r2);
    }
    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;
    function bnPow(e) {
      return this.exp(e, new NullExp());
    }
    function bnpMultiplyLowerTo(a, n2, r2) {
      var i2 = Math.min(this.t + a.t, n2);
      r2.s = 0;
      r2.t = i2;
      while (i2 > 0)
        r2.data[--i2] = 0;
      var j2;
      for (j2 = r2.t - this.t; i2 < j2; ++i2)
        r2.data[i2 + this.t] = this.am(0, a.data[i2], r2, i2, 0, this.t);
      for (j2 = Math.min(a.t, n2); i2 < j2; ++i2)
        this.am(0, a.data[i2], r2, i2, 0, n2 - i2);
      r2.clamp();
    }
    function bnpMultiplyUpperTo(a, n2, r2) {
      --n2;
      var i2 = r2.t = this.t + a.t - n2;
      r2.s = 0;
      while (--i2 >= 0)
        r2.data[i2] = 0;
      for (i2 = Math.max(n2 - this.t, 0); i2 < a.t; ++i2)
        r2.data[this.t + i2 - n2] = this.am(n2 - i2, a.data[i2], r2, 0, 0, this.t + i2 - n2);
      r2.clamp();
      r2.drShiftTo(1, r2);
    }
    function Barrett(m) {
      this.r2 = nbi();
      this.q3 = nbi();
      BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
      this.mu = this.r2.divide(m);
      this.m = m;
    }
    function barrettConvert(x3) {
      if (x3.s < 0 || x3.t > 2 * this.m.t)
        return x3.mod(this.m);
      else if (x3.compareTo(this.m) < 0)
        return x3;
      else {
        var r2 = nbi();
        x3.copyTo(r2);
        this.reduce(r2);
        return r2;
      }
    }
    function barrettRevert(x3) {
      return x3;
    }
    function barrettReduce(x3) {
      x3.drShiftTo(this.m.t - 1, this.r2);
      if (x3.t > this.m.t + 1) {
        x3.t = this.m.t + 1;
        x3.clamp();
      }
      this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
      this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
      while (x3.compareTo(this.r2) < 0)
        x3.dAddOffset(1, this.m.t + 1);
      x3.subTo(this.r2, x3);
      while (x3.compareTo(this.m) >= 0)
        x3.subTo(this.m, x3);
    }
    function barrettSqrTo(x3, r2) {
      x3.squareTo(r2);
      this.reduce(r2);
    }
    function barrettMulTo(x3, y2, r2) {
      x3.multiplyTo(y2, r2);
      this.reduce(r2);
    }
    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;
    function bnModPow(e, m) {
      var i2 = e.bitLength(), k3, r2 = nbv(1), z2;
      if (i2 <= 0)
        return r2;
      else if (i2 < 18)
        k3 = 1;
      else if (i2 < 48)
        k3 = 3;
      else if (i2 < 144)
        k3 = 4;
      else if (i2 < 768)
        k3 = 5;
      else
        k3 = 6;
      if (i2 < 8)
        z2 = new Classic(m);
      else if (m.isEven())
        z2 = new Barrett(m);
      else
        z2 = new Montgomery(m);
      var g2 = new Array(), n2 = 3, k1 = k3 - 1, km = (1 << k3) - 1;
      g2[1] = z2.convert(this);
      if (k3 > 1) {
        var g22 = nbi();
        z2.sqrTo(g2[1], g22);
        while (n2 <= km) {
          g2[n2] = nbi();
          z2.mulTo(g22, g2[n2 - 2], g2[n2]);
          n2 += 2;
        }
      }
      var j2 = e.t - 1, w2, is1 = true, r22 = nbi(), t;
      i2 = nbits(e.data[j2]) - 1;
      while (j2 >= 0) {
        if (i2 >= k1)
          w2 = e.data[j2] >> i2 - k1 & km;
        else {
          w2 = (e.data[j2] & (1 << i2 + 1) - 1) << k1 - i2;
          if (j2 > 0)
            w2 |= e.data[j2 - 1] >> this.DB + i2 - k1;
        }
        n2 = k3;
        while ((w2 & 1) == 0) {
          w2 >>= 1;
          --n2;
        }
        if ((i2 -= n2) < 0) {
          i2 += this.DB;
          --j2;
        }
        if (is1) {
          g2[w2].copyTo(r2);
          is1 = false;
        } else {
          while (n2 > 1) {
            z2.sqrTo(r2, r22);
            z2.sqrTo(r22, r2);
            n2 -= 2;
          }
          if (n2 > 0)
            z2.sqrTo(r2, r22);
          else {
            t = r2;
            r2 = r22;
            r22 = t;
          }
          z2.mulTo(r22, g2[w2], r2);
        }
        while (j2 >= 0 && (e.data[j2] & 1 << i2) == 0) {
          z2.sqrTo(r2, r22);
          t = r2;
          r2 = r22;
          r22 = t;
          if (--i2 < 0) {
            i2 = this.DB - 1;
            --j2;
          }
        }
      }
      return z2.revert(r2);
    }
    function bnGCD(a) {
      var x3 = this.s < 0 ? this.negate() : this.clone();
      var y2 = a.s < 0 ? a.negate() : a.clone();
      if (x3.compareTo(y2) < 0) {
        var t = x3;
        x3 = y2;
        y2 = t;
      }
      var i2 = x3.getLowestSetBit(), g2 = y2.getLowestSetBit();
      if (g2 < 0)
        return x3;
      if (i2 < g2)
        g2 = i2;
      if (g2 > 0) {
        x3.rShiftTo(g2, x3);
        y2.rShiftTo(g2, y2);
      }
      while (x3.signum() > 0) {
        if ((i2 = x3.getLowestSetBit()) > 0)
          x3.rShiftTo(i2, x3);
        if ((i2 = y2.getLowestSetBit()) > 0)
          y2.rShiftTo(i2, y2);
        if (x3.compareTo(y2) >= 0) {
          x3.subTo(y2, x3);
          x3.rShiftTo(1, x3);
        } else {
          y2.subTo(x3, y2);
          y2.rShiftTo(1, y2);
        }
      }
      if (g2 > 0)
        y2.lShiftTo(g2, y2);
      return y2;
    }
    function bnpModInt(n2) {
      if (n2 <= 0)
        return 0;
      var d = this.DV % n2, r2 = this.s < 0 ? n2 - 1 : 0;
      if (this.t > 0)
        if (d == 0)
          r2 = this.data[0] % n2;
        else
          for (var i2 = this.t - 1; i2 >= 0; --i2)
            r2 = (d * r2 + this.data[i2]) % n2;
      return r2;
    }
    function bnModInverse(m) {
      var ac2 = m.isEven();
      if (this.isEven() && ac2 || m.signum() == 0)
        return BigInteger.ZERO;
      var u4 = m.clone(), v2 = this.clone();
      var a = nbv(1), b2 = nbv(0), c = nbv(0), d = nbv(1);
      while (u4.signum() != 0) {
        while (u4.isEven()) {
          u4.rShiftTo(1, u4);
          if (ac2) {
            if (!a.isEven() || !b2.isEven()) {
              a.addTo(this, a);
              b2.subTo(m, b2);
            }
            a.rShiftTo(1, a);
          } else if (!b2.isEven())
            b2.subTo(m, b2);
          b2.rShiftTo(1, b2);
        }
        while (v2.isEven()) {
          v2.rShiftTo(1, v2);
          if (ac2) {
            if (!c.isEven() || !d.isEven()) {
              c.addTo(this, c);
              d.subTo(m, d);
            }
            c.rShiftTo(1, c);
          } else if (!d.isEven())
            d.subTo(m, d);
          d.rShiftTo(1, d);
        }
        if (u4.compareTo(v2) >= 0) {
          u4.subTo(v2, u4);
          if (ac2)
            a.subTo(c, a);
          b2.subTo(d, b2);
        } else {
          v2.subTo(u4, v2);
          if (ac2)
            c.subTo(a, c);
          d.subTo(b2, d);
        }
      }
      if (v2.compareTo(BigInteger.ONE) != 0)
        return BigInteger.ZERO;
      if (d.compareTo(m) >= 0)
        return d.subtract(m);
      if (d.signum() < 0)
        d.addTo(m, d);
      else
        return d;
      if (d.signum() < 0)
        return d.add(m);
      else
        return d;
    }
    var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];
    var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
    function bnIsProbablePrime(t) {
      var i2, x3 = this.abs();
      if (x3.t == 1 && x3.data[0] <= lowprimes[lowprimes.length - 1]) {
        for (i2 = 0; i2 < lowprimes.length; ++i2)
          if (x3.data[0] == lowprimes[i2])
            return true;
        return false;
      }
      if (x3.isEven())
        return false;
      i2 = 1;
      while (i2 < lowprimes.length) {
        var m = lowprimes[i2], j2 = i2 + 1;
        while (j2 < lowprimes.length && m < lplim)
          m *= lowprimes[j2++];
        m = x3.modInt(m);
        while (i2 < j2)
          if (m % lowprimes[i2++] == 0)
            return false;
      }
      return x3.millerRabin(t);
    }
    function bnpMillerRabin(t) {
      var n1 = this.subtract(BigInteger.ONE);
      var k3 = n1.getLowestSetBit();
      if (k3 <= 0)
        return false;
      var r2 = n1.shiftRight(k3);
      var prng = bnGetPrng();
      var a;
      for (var i2 = 0; i2 < t; ++i2) {
        do {
          a = new BigInteger(this.bitLength(), prng);
        } while (a.compareTo(BigInteger.ONE) <= 0 || a.compareTo(n1) >= 0);
        var y2 = a.modPow(r2, this);
        if (y2.compareTo(BigInteger.ONE) != 0 && y2.compareTo(n1) != 0) {
          var j2 = 1;
          while (j2++ < k3 && y2.compareTo(n1) != 0) {
            y2 = y2.modPowInt(2, this);
            if (y2.compareTo(BigInteger.ONE) == 0)
              return false;
          }
          if (y2.compareTo(n1) != 0)
            return false;
        }
      }
      return true;
    }
    function bnGetPrng() {
      return {
        // x is an array to fill with bytes
        nextBytes: function(x3) {
          for (var i2 = 0; i2 < x3.length; ++i2) {
            x3[i2] = Math.floor(Math.random() * 256);
          }
        }
      };
    }
    BigInteger.prototype.chunkSize = bnpChunkSize;
    BigInteger.prototype.toRadix = bnpToRadix;
    BigInteger.prototype.fromRadix = bnpFromRadix;
    BigInteger.prototype.fromNumber = bnpFromNumber;
    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    BigInteger.prototype.changeBit = bnpChangeBit;
    BigInteger.prototype.addTo = bnpAddTo;
    BigInteger.prototype.dMultiply = bnpDMultiply;
    BigInteger.prototype.dAddOffset = bnpDAddOffset;
    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    BigInteger.prototype.modInt = bnpModInt;
    BigInteger.prototype.millerRabin = bnpMillerRabin;
    BigInteger.prototype.clone = bnClone;
    BigInteger.prototype.intValue = bnIntValue;
    BigInteger.prototype.byteValue = bnByteValue;
    BigInteger.prototype.shortValue = bnShortValue;
    BigInteger.prototype.signum = bnSigNum;
    BigInteger.prototype.toByteArray = bnToByteArray;
    BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.min = bnMin;
    BigInteger.prototype.max = bnMax;
    BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.or = bnOr;
    BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.not = bnNot;
    BigInteger.prototype.shiftLeft = bnShiftLeft;
    BigInteger.prototype.shiftRight = bnShiftRight;
    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    BigInteger.prototype.bitCount = bnBitCount;
    BigInteger.prototype.testBit = bnTestBit;
    BigInteger.prototype.setBit = bnSetBit;
    BigInteger.prototype.clearBit = bnClearBit;
    BigInteger.prototype.flipBit = bnFlipBit;
    BigInteger.prototype.add = bnAdd;
    BigInteger.prototype.subtract = bnSubtract;
    BigInteger.prototype.multiply = bnMultiply;
    BigInteger.prototype.divide = bnDivide;
    BigInteger.prototype.remainder = bnRemainder;
    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    BigInteger.prototype.modPow = bnModPow;
    BigInteger.prototype.modInverse = bnModInverse;
    BigInteger.prototype.pow = bnPow;
    BigInteger.prototype.gcd = bnGCD;
    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
  }
});

// node_modules/node-forge/lib/sha1.js
var require_sha1 = __commonJS({
  "node_modules/node-forge/lib/sha1.js"(exports, module) {
    var forge = require_forge();
    require_md();
    require_util2();
    var sha1 = module.exports = forge.sha1 = forge.sha1 || {};
    forge.md.sha1 = forge.md.algorithms.sha1 = sha1;
    sha1.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge.util.createBuffer();
      var _w = new Array(80);
      var md2 = {
        algorithm: "sha1",
        blockLength: 64,
        digestLength: 20,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 8
      };
      md2.start = function() {
        md2.messageLength = 0;
        md2.fullMessageLength = md2.messageLength64 = [];
        var int32s = md2.messageLengthSize / 4;
        for (var i2 = 0; i2 < int32s; ++i2) {
          md2.fullMessageLength.push(0);
        }
        _input = forge.util.createBuffer();
        _state = {
          h0: 1732584193,
          h1: 4023233417,
          h2: 2562383102,
          h3: 271733878,
          h4: 3285377520
        };
        return md2;
      };
      md2.start();
      md2.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md2.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i2 = md2.fullMessageLength.length - 1; i2 >= 0; --i2) {
          md2.fullMessageLength[i2] += len[1];
          len[1] = len[0] + (md2.fullMessageLength[i2] / 4294967296 >>> 0);
          md2.fullMessageLength[i2] = md2.fullMessageLength[i2] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md2;
      };
      md2.digest = function() {
        var finalBlock = forge.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md2.fullMessageLength[md2.fullMessageLength.length - 1] + md2.messageLengthSize;
        var overflow = remaining & md2.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md2.blockLength - overflow));
        var next, carry;
        var bits = md2.fullMessageLength[0] * 8;
        for (var i2 = 0; i2 < md2.fullMessageLength.length - 1; ++i2) {
          next = md2.fullMessageLength[i2 + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4
        };
        _update(s2, _w, finalBlock);
        var rval = forge.util.createBuffer();
        rval.putInt32(s2.h0);
        rval.putInt32(s2.h1);
        rval.putInt32(s2.h2);
        rval.putInt32(s2.h3);
        rval.putInt32(s2.h4);
        return rval;
      };
      return md2;
    };
    var _padding = null;
    var _initialized = false;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge.util.fillString(String.fromCharCode(0), 64);
      _initialized = true;
    }
    function _update(s, w2, bytes) {
      var t, a, b2, c, d, e, f, i2;
      var len = bytes.length();
      while (len >= 64) {
        a = s.h0;
        b2 = s.h1;
        c = s.h2;
        d = s.h3;
        e = s.h4;
        for (i2 = 0; i2 < 16; ++i2) {
          t = bytes.getInt32();
          w2[i2] = t;
          f = d ^ b2 & (c ^ d);
          t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
          e = d;
          d = c;
          c = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a;
          a = t;
        }
        for (; i2 < 20; ++i2) {
          t = w2[i2 - 3] ^ w2[i2 - 8] ^ w2[i2 - 14] ^ w2[i2 - 16];
          t = t << 1 | t >>> 31;
          w2[i2] = t;
          f = d ^ b2 & (c ^ d);
          t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
          e = d;
          d = c;
          c = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a;
          a = t;
        }
        for (; i2 < 32; ++i2) {
          t = w2[i2 - 3] ^ w2[i2 - 8] ^ w2[i2 - 14] ^ w2[i2 - 16];
          t = t << 1 | t >>> 31;
          w2[i2] = t;
          f = b2 ^ c ^ d;
          t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
          e = d;
          d = c;
          c = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a;
          a = t;
        }
        for (; i2 < 40; ++i2) {
          t = w2[i2 - 6] ^ w2[i2 - 16] ^ w2[i2 - 28] ^ w2[i2 - 32];
          t = t << 2 | t >>> 30;
          w2[i2] = t;
          f = b2 ^ c ^ d;
          t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
          e = d;
          d = c;
          c = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a;
          a = t;
        }
        for (; i2 < 60; ++i2) {
          t = w2[i2 - 6] ^ w2[i2 - 16] ^ w2[i2 - 28] ^ w2[i2 - 32];
          t = t << 2 | t >>> 30;
          w2[i2] = t;
          f = b2 & c | d & (b2 ^ c);
          t = (a << 5 | a >>> 27) + f + e + 2400959708 + t;
          e = d;
          d = c;
          c = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a;
          a = t;
        }
        for (; i2 < 80; ++i2) {
          t = w2[i2 - 6] ^ w2[i2 - 16] ^ w2[i2 - 28] ^ w2[i2 - 32];
          t = t << 2 | t >>> 30;
          w2[i2] = t;
          f = b2 ^ c ^ d;
          t = (a << 5 | a >>> 27) + f + e + 3395469782 + t;
          e = d;
          d = c;
          c = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a;
          a = t;
        }
        s.h0 = s.h0 + a | 0;
        s.h1 = s.h1 + b2 | 0;
        s.h2 = s.h2 + c | 0;
        s.h3 = s.h3 + d | 0;
        s.h4 = s.h4 + e | 0;
        len -= 64;
      }
    }
  }
});

// node_modules/node-forge/lib/pkcs1.js
var require_pkcs1 = __commonJS({
  "node_modules/node-forge/lib/pkcs1.js"(exports, module) {
    var forge = require_forge();
    require_util2();
    require_random();
    require_sha1();
    var pkcs1 = module.exports = forge.pkcs1 = forge.pkcs1 || {};
    pkcs1.encode_rsa_oaep = function(key, message, options) {
      var label;
      var seed;
      var md2;
      var mgf1Md;
      if (typeof options === "string") {
        label = options;
        seed = arguments[3] || void 0;
        md2 = arguments[4] || void 0;
      } else if (options) {
        label = options.label || void 0;
        seed = options.seed || void 0;
        md2 = options.md || void 0;
        if (options.mgf1 && options.mgf1.md) {
          mgf1Md = options.mgf1.md;
        }
      }
      if (!md2) {
        md2 = forge.md.sha1.create();
      } else {
        md2.start();
      }
      if (!mgf1Md) {
        mgf1Md = md2;
      }
      var keyLength = Math.ceil(key.n.bitLength() / 8);
      var maxLength = keyLength - 2 * md2.digestLength - 2;
      if (message.length > maxLength) {
        var error = new Error("RSAES-OAEP input message length is too long.");
        error.length = message.length;
        error.maxLength = maxLength;
        throw error;
      }
      if (!label) {
        label = "";
      }
      md2.update(label, "raw");
      var lHash = md2.digest();
      var PS = "";
      var PS_length = maxLength - message.length;
      for (var i2 = 0; i2 < PS_length; i2++) {
        PS += "\0";
      }
      var DB = lHash.getBytes() + PS + "" + message;
      if (!seed) {
        seed = forge.random.getBytes(md2.digestLength);
      } else if (seed.length !== md2.digestLength) {
        var error = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
        error.seedLength = seed.length;
        error.digestLength = md2.digestLength;
        throw error;
      }
      var dbMask = rsa_mgf1(seed, keyLength - md2.digestLength - 1, mgf1Md);
      var maskedDB = forge.util.xorBytes(DB, dbMask, DB.length);
      var seedMask = rsa_mgf1(maskedDB, md2.digestLength, mgf1Md);
      var maskedSeed = forge.util.xorBytes(seed, seedMask, seed.length);
      return "\0" + maskedSeed + maskedDB;
    };
    pkcs1.decode_rsa_oaep = function(key, em, options) {
      var label;
      var md2;
      var mgf1Md;
      if (typeof options === "string") {
        label = options;
        md2 = arguments[3] || void 0;
      } else if (options) {
        label = options.label || void 0;
        md2 = options.md || void 0;
        if (options.mgf1 && options.mgf1.md) {
          mgf1Md = options.mgf1.md;
        }
      }
      var keyLength = Math.ceil(key.n.bitLength() / 8);
      if (em.length !== keyLength) {
        var error = new Error("RSAES-OAEP encoded message length is invalid.");
        error.length = em.length;
        error.expectedLength = keyLength;
        throw error;
      }
      if (md2 === void 0) {
        md2 = forge.md.sha1.create();
      } else {
        md2.start();
      }
      if (!mgf1Md) {
        mgf1Md = md2;
      }
      if (keyLength < 2 * md2.digestLength + 2) {
        throw new Error("RSAES-OAEP key is too short for the hash function.");
      }
      if (!label) {
        label = "";
      }
      md2.update(label, "raw");
      var lHash = md2.digest().getBytes();
      var y2 = em.charAt(0);
      var maskedSeed = em.substring(1, md2.digestLength + 1);
      var maskedDB = em.substring(1 + md2.digestLength);
      var seedMask = rsa_mgf1(maskedDB, md2.digestLength, mgf1Md);
      var seed = forge.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);
      var dbMask = rsa_mgf1(seed, keyLength - md2.digestLength - 1, mgf1Md);
      var db2 = forge.util.xorBytes(maskedDB, dbMask, maskedDB.length);
      var lHashPrime = db2.substring(0, md2.digestLength);
      var error = y2 !== "\0";
      for (var i2 = 0; i2 < md2.digestLength; ++i2) {
        error |= lHash.charAt(i2) !== lHashPrime.charAt(i2);
      }
      var in_ps = 1;
      var index = md2.digestLength;
      for (var j2 = md2.digestLength; j2 < db2.length; j2++) {
        var code = db2.charCodeAt(j2);
        var is_0 = code & 1 ^ 1;
        var error_mask = in_ps ? 65534 : 0;
        error |= code & error_mask;
        in_ps = in_ps & is_0;
        index += in_ps;
      }
      if (error || db2.charCodeAt(index) !== 1) {
        throw new Error("Invalid RSAES-OAEP padding.");
      }
      return db2.substring(index + 1);
    };
    function rsa_mgf1(seed, maskLength, hash) {
      if (!hash) {
        hash = forge.md.sha1.create();
      }
      var t = "";
      var count = Math.ceil(maskLength / hash.digestLength);
      for (var i2 = 0; i2 < count; ++i2) {
        var c = String.fromCharCode(
          i2 >> 24 & 255,
          i2 >> 16 & 255,
          i2 >> 8 & 255,
          i2 & 255
        );
        hash.start();
        hash.update(seed + c);
        t += hash.digest().getBytes();
      }
      return t.substring(0, maskLength);
    }
  }
});

// node_modules/node-forge/lib/prime.js
var require_prime = __commonJS({
  "node_modules/node-forge/lib/prime.js"(exports, module) {
    var forge = require_forge();
    require_util2();
    require_jsbn();
    require_random();
    (function() {
      if (forge.prime) {
        module.exports = forge.prime;
        return;
      }
      var prime = module.exports = forge.prime = forge.prime || {};
      var BigInteger = forge.jsbn.BigInteger;
      var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
      var THIRTY = new BigInteger(null);
      THIRTY.fromInt(30);
      var op_or = function(x3, y2) {
        return x3 | y2;
      };
      prime.generateProbablePrime = function(bits, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = options || {};
        var algorithm = options.algorithm || "PRIMEINC";
        if (typeof algorithm === "string") {
          algorithm = { name: algorithm };
        }
        algorithm.options = algorithm.options || {};
        var prng = options.prng || forge.random;
        var rng = {
          // x is an array to fill with bytes
          nextBytes: function(x3) {
            var b2 = prng.getBytesSync(x3.length);
            for (var i2 = 0; i2 < x3.length; ++i2) {
              x3[i2] = b2.charCodeAt(i2);
            }
          }
        };
        if (algorithm.name === "PRIMEINC") {
          return primeincFindPrime(bits, rng, algorithm.options, callback);
        }
        throw new Error("Invalid prime generation algorithm: " + algorithm.name);
      };
      function primeincFindPrime(bits, rng, options, callback) {
        if ("workers" in options) {
          return primeincFindPrimeWithWorkers(bits, rng, options, callback);
        }
        return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
      }
      function primeincFindPrimeWithoutWorkers(bits, rng, options, callback) {
        var num = generateRandom(bits, rng);
        var deltaIdx = 0;
        var mrTests = getMillerRabinTests(num.bitLength());
        if ("millerRabinTests" in options) {
          mrTests = options.millerRabinTests;
        }
        var maxBlockTime = 10;
        if ("maxBlockTime" in options) {
          maxBlockTime = options.maxBlockTime;
        }
        _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
      }
      function _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback) {
        var start2 = +/* @__PURE__ */ new Date();
        do {
          if (num.bitLength() > bits) {
            num = generateRandom(bits, rng);
          }
          if (num.isProbablePrime(mrTests)) {
            return callback(null, num);
          }
          num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
        } while (maxBlockTime < 0 || +/* @__PURE__ */ new Date() - start2 < maxBlockTime);
        forge.util.setImmediate(function() {
          _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
        });
      }
      function primeincFindPrimeWithWorkers(bits, rng, options, callback) {
        if (typeof Worker === "undefined") {
          return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
        }
        var num = generateRandom(bits, rng);
        var numWorkers = options.workers;
        var workLoad = options.workLoad || 100;
        var range2 = workLoad * 30 / 8;
        var workerScript = options.workerScript || "forge/prime.worker.js";
        if (numWorkers === -1) {
          return forge.util.estimateCores(function(err, cores) {
            if (err) {
              cores = 2;
            }
            numWorkers = cores - 1;
            generate2();
          });
        }
        generate2();
        function generate2() {
          numWorkers = Math.max(1, numWorkers);
          var workers = [];
          for (var i2 = 0; i2 < numWorkers; ++i2) {
            workers[i2] = new Worker(workerScript);
          }
          var running = numWorkers;
          for (var i2 = 0; i2 < numWorkers; ++i2) {
            workers[i2].addEventListener("message", workerMessage);
          }
          var found = false;
          function workerMessage(e) {
            if (found) {
              return;
            }
            --running;
            var data = e.data;
            if (data.found) {
              for (var i3 = 0; i3 < workers.length; ++i3) {
                workers[i3].terminate();
              }
              found = true;
              return callback(null, new BigInteger(data.prime, 16));
            }
            if (num.bitLength() > bits) {
              num = generateRandom(bits, rng);
            }
            var hex = num.toString(16);
            e.target.postMessage({
              hex,
              workLoad
            });
            num.dAddOffset(range2, 0);
          }
        }
      }
      function generateRandom(bits, rng) {
        var num = new BigInteger(bits, rng);
        var bits1 = bits - 1;
        if (!num.testBit(bits1)) {
          num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);
        }
        num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
        return num;
      }
      function getMillerRabinTests(bits) {
        if (bits <= 100)
          return 27;
        if (bits <= 150)
          return 18;
        if (bits <= 200)
          return 15;
        if (bits <= 250)
          return 12;
        if (bits <= 300)
          return 9;
        if (bits <= 350)
          return 8;
        if (bits <= 400)
          return 7;
        if (bits <= 500)
          return 6;
        if (bits <= 600)
          return 5;
        if (bits <= 800)
          return 4;
        if (bits <= 1250)
          return 3;
        return 2;
      }
    })();
  }
});

// node_modules/node-forge/lib/rsa.js
var require_rsa = __commonJS({
  "node_modules/node-forge/lib/rsa.js"(exports, module) {
    var forge = require_forge();
    require_asn1();
    require_jsbn();
    require_oids();
    require_pkcs1();
    require_prime();
    require_random();
    require_util2();
    if (typeof BigInteger === "undefined") {
      BigInteger = forge.jsbn.BigInteger;
    }
    var BigInteger;
    var _crypto = forge.util.isNodejs ? require_crypto() : null;
    var asn1 = forge.asn1;
    var util = forge.util;
    forge.pki = forge.pki || {};
    module.exports = forge.pki.rsa = forge.rsa = forge.rsa || {};
    var pki = forge.pki;
    var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
    var privateKeyValidator = {
      // PrivateKeyInfo
      name: "PrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // Version (INTEGER)
        name: "PrivateKeyInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        // privateKeyAlgorithm
        name: "PrivateKeyInfo.privateKeyAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "privateKeyOid"
        }]
      }, {
        // PrivateKey
        name: "PrivateKeyInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "privateKey"
      }]
    };
    var rsaPrivateKeyValidator = {
      // RSAPrivateKey
      name: "RSAPrivateKey",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // Version (INTEGER)
        name: "RSAPrivateKey.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        // modulus (n)
        name: "RSAPrivateKey.modulus",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyModulus"
      }, {
        // publicExponent (e)
        name: "RSAPrivateKey.publicExponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPublicExponent"
      }, {
        // privateExponent (d)
        name: "RSAPrivateKey.privateExponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrivateExponent"
      }, {
        // prime1 (p)
        name: "RSAPrivateKey.prime1",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrime1"
      }, {
        // prime2 (q)
        name: "RSAPrivateKey.prime2",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrime2"
      }, {
        // exponent1 (d mod (p-1))
        name: "RSAPrivateKey.exponent1",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyExponent1"
      }, {
        // exponent2 (d mod (q-1))
        name: "RSAPrivateKey.exponent2",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyExponent2"
      }, {
        // coefficient ((inverse of q) mod p)
        name: "RSAPrivateKey.coefficient",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyCoefficient"
      }]
    };
    var rsaPublicKeyValidator = {
      // RSAPublicKey
      name: "RSAPublicKey",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // modulus (n)
        name: "RSAPublicKey.modulus",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "publicKeyModulus"
      }, {
        // publicExponent (e)
        name: "RSAPublicKey.exponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "publicKeyExponent"
      }]
    };
    var publicKeyValidator = forge.pki.rsa.publicKeyValidator = {
      name: "SubjectPublicKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "subjectPublicKeyInfo",
      value: [{
        name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "publicKeyOid"
        }]
      }, {
        // subjectPublicKey
        name: "SubjectPublicKeyInfo.subjectPublicKey",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        value: [{
          // RSAPublicKey
          name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          optional: true,
          captureAsn1: "rsaPublicKey"
        }]
      }]
    };
    var digestInfoValidator = {
      name: "DigestInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "DigestInfo.DigestAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "DigestInfo.DigestAlgorithm.algorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "algorithmIdentifier"
        }, {
          // NULL paramters
          name: "DigestInfo.DigestAlgorithm.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.NULL,
          // captured only to check existence for md2 and md5
          capture: "parameters",
          optional: true,
          constructed: false
        }]
      }, {
        // digest
        name: "DigestInfo.digest",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "digest"
      }]
    };
    var emsaPkcs1v15encode = function(md2) {
      var oid;
      if (md2.algorithm in pki.oids) {
        oid = pki.oids[md2.algorithm];
      } else {
        var error = new Error("Unknown message digest algorithm.");
        error.algorithm = md2.algorithm;
        throw error;
      }
      var oidBytes = asn1.oidToDer(oid).getBytes();
      var digestInfo = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        []
      );
      var digestAlgorithm = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        []
      );
      digestAlgorithm.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OID,
        false,
        oidBytes
      ));
      digestAlgorithm.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.NULL,
        false,
        ""
      ));
      var digest = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        md2.digest().getBytes()
      );
      digestInfo.value.push(digestAlgorithm);
      digestInfo.value.push(digest);
      return asn1.toDer(digestInfo).getBytes();
    };
    var _modPow = function(x3, key, pub) {
      if (pub) {
        return x3.modPow(key.e, key.n);
      }
      if (!key.p || !key.q) {
        return x3.modPow(key.d, key.n);
      }
      if (!key.dP) {
        key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));
      }
      if (!key.dQ) {
        key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));
      }
      if (!key.qInv) {
        key.qInv = key.q.modInverse(key.p);
      }
      var r2;
      do {
        r2 = new BigInteger(
          forge.util.bytesToHex(forge.random.getBytes(key.n.bitLength() / 8)),
          16
        );
      } while (r2.compareTo(key.n) >= 0 || !r2.gcd(key.n).equals(BigInteger.ONE));
      x3 = x3.multiply(r2.modPow(key.e, key.n)).mod(key.n);
      var xp = x3.mod(key.p).modPow(key.dP, key.p);
      var xq = x3.mod(key.q).modPow(key.dQ, key.q);
      while (xp.compareTo(xq) < 0) {
        xp = xp.add(key.p);
      }
      var y2 = xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);
      y2 = y2.multiply(r2.modInverse(key.n)).mod(key.n);
      return y2;
    };
    pki.rsa.encrypt = function(m, key, bt2) {
      var pub = bt2;
      var eb2;
      var k3 = Math.ceil(key.n.bitLength() / 8);
      if (bt2 !== false && bt2 !== true) {
        pub = bt2 === 2;
        eb2 = _encodePkcs1_v1_5(m, key, bt2);
      } else {
        eb2 = forge.util.createBuffer();
        eb2.putBytes(m);
      }
      var x3 = new BigInteger(eb2.toHex(), 16);
      var y2 = _modPow(x3, key, pub);
      var yhex = y2.toString(16);
      var ed2 = forge.util.createBuffer();
      var zeros = k3 - Math.ceil(yhex.length / 2);
      while (zeros > 0) {
        ed2.putByte(0);
        --zeros;
      }
      ed2.putBytes(forge.util.hexToBytes(yhex));
      return ed2.getBytes();
    };
    pki.rsa.decrypt = function(ed2, key, pub, ml) {
      var k3 = Math.ceil(key.n.bitLength() / 8);
      if (ed2.length !== k3) {
        var error = new Error("Encrypted message length is invalid.");
        error.length = ed2.length;
        error.expected = k3;
        throw error;
      }
      var y2 = new BigInteger(forge.util.createBuffer(ed2).toHex(), 16);
      if (y2.compareTo(key.n) >= 0) {
        throw new Error("Encrypted message is invalid.");
      }
      var x3 = _modPow(y2, key, pub);
      var xhex = x3.toString(16);
      var eb2 = forge.util.createBuffer();
      var zeros = k3 - Math.ceil(xhex.length / 2);
      while (zeros > 0) {
        eb2.putByte(0);
        --zeros;
      }
      eb2.putBytes(forge.util.hexToBytes(xhex));
      if (ml !== false) {
        return _decodePkcs1_v1_5(eb2.getBytes(), key, pub);
      }
      return eb2.getBytes();
    };
    pki.rsa.createKeyPairGenerationState = function(bits, e, options) {
      if (typeof bits === "string") {
        bits = parseInt(bits, 10);
      }
      bits = bits || 2048;
      options = options || {};
      var prng = options.prng || forge.random;
      var rng = {
        // x is an array to fill with bytes
        nextBytes: function(x3) {
          var b2 = prng.getBytesSync(x3.length);
          for (var i2 = 0; i2 < x3.length; ++i2) {
            x3[i2] = b2.charCodeAt(i2);
          }
        }
      };
      var algorithm = options.algorithm || "PRIMEINC";
      var rval;
      if (algorithm === "PRIMEINC") {
        rval = {
          algorithm,
          state: 0,
          bits,
          rng,
          eInt: e || 65537,
          e: new BigInteger(null),
          p: null,
          q: null,
          qBits: bits >> 1,
          pBits: bits - (bits >> 1),
          pqState: 0,
          num: null,
          keys: null
        };
        rval.e.fromInt(rval.eInt);
      } else {
        throw new Error("Invalid key generation algorithm: " + algorithm);
      }
      return rval;
    };
    pki.rsa.stepKeyPairGenerationState = function(state, n2) {
      if (!("algorithm" in state)) {
        state.algorithm = "PRIMEINC";
      }
      var THIRTY = new BigInteger(null);
      THIRTY.fromInt(30);
      var deltaIdx = 0;
      var op_or = function(x3, y2) {
        return x3 | y2;
      };
      var t1 = +/* @__PURE__ */ new Date();
      var t2;
      var total = 0;
      while (state.keys === null && (n2 <= 0 || total < n2)) {
        if (state.state === 0) {
          var bits = state.p === null ? state.pBits : state.qBits;
          var bits1 = bits - 1;
          if (state.pqState === 0) {
            state.num = new BigInteger(bits, state.rng);
            if (!state.num.testBit(bits1)) {
              state.num.bitwiseTo(
                BigInteger.ONE.shiftLeft(bits1),
                op_or,
                state.num
              );
            }
            state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
            deltaIdx = 0;
            ++state.pqState;
          } else if (state.pqState === 1) {
            if (state.num.bitLength() > bits) {
              state.pqState = 0;
            } else if (state.num.isProbablePrime(
              _getMillerRabinTests(state.num.bitLength())
            )) {
              ++state.pqState;
            } else {
              state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
            }
          } else if (state.pqState === 2) {
            state.pqState = state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) === 0 ? 3 : 0;
          } else if (state.pqState === 3) {
            state.pqState = 0;
            if (state.p === null) {
              state.p = state.num;
            } else {
              state.q = state.num;
            }
            if (state.p !== null && state.q !== null) {
              ++state.state;
            }
            state.num = null;
          }
        } else if (state.state === 1) {
          if (state.p.compareTo(state.q) < 0) {
            state.num = state.p;
            state.p = state.q;
            state.q = state.num;
          }
          ++state.state;
        } else if (state.state === 2) {
          state.p1 = state.p.subtract(BigInteger.ONE);
          state.q1 = state.q.subtract(BigInteger.ONE);
          state.phi = state.p1.multiply(state.q1);
          ++state.state;
        } else if (state.state === 3) {
          if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) {
            ++state.state;
          } else {
            state.p = null;
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 4) {
          state.n = state.p.multiply(state.q);
          if (state.n.bitLength() === state.bits) {
            ++state.state;
          } else {
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 5) {
          var d = state.e.modInverse(state.phi);
          state.keys = {
            privateKey: pki.rsa.setPrivateKey(
              state.n,
              state.e,
              d,
              state.p,
              state.q,
              d.mod(state.p1),
              d.mod(state.q1),
              state.q.modInverse(state.p)
            ),
            publicKey: pki.rsa.setPublicKey(state.n, state.e)
          };
        }
        t2 = +/* @__PURE__ */ new Date();
        total += t2 - t1;
        t1 = t2;
      }
      return state.keys !== null;
    };
    pki.rsa.generateKeyPair = function(bits, e, options, callback) {
      if (arguments.length === 1) {
        if (typeof bits === "object") {
          options = bits;
          bits = void 0;
        } else if (typeof bits === "function") {
          callback = bits;
          bits = void 0;
        }
      } else if (arguments.length === 2) {
        if (typeof bits === "number") {
          if (typeof e === "function") {
            callback = e;
            e = void 0;
          } else if (typeof e !== "number") {
            options = e;
            e = void 0;
          }
        } else {
          options = bits;
          callback = e;
          bits = void 0;
          e = void 0;
        }
      } else if (arguments.length === 3) {
        if (typeof e === "number") {
          if (typeof options === "function") {
            callback = options;
            options = void 0;
          }
        } else {
          callback = options;
          options = e;
          e = void 0;
        }
      }
      options = options || {};
      if (bits === void 0) {
        bits = options.bits || 2048;
      }
      if (e === void 0) {
        e = options.e || 65537;
      }
      if (!forge.options.usePureJavaScript && !options.prng && bits >= 256 && bits <= 16384 && (e === 65537 || e === 3)) {
        if (callback) {
          if (_detectNodeCrypto("generateKeyPair")) {
            return _crypto.generateKeyPair("rsa", {
              modulusLength: bits,
              publicExponent: e,
              publicKeyEncoding: {
                type: "spki",
                format: "pem"
              },
              privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
              }
            }, function(err, pub, priv) {
              if (err) {
                return callback(err);
              }
              callback(null, {
                privateKey: pki.privateKeyFromPem(priv),
                publicKey: pki.publicKeyFromPem(pub)
              });
            });
          }
          if (_detectSubtleCrypto("generateKey") && _detectSubtleCrypto("exportKey")) {
            return util.globalScope.crypto.subtle.generateKey({
              name: "RSASSA-PKCS1-v1_5",
              modulusLength: bits,
              publicExponent: _intToUint8Array(e),
              hash: { name: "SHA-256" }
            }, true, ["sign", "verify"]).then(function(pair) {
              return util.globalScope.crypto.subtle.exportKey(
                "pkcs8",
                pair.privateKey
              );
            }).then(void 0, function(err) {
              callback(err);
            }).then(function(pkcs8) {
              if (pkcs8) {
                var privateKey = pki.privateKeyFromAsn1(
                  asn1.fromDer(forge.util.createBuffer(pkcs8))
                );
                callback(null, {
                  privateKey,
                  publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
                });
              }
            });
          }
          if (_detectSubtleMsCrypto("generateKey") && _detectSubtleMsCrypto("exportKey")) {
            var genOp = util.globalScope.msCrypto.subtle.generateKey({
              name: "RSASSA-PKCS1-v1_5",
              modulusLength: bits,
              publicExponent: _intToUint8Array(e),
              hash: { name: "SHA-256" }
            }, true, ["sign", "verify"]);
            genOp.oncomplete = function(e2) {
              var pair = e2.target.result;
              var exportOp = util.globalScope.msCrypto.subtle.exportKey(
                "pkcs8",
                pair.privateKey
              );
              exportOp.oncomplete = function(e3) {
                var pkcs8 = e3.target.result;
                var privateKey = pki.privateKeyFromAsn1(
                  asn1.fromDer(forge.util.createBuffer(pkcs8))
                );
                callback(null, {
                  privateKey,
                  publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
                });
              };
              exportOp.onerror = function(err) {
                callback(err);
              };
            };
            genOp.onerror = function(err) {
              callback(err);
            };
            return;
          }
        } else {
          if (_detectNodeCrypto("generateKeyPairSync")) {
            var keypair = _crypto.generateKeyPairSync("rsa", {
              modulusLength: bits,
              publicExponent: e,
              publicKeyEncoding: {
                type: "spki",
                format: "pem"
              },
              privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
              }
            });
            return {
              privateKey: pki.privateKeyFromPem(keypair.privateKey),
              publicKey: pki.publicKeyFromPem(keypair.publicKey)
            };
          }
        }
      }
      var state = pki.rsa.createKeyPairGenerationState(bits, e, options);
      if (!callback) {
        pki.rsa.stepKeyPairGenerationState(state, 0);
        return state.keys;
      }
      _generateKeyPair(state, options, callback);
    };
    pki.setRsaPublicKey = pki.rsa.setPublicKey = function(n2, e) {
      var key = {
        n: n2,
        e
      };
      key.encrypt = function(data, scheme, schemeOptions) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSAES-PKCS1-V1_5";
        }
        if (scheme === "RSAES-PKCS1-V1_5") {
          scheme = {
            encode: function(m, key2, pub) {
              return _encodePkcs1_v1_5(m, key2, 2).getBytes();
            }
          };
        } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
          scheme = {
            encode: function(m, key2) {
              return forge.pkcs1.encode_rsa_oaep(key2, m, schemeOptions);
            }
          };
        } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
          scheme = { encode: function(e3) {
            return e3;
          } };
        } else if (typeof scheme === "string") {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        var e2 = scheme.encode(data, key, true);
        return pki.rsa.encrypt(e2, key, true);
      };
      key.verify = function(digest, signature, scheme, options) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSASSA-PKCS1-V1_5";
        }
        if (options === void 0) {
          options = {
            _parseAllDigestBytes: true
          };
        }
        if (!("_parseAllDigestBytes" in options)) {
          options._parseAllDigestBytes = true;
        }
        if (scheme === "RSASSA-PKCS1-V1_5") {
          scheme = {
            verify: function(digest2, d2) {
              d2 = _decodePkcs1_v1_5(d2, key, true);
              var obj = asn1.fromDer(d2, {
                parseAllBytes: options._parseAllDigestBytes
              });
              var capture = {};
              var errors = [];
              if (!asn1.validate(obj, digestInfoValidator, capture, errors)) {
                var error = new Error(
                  "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value."
                );
                error.errors = errors;
                throw error;
              }
              var oid = asn1.derToOid(capture.algorithmIdentifier);
              if (!(oid === forge.oids.md2 || oid === forge.oids.md5 || oid === forge.oids.sha1 || oid === forge.oids.sha224 || oid === forge.oids.sha256 || oid === forge.oids.sha384 || oid === forge.oids.sha512 || oid === forge.oids["sha512-224"] || oid === forge.oids["sha512-256"])) {
                var error = new Error(
                  "Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier."
                );
                error.oid = oid;
                throw error;
              }
              if (oid === forge.oids.md2 || oid === forge.oids.md5) {
                if (!("parameters" in capture)) {
                  throw new Error(
                    "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifer NULL parameters."
                  );
                }
              }
              return digest2 === capture.digest;
            }
          };
        } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
          scheme = {
            verify: function(digest2, d2) {
              d2 = _decodePkcs1_v1_5(d2, key, true);
              return digest2 === d2;
            }
          };
        }
        var d = pki.rsa.decrypt(signature, key, true, false);
        return scheme.verify(digest, d, key.n.bitLength());
      };
      return key;
    };
    pki.setRsaPrivateKey = pki.rsa.setPrivateKey = function(n2, e, d, p2, q3, dP, dQ, qInv) {
      var key = {
        n: n2,
        e,
        d,
        p: p2,
        q: q3,
        dP,
        dQ,
        qInv
      };
      key.decrypt = function(data, scheme, schemeOptions) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSAES-PKCS1-V1_5";
        }
        var d2 = pki.rsa.decrypt(data, key, false, false);
        if (scheme === "RSAES-PKCS1-V1_5") {
          scheme = { decode: _decodePkcs1_v1_5 };
        } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
          scheme = {
            decode: function(d3, key2) {
              return forge.pkcs1.decode_rsa_oaep(key2, d3, schemeOptions);
            }
          };
        } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
          scheme = { decode: function(d3) {
            return d3;
          } };
        } else {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        return scheme.decode(d2, key, false);
      };
      key.sign = function(md2, scheme) {
        var bt2 = false;
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        }
        if (scheme === void 0 || scheme === "RSASSA-PKCS1-V1_5") {
          scheme = { encode: emsaPkcs1v15encode };
          bt2 = 1;
        } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
          scheme = { encode: function() {
            return md2;
          } };
          bt2 = 1;
        }
        var d2 = scheme.encode(md2, key.n.bitLength());
        return pki.rsa.encrypt(d2, key, bt2);
      };
      return key;
    };
    pki.wrapRsaPrivateKey = function(rsaKey) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version (0)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(0).getBytes()
        ),
        // privateKeyAlgorithm
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(pki.oids.rsaEncryption).getBytes()
          ),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        // PrivateKey
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          asn1.toDer(rsaKey).getBytes()
        )
      ]);
    };
    pki.privateKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (asn1.validate(obj, privateKeyValidator, capture, errors)) {
        obj = asn1.fromDer(forge.util.createBuffer(capture.privateKey));
      }
      capture = {};
      errors = [];
      if (!asn1.validate(obj, rsaPrivateKeyValidator, capture, errors)) {
        var error = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
        error.errors = errors;
        throw error;
      }
      var n2, e, d, p2, q3, dP, dQ, qInv;
      n2 = forge.util.createBuffer(capture.privateKeyModulus).toHex();
      e = forge.util.createBuffer(capture.privateKeyPublicExponent).toHex();
      d = forge.util.createBuffer(capture.privateKeyPrivateExponent).toHex();
      p2 = forge.util.createBuffer(capture.privateKeyPrime1).toHex();
      q3 = forge.util.createBuffer(capture.privateKeyPrime2).toHex();
      dP = forge.util.createBuffer(capture.privateKeyExponent1).toHex();
      dQ = forge.util.createBuffer(capture.privateKeyExponent2).toHex();
      qInv = forge.util.createBuffer(capture.privateKeyCoefficient).toHex();
      return pki.setRsaPrivateKey(
        new BigInteger(n2, 16),
        new BigInteger(e, 16),
        new BigInteger(d, 16),
        new BigInteger(p2, 16),
        new BigInteger(q3, 16),
        new BigInteger(dP, 16),
        new BigInteger(dQ, 16),
        new BigInteger(qInv, 16)
      );
    };
    pki.privateKeyToAsn1 = pki.privateKeyToRSAPrivateKey = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version (0 = only 2 primes, 1 multiple primes)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(0).getBytes()
        ),
        // modulus (n)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.n)
        ),
        // publicExponent (e)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.e)
        ),
        // privateExponent (d)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.d)
        ),
        // privateKeyPrime1 (p)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.p)
        ),
        // privateKeyPrime2 (q)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.q)
        ),
        // privateKeyExponent1 (dP)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.dP)
        ),
        // privateKeyExponent2 (dQ)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.dQ)
        ),
        // coefficient (qInv)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.qInv)
        )
      ]);
    };
    pki.publicKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (asn1.validate(obj, publicKeyValidator, capture, errors)) {
        var oid = asn1.derToOid(capture.publicKeyOid);
        if (oid !== pki.oids.rsaEncryption) {
          var error = new Error("Cannot read public key. Unknown OID.");
          error.oid = oid;
          throw error;
        }
        obj = capture.rsaPublicKey;
      }
      errors = [];
      if (!asn1.validate(obj, rsaPublicKeyValidator, capture, errors)) {
        var error = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
        error.errors = errors;
        throw error;
      }
      var n2 = forge.util.createBuffer(capture.publicKeyModulus).toHex();
      var e = forge.util.createBuffer(capture.publicKeyExponent).toHex();
      return pki.setRsaPublicKey(
        new BigInteger(n2, 16),
        new BigInteger(e, 16)
      );
    };
    pki.publicKeyToAsn1 = pki.publicKeyToSubjectPublicKeyInfo = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // AlgorithmIdentifier
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(pki.oids.rsaEncryption).getBytes()
          ),
          // parameters (null)
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        // subjectPublicKey
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [
          pki.publicKeyToRSAPublicKey(key)
        ])
      ]);
    };
    pki.publicKeyToRSAPublicKey = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // modulus (n)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.n)
        ),
        // publicExponent (e)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.e)
        )
      ]);
    };
    function _encodePkcs1_v1_5(m, key, bt2) {
      var eb2 = forge.util.createBuffer();
      var k3 = Math.ceil(key.n.bitLength() / 8);
      if (m.length > k3 - 11) {
        var error = new Error("Message is too long for PKCS#1 v1.5 padding.");
        error.length = m.length;
        error.max = k3 - 11;
        throw error;
      }
      eb2.putByte(0);
      eb2.putByte(bt2);
      var padNum = k3 - 3 - m.length;
      var padByte;
      if (bt2 === 0 || bt2 === 1) {
        padByte = bt2 === 0 ? 0 : 255;
        for (var i2 = 0; i2 < padNum; ++i2) {
          eb2.putByte(padByte);
        }
      } else {
        while (padNum > 0) {
          var numZeros = 0;
          var padBytes = forge.random.getBytes(padNum);
          for (var i2 = 0; i2 < padNum; ++i2) {
            padByte = padBytes.charCodeAt(i2);
            if (padByte === 0) {
              ++numZeros;
            } else {
              eb2.putByte(padByte);
            }
          }
          padNum = numZeros;
        }
      }
      eb2.putByte(0);
      eb2.putBytes(m);
      return eb2;
    }
    function _decodePkcs1_v1_5(em, key, pub, ml) {
      var k3 = Math.ceil(key.n.bitLength() / 8);
      var eb2 = forge.util.createBuffer(em);
      var first2 = eb2.getByte();
      var bt2 = eb2.getByte();
      if (first2 !== 0 || pub && bt2 !== 0 && bt2 !== 1 || !pub && bt2 != 2 || pub && bt2 === 0 && typeof ml === "undefined") {
        throw new Error("Encryption block is invalid.");
      }
      var padNum = 0;
      if (bt2 === 0) {
        padNum = k3 - 3 - ml;
        for (var i2 = 0; i2 < padNum; ++i2) {
          if (eb2.getByte() !== 0) {
            throw new Error("Encryption block is invalid.");
          }
        }
      } else if (bt2 === 1) {
        padNum = 0;
        while (eb2.length() > 1) {
          if (eb2.getByte() !== 255) {
            --eb2.read;
            break;
          }
          ++padNum;
        }
      } else if (bt2 === 2) {
        padNum = 0;
        while (eb2.length() > 1) {
          if (eb2.getByte() === 0) {
            --eb2.read;
            break;
          }
          ++padNum;
        }
      }
      var zero = eb2.getByte();
      if (zero !== 0 || padNum !== k3 - 3 - eb2.length()) {
        throw new Error("Encryption block is invalid.");
      }
      return eb2.getBytes();
    }
    function _generateKeyPair(state, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      var opts = {
        algorithm: {
          name: options.algorithm || "PRIMEINC",
          options: {
            workers: options.workers || 2,
            workLoad: options.workLoad || 100,
            workerScript: options.workerScript
          }
        }
      };
      if ("prng" in options) {
        opts.prng = options.prng;
      }
      generate2();
      function generate2() {
        getPrime(state.pBits, function(err, num) {
          if (err) {
            return callback(err);
          }
          state.p = num;
          if (state.q !== null) {
            return finish(err, state.q);
          }
          getPrime(state.qBits, finish);
        });
      }
      function getPrime(bits, callback2) {
        forge.prime.generateProbablePrime(bits, opts, callback2);
      }
      function finish(err, num) {
        if (err) {
          return callback(err);
        }
        state.q = num;
        if (state.p.compareTo(state.q) < 0) {
          var tmp = state.p;
          state.p = state.q;
          state.q = tmp;
        }
        if (state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.p = null;
          generate2();
          return;
        }
        if (state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.q = null;
          getPrime(state.qBits, finish);
          return;
        }
        state.p1 = state.p.subtract(BigInteger.ONE);
        state.q1 = state.q.subtract(BigInteger.ONE);
        state.phi = state.p1.multiply(state.q1);
        if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.p = state.q = null;
          generate2();
          return;
        }
        state.n = state.p.multiply(state.q);
        if (state.n.bitLength() !== state.bits) {
          state.q = null;
          getPrime(state.qBits, finish);
          return;
        }
        var d = state.e.modInverse(state.phi);
        state.keys = {
          privateKey: pki.rsa.setPrivateKey(
            state.n,
            state.e,
            d,
            state.p,
            state.q,
            d.mod(state.p1),
            d.mod(state.q1),
            state.q.modInverse(state.p)
          ),
          publicKey: pki.rsa.setPublicKey(state.n, state.e)
        };
        callback(null, state.keys);
      }
    }
    function _bnToBytes(b2) {
      var hex = b2.toString(16);
      if (hex[0] >= "8") {
        hex = "00" + hex;
      }
      var bytes = forge.util.hexToBytes(hex);
      if (bytes.length > 1 && // leading 0x00 for positive integer
      (bytes.charCodeAt(0) === 0 && (bytes.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer
      bytes.charCodeAt(0) === 255 && (bytes.charCodeAt(1) & 128) === 128)) {
        return bytes.substr(1);
      }
      return bytes;
    }
    function _getMillerRabinTests(bits) {
      if (bits <= 100)
        return 27;
      if (bits <= 150)
        return 18;
      if (bits <= 200)
        return 15;
      if (bits <= 250)
        return 12;
      if (bits <= 300)
        return 9;
      if (bits <= 350)
        return 8;
      if (bits <= 400)
        return 7;
      if (bits <= 500)
        return 6;
      if (bits <= 600)
        return 5;
      if (bits <= 800)
        return 4;
      if (bits <= 1250)
        return 3;
      return 2;
    }
    function _detectNodeCrypto(fn2) {
      return forge.util.isNodejs && typeof _crypto[fn2] === "function";
    }
    function _detectSubtleCrypto(fn2) {
      return typeof util.globalScope !== "undefined" && typeof util.globalScope.crypto === "object" && typeof util.globalScope.crypto.subtle === "object" && typeof util.globalScope.crypto.subtle[fn2] === "function";
    }
    function _detectSubtleMsCrypto(fn2) {
      return typeof util.globalScope !== "undefined" && typeof util.globalScope.msCrypto === "object" && typeof util.globalScope.msCrypto.subtle === "object" && typeof util.globalScope.msCrypto.subtle[fn2] === "function";
    }
    function _intToUint8Array(x3) {
      var bytes = forge.util.hexToBytes(x3.toString(16));
      var buffer = new Uint8Array(bytes.length);
      for (var i2 = 0; i2 < bytes.length; ++i2) {
        buffer[i2] = bytes.charCodeAt(i2);
      }
      return buffer;
    }
  }
});

// node_modules/node-forge/lib/pbe.js
var require_pbe = __commonJS({
  "node_modules/node-forge/lib/pbe.js"(exports, module) {
    var forge = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_md();
    require_oids();
    require_pbkdf2();
    require_pem();
    require_random();
    require_rc2();
    require_rsa();
    require_util2();
    if (typeof BigInteger === "undefined") {
      BigInteger = forge.jsbn.BigInteger;
    }
    var BigInteger;
    var asn1 = forge.asn1;
    var pki = forge.pki = forge.pki || {};
    module.exports = pki.pbe = forge.pbe = forge.pbe || {};
    var oids = pki.oids;
    var encryptedPrivateKeyValidator = {
      name: "EncryptedPrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encryptionOid"
        }, {
          name: "AlgorithmIdentifier.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "encryptionParams"
        }]
      }, {
        // encryptedData
        name: "EncryptedPrivateKeyInfo.encryptedData",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "encryptedData"
      }]
    };
    var PBES2AlgorithmsValidator = {
      name: "PBES2Algorithms",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "PBES2Algorithms.keyDerivationFunc",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.keyDerivationFunc.oid",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "kdfOid"
        }, {
          name: "PBES2Algorithms.params",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "PBES2Algorithms.params.salt",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: false,
            capture: "kdfSalt"
          }, {
            name: "PBES2Algorithms.params.iterationCount",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "kdfIterationCount"
          }, {
            name: "PBES2Algorithms.params.keyLength",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            optional: true,
            capture: "keyLength"
          }, {
            // prf
            name: "PBES2Algorithms.params.prf",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            optional: true,
            value: [{
              name: "PBES2Algorithms.params.prf.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "prfOid"
            }]
          }]
        }]
      }, {
        name: "PBES2Algorithms.encryptionScheme",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.encryptionScheme.oid",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encOid"
        }, {
          name: "PBES2Algorithms.encryptionScheme.iv",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: false,
          capture: "encIv"
        }]
      }]
    };
    var pkcs12PbeParamsValidator = {
      name: "pkcs-12PbeParams",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "pkcs-12PbeParams.salt",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "salt"
      }, {
        name: "pkcs-12PbeParams.iterations",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "iterations"
      }]
    };
    pki.encryptPrivateKeyInfo = function(obj, password, options) {
      options = options || {};
      options.saltSize = options.saltSize || 8;
      options.count = options.count || 2048;
      options.algorithm = options.algorithm || "aes128";
      options.prfAlgorithm = options.prfAlgorithm || "sha1";
      var salt = forge.random.getBytesSync(options.saltSize);
      var count = options.count;
      var countBytes = asn1.integerToDer(count);
      var dkLen;
      var encryptionAlgorithm;
      var encryptedData;
      if (options.algorithm.indexOf("aes") === 0 || options.algorithm === "des") {
        var ivLen, encOid, cipherFn;
        switch (options.algorithm) {
          case "aes128":
            dkLen = 16;
            ivLen = 16;
            encOid = oids["aes128-CBC"];
            cipherFn = forge.aes.createEncryptionCipher;
            break;
          case "aes192":
            dkLen = 24;
            ivLen = 16;
            encOid = oids["aes192-CBC"];
            cipherFn = forge.aes.createEncryptionCipher;
            break;
          case "aes256":
            dkLen = 32;
            ivLen = 16;
            encOid = oids["aes256-CBC"];
            cipherFn = forge.aes.createEncryptionCipher;
            break;
          case "des":
            dkLen = 8;
            ivLen = 8;
            encOid = oids["desCBC"];
            cipherFn = forge.des.createEncryptionCipher;
            break;
          default:
            var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
            error.algorithm = options.algorithm;
            throw error;
        }
        var prfAlgorithm = "hmacWith" + options.prfAlgorithm.toUpperCase();
        var md2 = prfAlgorithmToMessageDigest(prfAlgorithm);
        var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md2);
        var iv = forge.random.getBytesSync(ivLen);
        var cipher = cipherFn(dk);
        cipher.start(iv);
        cipher.update(asn1.toDer(obj));
        cipher.finish();
        encryptedData = cipher.output.getBytes();
        var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);
        encryptionAlgorithm = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(oids["pkcs5PBES2"]).getBytes()
            ),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // keyDerivationFunc
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(oids["pkcs5PBKDF2"]).getBytes()
                ),
                // PBKDF2-params
                params
              ]),
              // encryptionScheme
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(encOid).getBytes()
                ),
                // iv
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OCTETSTRING,
                  false,
                  iv
                )
              ])
            ])
          ]
        );
      } else if (options.algorithm === "3des") {
        dkLen = 24;
        var saltBytes = new forge.util.ByteBuffer(salt);
        var dk = pki.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);
        var iv = pki.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);
        var cipher = forge.des.createEncryptionCipher(dk);
        cipher.start(iv);
        cipher.update(asn1.toDer(obj));
        cipher.finish();
        encryptedData = cipher.output.getBytes();
        encryptionAlgorithm = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()
            ),
            // pkcs-12PbeParams
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // salt
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),
              // iteration count
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                countBytes.getBytes()
              )
            ])
          ]
        );
      } else {
        var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
        error.algorithm = options.algorithm;
        throw error;
      }
      var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // encryptionAlgorithm
        encryptionAlgorithm,
        // encryptedData
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          encryptedData
        )
      ]);
      return rval;
    };
    pki.decryptPrivateKeyInfo = function(obj, password) {
      var rval = null;
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, encryptedPrivateKeyValidator, capture, errors)) {
        var error = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors;
        throw error;
      }
      var oid = asn1.derToOid(capture.encryptionOid);
      var cipher = pki.pbe.getCipher(oid, capture.encryptionParams, password);
      var encrypted = forge.util.createBuffer(capture.encryptedData);
      cipher.update(encrypted);
      if (cipher.finish()) {
        rval = asn1.fromDer(cipher.output);
      }
      return rval;
    };
    pki.encryptedPrivateKeyToPem = function(epki, maxline) {
      var msg = {
        type: "ENCRYPTED PRIVATE KEY",
        body: asn1.toDer(epki).getBytes()
      };
      return forge.pem.encode(msg, { maxline });
    };
    pki.encryptedPrivateKeyFromPem = function(pem) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== "ENCRYPTED PRIVATE KEY") {
        var error = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
      }
      return asn1.fromDer(msg.body);
    };
    pki.encryptRsaPrivateKey = function(rsaKey, password, options) {
      options = options || {};
      if (!options.legacy) {
        var rval = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey));
        rval = pki.encryptPrivateKeyInfo(rval, password, options);
        return pki.encryptedPrivateKeyToPem(rval);
      }
      var algorithm;
      var iv;
      var dkLen;
      var cipherFn;
      switch (options.algorithm) {
        case "aes128":
          algorithm = "AES-128-CBC";
          dkLen = 16;
          iv = forge.random.getBytesSync(16);
          cipherFn = forge.aes.createEncryptionCipher;
          break;
        case "aes192":
          algorithm = "AES-192-CBC";
          dkLen = 24;
          iv = forge.random.getBytesSync(16);
          cipherFn = forge.aes.createEncryptionCipher;
          break;
        case "aes256":
          algorithm = "AES-256-CBC";
          dkLen = 32;
          iv = forge.random.getBytesSync(16);
          cipherFn = forge.aes.createEncryptionCipher;
          break;
        case "3des":
          algorithm = "DES-EDE3-CBC";
          dkLen = 24;
          iv = forge.random.getBytesSync(8);
          cipherFn = forge.des.createEncryptionCipher;
          break;
        case "des":
          algorithm = "DES-CBC";
          dkLen = 8;
          iv = forge.random.getBytesSync(8);
          cipherFn = forge.des.createEncryptionCipher;
          break;
        default:
          var error = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + options.algorithm + '".');
          error.algorithm = options.algorithm;
          throw error;
      }
      var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
      var cipher = cipherFn(dk);
      cipher.start(iv);
      cipher.update(asn1.toDer(pki.privateKeyToAsn1(rsaKey)));
      cipher.finish();
      var msg = {
        type: "RSA PRIVATE KEY",
        procType: {
          version: "4",
          type: "ENCRYPTED"
        },
        dekInfo: {
          algorithm,
          parameters: forge.util.bytesToHex(iv).toUpperCase()
        },
        body: cipher.output.getBytes()
      };
      return forge.pem.encode(msg);
    };
    pki.decryptRsaPrivateKey = function(pem, password) {
      var rval = null;
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== "ENCRYPTED PRIVATE KEY" && msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
        var error = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
        error.headerType = error;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        var dkLen;
        var cipherFn;
        switch (msg.dekInfo.algorithm) {
          case "DES-CBC":
            dkLen = 8;
            cipherFn = forge.des.createDecryptionCipher;
            break;
          case "DES-EDE3-CBC":
            dkLen = 24;
            cipherFn = forge.des.createDecryptionCipher;
            break;
          case "AES-128-CBC":
            dkLen = 16;
            cipherFn = forge.aes.createDecryptionCipher;
            break;
          case "AES-192-CBC":
            dkLen = 24;
            cipherFn = forge.aes.createDecryptionCipher;
            break;
          case "AES-256-CBC":
            dkLen = 32;
            cipherFn = forge.aes.createDecryptionCipher;
            break;
          case "RC2-40-CBC":
            dkLen = 5;
            cipherFn = function(key) {
              return forge.rc2.createDecryptionCipher(key, 40);
            };
            break;
          case "RC2-64-CBC":
            dkLen = 8;
            cipherFn = function(key) {
              return forge.rc2.createDecryptionCipher(key, 64);
            };
            break;
          case "RC2-128-CBC":
            dkLen = 16;
            cipherFn = function(key) {
              return forge.rc2.createDecryptionCipher(key, 128);
            };
            break;
          default:
            var error = new Error('Could not decrypt private key; unsupported encryption algorithm "' + msg.dekInfo.algorithm + '".');
            error.algorithm = msg.dekInfo.algorithm;
            throw error;
        }
        var iv = forge.util.hexToBytes(msg.dekInfo.parameters);
        var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
        var cipher = cipherFn(dk);
        cipher.start(iv);
        cipher.update(forge.util.createBuffer(msg.body));
        if (cipher.finish()) {
          rval = cipher.output.getBytes();
        } else {
          return rval;
        }
      } else {
        rval = msg.body;
      }
      if (msg.type === "ENCRYPTED PRIVATE KEY") {
        rval = pki.decryptPrivateKeyInfo(asn1.fromDer(rval), password);
      } else {
        rval = asn1.fromDer(rval);
      }
      if (rval !== null) {
        rval = pki.privateKeyFromAsn1(rval);
      }
      return rval;
    };
    pki.pbe.generatePkcs12Key = function(password, salt, id2, iter, n2, md2) {
      var j2, l;
      if (typeof md2 === "undefined" || md2 === null) {
        if (!("sha1" in forge.md)) {
          throw new Error('"sha1" hash algorithm unavailable.');
        }
        md2 = forge.md.sha1.create();
      }
      var u4 = md2.digestLength;
      var v2 = md2.blockLength;
      var result = new forge.util.ByteBuffer();
      var passBuf = new forge.util.ByteBuffer();
      if (password !== null && password !== void 0) {
        for (l = 0; l < password.length; l++) {
          passBuf.putInt16(password.charCodeAt(l));
        }
        passBuf.putInt16(0);
      }
      var p2 = passBuf.length();
      var s = salt.length();
      var D3 = new forge.util.ByteBuffer();
      D3.fillWithByte(id2, v2);
      var Slen = v2 * Math.ceil(s / v2);
      var S3 = new forge.util.ByteBuffer();
      for (l = 0; l < Slen; l++) {
        S3.putByte(salt.at(l % s));
      }
      var Plen = v2 * Math.ceil(p2 / v2);
      var P3 = new forge.util.ByteBuffer();
      for (l = 0; l < Plen; l++) {
        P3.putByte(passBuf.at(l % p2));
      }
      var I3 = S3;
      I3.putBuffer(P3);
      var c = Math.ceil(n2 / u4);
      for (var i2 = 1; i2 <= c; i2++) {
        var buf = new forge.util.ByteBuffer();
        buf.putBytes(D3.bytes());
        buf.putBytes(I3.bytes());
        for (var round = 0; round < iter; round++) {
          md2.start();
          md2.update(buf.getBytes());
          buf = md2.digest();
        }
        var B2 = new forge.util.ByteBuffer();
        for (l = 0; l < v2; l++) {
          B2.putByte(buf.at(l % u4));
        }
        var k3 = Math.ceil(s / v2) + Math.ceil(p2 / v2);
        var Inew = new forge.util.ByteBuffer();
        for (j2 = 0; j2 < k3; j2++) {
          var chunk = new forge.util.ByteBuffer(I3.getBytes(v2));
          var x3 = 511;
          for (l = B2.length() - 1; l >= 0; l--) {
            x3 = x3 >> 8;
            x3 += B2.at(l) + chunk.at(l);
            chunk.setAt(l, x3 & 255);
          }
          Inew.putBuffer(chunk);
        }
        I3 = Inew;
        result.putBuffer(buf);
      }
      result.truncate(result.length() - n2);
      return result;
    };
    pki.pbe.getCipher = function(oid, params, password) {
      switch (oid) {
        case pki.oids["pkcs5PBES2"]:
          return pki.pbe.getCipherForPBES2(oid, params, password);
        case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
        case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
          return pki.pbe.getCipherForPKCS12PBE(oid, params, password);
        default:
          var error = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
          error.oid = oid;
          error.supportedOids = [
            "pkcs5PBES2",
            "pbeWithSHAAnd3-KeyTripleDES-CBC",
            "pbewithSHAAnd40BitRC2-CBC"
          ];
          throw error;
      }
    };
    pki.pbe.getCipherForPBES2 = function(oid, params, password) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(params, PBES2AlgorithmsValidator, capture, errors)) {
        var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors;
        throw error;
      }
      oid = asn1.derToOid(capture.kdfOid);
      if (oid !== pki.oids["pkcs5PBKDF2"]) {
        var error = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
        error.oid = oid;
        error.supportedOids = ["pkcs5PBKDF2"];
        throw error;
      }
      oid = asn1.derToOid(capture.encOid);
      if (oid !== pki.oids["aes128-CBC"] && oid !== pki.oids["aes192-CBC"] && oid !== pki.oids["aes256-CBC"] && oid !== pki.oids["des-EDE3-CBC"] && oid !== pki.oids["desCBC"]) {
        var error = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
        error.oid = oid;
        error.supportedOids = [
          "aes128-CBC",
          "aes192-CBC",
          "aes256-CBC",
          "des-EDE3-CBC",
          "desCBC"
        ];
        throw error;
      }
      var salt = capture.kdfSalt;
      var count = forge.util.createBuffer(capture.kdfIterationCount);
      count = count.getInt(count.length() << 3);
      var dkLen;
      var cipherFn;
      switch (pki.oids[oid]) {
        case "aes128-CBC":
          dkLen = 16;
          cipherFn = forge.aes.createDecryptionCipher;
          break;
        case "aes192-CBC":
          dkLen = 24;
          cipherFn = forge.aes.createDecryptionCipher;
          break;
        case "aes256-CBC":
          dkLen = 32;
          cipherFn = forge.aes.createDecryptionCipher;
          break;
        case "des-EDE3-CBC":
          dkLen = 24;
          cipherFn = forge.des.createDecryptionCipher;
          break;
        case "desCBC":
          dkLen = 8;
          cipherFn = forge.des.createDecryptionCipher;
          break;
      }
      var md2 = prfOidToMessageDigest(capture.prfOid);
      var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md2);
      var iv = capture.encIv;
      var cipher = cipherFn(dk);
      cipher.start(iv);
      return cipher;
    };
    pki.pbe.getCipherForPKCS12PBE = function(oid, params, password) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(params, pkcs12PbeParamsValidator, capture, errors)) {
        var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors;
        throw error;
      }
      var salt = forge.util.createBuffer(capture.salt);
      var count = forge.util.createBuffer(capture.iterations);
      count = count.getInt(count.length() << 3);
      var dkLen, dIvLen, cipherFn;
      switch (oid) {
        case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
          dkLen = 24;
          dIvLen = 8;
          cipherFn = forge.des.startDecrypting;
          break;
        case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
          dkLen = 5;
          dIvLen = 8;
          cipherFn = function(key2, iv2) {
            var cipher = forge.rc2.createDecryptionCipher(key2, 40);
            cipher.start(iv2, null);
            return cipher;
          };
          break;
        default:
          var error = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
          error.oid = oid;
          throw error;
      }
      var md2 = prfOidToMessageDigest(capture.prfOid);
      var key = pki.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md2);
      md2.start();
      var iv = pki.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md2);
      return cipherFn(key, iv);
    };
    pki.pbe.opensslDeriveBytes = function(password, salt, dkLen, md2) {
      if (typeof md2 === "undefined" || md2 === null) {
        if (!("md5" in forge.md)) {
          throw new Error('"md5" hash algorithm unavailable.');
        }
        md2 = forge.md.md5.create();
      }
      if (salt === null) {
        salt = "";
      }
      var digests = [hash(md2, password + salt)];
      for (var length = 16, i2 = 1; length < dkLen; ++i2, length += 16) {
        digests.push(hash(md2, digests[i2 - 1] + password + salt));
      }
      return digests.join("").substr(0, dkLen);
    };
    function hash(md2, bytes) {
      return md2.start().update(bytes).digest().getBytes();
    }
    function prfOidToMessageDigest(prfOid) {
      var prfAlgorithm;
      if (!prfOid) {
        prfAlgorithm = "hmacWithSHA1";
      } else {
        prfAlgorithm = pki.oids[asn1.derToOid(prfOid)];
        if (!prfAlgorithm) {
          var error = new Error("Unsupported PRF OID.");
          error.oid = prfOid;
          error.supported = [
            "hmacWithSHA1",
            "hmacWithSHA224",
            "hmacWithSHA256",
            "hmacWithSHA384",
            "hmacWithSHA512"
          ];
          throw error;
        }
      }
      return prfAlgorithmToMessageDigest(prfAlgorithm);
    }
    function prfAlgorithmToMessageDigest(prfAlgorithm) {
      var factory2 = forge.md;
      switch (prfAlgorithm) {
        case "hmacWithSHA224":
          factory2 = forge.md.sha512;
        case "hmacWithSHA1":
        case "hmacWithSHA256":
        case "hmacWithSHA384":
        case "hmacWithSHA512":
          prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();
          break;
        default:
          var error = new Error("Unsupported PRF algorithm.");
          error.algorithm = prfAlgorithm;
          error.supported = [
            "hmacWithSHA1",
            "hmacWithSHA224",
            "hmacWithSHA256",
            "hmacWithSHA384",
            "hmacWithSHA512"
          ];
          throw error;
      }
      if (!factory2 || !(prfAlgorithm in factory2)) {
        throw new Error("Unknown hash algorithm: " + prfAlgorithm);
      }
      return factory2[prfAlgorithm].create();
    }
    function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {
      var params = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // salt
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          salt
        ),
        // iteration count
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          countBytes.getBytes()
        )
      ]);
      if (prfAlgorithm !== "hmacWithSHA1") {
        params.value.push(
          // key length
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            forge.util.hexToBytes(dkLen.toString(16))
          ),
          // AlgorithmIdentifier
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // algorithm
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki.oids[prfAlgorithm]).getBytes()
            ),
            // parameters (null)
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
          ])
        );
      }
      return params;
    }
  }
});

// node_modules/node-forge/lib/pkcs7asn1.js
var require_pkcs7asn1 = __commonJS({
  "node_modules/node-forge/lib/pkcs7asn1.js"(exports, module) {
    var forge = require_forge();
    require_asn1();
    require_util2();
    var asn1 = forge.asn1;
    var p7v = module.exports = forge.pkcs7asn1 = forge.pkcs7asn1 || {};
    forge.pkcs7 = forge.pkcs7 || {};
    forge.pkcs7.asn1 = p7v;
    var contentInfoValidator = {
      name: "ContentInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "ContentInfo.ContentType",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "ContentInfo.content",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        captureAsn1: "content"
      }]
    };
    p7v.contentInfoValidator = contentInfoValidator;
    var encryptedContentInfoValidator = {
      name: "EncryptedContentInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedContentInfo.contentType",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "EncryptedContentInfo.contentEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encAlgorithm"
        }, {
          name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          captureAsn1: "encParameter"
        }]
      }, {
        name: "EncryptedContentInfo.encryptedContent",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        /* The PKCS#7 structure output by OpenSSL somewhat differs from what
         * other implementations do generate.
         *
         * OpenSSL generates a structure like this:
         * SEQUENCE {
         *    ...
         *    [0]
         *       26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
         *       C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
         *       ...
         * }
         *
         * Whereas other implementations (and this PKCS#7 module) generate:
         * SEQUENCE {
         *    ...
         *    [0] {
         *       OCTET STRING
         *          26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
         *          C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
         *          ...
         *    }
         * }
         *
         * In order to support both, we just capture the context specific
         * field here.  The OCTET STRING bit is removed below.
         */
        capture: "encryptedContent",
        captureAsn1: "encryptedContentAsn1"
      }]
    };
    p7v.envelopedDataValidator = {
      name: "EnvelopedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EnvelopedData.Version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }, {
        name: "EnvelopedData.RecipientInfos",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        captureAsn1: "recipientInfos"
      }].concat(encryptedContentInfoValidator)
    };
    p7v.encryptedDataValidator = {
      name: "EncryptedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedData.Version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }].concat(encryptedContentInfoValidator)
    };
    var signerValidator = {
      name: "SignerInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "SignerInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false
      }, {
        name: "SignerInfo.issuerAndSerialNumber",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "SignerInfo.issuerAndSerialNumber.issuer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "issuer"
        }, {
          name: "SignerInfo.issuerAndSerialNumber.serialNumber",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "serial"
        }]
      }, {
        name: "SignerInfo.digestAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "SignerInfo.digestAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "digestAlgorithm"
        }, {
          name: "SignerInfo.digestAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          constructed: false,
          captureAsn1: "digestParameter",
          optional: true
        }]
      }, {
        name: "SignerInfo.authenticatedAttributes",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        capture: "authenticatedAttributes"
      }, {
        name: "SignerInfo.digestEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        capture: "signatureAlgorithm"
      }, {
        name: "SignerInfo.encryptedDigest",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "signature"
      }, {
        name: "SignerInfo.unauthenticatedAttributes",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        optional: true,
        capture: "unauthenticatedAttributes"
      }]
    };
    p7v.signedDataValidator = {
      name: "SignedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "SignedData.Version",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "version"
        },
        {
          name: "SignedData.DigestAlgorithms",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SET,
          constructed: true,
          captureAsn1: "digestAlgorithms"
        },
        contentInfoValidator,
        {
          name: "SignedData.Certificates",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          optional: true,
          captureAsn1: "certificates"
        },
        {
          name: "SignedData.CertificateRevocationLists",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 1,
          optional: true,
          captureAsn1: "crls"
        },
        {
          name: "SignedData.SignerInfos",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SET,
          capture: "signerInfos",
          optional: true,
          value: [signerValidator]
        }
      ]
    };
    p7v.recipientInfoValidator = {
      name: "RecipientInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "RecipientInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }, {
        name: "RecipientInfo.issuerAndSerial",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "RecipientInfo.issuerAndSerial.issuer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "issuer"
        }, {
          name: "RecipientInfo.issuerAndSerial.serialNumber",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "serial"
        }]
      }, {
        name: "RecipientInfo.keyEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encAlgorithm"
        }, {
          name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          constructed: false,
          captureAsn1: "encParameter",
          optional: true
        }]
      }, {
        name: "RecipientInfo.encryptedKey",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "encKey"
      }]
    };
  }
});

// node_modules/node-forge/lib/mgf1.js
var require_mgf1 = __commonJS({
  "node_modules/node-forge/lib/mgf1.js"(exports, module) {
    var forge = require_forge();
    require_util2();
    forge.mgf = forge.mgf || {};
    var mgf1 = module.exports = forge.mgf.mgf1 = forge.mgf1 = forge.mgf1 || {};
    mgf1.create = function(md2) {
      var mgf = {
        /**
         * Generate mask of specified length.
         *
         * @param {String} seed The seed for mask generation.
         * @param maskLen Number of bytes to generate.
         * @return {String} The generated mask.
         */
        generate: function(seed, maskLen) {
          var t = new forge.util.ByteBuffer();
          var len = Math.ceil(maskLen / md2.digestLength);
          for (var i2 = 0; i2 < len; i2++) {
            var c = new forge.util.ByteBuffer();
            c.putInt32(i2);
            md2.start();
            md2.update(seed + c.getBytes());
            t.putBuffer(md2.digest());
          }
          t.truncate(t.length() - maskLen);
          return t.getBytes();
        }
      };
      return mgf;
    };
  }
});

// node_modules/node-forge/lib/mgf.js
var require_mgf = __commonJS({
  "node_modules/node-forge/lib/mgf.js"(exports, module) {
    var forge = require_forge();
    require_mgf1();
    module.exports = forge.mgf = forge.mgf || {};
    forge.mgf.mgf1 = forge.mgf1;
  }
});

// node_modules/node-forge/lib/pss.js
var require_pss = __commonJS({
  "node_modules/node-forge/lib/pss.js"(exports, module) {
    var forge = require_forge();
    require_random();
    require_util2();
    var pss = module.exports = forge.pss = forge.pss || {};
    pss.create = function(options) {
      if (arguments.length === 3) {
        options = {
          md: arguments[0],
          mgf: arguments[1],
          saltLength: arguments[2]
        };
      }
      var hash = options.md;
      var mgf = options.mgf;
      var hLen = hash.digestLength;
      var salt_ = options.salt || null;
      if (typeof salt_ === "string") {
        salt_ = forge.util.createBuffer(salt_);
      }
      var sLen;
      if ("saltLength" in options) {
        sLen = options.saltLength;
      } else if (salt_ !== null) {
        sLen = salt_.length();
      } else {
        throw new Error("Salt length not specified or specific salt not given.");
      }
      if (salt_ !== null && salt_.length() !== sLen) {
        throw new Error("Given salt length does not match length of given salt.");
      }
      var prng = options.prng || forge.random;
      var pssobj = {};
      pssobj.encode = function(md2, modBits) {
        var i2;
        var emBits = modBits - 1;
        var emLen = Math.ceil(emBits / 8);
        var mHash = md2.digest().getBytes();
        if (emLen < hLen + sLen + 2) {
          throw new Error("Message is too long to encrypt.");
        }
        var salt;
        if (salt_ === null) {
          salt = prng.getBytesSync(sLen);
        } else {
          salt = salt_.bytes();
        }
        var m_ = new forge.util.ByteBuffer();
        m_.fillWithByte(0, 8);
        m_.putBytes(mHash);
        m_.putBytes(salt);
        hash.start();
        hash.update(m_.getBytes());
        var h = hash.digest().getBytes();
        var ps2 = new forge.util.ByteBuffer();
        ps2.fillWithByte(0, emLen - sLen - hLen - 2);
        ps2.putByte(1);
        ps2.putBytes(salt);
        var db2 = ps2.getBytes();
        var maskLen = emLen - hLen - 1;
        var dbMask = mgf.generate(h, maskLen);
        var maskedDB = "";
        for (i2 = 0; i2 < maskLen; i2++) {
          maskedDB += String.fromCharCode(db2.charCodeAt(i2) ^ dbMask.charCodeAt(i2));
        }
        var mask = 65280 >> 8 * emLen - emBits & 255;
        maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) + maskedDB.substr(1);
        return maskedDB + h + String.fromCharCode(188);
      };
      pssobj.verify = function(mHash, em, modBits) {
        var i2;
        var emBits = modBits - 1;
        var emLen = Math.ceil(emBits / 8);
        em = em.substr(-emLen);
        if (emLen < hLen + sLen + 2) {
          throw new Error("Inconsistent parameters to PSS signature verification.");
        }
        if (em.charCodeAt(emLen - 1) !== 188) {
          throw new Error("Encoded message does not end in 0xBC.");
        }
        var maskLen = emLen - hLen - 1;
        var maskedDB = em.substr(0, maskLen);
        var h = em.substr(maskLen, hLen);
        var mask = 65280 >> 8 * emLen - emBits & 255;
        if ((maskedDB.charCodeAt(0) & mask) !== 0) {
          throw new Error("Bits beyond keysize not zero as expected.");
        }
        var dbMask = mgf.generate(h, maskLen);
        var db2 = "";
        for (i2 = 0; i2 < maskLen; i2++) {
          db2 += String.fromCharCode(maskedDB.charCodeAt(i2) ^ dbMask.charCodeAt(i2));
        }
        db2 = String.fromCharCode(db2.charCodeAt(0) & ~mask) + db2.substr(1);
        var checkLen = emLen - hLen - sLen - 2;
        for (i2 = 0; i2 < checkLen; i2++) {
          if (db2.charCodeAt(i2) !== 0) {
            throw new Error("Leftmost octets not zero as expected");
          }
        }
        if (db2.charCodeAt(checkLen) !== 1) {
          throw new Error("Inconsistent PSS signature, 0x01 marker not found");
        }
        var salt = db2.substr(-sLen);
        var m_ = new forge.util.ByteBuffer();
        m_.fillWithByte(0, 8);
        m_.putBytes(mHash);
        m_.putBytes(salt);
        hash.start();
        hash.update(m_.getBytes());
        var h_ = hash.digest().getBytes();
        return h === h_;
      };
      return pssobj;
    };
  }
});

// node_modules/node-forge/lib/x509.js
var require_x509 = __commonJS({
  "node_modules/node-forge/lib/x509.js"(exports, module) {
    var forge = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_md();
    require_mgf();
    require_oids();
    require_pem();
    require_pss();
    require_rsa();
    require_util2();
    var asn1 = forge.asn1;
    var pki = module.exports = forge.pki = forge.pki || {};
    var oids = pki.oids;
    var _shortNames = {};
    _shortNames["CN"] = oids["commonName"];
    _shortNames["commonName"] = "CN";
    _shortNames["C"] = oids["countryName"];
    _shortNames["countryName"] = "C";
    _shortNames["L"] = oids["localityName"];
    _shortNames["localityName"] = "L";
    _shortNames["ST"] = oids["stateOrProvinceName"];
    _shortNames["stateOrProvinceName"] = "ST";
    _shortNames["O"] = oids["organizationName"];
    _shortNames["organizationName"] = "O";
    _shortNames["OU"] = oids["organizationalUnitName"];
    _shortNames["organizationalUnitName"] = "OU";
    _shortNames["E"] = oids["emailAddress"];
    _shortNames["emailAddress"] = "E";
    var publicKeyValidator = forge.pki.rsa.publicKeyValidator;
    var x509CertificateValidator = {
      name: "Certificate",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "Certificate.TBSCertificate",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "tbsCertificate",
        value: [
          {
            name: "Certificate.TBSCertificate.version",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 0,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.version.integer",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.INTEGER,
              constructed: false,
              capture: "certVersion"
            }]
          },
          {
            name: "Certificate.TBSCertificate.serialNumber",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "certSerialNumber"
          },
          {
            name: "Certificate.TBSCertificate.signature",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "Certificate.TBSCertificate.signature.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "certinfoSignatureOid"
            }, {
              name: "Certificate.TBSCertificate.signature.parameters",
              tagClass: asn1.Class.UNIVERSAL,
              optional: true,
              captureAsn1: "certinfoSignatureParams"
            }]
          },
          {
            name: "Certificate.TBSCertificate.issuer",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "certIssuer"
          },
          {
            name: "Certificate.TBSCertificate.validity",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            // Note: UTC and generalized times may both appear so the capture
            // names are based on their detected order, the names used below
            // are only for the common case, which validity time really means
            // "notBefore" and which means "notAfter" will be determined by order
            value: [{
              // notBefore (Time) (UTC time case)
              name: "Certificate.TBSCertificate.validity.notBefore (utc)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.UTCTIME,
              constructed: false,
              optional: true,
              capture: "certValidity1UTCTime"
            }, {
              // notBefore (Time) (generalized time case)
              name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.GENERALIZEDTIME,
              constructed: false,
              optional: true,
              capture: "certValidity2GeneralizedTime"
            }, {
              // notAfter (Time) (only UTC time is supported)
              name: "Certificate.TBSCertificate.validity.notAfter (utc)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.UTCTIME,
              constructed: false,
              optional: true,
              capture: "certValidity3UTCTime"
            }, {
              // notAfter (Time) (only UTC time is supported)
              name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.GENERALIZEDTIME,
              constructed: false,
              optional: true,
              capture: "certValidity4GeneralizedTime"
            }]
          },
          {
            // Name (subject) (RDNSequence)
            name: "Certificate.TBSCertificate.subject",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "certSubject"
          },
          // SubjectPublicKeyInfo
          publicKeyValidator,
          {
            // issuerUniqueID (optional)
            name: "Certificate.TBSCertificate.issuerUniqueID",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 1,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.issuerUniqueID.id",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.BITSTRING,
              constructed: false,
              // TODO: support arbitrary bit length ids
              captureBitStringValue: "certIssuerUniqueId"
            }]
          },
          {
            // subjectUniqueID (optional)
            name: "Certificate.TBSCertificate.subjectUniqueID",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 2,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.subjectUniqueID.id",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.BITSTRING,
              constructed: false,
              // TODO: support arbitrary bit length ids
              captureBitStringValue: "certSubjectUniqueId"
            }]
          },
          {
            // Extensions (optional)
            name: "Certificate.TBSCertificate.extensions",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 3,
            constructed: true,
            captureAsn1: "certExtensions",
            optional: true
          }
        ]
      }, {
        // AlgorithmIdentifier (signature algorithm)
        name: "Certificate.signatureAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          // algorithm
          name: "Certificate.signatureAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "certSignatureOid"
        }, {
          name: "Certificate.TBSCertificate.signature.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          optional: true,
          captureAsn1: "certSignatureParams"
        }]
      }, {
        // SignatureValue
        name: "Certificate.signatureValue",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        captureBitStringValue: "certSignature"
      }]
    };
    var rsassaPssParameterValidator = {
      name: "rsapss",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "rsapss.hashAlgorithm",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        value: [{
          name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "hashOid"
            /* parameter block omitted, for SHA1 NULL anyhow. */
          }]
        }]
      }, {
        name: "rsapss.maskGenAlgorithm",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        value: [{
          name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "maskGenOid"
          }, {
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "maskGenHashOid"
              /* parameter block omitted, for SHA1 NULL anyhow. */
            }]
          }]
        }]
      }, {
        name: "rsapss.saltLength",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 2,
        optional: true,
        value: [{
          name: "rsapss.saltLength.saltLength",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.INTEGER,
          constructed: false,
          capture: "saltLength"
        }]
      }, {
        name: "rsapss.trailerField",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 3,
        optional: true,
        value: [{
          name: "rsapss.trailer.trailer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.INTEGER,
          constructed: false,
          capture: "trailer"
        }]
      }]
    };
    var certificationRequestInfoValidator = {
      name: "CertificationRequestInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "certificationRequestInfo",
      value: [
        {
          name: "CertificationRequestInfo.integer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "certificationRequestInfoVersion"
        },
        {
          // Name (subject) (RDNSequence)
          name: "CertificationRequestInfo.subject",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "certificationRequestInfoSubject"
        },
        // SubjectPublicKeyInfo
        publicKeyValidator,
        {
          name: "CertificationRequestInfo.attributes",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          constructed: true,
          optional: true,
          capture: "certificationRequestInfoAttributes",
          value: [{
            name: "CertificationRequestInfo.attributes",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "CertificationRequestInfo.attributes.type",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false
            }, {
              name: "CertificationRequestInfo.attributes.value",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SET,
              constructed: true
            }]
          }]
        }
      ]
    };
    var certificationRequestValidator = {
      name: "CertificationRequest",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "csr",
      value: [
        certificationRequestInfoValidator,
        {
          // AlgorithmIdentifier (signature algorithm)
          name: "CertificationRequest.signatureAlgorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            // algorithm
            name: "CertificationRequest.signatureAlgorithm.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "csrSignatureOid"
          }, {
            name: "CertificationRequest.signatureAlgorithm.parameters",
            tagClass: asn1.Class.UNIVERSAL,
            optional: true,
            captureAsn1: "csrSignatureParams"
          }]
        },
        {
          // signature
          name: "CertificationRequest.signature",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.BITSTRING,
          constructed: false,
          captureBitStringValue: "csrSignature"
        }
      ]
    };
    pki.RDNAttributesAsArray = function(rdn, md2) {
      var rval = [];
      var set, attr, obj;
      for (var si2 = 0; si2 < rdn.value.length; ++si2) {
        set = rdn.value[si2];
        for (var i2 = 0; i2 < set.value.length; ++i2) {
          obj = {};
          attr = set.value[i2];
          obj.type = asn1.derToOid(attr.value[0].value);
          obj.value = attr.value[1].value;
          obj.valueTagClass = attr.value[1].type;
          if (obj.type in oids) {
            obj.name = oids[obj.type];
            if (obj.name in _shortNames) {
              obj.shortName = _shortNames[obj.name];
            }
          }
          if (md2) {
            md2.update(obj.type);
            md2.update(obj.value);
          }
          rval.push(obj);
        }
      }
      return rval;
    };
    pki.CRIAttributesAsArray = function(attributes) {
      var rval = [];
      for (var si2 = 0; si2 < attributes.length; ++si2) {
        var seq = attributes[si2];
        var type = asn1.derToOid(seq.value[0].value);
        var values = seq.value[1].value;
        for (var vi2 = 0; vi2 < values.length; ++vi2) {
          var obj = {};
          obj.type = type;
          obj.value = values[vi2].value;
          obj.valueTagClass = values[vi2].type;
          if (obj.type in oids) {
            obj.name = oids[obj.type];
            if (obj.name in _shortNames) {
              obj.shortName = _shortNames[obj.name];
            }
          }
          if (obj.type === oids.extensionRequest) {
            obj.extensions = [];
            for (var ei2 = 0; ei2 < obj.value.length; ++ei2) {
              obj.extensions.push(pki.certificateExtensionFromAsn1(obj.value[ei2]));
            }
          }
          rval.push(obj);
        }
      }
      return rval;
    };
    function _getAttribute(obj, options) {
      if (typeof options === "string") {
        options = { shortName: options };
      }
      var rval = null;
      var attr;
      for (var i2 = 0; rval === null && i2 < obj.attributes.length; ++i2) {
        attr = obj.attributes[i2];
        if (options.type && options.type === attr.type) {
          rval = attr;
        } else if (options.name && options.name === attr.name) {
          rval = attr;
        } else if (options.shortName && options.shortName === attr.shortName) {
          rval = attr;
        }
      }
      return rval;
    }
    var _readSignatureParameters = function(oid, obj, fillDefaults) {
      var params = {};
      if (oid !== oids["RSASSA-PSS"]) {
        return params;
      }
      if (fillDefaults) {
        params = {
          hash: {
            algorithmOid: oids["sha1"]
          },
          mgf: {
            algorithmOid: oids["mgf1"],
            hash: {
              algorithmOid: oids["sha1"]
            }
          },
          saltLength: 20
        };
      }
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, rsassaPssParameterValidator, capture, errors)) {
        var error = new Error("Cannot read RSASSA-PSS parameter block.");
        error.errors = errors;
        throw error;
      }
      if (capture.hashOid !== void 0) {
        params.hash = params.hash || {};
        params.hash.algorithmOid = asn1.derToOid(capture.hashOid);
      }
      if (capture.maskGenOid !== void 0) {
        params.mgf = params.mgf || {};
        params.mgf.algorithmOid = asn1.derToOid(capture.maskGenOid);
        params.mgf.hash = params.mgf.hash || {};
        params.mgf.hash.algorithmOid = asn1.derToOid(capture.maskGenHashOid);
      }
      if (capture.saltLength !== void 0) {
        params.saltLength = capture.saltLength.charCodeAt(0);
      }
      return params;
    };
    var _createSignatureDigest = function(options) {
      switch (oids[options.signatureOid]) {
        case "sha1WithRSAEncryption":
        case "sha1WithRSASignature":
          return forge.md.sha1.create();
        case "md5WithRSAEncryption":
          return forge.md.md5.create();
        case "sha256WithRSAEncryption":
          return forge.md.sha256.create();
        case "sha384WithRSAEncryption":
          return forge.md.sha384.create();
        case "sha512WithRSAEncryption":
          return forge.md.sha512.create();
        case "RSASSA-PSS":
          return forge.md.sha256.create();
        default:
          var error = new Error(
            "Could not compute " + options.type + " digest. Unknown signature OID."
          );
          error.signatureOid = options.signatureOid;
          throw error;
      }
    };
    var _verifySignature = function(options) {
      var cert2 = options.certificate;
      var scheme;
      switch (cert2.signatureOid) {
        case oids.sha1WithRSAEncryption:
        case oids.sha1WithRSASignature:
          break;
        case oids["RSASSA-PSS"]:
          var hash, mgf;
          hash = oids[cert2.signatureParameters.mgf.hash.algorithmOid];
          if (hash === void 0 || forge.md[hash] === void 0) {
            var error = new Error("Unsupported MGF hash function.");
            error.oid = cert2.signatureParameters.mgf.hash.algorithmOid;
            error.name = hash;
            throw error;
          }
          mgf = oids[cert2.signatureParameters.mgf.algorithmOid];
          if (mgf === void 0 || forge.mgf[mgf] === void 0) {
            var error = new Error("Unsupported MGF function.");
            error.oid = cert2.signatureParameters.mgf.algorithmOid;
            error.name = mgf;
            throw error;
          }
          mgf = forge.mgf[mgf].create(forge.md[hash].create());
          hash = oids[cert2.signatureParameters.hash.algorithmOid];
          if (hash === void 0 || forge.md[hash] === void 0) {
            var error = new Error("Unsupported RSASSA-PSS hash function.");
            error.oid = cert2.signatureParameters.hash.algorithmOid;
            error.name = hash;
            throw error;
          }
          scheme = forge.pss.create(
            forge.md[hash].create(),
            mgf,
            cert2.signatureParameters.saltLength
          );
          break;
      }
      return cert2.publicKey.verify(
        options.md.digest().getBytes(),
        options.signature,
        scheme
      );
    };
    pki.certificateFromPem = function(pem, computeHash, strict) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
        var error = new Error(
          'Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".'
        );
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error(
          "Could not convert certificate from PEM; PEM is encrypted."
        );
      }
      var obj = asn1.fromDer(msg.body, strict);
      return pki.certificateFromAsn1(obj, computeHash);
    };
    pki.certificateToPem = function(cert2, maxline) {
      var msg = {
        type: "CERTIFICATE",
        body: asn1.toDer(pki.certificateToAsn1(cert2)).getBytes()
      };
      return forge.pem.encode(msg, { maxline });
    };
    pki.publicKeyFromPem = function(pem) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== "PUBLIC KEY" && msg.type !== "RSA PUBLIC KEY") {
        var error = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert public key from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body);
      return pki.publicKeyFromAsn1(obj);
    };
    pki.publicKeyToPem = function(key, maxline) {
      var msg = {
        type: "PUBLIC KEY",
        body: asn1.toDer(pki.publicKeyToAsn1(key)).getBytes()
      };
      return forge.pem.encode(msg, { maxline });
    };
    pki.publicKeyToRSAPublicKeyPem = function(key, maxline) {
      var msg = {
        type: "RSA PUBLIC KEY",
        body: asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes()
      };
      return forge.pem.encode(msg, { maxline });
    };
    pki.getPublicKeyFingerprint = function(key, options) {
      options = options || {};
      var md2 = options.md || forge.md.sha1.create();
      var type = options.type || "RSAPublicKey";
      var bytes;
      switch (type) {
        case "RSAPublicKey":
          bytes = asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes();
          break;
        case "SubjectPublicKeyInfo":
          bytes = asn1.toDer(pki.publicKeyToAsn1(key)).getBytes();
          break;
        default:
          throw new Error('Unknown fingerprint type "' + options.type + '".');
      }
      md2.start();
      md2.update(bytes);
      var digest = md2.digest();
      if (options.encoding === "hex") {
        var hex = digest.toHex();
        if (options.delimiter) {
          return hex.match(/.{2}/g).join(options.delimiter);
        }
        return hex;
      } else if (options.encoding === "binary") {
        return digest.getBytes();
      } else if (options.encoding) {
        throw new Error('Unknown encoding "' + options.encoding + '".');
      }
      return digest;
    };
    pki.certificationRequestFromPem = function(pem, computeHash, strict) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== "CERTIFICATE REQUEST") {
        var error = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body, strict);
      return pki.certificationRequestFromAsn1(obj, computeHash);
    };
    pki.certificationRequestToPem = function(csr, maxline) {
      var msg = {
        type: "CERTIFICATE REQUEST",
        body: asn1.toDer(pki.certificationRequestToAsn1(csr)).getBytes()
      };
      return forge.pem.encode(msg, { maxline });
    };
    pki.createCertificate = function() {
      var cert2 = {};
      cert2.version = 2;
      cert2.serialNumber = "00";
      cert2.signatureOid = null;
      cert2.signature = null;
      cert2.siginfo = {};
      cert2.siginfo.algorithmOid = null;
      cert2.validity = {};
      cert2.validity.notBefore = /* @__PURE__ */ new Date();
      cert2.validity.notAfter = /* @__PURE__ */ new Date();
      cert2.issuer = {};
      cert2.issuer.getField = function(sn2) {
        return _getAttribute(cert2.issuer, sn2);
      };
      cert2.issuer.addField = function(attr) {
        _fillMissingFields([attr]);
        cert2.issuer.attributes.push(attr);
      };
      cert2.issuer.attributes = [];
      cert2.issuer.hash = null;
      cert2.subject = {};
      cert2.subject.getField = function(sn2) {
        return _getAttribute(cert2.subject, sn2);
      };
      cert2.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        cert2.subject.attributes.push(attr);
      };
      cert2.subject.attributes = [];
      cert2.subject.hash = null;
      cert2.extensions = [];
      cert2.publicKey = null;
      cert2.md = null;
      cert2.setSubject = function(attrs, uniqueId) {
        _fillMissingFields(attrs);
        cert2.subject.attributes = attrs;
        delete cert2.subject.uniqueId;
        if (uniqueId) {
          cert2.subject.uniqueId = uniqueId;
        }
        cert2.subject.hash = null;
      };
      cert2.setIssuer = function(attrs, uniqueId) {
        _fillMissingFields(attrs);
        cert2.issuer.attributes = attrs;
        delete cert2.issuer.uniqueId;
        if (uniqueId) {
          cert2.issuer.uniqueId = uniqueId;
        }
        cert2.issuer.hash = null;
      };
      cert2.setExtensions = function(exts) {
        for (var i2 = 0; i2 < exts.length; ++i2) {
          _fillMissingExtensionFields(exts[i2], { cert: cert2 });
        }
        cert2.extensions = exts;
      };
      cert2.getExtension = function(options) {
        if (typeof options === "string") {
          options = { name: options };
        }
        var rval = null;
        var ext;
        for (var i2 = 0; rval === null && i2 < cert2.extensions.length; ++i2) {
          ext = cert2.extensions[i2];
          if (options.id && ext.id === options.id) {
            rval = ext;
          } else if (options.name && ext.name === options.name) {
            rval = ext;
          }
        }
        return rval;
      };
      cert2.sign = function(key, md2) {
        cert2.md = md2 || forge.md.sha1.create();
        var algorithmOid = oids[cert2.md.algorithm + "WithRSAEncryption"];
        if (!algorithmOid) {
          var error = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
          error.algorithm = cert2.md.algorithm;
          throw error;
        }
        cert2.signatureOid = cert2.siginfo.algorithmOid = algorithmOid;
        cert2.tbsCertificate = pki.getTBSCertificate(cert2);
        var bytes = asn1.toDer(cert2.tbsCertificate);
        cert2.md.update(bytes.getBytes());
        cert2.signature = key.sign(cert2.md);
      };
      cert2.verify = function(child2) {
        var rval = false;
        if (!cert2.issued(child2)) {
          var issuer = child2.issuer;
          var subject = cert2.subject;
          var error = new Error(
            "The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject."
          );
          error.expectedIssuer = subject.attributes;
          error.actualIssuer = issuer.attributes;
          throw error;
        }
        var md2 = child2.md;
        if (md2 === null) {
          md2 = _createSignatureDigest({
            signatureOid: child2.signatureOid,
            type: "certificate"
          });
          var tbsCertificate = child2.tbsCertificate || pki.getTBSCertificate(child2);
          var bytes = asn1.toDer(tbsCertificate);
          md2.update(bytes.getBytes());
        }
        if (md2 !== null) {
          rval = _verifySignature({
            certificate: cert2,
            md: md2,
            signature: child2.signature
          });
        }
        return rval;
      };
      cert2.isIssuer = function(parent2) {
        var rval = false;
        var i2 = cert2.issuer;
        var s = parent2.subject;
        if (i2.hash && s.hash) {
          rval = i2.hash === s.hash;
        } else if (i2.attributes.length === s.attributes.length) {
          rval = true;
          var iattr, sattr;
          for (var n2 = 0; rval && n2 < i2.attributes.length; ++n2) {
            iattr = i2.attributes[n2];
            sattr = s.attributes[n2];
            if (iattr.type !== sattr.type || iattr.value !== sattr.value) {
              rval = false;
            }
          }
        }
        return rval;
      };
      cert2.issued = function(child2) {
        return child2.isIssuer(cert2);
      };
      cert2.generateSubjectKeyIdentifier = function() {
        return pki.getPublicKeyFingerprint(cert2.publicKey, { type: "RSAPublicKey" });
      };
      cert2.verifySubjectKeyIdentifier = function() {
        var oid = oids["subjectKeyIdentifier"];
        for (var i2 = 0; i2 < cert2.extensions.length; ++i2) {
          var ext = cert2.extensions[i2];
          if (ext.id === oid) {
            var ski = cert2.generateSubjectKeyIdentifier().getBytes();
            return forge.util.hexToBytes(ext.subjectKeyIdentifier) === ski;
          }
        }
        return false;
      };
      return cert2;
    };
    pki.certificateFromAsn1 = function(obj, computeHash) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, x509CertificateValidator, capture, errors)) {
        var error = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
        error.errors = errors;
        throw error;
      }
      var oid = asn1.derToOid(capture.publicKeyOid);
      if (oid !== pki.oids.rsaEncryption) {
        throw new Error("Cannot read public key. OID is not RSA.");
      }
      var cert2 = pki.createCertificate();
      cert2.version = capture.certVersion ? capture.certVersion.charCodeAt(0) : 0;
      var serial = forge.util.createBuffer(capture.certSerialNumber);
      cert2.serialNumber = serial.toHex();
      cert2.signatureOid = forge.asn1.derToOid(capture.certSignatureOid);
      cert2.signatureParameters = _readSignatureParameters(
        cert2.signatureOid,
        capture.certSignatureParams,
        true
      );
      cert2.siginfo.algorithmOid = forge.asn1.derToOid(capture.certinfoSignatureOid);
      cert2.siginfo.parameters = _readSignatureParameters(
        cert2.siginfo.algorithmOid,
        capture.certinfoSignatureParams,
        false
      );
      cert2.signature = capture.certSignature;
      var validity = [];
      if (capture.certValidity1UTCTime !== void 0) {
        validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));
      }
      if (capture.certValidity2GeneralizedTime !== void 0) {
        validity.push(asn1.generalizedTimeToDate(
          capture.certValidity2GeneralizedTime
        ));
      }
      if (capture.certValidity3UTCTime !== void 0) {
        validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));
      }
      if (capture.certValidity4GeneralizedTime !== void 0) {
        validity.push(asn1.generalizedTimeToDate(
          capture.certValidity4GeneralizedTime
        ));
      }
      if (validity.length > 2) {
        throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
      }
      if (validity.length < 2) {
        throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
      }
      cert2.validity.notBefore = validity[0];
      cert2.validity.notAfter = validity[1];
      cert2.tbsCertificate = capture.tbsCertificate;
      if (computeHash) {
        cert2.md = _createSignatureDigest({
          signatureOid: cert2.signatureOid,
          type: "certificate"
        });
        var bytes = asn1.toDer(cert2.tbsCertificate);
        cert2.md.update(bytes.getBytes());
      }
      var imd = forge.md.sha1.create();
      var ibytes = asn1.toDer(capture.certIssuer);
      imd.update(ibytes.getBytes());
      cert2.issuer.getField = function(sn2) {
        return _getAttribute(cert2.issuer, sn2);
      };
      cert2.issuer.addField = function(attr) {
        _fillMissingFields([attr]);
        cert2.issuer.attributes.push(attr);
      };
      cert2.issuer.attributes = pki.RDNAttributesAsArray(capture.certIssuer);
      if (capture.certIssuerUniqueId) {
        cert2.issuer.uniqueId = capture.certIssuerUniqueId;
      }
      cert2.issuer.hash = imd.digest().toHex();
      var smd = forge.md.sha1.create();
      var sbytes = asn1.toDer(capture.certSubject);
      smd.update(sbytes.getBytes());
      cert2.subject.getField = function(sn2) {
        return _getAttribute(cert2.subject, sn2);
      };
      cert2.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        cert2.subject.attributes.push(attr);
      };
      cert2.subject.attributes = pki.RDNAttributesAsArray(capture.certSubject);
      if (capture.certSubjectUniqueId) {
        cert2.subject.uniqueId = capture.certSubjectUniqueId;
      }
      cert2.subject.hash = smd.digest().toHex();
      if (capture.certExtensions) {
        cert2.extensions = pki.certificateExtensionsFromAsn1(capture.certExtensions);
      } else {
        cert2.extensions = [];
      }
      cert2.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
      return cert2;
    };
    pki.certificateExtensionsFromAsn1 = function(exts) {
      var rval = [];
      for (var i2 = 0; i2 < exts.value.length; ++i2) {
        var extseq = exts.value[i2];
        for (var ei2 = 0; ei2 < extseq.value.length; ++ei2) {
          rval.push(pki.certificateExtensionFromAsn1(extseq.value[ei2]));
        }
      }
      return rval;
    };
    pki.certificateExtensionFromAsn1 = function(ext) {
      var e = {};
      e.id = asn1.derToOid(ext.value[0].value);
      e.critical = false;
      if (ext.value[1].type === asn1.Type.BOOLEAN) {
        e.critical = ext.value[1].value.charCodeAt(0) !== 0;
        e.value = ext.value[2].value;
      } else {
        e.value = ext.value[1].value;
      }
      if (e.id in oids) {
        e.name = oids[e.id];
        if (e.name === "keyUsage") {
          var ev = asn1.fromDer(e.value);
          var b2 = 0;
          var b3 = 0;
          if (ev.value.length > 1) {
            b2 = ev.value.charCodeAt(1);
            b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;
          }
          e.digitalSignature = (b2 & 128) === 128;
          e.nonRepudiation = (b2 & 64) === 64;
          e.keyEncipherment = (b2 & 32) === 32;
          e.dataEncipherment = (b2 & 16) === 16;
          e.keyAgreement = (b2 & 8) === 8;
          e.keyCertSign = (b2 & 4) === 4;
          e.cRLSign = (b2 & 2) === 2;
          e.encipherOnly = (b2 & 1) === 1;
          e.decipherOnly = (b3 & 128) === 128;
        } else if (e.name === "basicConstraints") {
          var ev = asn1.fromDer(e.value);
          if (ev.value.length > 0 && ev.value[0].type === asn1.Type.BOOLEAN) {
            e.cA = ev.value[0].value.charCodeAt(0) !== 0;
          } else {
            e.cA = false;
          }
          var value = null;
          if (ev.value.length > 0 && ev.value[0].type === asn1.Type.INTEGER) {
            value = ev.value[0].value;
          } else if (ev.value.length > 1) {
            value = ev.value[1].value;
          }
          if (value !== null) {
            e.pathLenConstraint = asn1.derToInteger(value);
          }
        } else if (e.name === "extKeyUsage") {
          var ev = asn1.fromDer(e.value);
          for (var vi2 = 0; vi2 < ev.value.length; ++vi2) {
            var oid = asn1.derToOid(ev.value[vi2].value);
            if (oid in oids) {
              e[oids[oid]] = true;
            } else {
              e[oid] = true;
            }
          }
        } else if (e.name === "nsCertType") {
          var ev = asn1.fromDer(e.value);
          var b2 = 0;
          if (ev.value.length > 1) {
            b2 = ev.value.charCodeAt(1);
          }
          e.client = (b2 & 128) === 128;
          e.server = (b2 & 64) === 64;
          e.email = (b2 & 32) === 32;
          e.objsign = (b2 & 16) === 16;
          e.reserved = (b2 & 8) === 8;
          e.sslCA = (b2 & 4) === 4;
          e.emailCA = (b2 & 2) === 2;
          e.objCA = (b2 & 1) === 1;
        } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
          e.altNames = [];
          var gn2;
          var ev = asn1.fromDer(e.value);
          for (var n2 = 0; n2 < ev.value.length; ++n2) {
            gn2 = ev.value[n2];
            var altName = {
              type: gn2.type,
              value: gn2.value
            };
            e.altNames.push(altName);
            switch (gn2.type) {
              case 1:
              case 2:
              case 6:
                break;
              case 7:
                altName.ip = forge.util.bytesToIP(gn2.value);
                break;
              case 8:
                altName.oid = asn1.derToOid(gn2.value);
                break;
              default:
            }
          }
        } else if (e.name === "subjectKeyIdentifier") {
          var ev = asn1.fromDer(e.value);
          e.subjectKeyIdentifier = forge.util.bytesToHex(ev.value);
        }
      }
      return e;
    };
    pki.certificationRequestFromAsn1 = function(obj, computeHash) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, certificationRequestValidator, capture, errors)) {
        var error = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
        error.errors = errors;
        throw error;
      }
      var oid = asn1.derToOid(capture.publicKeyOid);
      if (oid !== pki.oids.rsaEncryption) {
        throw new Error("Cannot read public key. OID is not RSA.");
      }
      var csr = pki.createCertificationRequest();
      csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;
      csr.signatureOid = forge.asn1.derToOid(capture.csrSignatureOid);
      csr.signatureParameters = _readSignatureParameters(
        csr.signatureOid,
        capture.csrSignatureParams,
        true
      );
      csr.siginfo.algorithmOid = forge.asn1.derToOid(capture.csrSignatureOid);
      csr.siginfo.parameters = _readSignatureParameters(
        csr.siginfo.algorithmOid,
        capture.csrSignatureParams,
        false
      );
      csr.signature = capture.csrSignature;
      csr.certificationRequestInfo = capture.certificationRequestInfo;
      if (computeHash) {
        csr.md = _createSignatureDigest({
          signatureOid: csr.signatureOid,
          type: "certification request"
        });
        var bytes = asn1.toDer(csr.certificationRequestInfo);
        csr.md.update(bytes.getBytes());
      }
      var smd = forge.md.sha1.create();
      csr.subject.getField = function(sn2) {
        return _getAttribute(csr.subject, sn2);
      };
      csr.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        csr.subject.attributes.push(attr);
      };
      csr.subject.attributes = pki.RDNAttributesAsArray(
        capture.certificationRequestInfoSubject,
        smd
      );
      csr.subject.hash = smd.digest().toHex();
      csr.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
      csr.getAttribute = function(sn2) {
        return _getAttribute(csr, sn2);
      };
      csr.addAttribute = function(attr) {
        _fillMissingFields([attr]);
        csr.attributes.push(attr);
      };
      csr.attributes = pki.CRIAttributesAsArray(
        capture.certificationRequestInfoAttributes || []
      );
      return csr;
    };
    pki.createCertificationRequest = function() {
      var csr = {};
      csr.version = 0;
      csr.signatureOid = null;
      csr.signature = null;
      csr.siginfo = {};
      csr.siginfo.algorithmOid = null;
      csr.subject = {};
      csr.subject.getField = function(sn2) {
        return _getAttribute(csr.subject, sn2);
      };
      csr.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        csr.subject.attributes.push(attr);
      };
      csr.subject.attributes = [];
      csr.subject.hash = null;
      csr.publicKey = null;
      csr.attributes = [];
      csr.getAttribute = function(sn2) {
        return _getAttribute(csr, sn2);
      };
      csr.addAttribute = function(attr) {
        _fillMissingFields([attr]);
        csr.attributes.push(attr);
      };
      csr.md = null;
      csr.setSubject = function(attrs) {
        _fillMissingFields(attrs);
        csr.subject.attributes = attrs;
        csr.subject.hash = null;
      };
      csr.setAttributes = function(attrs) {
        _fillMissingFields(attrs);
        csr.attributes = attrs;
      };
      csr.sign = function(key, md2) {
        csr.md = md2 || forge.md.sha1.create();
        var algorithmOid = oids[csr.md.algorithm + "WithRSAEncryption"];
        if (!algorithmOid) {
          var error = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
          error.algorithm = csr.md.algorithm;
          throw error;
        }
        csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;
        csr.certificationRequestInfo = pki.getCertificationRequestInfo(csr);
        var bytes = asn1.toDer(csr.certificationRequestInfo);
        csr.md.update(bytes.getBytes());
        csr.signature = key.sign(csr.md);
      };
      csr.verify = function() {
        var rval = false;
        var md2 = csr.md;
        if (md2 === null) {
          md2 = _createSignatureDigest({
            signatureOid: csr.signatureOid,
            type: "certification request"
          });
          var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);
          var bytes = asn1.toDer(cri);
          md2.update(bytes.getBytes());
        }
        if (md2 !== null) {
          rval = _verifySignature({
            certificate: csr,
            md: md2,
            signature: csr.signature
          });
        }
        return rval;
      };
      return csr;
    };
    function _dnToAsn1(obj) {
      var rval = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        []
      );
      var attr, set;
      var attrs = obj.attributes;
      for (var i2 = 0; i2 < attrs.length; ++i2) {
        attr = attrs[i2];
        var value = attr.value;
        var valueTagClass = asn1.Type.PRINTABLESTRING;
        if ("valueTagClass" in attr) {
          valueTagClass = attr.valueTagClass;
          if (valueTagClass === asn1.Type.UTF8) {
            value = forge.util.encodeUtf8(value);
          }
        }
        set = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // AttributeType
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(attr.type).getBytes()
            ),
            // AttributeValue
            asn1.create(asn1.Class.UNIVERSAL, valueTagClass, false, value)
          ])
        ]);
        rval.value.push(set);
      }
      return rval;
    }
    function _fillMissingFields(attrs) {
      var attr;
      for (var i2 = 0; i2 < attrs.length; ++i2) {
        attr = attrs[i2];
        if (typeof attr.name === "undefined") {
          if (attr.type && attr.type in pki.oids) {
            attr.name = pki.oids[attr.type];
          } else if (attr.shortName && attr.shortName in _shortNames) {
            attr.name = pki.oids[_shortNames[attr.shortName]];
          }
        }
        if (typeof attr.type === "undefined") {
          if (attr.name && attr.name in pki.oids) {
            attr.type = pki.oids[attr.name];
          } else {
            var error = new Error("Attribute type not specified.");
            error.attribute = attr;
            throw error;
          }
        }
        if (typeof attr.shortName === "undefined") {
          if (attr.name && attr.name in _shortNames) {
            attr.shortName = _shortNames[attr.name];
          }
        }
        if (attr.type === oids.extensionRequest) {
          attr.valueConstructed = true;
          attr.valueTagClass = asn1.Type.SEQUENCE;
          if (!attr.value && attr.extensions) {
            attr.value = [];
            for (var ei2 = 0; ei2 < attr.extensions.length; ++ei2) {
              attr.value.push(pki.certificateExtensionToAsn1(
                _fillMissingExtensionFields(attr.extensions[ei2])
              ));
            }
          }
        }
        if (typeof attr.value === "undefined") {
          var error = new Error("Attribute value not specified.");
          error.attribute = attr;
          throw error;
        }
      }
    }
    function _fillMissingExtensionFields(e, options) {
      options = options || {};
      if (typeof e.name === "undefined") {
        if (e.id && e.id in pki.oids) {
          e.name = pki.oids[e.id];
        }
      }
      if (typeof e.id === "undefined") {
        if (e.name && e.name in pki.oids) {
          e.id = pki.oids[e.name];
        } else {
          var error = new Error("Extension ID not specified.");
          error.extension = e;
          throw error;
        }
      }
      if (typeof e.value !== "undefined") {
        return e;
      }
      if (e.name === "keyUsage") {
        var unused = 0;
        var b2 = 0;
        var b3 = 0;
        if (e.digitalSignature) {
          b2 |= 128;
          unused = 7;
        }
        if (e.nonRepudiation) {
          b2 |= 64;
          unused = 6;
        }
        if (e.keyEncipherment) {
          b2 |= 32;
          unused = 5;
        }
        if (e.dataEncipherment) {
          b2 |= 16;
          unused = 4;
        }
        if (e.keyAgreement) {
          b2 |= 8;
          unused = 3;
        }
        if (e.keyCertSign) {
          b2 |= 4;
          unused = 2;
        }
        if (e.cRLSign) {
          b2 |= 2;
          unused = 1;
        }
        if (e.encipherOnly) {
          b2 |= 1;
          unused = 0;
        }
        if (e.decipherOnly) {
          b3 |= 128;
          unused = 7;
        }
        var value = String.fromCharCode(unused);
        if (b3 !== 0) {
          value += String.fromCharCode(b2) + String.fromCharCode(b3);
        } else if (b2 !== 0) {
          value += String.fromCharCode(b2);
        }
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          value
        );
      } else if (e.name === "basicConstraints") {
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          []
        );
        if (e.cA) {
          e.value.value.push(asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.BOOLEAN,
            false,
            String.fromCharCode(255)
          ));
        }
        if ("pathLenConstraint" in e) {
          e.value.value.push(asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            asn1.integerToDer(e.pathLenConstraint).getBytes()
          ));
        }
      } else if (e.name === "extKeyUsage") {
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          []
        );
        var seq = e.value.value;
        for (var key in e) {
          if (e[key] !== true) {
            continue;
          }
          if (key in oids) {
            seq.push(asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(oids[key]).getBytes()
            ));
          } else if (key.indexOf(".") !== -1) {
            seq.push(asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(key).getBytes()
            ));
          }
        }
      } else if (e.name === "nsCertType") {
        var unused = 0;
        var b2 = 0;
        if (e.client) {
          b2 |= 128;
          unused = 7;
        }
        if (e.server) {
          b2 |= 64;
          unused = 6;
        }
        if (e.email) {
          b2 |= 32;
          unused = 5;
        }
        if (e.objsign) {
          b2 |= 16;
          unused = 4;
        }
        if (e.reserved) {
          b2 |= 8;
          unused = 3;
        }
        if (e.sslCA) {
          b2 |= 4;
          unused = 2;
        }
        if (e.emailCA) {
          b2 |= 2;
          unused = 1;
        }
        if (e.objCA) {
          b2 |= 1;
          unused = 0;
        }
        var value = String.fromCharCode(unused);
        if (b2 !== 0) {
          value += String.fromCharCode(b2);
        }
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          value
        );
      } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var altName;
        for (var n2 = 0; n2 < e.altNames.length; ++n2) {
          altName = e.altNames[n2];
          var value = altName.value;
          if (altName.type === 7 && altName.ip) {
            value = forge.util.bytesFromIP(altName.ip);
            if (value === null) {
              var error = new Error(
                'Extension "ip" value is not a valid IPv4 or IPv6 address.'
              );
              error.extension = e;
              throw error;
            }
          } else if (altName.type === 8) {
            if (altName.oid) {
              value = asn1.oidToDer(asn1.oidToDer(altName.oid));
            } else {
              value = asn1.oidToDer(value);
            }
          }
          e.value.value.push(asn1.create(
            asn1.Class.CONTEXT_SPECIFIC,
            altName.type,
            false,
            value
          ));
        }
      } else if (e.name === "nsComment" && options.cert) {
        if (!/^[\x00-\x7F]*$/.test(e.comment) || e.comment.length < 1 || e.comment.length > 128) {
          throw new Error('Invalid "nsComment" content.');
        }
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.IA5STRING,
          false,
          e.comment
        );
      } else if (e.name === "subjectKeyIdentifier" && options.cert) {
        var ski = options.cert.generateSubjectKeyIdentifier();
        e.subjectKeyIdentifier = ski.toHex();
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          ski.getBytes()
        );
      } else if (e.name === "authorityKeyIdentifier" && options.cert) {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var seq = e.value.value;
        if (e.keyIdentifier) {
          var keyIdentifier = e.keyIdentifier === true ? options.cert.generateSubjectKeyIdentifier().getBytes() : e.keyIdentifier;
          seq.push(
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier)
          );
        }
        if (e.authorityCertIssuer) {
          var authorityCertIssuer = [
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 4, true, [
              _dnToAsn1(e.authorityCertIssuer === true ? options.cert.issuer : e.authorityCertIssuer)
            ])
          ];
          seq.push(
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer)
          );
        }
        if (e.serialNumber) {
          var serialNumber = forge.util.hexToBytes(e.serialNumber === true ? options.cert.serialNumber : e.serialNumber);
          seq.push(
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, false, serialNumber)
          );
        }
      } else if (e.name === "cRLDistributionPoints") {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var seq = e.value.value;
        var subSeq = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          []
        );
        var fullNameGeneralNames = asn1.create(
          asn1.Class.CONTEXT_SPECIFIC,
          0,
          true,
          []
        );
        var altName;
        for (var n2 = 0; n2 < e.altNames.length; ++n2) {
          altName = e.altNames[n2];
          var value = altName.value;
          if (altName.type === 7 && altName.ip) {
            value = forge.util.bytesFromIP(altName.ip);
            if (value === null) {
              var error = new Error(
                'Extension "ip" value is not a valid IPv4 or IPv6 address.'
              );
              error.extension = e;
              throw error;
            }
          } else if (altName.type === 8) {
            if (altName.oid) {
              value = asn1.oidToDer(asn1.oidToDer(altName.oid));
            } else {
              value = asn1.oidToDer(value);
            }
          }
          fullNameGeneralNames.value.push(asn1.create(
            asn1.Class.CONTEXT_SPECIFIC,
            altName.type,
            false,
            value
          ));
        }
        subSeq.value.push(asn1.create(
          asn1.Class.CONTEXT_SPECIFIC,
          0,
          true,
          [fullNameGeneralNames]
        ));
        seq.push(subSeq);
      }
      if (typeof e.value === "undefined") {
        var error = new Error("Extension value not specified.");
        error.extension = e;
        throw error;
      }
      return e;
    }
    function _signatureParametersToAsn1(oid, params) {
      switch (oid) {
        case oids["RSASSA-PSS"]:
          var parts = [];
          if (params.hash.algorithmOid !== void 0) {
            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(params.hash.algorithmOid).getBytes()
                ),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
              ])
            ]));
          }
          if (params.mgf.algorithmOid !== void 0) {
            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(params.mgf.algorithmOid).getBytes()
                ),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                  asn1.create(
                    asn1.Class.UNIVERSAL,
                    asn1.Type.OID,
                    false,
                    asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()
                  ),
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
                ])
              ])
            ]));
          }
          if (params.saltLength !== void 0) {
            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                asn1.integerToDer(params.saltLength).getBytes()
              )
            ]));
          }
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, parts);
        default:
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "");
      }
    }
    function _CRIAttributesToAsn1(csr) {
      var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
      if (csr.attributes.length === 0) {
        return rval;
      }
      var attrs = csr.attributes;
      for (var i2 = 0; i2 < attrs.length; ++i2) {
        var attr = attrs[i2];
        var value = attr.value;
        var valueTagClass = asn1.Type.UTF8;
        if ("valueTagClass" in attr) {
          valueTagClass = attr.valueTagClass;
        }
        if (valueTagClass === asn1.Type.UTF8) {
          value = forge.util.encodeUtf8(value);
        }
        var valueConstructed = false;
        if ("valueConstructed" in attr) {
          valueConstructed = attr.valueConstructed;
        }
        var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // AttributeType
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(attr.type).getBytes()
          ),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
            // AttributeValue
            asn1.create(
              asn1.Class.UNIVERSAL,
              valueTagClass,
              valueConstructed,
              value
            )
          ])
        ]);
        rval.value.push(seq);
      }
      return rval;
    }
    var jan_1_1950 = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z");
    var jan_1_2050 = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z");
    function _dateToAsn1(date) {
      if (date >= jan_1_1950 && date < jan_1_2050) {
        return asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.UTCTIME,
          false,
          asn1.dateToUtcTime(date)
        );
      } else {
        return asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.GENERALIZEDTIME,
          false,
          asn1.dateToGeneralizedTime(date)
        );
      }
    }
    pki.getTBSCertificate = function(cert2) {
      var notBefore = _dateToAsn1(cert2.validity.notBefore);
      var notAfter = _dateToAsn1(cert2.validity.notAfter);
      var tbs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          // integer
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            asn1.integerToDer(cert2.version).getBytes()
          )
        ]),
        // serialNumber
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          forge.util.hexToBytes(cert2.serialNumber)
        ),
        // signature
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(cert2.siginfo.algorithmOid).getBytes()
          ),
          // parameters
          _signatureParametersToAsn1(
            cert2.siginfo.algorithmOid,
            cert2.siginfo.parameters
          )
        ]),
        // issuer
        _dnToAsn1(cert2.issuer),
        // validity
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          notBefore,
          notAfter
        ]),
        // subject
        _dnToAsn1(cert2.subject),
        // SubjectPublicKeyInfo
        pki.publicKeyToAsn1(cert2.publicKey)
      ]);
      if (cert2.issuer.uniqueId) {
        tbs.value.push(
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.BITSTRING,
              false,
              // TODO: support arbitrary bit length ids
              String.fromCharCode(0) + cert2.issuer.uniqueId
            )
          ])
        );
      }
      if (cert2.subject.uniqueId) {
        tbs.value.push(
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.BITSTRING,
              false,
              // TODO: support arbitrary bit length ids
              String.fromCharCode(0) + cert2.subject.uniqueId
            )
          ])
        );
      }
      if (cert2.extensions.length > 0) {
        tbs.value.push(pki.certificateExtensionsToAsn1(cert2.extensions));
      }
      return tbs;
    };
    pki.getCertificationRequestInfo = function(csr) {
      var cri = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(csr.version).getBytes()
        ),
        // subject
        _dnToAsn1(csr.subject),
        // SubjectPublicKeyInfo
        pki.publicKeyToAsn1(csr.publicKey),
        // attributes
        _CRIAttributesToAsn1(csr)
      ]);
      return cri;
    };
    pki.distinguishedNameToAsn1 = function(dn2) {
      return _dnToAsn1(dn2);
    };
    pki.certificateToAsn1 = function(cert2) {
      var tbsCertificate = cert2.tbsCertificate || pki.getTBSCertificate(cert2);
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // TBSCertificate
        tbsCertificate,
        // AlgorithmIdentifier (signature algorithm)
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(cert2.signatureOid).getBytes()
          ),
          // parameters
          _signatureParametersToAsn1(cert2.signatureOid, cert2.signatureParameters)
        ]),
        // SignatureValue
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          String.fromCharCode(0) + cert2.signature
        )
      ]);
    };
    pki.certificateExtensionsToAsn1 = function(exts) {
      var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 3, true, []);
      var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      rval.value.push(seq);
      for (var i2 = 0; i2 < exts.length; ++i2) {
        seq.value.push(pki.certificateExtensionToAsn1(exts[i2]));
      }
      return rval;
    };
    pki.certificateExtensionToAsn1 = function(ext) {
      var extseq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      extseq.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OID,
        false,
        asn1.oidToDer(ext.id).getBytes()
      ));
      if (ext.critical) {
        extseq.value.push(asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BOOLEAN,
          false,
          String.fromCharCode(255)
        ));
      }
      var value = ext.value;
      if (typeof ext.value !== "string") {
        value = asn1.toDer(value).getBytes();
      }
      extseq.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        value
      ));
      return extseq;
    };
    pki.certificationRequestToAsn1 = function(csr) {
      var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // CertificationRequestInfo
        cri,
        // AlgorithmIdentifier (signature algorithm)
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(csr.signatureOid).getBytes()
          ),
          // parameters
          _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)
        ]),
        // signature
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          String.fromCharCode(0) + csr.signature
        )
      ]);
    };
    pki.createCaStore = function(certs) {
      var caStore = {
        // stored certificates
        certs: {}
      };
      caStore.getIssuer = function(cert3) {
        var rval = getBySubject(cert3.issuer);
        return rval;
      };
      caStore.addCertificate = function(cert3) {
        if (typeof cert3 === "string") {
          cert3 = forge.pki.certificateFromPem(cert3);
        }
        ensureSubjectHasHash(cert3.subject);
        if (!caStore.hasCertificate(cert3)) {
          if (cert3.subject.hash in caStore.certs) {
            var tmp = caStore.certs[cert3.subject.hash];
            if (!forge.util.isArray(tmp)) {
              tmp = [tmp];
            }
            tmp.push(cert3);
            caStore.certs[cert3.subject.hash] = tmp;
          } else {
            caStore.certs[cert3.subject.hash] = cert3;
          }
        }
      };
      caStore.hasCertificate = function(cert3) {
        if (typeof cert3 === "string") {
          cert3 = forge.pki.certificateFromPem(cert3);
        }
        var match = getBySubject(cert3.subject);
        if (!match) {
          return false;
        }
        if (!forge.util.isArray(match)) {
          match = [match];
        }
        var der1 = asn1.toDer(pki.certificateToAsn1(cert3)).getBytes();
        for (var i3 = 0; i3 < match.length; ++i3) {
          var der2 = asn1.toDer(pki.certificateToAsn1(match[i3])).getBytes();
          if (der1 === der2) {
            return true;
          }
        }
        return false;
      };
      caStore.listAllCertificates = function() {
        var certList = [];
        for (var hash in caStore.certs) {
          if (caStore.certs.hasOwnProperty(hash)) {
            var value = caStore.certs[hash];
            if (!forge.util.isArray(value)) {
              certList.push(value);
            } else {
              for (var i3 = 0; i3 < value.length; ++i3) {
                certList.push(value[i3]);
              }
            }
          }
        }
        return certList;
      };
      caStore.removeCertificate = function(cert3) {
        var result;
        if (typeof cert3 === "string") {
          cert3 = forge.pki.certificateFromPem(cert3);
        }
        ensureSubjectHasHash(cert3.subject);
        if (!caStore.hasCertificate(cert3)) {
          return null;
        }
        var match = getBySubject(cert3.subject);
        if (!forge.util.isArray(match)) {
          result = caStore.certs[cert3.subject.hash];
          delete caStore.certs[cert3.subject.hash];
          return result;
        }
        var der1 = asn1.toDer(pki.certificateToAsn1(cert3)).getBytes();
        for (var i3 = 0; i3 < match.length; ++i3) {
          var der2 = asn1.toDer(pki.certificateToAsn1(match[i3])).getBytes();
          if (der1 === der2) {
            result = match[i3];
            match.splice(i3, 1);
          }
        }
        if (match.length === 0) {
          delete caStore.certs[cert3.subject.hash];
        }
        return result;
      };
      function getBySubject(subject) {
        ensureSubjectHasHash(subject);
        return caStore.certs[subject.hash] || null;
      }
      function ensureSubjectHasHash(subject) {
        if (!subject.hash) {
          var md2 = forge.md.sha1.create();
          subject.attributes = pki.RDNAttributesAsArray(_dnToAsn1(subject), md2);
          subject.hash = md2.digest().toHex();
        }
      }
      if (certs) {
        for (var i2 = 0; i2 < certs.length; ++i2) {
          var cert2 = certs[i2];
          caStore.addCertificate(cert2);
        }
      }
      return caStore;
    };
    pki.certificateError = {
      bad_certificate: "forge.pki.BadCertificate",
      unsupported_certificate: "forge.pki.UnsupportedCertificate",
      certificate_revoked: "forge.pki.CertificateRevoked",
      certificate_expired: "forge.pki.CertificateExpired",
      certificate_unknown: "forge.pki.CertificateUnknown",
      unknown_ca: "forge.pki.UnknownCertificateAuthority"
    };
    pki.verifyCertificateChain = function(caStore, chain, options) {
      if (typeof options === "function") {
        options = { verify: options };
      }
      options = options || {};
      chain = chain.slice(0);
      var certs = chain.slice(0);
      var validityCheckDate = options.validityCheckDate;
      if (typeof validityCheckDate === "undefined") {
        validityCheckDate = /* @__PURE__ */ new Date();
      }
      var first2 = true;
      var error = null;
      var depth = 0;
      do {
        var cert2 = chain.shift();
        var parent2 = null;
        var selfSigned = false;
        if (validityCheckDate) {
          if (validityCheckDate < cert2.validity.notBefore || validityCheckDate > cert2.validity.notAfter) {
            error = {
              message: "Certificate is not valid yet or has expired.",
              error: pki.certificateError.certificate_expired,
              notBefore: cert2.validity.notBefore,
              notAfter: cert2.validity.notAfter,
              // TODO: we might want to reconsider renaming 'now' to
              // 'validityCheckDate' should this API be changed in the future.
              now: validityCheckDate
            };
          }
        }
        if (error === null) {
          parent2 = chain[0] || caStore.getIssuer(cert2);
          if (parent2 === null) {
            if (cert2.isIssuer(cert2)) {
              selfSigned = true;
              parent2 = cert2;
            }
          }
          if (parent2) {
            var parents = parent2;
            if (!forge.util.isArray(parents)) {
              parents = [parents];
            }
            var verified = false;
            while (!verified && parents.length > 0) {
              parent2 = parents.shift();
              try {
                verified = parent2.verify(cert2);
              } catch (ex) {
              }
            }
            if (!verified) {
              error = {
                message: "Certificate signature is invalid.",
                error: pki.certificateError.bad_certificate
              };
            }
          }
          if (error === null && (!parent2 || selfSigned) && !caStore.hasCertificate(cert2)) {
            error = {
              message: "Certificate is not trusted.",
              error: pki.certificateError.unknown_ca
            };
          }
        }
        if (error === null && parent2 && !cert2.isIssuer(parent2)) {
          error = {
            message: "Certificate issuer is invalid.",
            error: pki.certificateError.bad_certificate
          };
        }
        if (error === null) {
          var se2 = {
            keyUsage: true,
            basicConstraints: true
          };
          for (var i2 = 0; error === null && i2 < cert2.extensions.length; ++i2) {
            var ext = cert2.extensions[i2];
            if (ext.critical && !(ext.name in se2)) {
              error = {
                message: "Certificate has an unsupported critical extension.",
                error: pki.certificateError.unsupported_certificate
              };
            }
          }
        }
        if (error === null && (!first2 || chain.length === 0 && (!parent2 || selfSigned))) {
          var bcExt = cert2.getExtension("basicConstraints");
          var keyUsageExt = cert2.getExtension("keyUsage");
          if (keyUsageExt !== null) {
            if (!keyUsageExt.keyCertSign || bcExt === null) {
              error = {
                message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
                error: pki.certificateError.bad_certificate
              };
            }
          }
          if (error === null && bcExt !== null && !bcExt.cA) {
            error = {
              message: "Certificate basicConstraints indicates the certificate is not a CA.",
              error: pki.certificateError.bad_certificate
            };
          }
          if (error === null && keyUsageExt !== null && "pathLenConstraint" in bcExt) {
            var pathLen = depth - 1;
            if (pathLen > bcExt.pathLenConstraint) {
              error = {
                message: "Certificate basicConstraints pathLenConstraint violated.",
                error: pki.certificateError.bad_certificate
              };
            }
          }
        }
        var vfd = error === null ? true : error.error;
        var ret = options.verify ? options.verify(vfd, depth, certs) : vfd;
        if (ret === true) {
          error = null;
        } else {
          if (vfd === true) {
            error = {
              message: "The application rejected the certificate.",
              error: pki.certificateError.bad_certificate
            };
          }
          if (ret || ret === 0) {
            if (typeof ret === "object" && !forge.util.isArray(ret)) {
              if (ret.message) {
                error.message = ret.message;
              }
              if (ret.error) {
                error.error = ret.error;
              }
            } else if (typeof ret === "string") {
              error.error = ret;
            }
          }
          throw error;
        }
        first2 = false;
        ++depth;
      } while (chain.length > 0);
      return true;
    };
  }
});

// node_modules/node-forge/lib/pkcs12.js
var require_pkcs12 = __commonJS({
  "node_modules/node-forge/lib/pkcs12.js"(exports, module) {
    var forge = require_forge();
    require_asn1();
    require_hmac();
    require_oids();
    require_pkcs7asn1();
    require_pbe();
    require_random();
    require_rsa();
    require_sha1();
    require_util2();
    require_x509();
    var asn1 = forge.asn1;
    var pki = forge.pki;
    var p12 = module.exports = forge.pkcs12 = forge.pkcs12 || {};
    var contentInfoValidator = {
      name: "ContentInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      // a ContentInfo
      constructed: true,
      value: [{
        name: "ContentInfo.contentType",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "ContentInfo.content",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        constructed: true,
        captureAsn1: "content"
      }]
    };
    var pfxValidator = {
      name: "PFX",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "PFX.version",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "version"
        },
        contentInfoValidator,
        {
          name: "PFX.macData",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          optional: true,
          captureAsn1: "mac",
          value: [{
            name: "PFX.macData.mac",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            // DigestInfo
            constructed: true,
            value: [{
              name: "PFX.macData.mac.digestAlgorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SEQUENCE,
              // DigestAlgorithmIdentifier
              constructed: true,
              value: [{
                name: "PFX.macData.mac.digestAlgorithm.algorithm",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.OID,
                constructed: false,
                capture: "macAlgorithm"
              }, {
                name: "PFX.macData.mac.digestAlgorithm.parameters",
                tagClass: asn1.Class.UNIVERSAL,
                captureAsn1: "macAlgorithmParameters"
              }]
            }, {
              name: "PFX.macData.mac.digest",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OCTETSTRING,
              constructed: false,
              capture: "macDigest"
            }]
          }, {
            name: "PFX.macData.macSalt",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: false,
            capture: "macSalt"
          }, {
            name: "PFX.macData.iterations",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            optional: true,
            capture: "macIterations"
          }]
        }
      ]
    };
    var safeBagValidator = {
      name: "SafeBag",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "SafeBag.bagId",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "bagId"
      }, {
        name: "SafeBag.bagValue",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        constructed: true,
        captureAsn1: "bagValue"
      }, {
        name: "SafeBag.bagAttributes",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        optional: true,
        capture: "bagAttributes"
      }]
    };
    var attributeValidator = {
      name: "Attribute",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "Attribute.attrId",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "oid"
      }, {
        name: "Attribute.attrValues",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        capture: "values"
      }]
    };
    var certBagValidator = {
      name: "CertBag",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "CertBag.certId",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "certId"
      }, {
        name: "CertBag.certValue",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        constructed: true,
        /* So far we only support X.509 certificates (which are wrapped in
           an OCTET STRING, hence hard code that here). */
        value: [{
          name: "CertBag.certValue[0]",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.OCTETSTRING,
          constructed: false,
          capture: "cert"
        }]
      }]
    };
    function _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {
      var result = [];
      for (var i2 = 0; i2 < safeContents.length; i2++) {
        for (var j2 = 0; j2 < safeContents[i2].safeBags.length; j2++) {
          var bag = safeContents[i2].safeBags[j2];
          if (bagType !== void 0 && bag.type !== bagType) {
            continue;
          }
          if (attrName === null) {
            result.push(bag);
            continue;
          }
          if (bag.attributes[attrName] !== void 0 && bag.attributes[attrName].indexOf(attrValue) >= 0) {
            result.push(bag);
          }
        }
      }
      return result;
    }
    p12.pkcs12FromAsn1 = function(obj, strict, password) {
      if (typeof strict === "string") {
        password = strict;
        strict = true;
      } else if (strict === void 0) {
        strict = true;
      }
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, pfxValidator, capture, errors)) {
        var error = new Error("Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.");
        error.errors = error;
        throw error;
      }
      var pfx = {
        version: capture.version.charCodeAt(0),
        safeContents: [],
        /**
         * Gets bags with matching attributes.
         *
         * @param filter the attributes to filter by:
         *          [localKeyId] the localKeyId to search for.
         *          [localKeyIdHex] the localKeyId in hex to search for.
         *          [friendlyName] the friendly name to search for.
         *          [bagType] bag type to narrow each attribute search by.
         *
         * @return a map of attribute type to an array of matching bags or, if no
         *           attribute was given but a bag type, the map key will be the
         *           bag type.
         */
        getBags: function(filter2) {
          var rval = {};
          var localKeyId;
          if ("localKeyId" in filter2) {
            localKeyId = filter2.localKeyId;
          } else if ("localKeyIdHex" in filter2) {
            localKeyId = forge.util.hexToBytes(filter2.localKeyIdHex);
          }
          if (localKeyId === void 0 && !("friendlyName" in filter2) && "bagType" in filter2) {
            rval[filter2.bagType] = _getBagsByAttribute(
              pfx.safeContents,
              null,
              null,
              filter2.bagType
            );
          }
          if (localKeyId !== void 0) {
            rval.localKeyId = _getBagsByAttribute(
              pfx.safeContents,
              "localKeyId",
              localKeyId,
              filter2.bagType
            );
          }
          if ("friendlyName" in filter2) {
            rval.friendlyName = _getBagsByAttribute(
              pfx.safeContents,
              "friendlyName",
              filter2.friendlyName,
              filter2.bagType
            );
          }
          return rval;
        },
        /**
         * DEPRECATED: use getBags() instead.
         *
         * Get bags with matching friendlyName attribute.
         *
         * @param friendlyName the friendly name to search for.
         * @param [bagType] bag type to narrow search by.
         *
         * @return an array of bags with matching friendlyName attribute.
         */
        getBagsByFriendlyName: function(friendlyName, bagType) {
          return _getBagsByAttribute(
            pfx.safeContents,
            "friendlyName",
            friendlyName,
            bagType
          );
        },
        /**
         * DEPRECATED: use getBags() instead.
         *
         * Get bags with matching localKeyId attribute.
         *
         * @param localKeyId the localKeyId to search for.
         * @param [bagType] bag type to narrow search by.
         *
         * @return an array of bags with matching localKeyId attribute.
         */
        getBagsByLocalKeyId: function(localKeyId, bagType) {
          return _getBagsByAttribute(
            pfx.safeContents,
            "localKeyId",
            localKeyId,
            bagType
          );
        }
      };
      if (capture.version.charCodeAt(0) !== 3) {
        var error = new Error("PKCS#12 PFX of version other than 3 not supported.");
        error.version = capture.version.charCodeAt(0);
        throw error;
      }
      if (asn1.derToOid(capture.contentType) !== pki.oids.data) {
        var error = new Error("Only PKCS#12 PFX in password integrity mode supported.");
        error.oid = asn1.derToOid(capture.contentType);
        throw error;
      }
      var data = capture.content.value[0];
      if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) {
        throw new Error("PKCS#12 authSafe content data is not an OCTET STRING.");
      }
      data = _decodePkcs7Data(data);
      if (capture.mac) {
        var md2 = null;
        var macKeyBytes = 0;
        var macAlgorithm = asn1.derToOid(capture.macAlgorithm);
        switch (macAlgorithm) {
          case pki.oids.sha1:
            md2 = forge.md.sha1.create();
            macKeyBytes = 20;
            break;
          case pki.oids.sha256:
            md2 = forge.md.sha256.create();
            macKeyBytes = 32;
            break;
          case pki.oids.sha384:
            md2 = forge.md.sha384.create();
            macKeyBytes = 48;
            break;
          case pki.oids.sha512:
            md2 = forge.md.sha512.create();
            macKeyBytes = 64;
            break;
          case pki.oids.md5:
            md2 = forge.md.md5.create();
            macKeyBytes = 16;
            break;
        }
        if (md2 === null) {
          throw new Error("PKCS#12 uses unsupported MAC algorithm: " + macAlgorithm);
        }
        var macSalt = new forge.util.ByteBuffer(capture.macSalt);
        var macIterations = "macIterations" in capture ? parseInt(forge.util.bytesToHex(capture.macIterations), 16) : 1;
        var macKey = p12.generateKey(
          password,
          macSalt,
          3,
          macIterations,
          macKeyBytes,
          md2
        );
        var mac = forge.hmac.create();
        mac.start(md2, macKey);
        mac.update(data.value);
        var macValue = mac.getMac();
        if (macValue.getBytes() !== capture.macDigest) {
          throw new Error("PKCS#12 MAC could not be verified. Invalid password?");
        }
      }
      _decodeAuthenticatedSafe(pfx, data.value, strict, password);
      return pfx;
    };
    function _decodePkcs7Data(data) {
      if (data.composed || data.constructed) {
        var value = forge.util.createBuffer();
        for (var i2 = 0; i2 < data.value.length; ++i2) {
          value.putBytes(data.value[i2].value);
        }
        data.composed = data.constructed = false;
        data.value = value.getBytes();
      }
      return data;
    }
    function _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {
      authSafe = asn1.fromDer(authSafe, strict);
      if (authSafe.tagClass !== asn1.Class.UNIVERSAL || authSafe.type !== asn1.Type.SEQUENCE || authSafe.constructed !== true) {
        throw new Error("PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo");
      }
      for (var i2 = 0; i2 < authSafe.value.length; i2++) {
        var contentInfo = authSafe.value[i2];
        var capture = {};
        var errors = [];
        if (!asn1.validate(contentInfo, contentInfoValidator, capture, errors)) {
          var error = new Error("Cannot read ContentInfo.");
          error.errors = errors;
          throw error;
        }
        var obj = {
          encrypted: false
        };
        var safeContents = null;
        var data = capture.content.value[0];
        switch (asn1.derToOid(capture.contentType)) {
          case pki.oids.data:
            if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) {
              throw new Error("PKCS#12 SafeContents Data is not an OCTET STRING.");
            }
            safeContents = _decodePkcs7Data(data).value;
            break;
          case pki.oids.encryptedData:
            safeContents = _decryptSafeContents(data, password);
            obj.encrypted = true;
            break;
          default:
            var error = new Error("Unsupported PKCS#12 contentType.");
            error.contentType = asn1.derToOid(capture.contentType);
            throw error;
        }
        obj.safeBags = _decodeSafeContents(safeContents, strict, password);
        pfx.safeContents.push(obj);
      }
    }
    function _decryptSafeContents(data, password) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(
        data,
        forge.pkcs7.asn1.encryptedDataValidator,
        capture,
        errors
      )) {
        var error = new Error("Cannot read EncryptedContentInfo.");
        error.errors = errors;
        throw error;
      }
      var oid = asn1.derToOid(capture.contentType);
      if (oid !== pki.oids.data) {
        var error = new Error(
          "PKCS#12 EncryptedContentInfo ContentType is not Data."
        );
        error.oid = oid;
        throw error;
      }
      oid = asn1.derToOid(capture.encAlgorithm);
      var cipher = pki.pbe.getCipher(oid, capture.encParameter, password);
      var encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1);
      var encrypted = forge.util.createBuffer(encryptedContentAsn1.value);
      cipher.update(encrypted);
      if (!cipher.finish()) {
        throw new Error("Failed to decrypt PKCS#12 SafeContents.");
      }
      return cipher.output.getBytes();
    }
    function _decodeSafeContents(safeContents, strict, password) {
      if (!strict && safeContents.length === 0) {
        return [];
      }
      safeContents = asn1.fromDer(safeContents, strict);
      if (safeContents.tagClass !== asn1.Class.UNIVERSAL || safeContents.type !== asn1.Type.SEQUENCE || safeContents.constructed !== true) {
        throw new Error(
          "PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag."
        );
      }
      var res = [];
      for (var i2 = 0; i2 < safeContents.value.length; i2++) {
        var safeBag = safeContents.value[i2];
        var capture = {};
        var errors = [];
        if (!asn1.validate(safeBag, safeBagValidator, capture, errors)) {
          var error = new Error("Cannot read SafeBag.");
          error.errors = errors;
          throw error;
        }
        var bag = {
          type: asn1.derToOid(capture.bagId),
          attributes: _decodeBagAttributes(capture.bagAttributes)
        };
        res.push(bag);
        var validator, decoder;
        var bagAsn1 = capture.bagValue.value[0];
        switch (bag.type) {
          case pki.oids.pkcs8ShroudedKeyBag:
            bagAsn1 = pki.decryptPrivateKeyInfo(bagAsn1, password);
            if (bagAsn1 === null) {
              throw new Error(
                "Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?"
              );
            }
          case pki.oids.keyBag:
            try {
              bag.key = pki.privateKeyFromAsn1(bagAsn1);
            } catch (e) {
              bag.key = null;
              bag.asn1 = bagAsn1;
            }
            continue;
          case pki.oids.certBag:
            validator = certBagValidator;
            decoder = function() {
              if (asn1.derToOid(capture.certId) !== pki.oids.x509Certificate) {
                var error2 = new Error(
                  "Unsupported certificate type, only X.509 supported."
                );
                error2.oid = asn1.derToOid(capture.certId);
                throw error2;
              }
              var certAsn1 = asn1.fromDer(capture.cert, strict);
              try {
                bag.cert = pki.certificateFromAsn1(certAsn1, true);
              } catch (e) {
                bag.cert = null;
                bag.asn1 = certAsn1;
              }
            };
            break;
          default:
            var error = new Error("Unsupported PKCS#12 SafeBag type.");
            error.oid = bag.type;
            throw error;
        }
        if (validator !== void 0 && !asn1.validate(bagAsn1, validator, capture, errors)) {
          var error = new Error("Cannot read PKCS#12 " + validator.name);
          error.errors = errors;
          throw error;
        }
        decoder();
      }
      return res;
    }
    function _decodeBagAttributes(attributes) {
      var decodedAttrs = {};
      if (attributes !== void 0) {
        for (var i2 = 0; i2 < attributes.length; ++i2) {
          var capture = {};
          var errors = [];
          if (!asn1.validate(attributes[i2], attributeValidator, capture, errors)) {
            var error = new Error("Cannot read PKCS#12 BagAttribute.");
            error.errors = errors;
            throw error;
          }
          var oid = asn1.derToOid(capture.oid);
          if (pki.oids[oid] === void 0) {
            continue;
          }
          decodedAttrs[pki.oids[oid]] = [];
          for (var j2 = 0; j2 < capture.values.length; ++j2) {
            decodedAttrs[pki.oids[oid]].push(capture.values[j2].value);
          }
        }
      }
      return decodedAttrs;
    }
    p12.toPkcs12Asn1 = function(key, cert2, password, options) {
      options = options || {};
      options.saltSize = options.saltSize || 8;
      options.count = options.count || 2048;
      options.algorithm = options.algorithm || options.encAlgorithm || "aes128";
      if (!("useMac" in options)) {
        options.useMac = true;
      }
      if (!("localKeyId" in options)) {
        options.localKeyId = null;
      }
      if (!("generateLocalKeyId" in options)) {
        options.generateLocalKeyId = true;
      }
      var localKeyId = options.localKeyId;
      var bagAttrs;
      if (localKeyId !== null) {
        localKeyId = forge.util.hexToBytes(localKeyId);
      } else if (options.generateLocalKeyId) {
        if (cert2) {
          var pairedCert = forge.util.isArray(cert2) ? cert2[0] : cert2;
          if (typeof pairedCert === "string") {
            pairedCert = pki.certificateFromPem(pairedCert);
          }
          var sha1 = forge.md.sha1.create();
          sha1.update(asn1.toDer(pki.certificateToAsn1(pairedCert)).getBytes());
          localKeyId = sha1.digest().getBytes();
        } else {
          localKeyId = forge.random.getBytes(20);
        }
      }
      var attrs = [];
      if (localKeyId !== null) {
        attrs.push(
          // localKeyID
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // attrId
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki.oids.localKeyId).getBytes()
            ),
            // attrValues
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OCTETSTRING,
                false,
                localKeyId
              )
            ])
          ])
        );
      }
      if ("friendlyName" in options) {
        attrs.push(
          // friendlyName
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // attrId
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki.oids.friendlyName).getBytes()
            ),
            // attrValues
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.BMPSTRING,
                false,
                options.friendlyName
              )
            ])
          ])
        );
      }
      if (attrs.length > 0) {
        bagAttrs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, attrs);
      }
      var contents = [];
      var chain = [];
      if (cert2 !== null) {
        if (forge.util.isArray(cert2)) {
          chain = cert2;
        } else {
          chain = [cert2];
        }
      }
      var certSafeBags = [];
      for (var i2 = 0; i2 < chain.length; ++i2) {
        cert2 = chain[i2];
        if (typeof cert2 === "string") {
          cert2 = pki.certificateFromPem(cert2);
        }
        var certBagAttrs = i2 === 0 ? bagAttrs : void 0;
        var certAsn1 = pki.certificateToAsn1(cert2);
        var certSafeBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // bagId
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(pki.oids.certBag).getBytes()
          ),
          // bagValue
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            // CertBag
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // certId
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(pki.oids.x509Certificate).getBytes()
              ),
              // certValue (x509Certificate)
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OCTETSTRING,
                  false,
                  asn1.toDer(certAsn1).getBytes()
                )
              ])
            ])
          ]),
          // bagAttributes (OPTIONAL)
          certBagAttrs
        ]);
        certSafeBags.push(certSafeBag);
      }
      if (certSafeBags.length > 0) {
        var certSafeContents = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          certSafeBags
        );
        var certCI = (
          // PKCS#7 ContentInfo
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // contentType
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              // OID for the content type is 'data'
              asn1.oidToDer(pki.oids.data).getBytes()
            ),
            // content
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OCTETSTRING,
                false,
                asn1.toDer(certSafeContents).getBytes()
              )
            ])
          ])
        );
        contents.push(certCI);
      }
      var keyBag = null;
      if (key !== null) {
        var pkAsn1 = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(key));
        if (password === null) {
          keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // bagId
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki.oids.keyBag).getBytes()
            ),
            // bagValue
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              // PrivateKeyInfo
              pkAsn1
            ]),
            // bagAttributes (OPTIONAL)
            bagAttrs
          ]);
        } else {
          keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // bagId
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki.oids.pkcs8ShroudedKeyBag).getBytes()
            ),
            // bagValue
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              // EncryptedPrivateKeyInfo
              pki.encryptPrivateKeyInfo(pkAsn1, password, options)
            ]),
            // bagAttributes (OPTIONAL)
            bagAttrs
          ]);
        }
        var keySafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [keyBag]);
        var keyCI = (
          // PKCS#7 ContentInfo
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // contentType
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              // OID for the content type is 'data'
              asn1.oidToDer(pki.oids.data).getBytes()
            ),
            // content
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OCTETSTRING,
                false,
                asn1.toDer(keySafeContents).getBytes()
              )
            ])
          ])
        );
        contents.push(keyCI);
      }
      var safe = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        contents
      );
      var macData;
      if (options.useMac) {
        var sha1 = forge.md.sha1.create();
        var macSalt = new forge.util.ByteBuffer(
          forge.random.getBytes(options.saltSize)
        );
        var count = options.count;
        var key = p12.generateKey(password, macSalt, 3, count, 20);
        var mac = forge.hmac.create();
        mac.start(sha1, key);
        mac.update(asn1.toDer(safe).getBytes());
        var macValue = mac.getMac();
        macData = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // mac DigestInfo
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // digestAlgorithm
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // algorithm = SHA-1
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(pki.oids.sha1).getBytes()
              ),
              // parameters = Null
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
            ]),
            // digest
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OCTETSTRING,
              false,
              macValue.getBytes()
            )
          ]),
          // macSalt OCTET STRING
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OCTETSTRING,
            false,
            macSalt.getBytes()
          ),
          // iterations INTEGER (XXX: Only support count < 65536)
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            asn1.integerToDer(count).getBytes()
          )
        ]);
      }
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version (3)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(3).getBytes()
        ),
        // PKCS#7 ContentInfo
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // contentType
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            // OID for the content type is 'data'
            asn1.oidToDer(pki.oids.data).getBytes()
          ),
          // content
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OCTETSTRING,
              false,
              asn1.toDer(safe).getBytes()
            )
          ])
        ]),
        macData
      ]);
    };
    p12.generateKey = forge.pbe.generatePkcs12Key;
  }
});

// node_modules/node-forge/lib/pki.js
var require_pki = __commonJS({
  "node_modules/node-forge/lib/pki.js"(exports, module) {
    var forge = require_forge();
    require_asn1();
    require_oids();
    require_pbe();
    require_pem();
    require_pbkdf2();
    require_pkcs12();
    require_pss();
    require_rsa();
    require_util2();
    require_x509();
    var asn1 = forge.asn1;
    var pki = module.exports = forge.pki = forge.pki || {};
    pki.pemToDer = function(pem) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert PEM to DER; PEM is encrypted.");
      }
      return forge.util.createBuffer(msg.body);
    };
    pki.privateKeyFromPem = function(pem) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
        var error = new Error('Could not convert private key from PEM; PEM header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert private key from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body);
      return pki.privateKeyFromAsn1(obj);
    };
    pki.privateKeyToPem = function(key, maxline) {
      var msg = {
        type: "RSA PRIVATE KEY",
        body: asn1.toDer(pki.privateKeyToAsn1(key)).getBytes()
      };
      return forge.pem.encode(msg, { maxline });
    };
    pki.privateKeyInfoToPem = function(pki2, maxline) {
      var msg = {
        type: "PRIVATE KEY",
        body: asn1.toDer(pki2).getBytes()
      };
      return forge.pem.encode(msg, { maxline });
    };
  }
});

// node_modules/node-forge/lib/tls.js
var require_tls = __commonJS({
  "node_modules/node-forge/lib/tls.js"(exports, module) {
    var forge = require_forge();
    require_asn1();
    require_hmac();
    require_md5();
    require_pem();
    require_pki();
    require_random();
    require_sha1();
    require_util2();
    var prf_TLS1 = function(secret, label, seed, length) {
      var rval = forge.util.createBuffer();
      var idx = secret.length >> 1;
      var slen = idx + (secret.length & 1);
      var s1 = secret.substr(0, slen);
      var s2 = secret.substr(idx, slen);
      var ai2 = forge.util.createBuffer();
      var hmac = forge.hmac.create();
      seed = label + seed;
      var md5itr = Math.ceil(length / 16);
      var sha1itr = Math.ceil(length / 20);
      hmac.start("MD5", s1);
      var md5bytes = forge.util.createBuffer();
      ai2.putBytes(seed);
      for (var i2 = 0; i2 < md5itr; ++i2) {
        hmac.start(null, null);
        hmac.update(ai2.getBytes());
        ai2.putBuffer(hmac.digest());
        hmac.start(null, null);
        hmac.update(ai2.bytes() + seed);
        md5bytes.putBuffer(hmac.digest());
      }
      hmac.start("SHA1", s2);
      var sha1bytes = forge.util.createBuffer();
      ai2.clear();
      ai2.putBytes(seed);
      for (var i2 = 0; i2 < sha1itr; ++i2) {
        hmac.start(null, null);
        hmac.update(ai2.getBytes());
        ai2.putBuffer(hmac.digest());
        hmac.start(null, null);
        hmac.update(ai2.bytes() + seed);
        sha1bytes.putBuffer(hmac.digest());
      }
      rval.putBytes(forge.util.xorBytes(
        md5bytes.getBytes(),
        sha1bytes.getBytes(),
        length
      ));
      return rval;
    };
    var hmac_sha1 = function(key2, seqNum, record) {
      var hmac = forge.hmac.create();
      hmac.start("SHA1", key2);
      var b2 = forge.util.createBuffer();
      b2.putInt32(seqNum[0]);
      b2.putInt32(seqNum[1]);
      b2.putByte(record.type);
      b2.putByte(record.version.major);
      b2.putByte(record.version.minor);
      b2.putInt16(record.length);
      b2.putBytes(record.fragment.bytes());
      hmac.update(b2.getBytes());
      return hmac.digest().getBytes();
    };
    var deflate = function(c, record, s) {
      var rval = false;
      try {
        var bytes = c.deflate(record.fragment.getBytes());
        record.fragment = forge.util.createBuffer(bytes);
        record.length = bytes.length;
        rval = true;
      } catch (ex) {
      }
      return rval;
    };
    var inflate = function(c, record, s) {
      var rval = false;
      try {
        var bytes = c.inflate(record.fragment.getBytes());
        record.fragment = forge.util.createBuffer(bytes);
        record.length = bytes.length;
        rval = true;
      } catch (ex) {
      }
      return rval;
    };
    var readVector = function(b2, lenBytes) {
      var len = 0;
      switch (lenBytes) {
        case 1:
          len = b2.getByte();
          break;
        case 2:
          len = b2.getInt16();
          break;
        case 3:
          len = b2.getInt24();
          break;
        case 4:
          len = b2.getInt32();
          break;
      }
      return forge.util.createBuffer(b2.getBytes(len));
    };
    var writeVector = function(b2, lenBytes, v2) {
      b2.putInt(v2.length(), lenBytes << 3);
      b2.putBuffer(v2);
    };
    var tls = {};
    tls.Versions = {
      TLS_1_0: { major: 3, minor: 1 },
      TLS_1_1: { major: 3, minor: 2 },
      TLS_1_2: { major: 3, minor: 3 }
    };
    tls.SupportedVersions = [
      tls.Versions.TLS_1_1,
      tls.Versions.TLS_1_0
    ];
    tls.Version = tls.SupportedVersions[0];
    tls.MaxFragment = 16384 - 1024;
    tls.ConnectionEnd = {
      server: 0,
      client: 1
    };
    tls.PRFAlgorithm = {
      tls_prf_sha256: 0
    };
    tls.BulkCipherAlgorithm = {
      none: null,
      rc4: 0,
      des3: 1,
      aes: 2
    };
    tls.CipherType = {
      stream: 0,
      block: 1,
      aead: 2
    };
    tls.MACAlgorithm = {
      none: null,
      hmac_md5: 0,
      hmac_sha1: 1,
      hmac_sha256: 2,
      hmac_sha384: 3,
      hmac_sha512: 4
    };
    tls.CompressionMethod = {
      none: 0,
      deflate: 1
    };
    tls.ContentType = {
      change_cipher_spec: 20,
      alert: 21,
      handshake: 22,
      application_data: 23,
      heartbeat: 24
    };
    tls.HandshakeType = {
      hello_request: 0,
      client_hello: 1,
      server_hello: 2,
      certificate: 11,
      server_key_exchange: 12,
      certificate_request: 13,
      server_hello_done: 14,
      certificate_verify: 15,
      client_key_exchange: 16,
      finished: 20
    };
    tls.Alert = {};
    tls.Alert.Level = {
      warning: 1,
      fatal: 2
    };
    tls.Alert.Description = {
      close_notify: 0,
      unexpected_message: 10,
      bad_record_mac: 20,
      decryption_failed: 21,
      record_overflow: 22,
      decompression_failure: 30,
      handshake_failure: 40,
      bad_certificate: 42,
      unsupported_certificate: 43,
      certificate_revoked: 44,
      certificate_expired: 45,
      certificate_unknown: 46,
      illegal_parameter: 47,
      unknown_ca: 48,
      access_denied: 49,
      decode_error: 50,
      decrypt_error: 51,
      export_restriction: 60,
      protocol_version: 70,
      insufficient_security: 71,
      internal_error: 80,
      user_canceled: 90,
      no_renegotiation: 100
    };
    tls.HeartbeatMessageType = {
      heartbeat_request: 1,
      heartbeat_response: 2
    };
    tls.CipherSuites = {};
    tls.getCipherSuite = function(twoBytes) {
      var rval = null;
      for (var key2 in tls.CipherSuites) {
        var cs2 = tls.CipherSuites[key2];
        if (cs2.id[0] === twoBytes.charCodeAt(0) && cs2.id[1] === twoBytes.charCodeAt(1)) {
          rval = cs2;
          break;
        }
      }
      return rval;
    };
    tls.handleUnexpected = function(c, record) {
      var ignore = !c.open && c.entity === tls.ConnectionEnd.client;
      if (!ignore) {
        c.error(c, {
          message: "Unexpected message. Received TLS record out of order.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.unexpected_message
          }
        });
      }
    };
    tls.handleHelloRequest = function(c, record, length) {
      if (!c.handshaking && c.handshakes > 0) {
        tls.queue(c, tls.createAlert(c, {
          level: tls.Alert.Level.warning,
          description: tls.Alert.Description.no_renegotiation
        }));
        tls.flush(c);
      }
      c.process();
    };
    tls.parseHelloMessage = function(c, record, length) {
      var msg = null;
      var client = c.entity === tls.ConnectionEnd.client;
      if (length < 38) {
        c.error(c, {
          message: client ? "Invalid ServerHello message. Message too short." : "Invalid ClientHello message. Message too short.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      } else {
        var b2 = record.fragment;
        var remaining = b2.length();
        msg = {
          version: {
            major: b2.getByte(),
            minor: b2.getByte()
          },
          random: forge.util.createBuffer(b2.getBytes(32)),
          session_id: readVector(b2, 1),
          extensions: []
        };
        if (client) {
          msg.cipher_suite = b2.getBytes(2);
          msg.compression_method = b2.getByte();
        } else {
          msg.cipher_suites = readVector(b2, 2);
          msg.compression_methods = readVector(b2, 1);
        }
        remaining = length - (remaining - b2.length());
        if (remaining > 0) {
          var exts = readVector(b2, 2);
          while (exts.length() > 0) {
            msg.extensions.push({
              type: [exts.getByte(), exts.getByte()],
              data: readVector(exts, 2)
            });
          }
          if (!client) {
            for (var i2 = 0; i2 < msg.extensions.length; ++i2) {
              var ext = msg.extensions[i2];
              if (ext.type[0] === 0 && ext.type[1] === 0) {
                var snl = readVector(ext.data, 2);
                while (snl.length() > 0) {
                  var snType = snl.getByte();
                  if (snType !== 0) {
                    break;
                  }
                  c.session.extensions.server_name.serverNameList.push(
                    readVector(snl, 2).getBytes()
                  );
                }
              }
            }
          }
        }
        if (c.session.version) {
          if (msg.version.major !== c.session.version.major || msg.version.minor !== c.session.version.minor) {
            return c.error(c, {
              message: "TLS version change is disallowed during renegotiation.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.protocol_version
              }
            });
          }
        }
        if (client) {
          c.session.cipherSuite = tls.getCipherSuite(msg.cipher_suite);
        } else {
          var tmp = forge.util.createBuffer(msg.cipher_suites.bytes());
          while (tmp.length() > 0) {
            c.session.cipherSuite = tls.getCipherSuite(tmp.getBytes(2));
            if (c.session.cipherSuite !== null) {
              break;
            }
          }
        }
        if (c.session.cipherSuite === null) {
          return c.error(c, {
            message: "No cipher suites in common.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.handshake_failure
            },
            cipherSuite: forge.util.bytesToHex(msg.cipher_suite)
          });
        }
        if (client) {
          c.session.compressionMethod = msg.compression_method;
        } else {
          c.session.compressionMethod = tls.CompressionMethod.none;
        }
      }
      return msg;
    };
    tls.createSecurityParameters = function(c, msg) {
      var client = c.entity === tls.ConnectionEnd.client;
      var msgRandom = msg.random.bytes();
      var cRandom = client ? c.session.sp.client_random : msgRandom;
      var sRandom = client ? msgRandom : tls.createRandom().getBytes();
      c.session.sp = {
        entity: c.entity,
        prf_algorithm: tls.PRFAlgorithm.tls_prf_sha256,
        bulk_cipher_algorithm: null,
        cipher_type: null,
        enc_key_length: null,
        block_length: null,
        fixed_iv_length: null,
        record_iv_length: null,
        mac_algorithm: null,
        mac_length: null,
        mac_key_length: null,
        compression_algorithm: c.session.compressionMethod,
        pre_master_secret: null,
        master_secret: null,
        client_random: cRandom,
        server_random: sRandom
      };
    };
    tls.handleServerHello = function(c, record, length) {
      var msg = tls.parseHelloMessage(c, record, length);
      if (c.fail) {
        return;
      }
      if (msg.version.minor <= c.version.minor) {
        c.version.minor = msg.version.minor;
      } else {
        return c.error(c, {
          message: "Incompatible TLS version.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.protocol_version
          }
        });
      }
      c.session.version = c.version;
      var sessionId = msg.session_id.bytes();
      if (sessionId.length > 0 && sessionId === c.session.id) {
        c.expect = SCC;
        c.session.resuming = true;
        c.session.sp.server_random = msg.random.bytes();
      } else {
        c.expect = SCE;
        c.session.resuming = false;
        tls.createSecurityParameters(c, msg);
      }
      c.session.id = sessionId;
      c.process();
    };
    tls.handleClientHello = function(c, record, length) {
      var msg = tls.parseHelloMessage(c, record, length);
      if (c.fail) {
        return;
      }
      var sessionId = msg.session_id.bytes();
      var session = null;
      if (c.sessionCache) {
        session = c.sessionCache.getSession(sessionId);
        if (session === null) {
          sessionId = "";
        } else if (session.version.major !== msg.version.major || session.version.minor > msg.version.minor) {
          session = null;
          sessionId = "";
        }
      }
      if (sessionId.length === 0) {
        sessionId = forge.random.getBytes(32);
      }
      c.session.id = sessionId;
      c.session.clientHelloVersion = msg.version;
      c.session.sp = {};
      if (session) {
        c.version = c.session.version = session.version;
        c.session.sp = session.sp;
      } else {
        var version3;
        for (var i2 = 1; i2 < tls.SupportedVersions.length; ++i2) {
          version3 = tls.SupportedVersions[i2];
          if (version3.minor <= msg.version.minor) {
            break;
          }
        }
        c.version = { major: version3.major, minor: version3.minor };
        c.session.version = c.version;
      }
      if (session !== null) {
        c.expect = CCC;
        c.session.resuming = true;
        c.session.sp.client_random = msg.random.bytes();
      } else {
        c.expect = c.verifyClient !== false ? CCE : CKE;
        c.session.resuming = false;
        tls.createSecurityParameters(c, msg);
      }
      c.open = true;
      tls.queue(c, tls.createRecord(c, {
        type: tls.ContentType.handshake,
        data: tls.createServerHello(c)
      }));
      if (c.session.resuming) {
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.change_cipher_spec,
          data: tls.createChangeCipherSpec()
        }));
        c.state.pending = tls.createConnectionState(c);
        c.state.current.write = c.state.pending.write;
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.handshake,
          data: tls.createFinished(c)
        }));
      } else {
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.handshake,
          data: tls.createCertificate(c)
        }));
        if (!c.fail) {
          tls.queue(c, tls.createRecord(c, {
            type: tls.ContentType.handshake,
            data: tls.createServerKeyExchange(c)
          }));
          if (c.verifyClient !== false) {
            tls.queue(c, tls.createRecord(c, {
              type: tls.ContentType.handshake,
              data: tls.createCertificateRequest(c)
            }));
          }
          tls.queue(c, tls.createRecord(c, {
            type: tls.ContentType.handshake,
            data: tls.createServerHelloDone(c)
          }));
        }
      }
      tls.flush(c);
      c.process();
    };
    tls.handleCertificate = function(c, record, length) {
      if (length < 3) {
        return c.error(c, {
          message: "Invalid Certificate message. Message too short.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      }
      var b2 = record.fragment;
      var msg = {
        certificate_list: readVector(b2, 3)
      };
      var cert2, asn1;
      var certs = [];
      try {
        while (msg.certificate_list.length() > 0) {
          cert2 = readVector(msg.certificate_list, 3);
          asn1 = forge.asn1.fromDer(cert2);
          cert2 = forge.pki.certificateFromAsn1(asn1, true);
          certs.push(cert2);
        }
      } catch (ex) {
        return c.error(c, {
          message: "Could not parse certificate list.",
          cause: ex,
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.bad_certificate
          }
        });
      }
      var client = c.entity === tls.ConnectionEnd.client;
      if ((client || c.verifyClient === true) && certs.length === 0) {
        c.error(c, {
          message: client ? "No server certificate provided." : "No client certificate provided.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      } else if (certs.length === 0) {
        c.expect = client ? SKE : CKE;
      } else {
        if (client) {
          c.session.serverCertificate = certs[0];
        } else {
          c.session.clientCertificate = certs[0];
        }
        if (tls.verifyCertificateChain(c, certs)) {
          c.expect = client ? SKE : CKE;
        }
      }
      c.process();
    };
    tls.handleServerKeyExchange = function(c, record, length) {
      if (length > 0) {
        return c.error(c, {
          message: "Invalid key parameters. Only RSA is supported.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.unsupported_certificate
          }
        });
      }
      c.expect = SCR;
      c.process();
    };
    tls.handleClientKeyExchange = function(c, record, length) {
      if (length < 48) {
        return c.error(c, {
          message: "Invalid key parameters. Only RSA is supported.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.unsupported_certificate
          }
        });
      }
      var b2 = record.fragment;
      var msg = {
        enc_pre_master_secret: readVector(b2, 2).getBytes()
      };
      var privateKey = null;
      if (c.getPrivateKey) {
        try {
          privateKey = c.getPrivateKey(c, c.session.serverCertificate);
          privateKey = forge.pki.privateKeyFromPem(privateKey);
        } catch (ex) {
          c.error(c, {
            message: "Could not get private key.",
            cause: ex,
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        }
      }
      if (privateKey === null) {
        return c.error(c, {
          message: "No private key set.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.internal_error
          }
        });
      }
      try {
        var sp = c.session.sp;
        sp.pre_master_secret = privateKey.decrypt(msg.enc_pre_master_secret);
        var version3 = c.session.clientHelloVersion;
        if (version3.major !== sp.pre_master_secret.charCodeAt(0) || version3.minor !== sp.pre_master_secret.charCodeAt(1)) {
          throw new Error("TLS version rollback attack detected.");
        }
      } catch (ex) {
        sp.pre_master_secret = forge.random.getBytes(48);
      }
      c.expect = CCC;
      if (c.session.clientCertificate !== null) {
        c.expect = CCV;
      }
      c.process();
    };
    tls.handleCertificateRequest = function(c, record, length) {
      if (length < 3) {
        return c.error(c, {
          message: "Invalid CertificateRequest. Message too short.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      }
      var b2 = record.fragment;
      var msg = {
        certificate_types: readVector(b2, 1),
        certificate_authorities: readVector(b2, 2)
      };
      c.session.certificateRequest = msg;
      c.expect = SHD;
      c.process();
    };
    tls.handleCertificateVerify = function(c, record, length) {
      if (length < 2) {
        return c.error(c, {
          message: "Invalid CertificateVerify. Message too short.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      }
      var b2 = record.fragment;
      b2.read -= 4;
      var msgBytes = b2.bytes();
      b2.read += 4;
      var msg = {
        signature: readVector(b2, 2).getBytes()
      };
      var verify = forge.util.createBuffer();
      verify.putBuffer(c.session.md5.digest());
      verify.putBuffer(c.session.sha1.digest());
      verify = verify.getBytes();
      try {
        var cert2 = c.session.clientCertificate;
        if (!cert2.publicKey.verify(verify, msg.signature, "NONE")) {
          throw new Error("CertificateVerify signature does not match.");
        }
        c.session.md5.update(msgBytes);
        c.session.sha1.update(msgBytes);
      } catch (ex) {
        return c.error(c, {
          message: "Bad signature in CertificateVerify.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.handshake_failure
          }
        });
      }
      c.expect = CCC;
      c.process();
    };
    tls.handleServerHelloDone = function(c, record, length) {
      if (length > 0) {
        return c.error(c, {
          message: "Invalid ServerHelloDone message. Invalid length.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.record_overflow
          }
        });
      }
      if (c.serverCertificate === null) {
        var error = {
          message: "No server certificate provided. Not enough security.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.insufficient_security
          }
        };
        var depth = 0;
        var ret = c.verify(c, error.alert.description, depth, []);
        if (ret !== true) {
          if (ret || ret === 0) {
            if (typeof ret === "object" && !forge.util.isArray(ret)) {
              if (ret.message) {
                error.message = ret.message;
              }
              if (ret.alert) {
                error.alert.description = ret.alert;
              }
            } else if (typeof ret === "number") {
              error.alert.description = ret;
            }
          }
          return c.error(c, error);
        }
      }
      if (c.session.certificateRequest !== null) {
        record = tls.createRecord(c, {
          type: tls.ContentType.handshake,
          data: tls.createCertificate(c)
        });
        tls.queue(c, record);
      }
      record = tls.createRecord(c, {
        type: tls.ContentType.handshake,
        data: tls.createClientKeyExchange(c)
      });
      tls.queue(c, record);
      c.expect = SER;
      var callback = function(c2, signature) {
        if (c2.session.certificateRequest !== null && c2.session.clientCertificate !== null) {
          tls.queue(c2, tls.createRecord(c2, {
            type: tls.ContentType.handshake,
            data: tls.createCertificateVerify(c2, signature)
          }));
        }
        tls.queue(c2, tls.createRecord(c2, {
          type: tls.ContentType.change_cipher_spec,
          data: tls.createChangeCipherSpec()
        }));
        c2.state.pending = tls.createConnectionState(c2);
        c2.state.current.write = c2.state.pending.write;
        tls.queue(c2, tls.createRecord(c2, {
          type: tls.ContentType.handshake,
          data: tls.createFinished(c2)
        }));
        c2.expect = SCC;
        tls.flush(c2);
        c2.process();
      };
      if (c.session.certificateRequest === null || c.session.clientCertificate === null) {
        return callback(c, null);
      }
      tls.getClientSignature(c, callback);
    };
    tls.handleChangeCipherSpec = function(c, record) {
      if (record.fragment.getByte() !== 1) {
        return c.error(c, {
          message: "Invalid ChangeCipherSpec message received.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      }
      var client = c.entity === tls.ConnectionEnd.client;
      if (c.session.resuming && client || !c.session.resuming && !client) {
        c.state.pending = tls.createConnectionState(c);
      }
      c.state.current.read = c.state.pending.read;
      if (!c.session.resuming && client || c.session.resuming && !client) {
        c.state.pending = null;
      }
      c.expect = client ? SFI : CFI;
      c.process();
    };
    tls.handleFinished = function(c, record, length) {
      var b2 = record.fragment;
      b2.read -= 4;
      var msgBytes = b2.bytes();
      b2.read += 4;
      var vd2 = record.fragment.getBytes();
      b2 = forge.util.createBuffer();
      b2.putBuffer(c.session.md5.digest());
      b2.putBuffer(c.session.sha1.digest());
      var client = c.entity === tls.ConnectionEnd.client;
      var label = client ? "server finished" : "client finished";
      var sp = c.session.sp;
      var vdl = 12;
      var prf = prf_TLS1;
      b2 = prf(sp.master_secret, label, b2.getBytes(), vdl);
      if (b2.getBytes() !== vd2) {
        return c.error(c, {
          message: "Invalid verify_data in Finished message.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.decrypt_error
          }
        });
      }
      c.session.md5.update(msgBytes);
      c.session.sha1.update(msgBytes);
      if (c.session.resuming && client || !c.session.resuming && !client) {
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.change_cipher_spec,
          data: tls.createChangeCipherSpec()
        }));
        c.state.current.write = c.state.pending.write;
        c.state.pending = null;
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.handshake,
          data: tls.createFinished(c)
        }));
      }
      c.expect = client ? SAD : CAD;
      c.handshaking = false;
      ++c.handshakes;
      c.peerCertificate = client ? c.session.serverCertificate : c.session.clientCertificate;
      tls.flush(c);
      c.isConnected = true;
      c.connected(c);
      c.process();
    };
    tls.handleAlert = function(c, record) {
      var b2 = record.fragment;
      var alert = {
        level: b2.getByte(),
        description: b2.getByte()
      };
      var msg;
      switch (alert.description) {
        case tls.Alert.Description.close_notify:
          msg = "Connection closed.";
          break;
        case tls.Alert.Description.unexpected_message:
          msg = "Unexpected message.";
          break;
        case tls.Alert.Description.bad_record_mac:
          msg = "Bad record MAC.";
          break;
        case tls.Alert.Description.decryption_failed:
          msg = "Decryption failed.";
          break;
        case tls.Alert.Description.record_overflow:
          msg = "Record overflow.";
          break;
        case tls.Alert.Description.decompression_failure:
          msg = "Decompression failed.";
          break;
        case tls.Alert.Description.handshake_failure:
          msg = "Handshake failure.";
          break;
        case tls.Alert.Description.bad_certificate:
          msg = "Bad certificate.";
          break;
        case tls.Alert.Description.unsupported_certificate:
          msg = "Unsupported certificate.";
          break;
        case tls.Alert.Description.certificate_revoked:
          msg = "Certificate revoked.";
          break;
        case tls.Alert.Description.certificate_expired:
          msg = "Certificate expired.";
          break;
        case tls.Alert.Description.certificate_unknown:
          msg = "Certificate unknown.";
          break;
        case tls.Alert.Description.illegal_parameter:
          msg = "Illegal parameter.";
          break;
        case tls.Alert.Description.unknown_ca:
          msg = "Unknown certificate authority.";
          break;
        case tls.Alert.Description.access_denied:
          msg = "Access denied.";
          break;
        case tls.Alert.Description.decode_error:
          msg = "Decode error.";
          break;
        case tls.Alert.Description.decrypt_error:
          msg = "Decrypt error.";
          break;
        case tls.Alert.Description.export_restriction:
          msg = "Export restriction.";
          break;
        case tls.Alert.Description.protocol_version:
          msg = "Unsupported protocol version.";
          break;
        case tls.Alert.Description.insufficient_security:
          msg = "Insufficient security.";
          break;
        case tls.Alert.Description.internal_error:
          msg = "Internal error.";
          break;
        case tls.Alert.Description.user_canceled:
          msg = "User canceled.";
          break;
        case tls.Alert.Description.no_renegotiation:
          msg = "Renegotiation not supported.";
          break;
        default:
          msg = "Unknown error.";
          break;
      }
      if (alert.description === tls.Alert.Description.close_notify) {
        return c.close();
      }
      c.error(c, {
        message: msg,
        send: false,
        // origin is the opposite end
        origin: c.entity === tls.ConnectionEnd.client ? "server" : "client",
        alert
      });
      c.process();
    };
    tls.handleHandshake = function(c, record) {
      var b2 = record.fragment;
      var type = b2.getByte();
      var length = b2.getInt24();
      if (length > b2.length()) {
        c.fragmented = record;
        record.fragment = forge.util.createBuffer();
        b2.read -= 4;
        return c.process();
      }
      c.fragmented = null;
      b2.read -= 4;
      var bytes = b2.bytes(length + 4);
      b2.read += 4;
      if (type in hsTable[c.entity][c.expect]) {
        if (c.entity === tls.ConnectionEnd.server && !c.open && !c.fail) {
          c.handshaking = true;
          c.session = {
            version: null,
            extensions: {
              server_name: {
                serverNameList: []
              }
            },
            cipherSuite: null,
            compressionMethod: null,
            serverCertificate: null,
            clientCertificate: null,
            md5: forge.md.md5.create(),
            sha1: forge.md.sha1.create()
          };
        }
        if (type !== tls.HandshakeType.hello_request && type !== tls.HandshakeType.certificate_verify && type !== tls.HandshakeType.finished) {
          c.session.md5.update(bytes);
          c.session.sha1.update(bytes);
        }
        hsTable[c.entity][c.expect][type](c, record, length);
      } else {
        tls.handleUnexpected(c, record);
      }
    };
    tls.handleApplicationData = function(c, record) {
      c.data.putBuffer(record.fragment);
      c.dataReady(c);
      c.process();
    };
    tls.handleHeartbeat = function(c, record) {
      var b2 = record.fragment;
      var type = b2.getByte();
      var length = b2.getInt16();
      var payload = b2.getBytes(length);
      if (type === tls.HeartbeatMessageType.heartbeat_request) {
        if (c.handshaking || length > payload.length) {
          return c.process();
        }
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.heartbeat,
          data: tls.createHeartbeat(
            tls.HeartbeatMessageType.heartbeat_response,
            payload
          )
        }));
        tls.flush(c);
      } else if (type === tls.HeartbeatMessageType.heartbeat_response) {
        if (payload !== c.expectedHeartbeatPayload) {
          return c.process();
        }
        if (c.heartbeatReceived) {
          c.heartbeatReceived(c, forge.util.createBuffer(payload));
        }
      }
      c.process();
    };
    var SHE = 0;
    var SCE = 1;
    var SKE = 2;
    var SCR = 3;
    var SHD = 4;
    var SCC = 5;
    var SFI = 6;
    var SAD = 7;
    var SER = 8;
    var CHE = 0;
    var CCE = 1;
    var CKE = 2;
    var CCV = 3;
    var CCC = 4;
    var CFI = 5;
    var CAD = 6;
    var __ = tls.handleUnexpected;
    var R0 = tls.handleChangeCipherSpec;
    var R1 = tls.handleAlert;
    var R22 = tls.handleHandshake;
    var R3 = tls.handleApplicationData;
    var R4 = tls.handleHeartbeat;
    var ctTable = [];
    ctTable[tls.ConnectionEnd.client] = [
      //      CC,AL,HS,AD,HB
      /*SHE*/
      [__, R1, R22, __, R4],
      /*SCE*/
      [__, R1, R22, __, R4],
      /*SKE*/
      [__, R1, R22, __, R4],
      /*SCR*/
      [__, R1, R22, __, R4],
      /*SHD*/
      [__, R1, R22, __, R4],
      /*SCC*/
      [R0, R1, __, __, R4],
      /*SFI*/
      [__, R1, R22, __, R4],
      /*SAD*/
      [__, R1, R22, R3, R4],
      /*SER*/
      [__, R1, R22, __, R4]
    ];
    ctTable[tls.ConnectionEnd.server] = [
      //      CC,AL,HS,AD
      /*CHE*/
      [__, R1, R22, __, R4],
      /*CCE*/
      [__, R1, R22, __, R4],
      /*CKE*/
      [__, R1, R22, __, R4],
      /*CCV*/
      [__, R1, R22, __, R4],
      /*CCC*/
      [R0, R1, __, __, R4],
      /*CFI*/
      [__, R1, R22, __, R4],
      /*CAD*/
      [__, R1, R22, R3, R4],
      /*CER*/
      [__, R1, R22, __, R4]
    ];
    var H0 = tls.handleHelloRequest;
    var H1 = tls.handleServerHello;
    var H22 = tls.handleCertificate;
    var H3 = tls.handleServerKeyExchange;
    var H4 = tls.handleCertificateRequest;
    var H5 = tls.handleServerHelloDone;
    var H6 = tls.handleFinished;
    var hsTable = [];
    hsTable[tls.ConnectionEnd.client] = [
      //      HR,01,SH,03,04,05,06,07,08,09,10,SC,SK,CR,HD,15,CK,17,18,19,FI
      /*SHE*/
      [__, __, H1, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*SCE*/
      [H0, __, __, __, __, __, __, __, __, __, __, H22, H3, H4, H5, __, __, __, __, __, __],
      /*SKE*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, H3, H4, H5, __, __, __, __, __, __],
      /*SCR*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, H4, H5, __, __, __, __, __, __],
      /*SHD*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, H5, __, __, __, __, __, __],
      /*SCC*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*SFI*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6],
      /*SAD*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*SER*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]
    ];
    var H7 = tls.handleClientHello;
    var H8 = tls.handleClientKeyExchange;
    var H9 = tls.handleCertificateVerify;
    hsTable[tls.ConnectionEnd.server] = [
      //      01,CH,02,03,04,05,06,07,08,09,10,CC,12,13,14,CV,CK,17,18,19,FI
      /*CHE*/
      [__, H7, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*CCE*/
      [__, __, __, __, __, __, __, __, __, __, __, H22, __, __, __, __, __, __, __, __, __],
      /*CKE*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H8, __, __, __, __],
      /*CCV*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H9, __, __, __, __, __],
      /*CCC*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*CFI*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6],
      /*CAD*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*CER*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]
    ];
    tls.generateKeys = function(c, sp) {
      var prf = prf_TLS1;
      var random = sp.client_random + sp.server_random;
      if (!c.session.resuming) {
        sp.master_secret = prf(
          sp.pre_master_secret,
          "master secret",
          random,
          48
        ).bytes();
        sp.pre_master_secret = null;
      }
      random = sp.server_random + sp.client_random;
      var length = 2 * sp.mac_key_length + 2 * sp.enc_key_length;
      var tls10 = c.version.major === tls.Versions.TLS_1_0.major && c.version.minor === tls.Versions.TLS_1_0.minor;
      if (tls10) {
        length += 2 * sp.fixed_iv_length;
      }
      var km = prf(sp.master_secret, "key expansion", random, length);
      var rval = {
        client_write_MAC_key: km.getBytes(sp.mac_key_length),
        server_write_MAC_key: km.getBytes(sp.mac_key_length),
        client_write_key: km.getBytes(sp.enc_key_length),
        server_write_key: km.getBytes(sp.enc_key_length)
      };
      if (tls10) {
        rval.client_write_IV = km.getBytes(sp.fixed_iv_length);
        rval.server_write_IV = km.getBytes(sp.fixed_iv_length);
      }
      return rval;
    };
    tls.createConnectionState = function(c) {
      var client = c.entity === tls.ConnectionEnd.client;
      var createMode = function() {
        var mode = {
          // two 32-bit numbers, first is most significant
          sequenceNumber: [0, 0],
          macKey: null,
          macLength: 0,
          macFunction: null,
          cipherState: null,
          cipherFunction: function(record) {
            return true;
          },
          compressionState: null,
          compressFunction: function(record) {
            return true;
          },
          updateSequenceNumber: function() {
            if (mode.sequenceNumber[1] === 4294967295) {
              mode.sequenceNumber[1] = 0;
              ++mode.sequenceNumber[0];
            } else {
              ++mode.sequenceNumber[1];
            }
          }
        };
        return mode;
      };
      var state = {
        read: createMode(),
        write: createMode()
      };
      state.read.update = function(c2, record) {
        if (!state.read.cipherFunction(record, state.read)) {
          c2.error(c2, {
            message: "Could not decrypt record or bad MAC.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              // doesn't matter if decryption failed or MAC was
              // invalid, return the same error so as not to reveal
              // which one occurred
              description: tls.Alert.Description.bad_record_mac
            }
          });
        } else if (!state.read.compressFunction(c2, record, state.read)) {
          c2.error(c2, {
            message: "Could not decompress record.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.decompression_failure
            }
          });
        }
        return !c2.fail;
      };
      state.write.update = function(c2, record) {
        if (!state.write.compressFunction(c2, record, state.write)) {
          c2.error(c2, {
            message: "Could not compress record.",
            send: false,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        } else if (!state.write.cipherFunction(record, state.write)) {
          c2.error(c2, {
            message: "Could not encrypt record.",
            send: false,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        }
        return !c2.fail;
      };
      if (c.session) {
        var sp = c.session.sp;
        c.session.cipherSuite.initSecurityParameters(sp);
        sp.keys = tls.generateKeys(c, sp);
        state.read.macKey = client ? sp.keys.server_write_MAC_key : sp.keys.client_write_MAC_key;
        state.write.macKey = client ? sp.keys.client_write_MAC_key : sp.keys.server_write_MAC_key;
        c.session.cipherSuite.initConnectionState(state, c, sp);
        switch (sp.compression_algorithm) {
          case tls.CompressionMethod.none:
            break;
          case tls.CompressionMethod.deflate:
            state.read.compressFunction = inflate;
            state.write.compressFunction = deflate;
            break;
          default:
            throw new Error("Unsupported compression algorithm.");
        }
      }
      return state;
    };
    tls.createRandom = function() {
      var d = /* @__PURE__ */ new Date();
      var utc = +d + d.getTimezoneOffset() * 6e4;
      var rval = forge.util.createBuffer();
      rval.putInt32(utc);
      rval.putBytes(forge.random.getBytes(28));
      return rval;
    };
    tls.createRecord = function(c, options) {
      if (!options.data) {
        return null;
      }
      var record = {
        type: options.type,
        version: {
          major: c.version.major,
          minor: c.version.minor
        },
        length: options.data.length(),
        fragment: options.data
      };
      return record;
    };
    tls.createAlert = function(c, alert) {
      var b2 = forge.util.createBuffer();
      b2.putByte(alert.level);
      b2.putByte(alert.description);
      return tls.createRecord(c, {
        type: tls.ContentType.alert,
        data: b2
      });
    };
    tls.createClientHello = function(c) {
      c.session.clientHelloVersion = {
        major: c.version.major,
        minor: c.version.minor
      };
      var cipherSuites = forge.util.createBuffer();
      for (var i2 = 0; i2 < c.cipherSuites.length; ++i2) {
        var cs2 = c.cipherSuites[i2];
        cipherSuites.putByte(cs2.id[0]);
        cipherSuites.putByte(cs2.id[1]);
      }
      var cSuites = cipherSuites.length();
      var compressionMethods = forge.util.createBuffer();
      compressionMethods.putByte(tls.CompressionMethod.none);
      var cMethods = compressionMethods.length();
      var extensions = forge.util.createBuffer();
      if (c.virtualHost) {
        var ext = forge.util.createBuffer();
        ext.putByte(0);
        ext.putByte(0);
        var serverName = forge.util.createBuffer();
        serverName.putByte(0);
        writeVector(serverName, 2, forge.util.createBuffer(c.virtualHost));
        var snList = forge.util.createBuffer();
        writeVector(snList, 2, serverName);
        writeVector(ext, 2, snList);
        extensions.putBuffer(ext);
      }
      var extLength = extensions.length();
      if (extLength > 0) {
        extLength += 2;
      }
      var sessionId = c.session.id;
      var length = sessionId.length + 1 + // session ID vector
      2 + // version (major + minor)
      4 + 28 + // random time and random bytes
      2 + cSuites + // cipher suites vector
      1 + cMethods + // compression methods vector
      extLength;
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.client_hello);
      rval.putInt24(length);
      rval.putByte(c.version.major);
      rval.putByte(c.version.minor);
      rval.putBytes(c.session.sp.client_random);
      writeVector(rval, 1, forge.util.createBuffer(sessionId));
      writeVector(rval, 2, cipherSuites);
      writeVector(rval, 1, compressionMethods);
      if (extLength > 0) {
        writeVector(rval, 2, extensions);
      }
      return rval;
    };
    tls.createServerHello = function(c) {
      var sessionId = c.session.id;
      var length = sessionId.length + 1 + // session ID vector
      2 + // version (major + minor)
      4 + 28 + // random time and random bytes
      2 + // chosen cipher suite
      1;
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.server_hello);
      rval.putInt24(length);
      rval.putByte(c.version.major);
      rval.putByte(c.version.minor);
      rval.putBytes(c.session.sp.server_random);
      writeVector(rval, 1, forge.util.createBuffer(sessionId));
      rval.putByte(c.session.cipherSuite.id[0]);
      rval.putByte(c.session.cipherSuite.id[1]);
      rval.putByte(c.session.compressionMethod);
      return rval;
    };
    tls.createCertificate = function(c) {
      var client = c.entity === tls.ConnectionEnd.client;
      var cert2 = null;
      if (c.getCertificate) {
        var hint;
        if (client) {
          hint = c.session.certificateRequest;
        } else {
          hint = c.session.extensions.server_name.serverNameList;
        }
        cert2 = c.getCertificate(c, hint);
      }
      var certList = forge.util.createBuffer();
      if (cert2 !== null) {
        try {
          if (!forge.util.isArray(cert2)) {
            cert2 = [cert2];
          }
          var asn1 = null;
          for (var i2 = 0; i2 < cert2.length; ++i2) {
            var msg = forge.pem.decode(cert2[i2])[0];
            if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
              var error = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
              error.headerType = msg.type;
              throw error;
            }
            if (msg.procType && msg.procType.type === "ENCRYPTED") {
              throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
            }
            var der = forge.util.createBuffer(msg.body);
            if (asn1 === null) {
              asn1 = forge.asn1.fromDer(der.bytes(), false);
            }
            var certBuffer = forge.util.createBuffer();
            writeVector(certBuffer, 3, der);
            certList.putBuffer(certBuffer);
          }
          cert2 = forge.pki.certificateFromAsn1(asn1);
          if (client) {
            c.session.clientCertificate = cert2;
          } else {
            c.session.serverCertificate = cert2;
          }
        } catch (ex) {
          return c.error(c, {
            message: "Could not send certificate list.",
            cause: ex,
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.bad_certificate
            }
          });
        }
      }
      var length = 3 + certList.length();
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.certificate);
      rval.putInt24(length);
      writeVector(rval, 3, certList);
      return rval;
    };
    tls.createClientKeyExchange = function(c) {
      var b2 = forge.util.createBuffer();
      b2.putByte(c.session.clientHelloVersion.major);
      b2.putByte(c.session.clientHelloVersion.minor);
      b2.putBytes(forge.random.getBytes(46));
      var sp = c.session.sp;
      sp.pre_master_secret = b2.getBytes();
      var key2 = c.session.serverCertificate.publicKey;
      b2 = key2.encrypt(sp.pre_master_secret);
      var length = b2.length + 2;
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.client_key_exchange);
      rval.putInt24(length);
      rval.putInt16(b2.length);
      rval.putBytes(b2);
      return rval;
    };
    tls.createServerKeyExchange = function(c) {
      var length = 0;
      var rval = forge.util.createBuffer();
      if (length > 0) {
        rval.putByte(tls.HandshakeType.server_key_exchange);
        rval.putInt24(length);
      }
      return rval;
    };
    tls.getClientSignature = function(c, callback) {
      var b2 = forge.util.createBuffer();
      b2.putBuffer(c.session.md5.digest());
      b2.putBuffer(c.session.sha1.digest());
      b2 = b2.getBytes();
      c.getSignature = c.getSignature || function(c2, b3, callback2) {
        var privateKey = null;
        if (c2.getPrivateKey) {
          try {
            privateKey = c2.getPrivateKey(c2, c2.session.clientCertificate);
            privateKey = forge.pki.privateKeyFromPem(privateKey);
          } catch (ex) {
            c2.error(c2, {
              message: "Could not get private key.",
              cause: ex,
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.internal_error
              }
            });
          }
        }
        if (privateKey === null) {
          c2.error(c2, {
            message: "No private key set.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        } else {
          b3 = privateKey.sign(b3, null);
        }
        callback2(c2, b3);
      };
      c.getSignature(c, b2, callback);
    };
    tls.createCertificateVerify = function(c, signature) {
      var length = signature.length + 2;
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.certificate_verify);
      rval.putInt24(length);
      rval.putInt16(signature.length);
      rval.putBytes(signature);
      return rval;
    };
    tls.createCertificateRequest = function(c) {
      var certTypes = forge.util.createBuffer();
      certTypes.putByte(1);
      var cAs = forge.util.createBuffer();
      for (var key2 in c.caStore.certs) {
        var cert2 = c.caStore.certs[key2];
        var dn2 = forge.pki.distinguishedNameToAsn1(cert2.subject);
        var byteBuffer = forge.asn1.toDer(dn2);
        cAs.putInt16(byteBuffer.length());
        cAs.putBuffer(byteBuffer);
      }
      var length = 1 + certTypes.length() + 2 + cAs.length();
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.certificate_request);
      rval.putInt24(length);
      writeVector(rval, 1, certTypes);
      writeVector(rval, 2, cAs);
      return rval;
    };
    tls.createServerHelloDone = function(c) {
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.server_hello_done);
      rval.putInt24(0);
      return rval;
    };
    tls.createChangeCipherSpec = function() {
      var rval = forge.util.createBuffer();
      rval.putByte(1);
      return rval;
    };
    tls.createFinished = function(c) {
      var b2 = forge.util.createBuffer();
      b2.putBuffer(c.session.md5.digest());
      b2.putBuffer(c.session.sha1.digest());
      var client = c.entity === tls.ConnectionEnd.client;
      var sp = c.session.sp;
      var vdl = 12;
      var prf = prf_TLS1;
      var label = client ? "client finished" : "server finished";
      b2 = prf(sp.master_secret, label, b2.getBytes(), vdl);
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.finished);
      rval.putInt24(b2.length());
      rval.putBuffer(b2);
      return rval;
    };
    tls.createHeartbeat = function(type, payload, payloadLength) {
      if (typeof payloadLength === "undefined") {
        payloadLength = payload.length;
      }
      var rval = forge.util.createBuffer();
      rval.putByte(type);
      rval.putInt16(payloadLength);
      rval.putBytes(payload);
      var plaintextLength = rval.length();
      var paddingLength = Math.max(16, plaintextLength - payloadLength - 3);
      rval.putBytes(forge.random.getBytes(paddingLength));
      return rval;
    };
    tls.queue = function(c, record) {
      if (!record) {
        return;
      }
      if (record.fragment.length() === 0) {
        if (record.type === tls.ContentType.handshake || record.type === tls.ContentType.alert || record.type === tls.ContentType.change_cipher_spec) {
          return;
        }
      }
      if (record.type === tls.ContentType.handshake) {
        var bytes = record.fragment.bytes();
        c.session.md5.update(bytes);
        c.session.sha1.update(bytes);
        bytes = null;
      }
      var records;
      if (record.fragment.length() <= tls.MaxFragment) {
        records = [record];
      } else {
        records = [];
        var data = record.fragment.bytes();
        while (data.length > tls.MaxFragment) {
          records.push(tls.createRecord(c, {
            type: record.type,
            data: forge.util.createBuffer(data.slice(0, tls.MaxFragment))
          }));
          data = data.slice(tls.MaxFragment);
        }
        if (data.length > 0) {
          records.push(tls.createRecord(c, {
            type: record.type,
            data: forge.util.createBuffer(data)
          }));
        }
      }
      for (var i2 = 0; i2 < records.length && !c.fail; ++i2) {
        var rec = records[i2];
        var s = c.state.current.write;
        if (s.update(c, rec)) {
          c.records.push(rec);
        }
      }
    };
    tls.flush = function(c) {
      for (var i2 = 0; i2 < c.records.length; ++i2) {
        var record = c.records[i2];
        c.tlsData.putByte(record.type);
        c.tlsData.putByte(record.version.major);
        c.tlsData.putByte(record.version.minor);
        c.tlsData.putInt16(record.fragment.length());
        c.tlsData.putBuffer(c.records[i2].fragment);
      }
      c.records = [];
      return c.tlsDataReady(c);
    };
    var _certErrorToAlertDesc = function(error) {
      switch (error) {
        case true:
          return true;
        case forge.pki.certificateError.bad_certificate:
          return tls.Alert.Description.bad_certificate;
        case forge.pki.certificateError.unsupported_certificate:
          return tls.Alert.Description.unsupported_certificate;
        case forge.pki.certificateError.certificate_revoked:
          return tls.Alert.Description.certificate_revoked;
        case forge.pki.certificateError.certificate_expired:
          return tls.Alert.Description.certificate_expired;
        case forge.pki.certificateError.certificate_unknown:
          return tls.Alert.Description.certificate_unknown;
        case forge.pki.certificateError.unknown_ca:
          return tls.Alert.Description.unknown_ca;
        default:
          return tls.Alert.Description.bad_certificate;
      }
    };
    var _alertDescToCertError = function(desc) {
      switch (desc) {
        case true:
          return true;
        case tls.Alert.Description.bad_certificate:
          return forge.pki.certificateError.bad_certificate;
        case tls.Alert.Description.unsupported_certificate:
          return forge.pki.certificateError.unsupported_certificate;
        case tls.Alert.Description.certificate_revoked:
          return forge.pki.certificateError.certificate_revoked;
        case tls.Alert.Description.certificate_expired:
          return forge.pki.certificateError.certificate_expired;
        case tls.Alert.Description.certificate_unknown:
          return forge.pki.certificateError.certificate_unknown;
        case tls.Alert.Description.unknown_ca:
          return forge.pki.certificateError.unknown_ca;
        default:
          return forge.pki.certificateError.bad_certificate;
      }
    };
    tls.verifyCertificateChain = function(c, chain) {
      try {
        var options = {};
        for (var key2 in c.verifyOptions) {
          options[key2] = c.verifyOptions[key2];
        }
        options.verify = function(vfd, depth, chain2) {
          var desc = _certErrorToAlertDesc(vfd);
          var ret = c.verify(c, vfd, depth, chain2);
          if (ret !== true) {
            if (typeof ret === "object" && !forge.util.isArray(ret)) {
              var error = new Error("The application rejected the certificate.");
              error.send = true;
              error.alert = {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.bad_certificate
              };
              if (ret.message) {
                error.message = ret.message;
              }
              if (ret.alert) {
                error.alert.description = ret.alert;
              }
              throw error;
            }
            if (ret !== vfd) {
              ret = _alertDescToCertError(ret);
            }
          }
          return ret;
        };
        forge.pki.verifyCertificateChain(c.caStore, chain, options);
      } catch (ex) {
        var err = ex;
        if (typeof err !== "object" || forge.util.isArray(err)) {
          err = {
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: _certErrorToAlertDesc(ex)
            }
          };
        }
        if (!("send" in err)) {
          err.send = true;
        }
        if (!("alert" in err)) {
          err.alert = {
            level: tls.Alert.Level.fatal,
            description: _certErrorToAlertDesc(err.error)
          };
        }
        c.error(c, err);
      }
      return !c.fail;
    };
    tls.createSessionCache = function(cache, capacity) {
      var rval = null;
      if (cache && cache.getSession && cache.setSession && cache.order) {
        rval = cache;
      } else {
        rval = {};
        rval.cache = cache || {};
        rval.capacity = Math.max(capacity || 100, 1);
        rval.order = [];
        for (var key2 in cache) {
          if (rval.order.length <= capacity) {
            rval.order.push(key2);
          } else {
            delete cache[key2];
          }
        }
        rval.getSession = function(sessionId) {
          var session = null;
          var key3 = null;
          if (sessionId) {
            key3 = forge.util.bytesToHex(sessionId);
          } else if (rval.order.length > 0) {
            key3 = rval.order[0];
          }
          if (key3 !== null && key3 in rval.cache) {
            session = rval.cache[key3];
            delete rval.cache[key3];
            for (var i2 in rval.order) {
              if (rval.order[i2] === key3) {
                rval.order.splice(i2, 1);
                break;
              }
            }
          }
          return session;
        };
        rval.setSession = function(sessionId, session) {
          if (rval.order.length === rval.capacity) {
            var key3 = rval.order.shift();
            delete rval.cache[key3];
          }
          var key3 = forge.util.bytesToHex(sessionId);
          rval.order.push(key3);
          rval.cache[key3] = session;
        };
      }
      return rval;
    };
    tls.createConnection = function(options) {
      var caStore = null;
      if (options.caStore) {
        if (forge.util.isArray(options.caStore)) {
          caStore = forge.pki.createCaStore(options.caStore);
        } else {
          caStore = options.caStore;
        }
      } else {
        caStore = forge.pki.createCaStore();
      }
      var cipherSuites = options.cipherSuites || null;
      if (cipherSuites === null) {
        cipherSuites = [];
        for (var key2 in tls.CipherSuites) {
          cipherSuites.push(tls.CipherSuites[key2]);
        }
      }
      var entity = options.server || false ? tls.ConnectionEnd.server : tls.ConnectionEnd.client;
      var sessionCache = options.sessionCache ? tls.createSessionCache(options.sessionCache) : null;
      var c = {
        version: { major: tls.Version.major, minor: tls.Version.minor },
        entity,
        sessionId: options.sessionId,
        caStore,
        sessionCache,
        cipherSuites,
        connected: options.connected,
        virtualHost: options.virtualHost || null,
        verifyClient: options.verifyClient || false,
        verify: options.verify || function(cn2, vfd, dpth, cts) {
          return vfd;
        },
        verifyOptions: options.verifyOptions || {},
        getCertificate: options.getCertificate || null,
        getPrivateKey: options.getPrivateKey || null,
        getSignature: options.getSignature || null,
        input: forge.util.createBuffer(),
        tlsData: forge.util.createBuffer(),
        data: forge.util.createBuffer(),
        tlsDataReady: options.tlsDataReady,
        dataReady: options.dataReady,
        heartbeatReceived: options.heartbeatReceived,
        closed: options.closed,
        error: function(c2, ex) {
          ex.origin = ex.origin || (c2.entity === tls.ConnectionEnd.client ? "client" : "server");
          if (ex.send) {
            tls.queue(c2, tls.createAlert(c2, ex.alert));
            tls.flush(c2);
          }
          var fatal = ex.fatal !== false;
          if (fatal) {
            c2.fail = true;
          }
          options.error(c2, ex);
          if (fatal) {
            c2.close(false);
          }
        },
        deflate: options.deflate || null,
        inflate: options.inflate || null
      };
      c.reset = function(clearFail) {
        c.version = { major: tls.Version.major, minor: tls.Version.minor };
        c.record = null;
        c.session = null;
        c.peerCertificate = null;
        c.state = {
          pending: null,
          current: null
        };
        c.expect = c.entity === tls.ConnectionEnd.client ? SHE : CHE;
        c.fragmented = null;
        c.records = [];
        c.open = false;
        c.handshakes = 0;
        c.handshaking = false;
        c.isConnected = false;
        c.fail = !(clearFail || typeof clearFail === "undefined");
        c.input.clear();
        c.tlsData.clear();
        c.data.clear();
        c.state.current = tls.createConnectionState(c);
      };
      c.reset();
      var _update = function(c2, record) {
        var aligned = record.type - tls.ContentType.change_cipher_spec;
        var handlers = ctTable[c2.entity][c2.expect];
        if (aligned in handlers) {
          handlers[aligned](c2, record);
        } else {
          tls.handleUnexpected(c2, record);
        }
      };
      var _readRecordHeader = function(c2) {
        var rval = 0;
        var b2 = c2.input;
        var len = b2.length();
        if (len < 5) {
          rval = 5 - len;
        } else {
          c2.record = {
            type: b2.getByte(),
            version: {
              major: b2.getByte(),
              minor: b2.getByte()
            },
            length: b2.getInt16(),
            fragment: forge.util.createBuffer(),
            ready: false
          };
          var compatibleVersion = c2.record.version.major === c2.version.major;
          if (compatibleVersion && c2.session && c2.session.version) {
            compatibleVersion = c2.record.version.minor === c2.version.minor;
          }
          if (!compatibleVersion) {
            c2.error(c2, {
              message: "Incompatible TLS version.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.protocol_version
              }
            });
          }
        }
        return rval;
      };
      var _readRecord = function(c2) {
        var rval = 0;
        var b2 = c2.input;
        var len = b2.length();
        if (len < c2.record.length) {
          rval = c2.record.length - len;
        } else {
          c2.record.fragment.putBytes(b2.getBytes(c2.record.length));
          b2.compact();
          var s = c2.state.current.read;
          if (s.update(c2, c2.record)) {
            if (c2.fragmented !== null) {
              if (c2.fragmented.type === c2.record.type) {
                c2.fragmented.fragment.putBuffer(c2.record.fragment);
                c2.record = c2.fragmented;
              } else {
                c2.error(c2, {
                  message: "Invalid fragmented record.",
                  send: true,
                  alert: {
                    level: tls.Alert.Level.fatal,
                    description: tls.Alert.Description.unexpected_message
                  }
                });
              }
            }
            c2.record.ready = true;
          }
        }
        return rval;
      };
      c.handshake = function(sessionId) {
        if (c.entity !== tls.ConnectionEnd.client) {
          c.error(c, {
            message: "Cannot initiate handshake as a server.",
            fatal: false
          });
        } else if (c.handshaking) {
          c.error(c, {
            message: "Handshake already in progress.",
            fatal: false
          });
        } else {
          if (c.fail && !c.open && c.handshakes === 0) {
            c.fail = false;
          }
          c.handshaking = true;
          sessionId = sessionId || "";
          var session = null;
          if (sessionId.length > 0) {
            if (c.sessionCache) {
              session = c.sessionCache.getSession(sessionId);
            }
            if (session === null) {
              sessionId = "";
            }
          }
          if (sessionId.length === 0 && c.sessionCache) {
            session = c.sessionCache.getSession();
            if (session !== null) {
              sessionId = session.id;
            }
          }
          c.session = {
            id: sessionId,
            version: null,
            cipherSuite: null,
            compressionMethod: null,
            serverCertificate: null,
            certificateRequest: null,
            clientCertificate: null,
            sp: {},
            md5: forge.md.md5.create(),
            sha1: forge.md.sha1.create()
          };
          if (session) {
            c.version = session.version;
            c.session.sp = session.sp;
          }
          c.session.sp.client_random = tls.createRandom().getBytes();
          c.open = true;
          tls.queue(c, tls.createRecord(c, {
            type: tls.ContentType.handshake,
            data: tls.createClientHello(c)
          }));
          tls.flush(c);
        }
      };
      c.process = function(data) {
        var rval = 0;
        if (data) {
          c.input.putBytes(data);
        }
        if (!c.fail) {
          if (c.record !== null && c.record.ready && c.record.fragment.isEmpty()) {
            c.record = null;
          }
          if (c.record === null) {
            rval = _readRecordHeader(c);
          }
          if (!c.fail && c.record !== null && !c.record.ready) {
            rval = _readRecord(c);
          }
          if (!c.fail && c.record !== null && c.record.ready) {
            _update(c, c.record);
          }
        }
        return rval;
      };
      c.prepare = function(data) {
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.application_data,
          data: forge.util.createBuffer(data)
        }));
        return tls.flush(c);
      };
      c.prepareHeartbeatRequest = function(payload, payloadLength) {
        if (payload instanceof forge.util.ByteBuffer) {
          payload = payload.bytes();
        }
        if (typeof payloadLength === "undefined") {
          payloadLength = payload.length;
        }
        c.expectedHeartbeatPayload = payload;
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.heartbeat,
          data: tls.createHeartbeat(
            tls.HeartbeatMessageType.heartbeat_request,
            payload,
            payloadLength
          )
        }));
        return tls.flush(c);
      };
      c.close = function(clearFail) {
        if (!c.fail && c.sessionCache && c.session) {
          var session = {
            id: c.session.id,
            version: c.session.version,
            sp: c.session.sp
          };
          session.sp.keys = null;
          c.sessionCache.setSession(session.id, session);
        }
        if (c.open) {
          c.open = false;
          c.input.clear();
          if (c.isConnected || c.handshaking) {
            c.isConnected = c.handshaking = false;
            tls.queue(c, tls.createAlert(c, {
              level: tls.Alert.Level.warning,
              description: tls.Alert.Description.close_notify
            }));
            tls.flush(c);
          }
          c.closed(c);
        }
        c.reset(clearFail);
      };
      return c;
    };
    module.exports = forge.tls = forge.tls || {};
    for (key in tls) {
      if (typeof tls[key] !== "function") {
        forge.tls[key] = tls[key];
      }
    }
    var key;
    forge.tls.prf_tls1 = prf_TLS1;
    forge.tls.hmac_sha1 = hmac_sha1;
    forge.tls.createSessionCache = tls.createSessionCache;
    forge.tls.createConnection = tls.createConnection;
  }
});

// node_modules/node-forge/lib/aesCipherSuites.js
var require_aesCipherSuites = __commonJS({
  "node_modules/node-forge/lib/aesCipherSuites.js"(exports, module) {
    var forge = require_forge();
    require_aes();
    require_tls();
    var tls = module.exports = forge.tls;
    tls.CipherSuites["TLS_RSA_WITH_AES_128_CBC_SHA"] = {
      id: [0, 47],
      name: "TLS_RSA_WITH_AES_128_CBC_SHA",
      initSecurityParameters: function(sp) {
        sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;
        sp.cipher_type = tls.CipherType.block;
        sp.enc_key_length = 16;
        sp.block_length = 16;
        sp.fixed_iv_length = 16;
        sp.record_iv_length = 16;
        sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;
        sp.mac_length = 20;
        sp.mac_key_length = 20;
      },
      initConnectionState
    };
    tls.CipherSuites["TLS_RSA_WITH_AES_256_CBC_SHA"] = {
      id: [0, 53],
      name: "TLS_RSA_WITH_AES_256_CBC_SHA",
      initSecurityParameters: function(sp) {
        sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;
        sp.cipher_type = tls.CipherType.block;
        sp.enc_key_length = 32;
        sp.block_length = 16;
        sp.fixed_iv_length = 16;
        sp.record_iv_length = 16;
        sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;
        sp.mac_length = 20;
        sp.mac_key_length = 20;
      },
      initConnectionState
    };
    function initConnectionState(state, c, sp) {
      var client = c.entity === forge.tls.ConnectionEnd.client;
      state.read.cipherState = {
        init: false,
        cipher: forge.cipher.createDecipher("AES-CBC", client ? sp.keys.server_write_key : sp.keys.client_write_key),
        iv: client ? sp.keys.server_write_IV : sp.keys.client_write_IV
      };
      state.write.cipherState = {
        init: false,
        cipher: forge.cipher.createCipher("AES-CBC", client ? sp.keys.client_write_key : sp.keys.server_write_key),
        iv: client ? sp.keys.client_write_IV : sp.keys.server_write_IV
      };
      state.read.cipherFunction = decrypt_aes_cbc_sha1;
      state.write.cipherFunction = encrypt_aes_cbc_sha1;
      state.read.macLength = state.write.macLength = sp.mac_length;
      state.read.macFunction = state.write.macFunction = tls.hmac_sha1;
    }
    function encrypt_aes_cbc_sha1(record, s) {
      var rval = false;
      var mac = s.macFunction(s.macKey, s.sequenceNumber, record);
      record.fragment.putBytes(mac);
      s.updateSequenceNumber();
      var iv;
      if (record.version.minor === tls.Versions.TLS_1_0.minor) {
        iv = s.cipherState.init ? null : s.cipherState.iv;
      } else {
        iv = forge.random.getBytesSync(16);
      }
      s.cipherState.init = true;
      var cipher = s.cipherState.cipher;
      cipher.start({ iv });
      if (record.version.minor >= tls.Versions.TLS_1_1.minor) {
        cipher.output.putBytes(iv);
      }
      cipher.update(record.fragment);
      if (cipher.finish(encrypt_aes_cbc_sha1_padding)) {
        record.fragment = cipher.output;
        record.length = record.fragment.length();
        rval = true;
      }
      return rval;
    }
    function encrypt_aes_cbc_sha1_padding(blockSize, input, decrypt) {
      if (!decrypt) {
        var padding = blockSize - input.length() % blockSize;
        input.fillWithByte(padding - 1, padding);
      }
      return true;
    }
    function decrypt_aes_cbc_sha1_padding(blockSize, output, decrypt) {
      var rval = true;
      if (decrypt) {
        var len = output.length();
        var paddingLength = output.last();
        for (var i2 = len - 1 - paddingLength; i2 < len - 1; ++i2) {
          rval = rval && output.at(i2) == paddingLength;
        }
        if (rval) {
          output.truncate(paddingLength + 1);
        }
      }
      return rval;
    }
    function decrypt_aes_cbc_sha1(record, s) {
      var rval = false;
      var iv;
      if (record.version.minor === tls.Versions.TLS_1_0.minor) {
        iv = s.cipherState.init ? null : s.cipherState.iv;
      } else {
        iv = record.fragment.getBytes(16);
      }
      s.cipherState.init = true;
      var cipher = s.cipherState.cipher;
      cipher.start({ iv });
      cipher.update(record.fragment);
      rval = cipher.finish(decrypt_aes_cbc_sha1_padding);
      var macLen = s.macLength;
      var mac = forge.random.getBytesSync(macLen);
      var len = cipher.output.length();
      if (len >= macLen) {
        record.fragment = cipher.output.getBytes(len - macLen);
        mac = cipher.output.getBytes(macLen);
      } else {
        record.fragment = cipher.output.getBytes();
      }
      record.fragment = forge.util.createBuffer(record.fragment);
      record.length = record.fragment.length();
      var mac2 = s.macFunction(s.macKey, s.sequenceNumber, record);
      s.updateSequenceNumber();
      rval = compareMacs(s.macKey, mac, mac2) && rval;
      return rval;
    }
    function compareMacs(key, mac1, mac2) {
      var hmac = forge.hmac.create();
      hmac.start("SHA1", key);
      hmac.update(mac1);
      mac1 = hmac.digest().getBytes();
      hmac.start(null, null);
      hmac.update(mac2);
      mac2 = hmac.digest().getBytes();
      return mac1 === mac2;
    }
  }
});

// node_modules/node-forge/lib/sha512.js
var require_sha512 = __commonJS({
  "node_modules/node-forge/lib/sha512.js"(exports, module) {
    var forge = require_forge();
    require_md();
    require_util2();
    var sha512 = module.exports = forge.sha512 = forge.sha512 || {};
    forge.md.sha512 = forge.md.algorithms.sha512 = sha512;
    var sha384 = forge.sha384 = forge.sha512.sha384 = forge.sha512.sha384 || {};
    sha384.create = function() {
      return sha512.create("SHA-384");
    };
    forge.md.sha384 = forge.md.algorithms.sha384 = sha384;
    forge.sha512.sha256 = forge.sha512.sha256 || {
      create: function() {
        return sha512.create("SHA-512/256");
      }
    };
    forge.md["sha512/256"] = forge.md.algorithms["sha512/256"] = forge.sha512.sha256;
    forge.sha512.sha224 = forge.sha512.sha224 || {
      create: function() {
        return sha512.create("SHA-512/224");
      }
    };
    forge.md["sha512/224"] = forge.md.algorithms["sha512/224"] = forge.sha512.sha224;
    sha512.create = function(algorithm) {
      if (!_initialized) {
        _init();
      }
      if (typeof algorithm === "undefined") {
        algorithm = "SHA-512";
      }
      if (!(algorithm in _states)) {
        throw new Error("Invalid SHA-512 algorithm: " + algorithm);
      }
      var _state = _states[algorithm];
      var _h = null;
      var _input = forge.util.createBuffer();
      var _w = new Array(80);
      for (var wi2 = 0; wi2 < 80; ++wi2) {
        _w[wi2] = new Array(2);
      }
      var digestLength = 64;
      switch (algorithm) {
        case "SHA-384":
          digestLength = 48;
          break;
        case "SHA-512/256":
          digestLength = 32;
          break;
        case "SHA-512/224":
          digestLength = 28;
          break;
      }
      var md2 = {
        // SHA-512 => sha512
        algorithm: algorithm.replace("-", "").toLowerCase(),
        blockLength: 128,
        digestLength,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 16
      };
      md2.start = function() {
        md2.messageLength = 0;
        md2.fullMessageLength = md2.messageLength128 = [];
        var int32s = md2.messageLengthSize / 4;
        for (var i2 = 0; i2 < int32s; ++i2) {
          md2.fullMessageLength.push(0);
        }
        _input = forge.util.createBuffer();
        _h = new Array(_state.length);
        for (var i2 = 0; i2 < _state.length; ++i2) {
          _h[i2] = _state[i2].slice(0);
        }
        return md2;
      };
      md2.start();
      md2.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md2.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i2 = md2.fullMessageLength.length - 1; i2 >= 0; --i2) {
          md2.fullMessageLength[i2] += len[1];
          len[1] = len[0] + (md2.fullMessageLength[i2] / 4294967296 >>> 0);
          md2.fullMessageLength[i2] = md2.fullMessageLength[i2] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_h, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md2;
      };
      md2.digest = function() {
        var finalBlock = forge.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md2.fullMessageLength[md2.fullMessageLength.length - 1] + md2.messageLengthSize;
        var overflow = remaining & md2.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md2.blockLength - overflow));
        var next, carry;
        var bits = md2.fullMessageLength[0] * 8;
        for (var i2 = 0; i2 < md2.fullMessageLength.length - 1; ++i2) {
          next = md2.fullMessageLength[i2 + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var h = new Array(_h.length);
        for (var i2 = 0; i2 < _h.length; ++i2) {
          h[i2] = _h[i2].slice(0);
        }
        _update(h, _w, finalBlock);
        var rval = forge.util.createBuffer();
        var hlen;
        if (algorithm === "SHA-512") {
          hlen = h.length;
        } else if (algorithm === "SHA-384") {
          hlen = h.length - 2;
        } else {
          hlen = h.length - 4;
        }
        for (var i2 = 0; i2 < hlen; ++i2) {
          rval.putInt32(h[i2][0]);
          if (i2 !== hlen - 1 || algorithm !== "SHA-512/224") {
            rval.putInt32(h[i2][1]);
          }
        }
        return rval;
      };
      return md2;
    };
    var _padding = null;
    var _initialized = false;
    var _k = null;
    var _states = null;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge.util.fillString(String.fromCharCode(0), 128);
      _k = [
        [1116352408, 3609767458],
        [1899447441, 602891725],
        [3049323471, 3964484399],
        [3921009573, 2173295548],
        [961987163, 4081628472],
        [1508970993, 3053834265],
        [2453635748, 2937671579],
        [2870763221, 3664609560],
        [3624381080, 2734883394],
        [310598401, 1164996542],
        [607225278, 1323610764],
        [1426881987, 3590304994],
        [1925078388, 4068182383],
        [2162078206, 991336113],
        [2614888103, 633803317],
        [3248222580, 3479774868],
        [3835390401, 2666613458],
        [4022224774, 944711139],
        [264347078, 2341262773],
        [604807628, 2007800933],
        [770255983, 1495990901],
        [1249150122, 1856431235],
        [1555081692, 3175218132],
        [1996064986, 2198950837],
        [2554220882, 3999719339],
        [2821834349, 766784016],
        [2952996808, 2566594879],
        [3210313671, 3203337956],
        [3336571891, 1034457026],
        [3584528711, 2466948901],
        [113926993, 3758326383],
        [338241895, 168717936],
        [666307205, 1188179964],
        [773529912, 1546045734],
        [1294757372, 1522805485],
        [1396182291, 2643833823],
        [1695183700, 2343527390],
        [1986661051, 1014477480],
        [2177026350, 1206759142],
        [2456956037, 344077627],
        [2730485921, 1290863460],
        [2820302411, 3158454273],
        [3259730800, 3505952657],
        [3345764771, 106217008],
        [3516065817, 3606008344],
        [3600352804, 1432725776],
        [4094571909, 1467031594],
        [275423344, 851169720],
        [430227734, 3100823752],
        [506948616, 1363258195],
        [659060556, 3750685593],
        [883997877, 3785050280],
        [958139571, 3318307427],
        [1322822218, 3812723403],
        [1537002063, 2003034995],
        [1747873779, 3602036899],
        [1955562222, 1575990012],
        [2024104815, 1125592928],
        [2227730452, 2716904306],
        [2361852424, 442776044],
        [2428436474, 593698344],
        [2756734187, 3733110249],
        [3204031479, 2999351573],
        [3329325298, 3815920427],
        [3391569614, 3928383900],
        [3515267271, 566280711],
        [3940187606, 3454069534],
        [4118630271, 4000239992],
        [116418474, 1914138554],
        [174292421, 2731055270],
        [289380356, 3203993006],
        [460393269, 320620315],
        [685471733, 587496836],
        [852142971, 1086792851],
        [1017036298, 365543100],
        [1126000580, 2618297676],
        [1288033470, 3409855158],
        [1501505948, 4234509866],
        [1607167915, 987167468],
        [1816402316, 1246189591]
      ];
      _states = {};
      _states["SHA-512"] = [
        [1779033703, 4089235720],
        [3144134277, 2227873595],
        [1013904242, 4271175723],
        [2773480762, 1595750129],
        [1359893119, 2917565137],
        [2600822924, 725511199],
        [528734635, 4215389547],
        [1541459225, 327033209]
      ];
      _states["SHA-384"] = [
        [3418070365, 3238371032],
        [1654270250, 914150663],
        [2438529370, 812702999],
        [355462360, 4144912697],
        [1731405415, 4290775857],
        [2394180231, 1750603025],
        [3675008525, 1694076839],
        [1203062813, 3204075428]
      ];
      _states["SHA-512/256"] = [
        [573645204, 4230739756],
        [2673172387, 3360449730],
        [596883563, 1867755857],
        [2520282905, 1497426621],
        [2519219938, 2827943907],
        [3193839141, 1401305490],
        [721525244, 746961066],
        [246885852, 2177182882]
      ];
      _states["SHA-512/224"] = [
        [2352822216, 424955298],
        [1944164710, 2312950998],
        [502970286, 855612546],
        [1738396948, 1479516111],
        [258812777, 2077511080],
        [2011393907, 79989058],
        [1067287976, 1780299464],
        [286451373, 2446758561]
      ];
      _initialized = true;
    }
    function _update(s, w2, bytes) {
      var t1_hi, t1_lo;
      var t2_hi, t2_lo;
      var s0_hi, s0_lo;
      var s1_hi, s1_lo;
      var ch_hi, ch_lo;
      var maj_hi, maj_lo;
      var a_hi, a_lo;
      var b_hi, b_lo;
      var c_hi, c_lo;
      var d_hi, d_lo;
      var e_hi, e_lo;
      var f_hi, f_lo;
      var g_hi, g_lo;
      var h_hi, h_lo;
      var i2, hi2, lo2, w22, w7, w15, w16;
      var len = bytes.length();
      while (len >= 128) {
        for (i2 = 0; i2 < 16; ++i2) {
          w2[i2][0] = bytes.getInt32() >>> 0;
          w2[i2][1] = bytes.getInt32() >>> 0;
        }
        for (; i2 < 80; ++i2) {
          w22 = w2[i2 - 2];
          hi2 = w22[0];
          lo2 = w22[1];
          t1_hi = ((hi2 >>> 19 | lo2 << 13) ^ // ROTR 19
          (lo2 >>> 29 | hi2 << 3) ^ // ROTR 61/(swap + ROTR 29)
          hi2 >>> 6) >>> 0;
          t1_lo = ((hi2 << 13 | lo2 >>> 19) ^ // ROTR 19
          (lo2 << 3 | hi2 >>> 29) ^ // ROTR 61/(swap + ROTR 29)
          (hi2 << 26 | lo2 >>> 6)) >>> 0;
          w15 = w2[i2 - 15];
          hi2 = w15[0];
          lo2 = w15[1];
          t2_hi = ((hi2 >>> 1 | lo2 << 31) ^ // ROTR 1
          (hi2 >>> 8 | lo2 << 24) ^ // ROTR 8
          hi2 >>> 7) >>> 0;
          t2_lo = ((hi2 << 31 | lo2 >>> 1) ^ // ROTR 1
          (hi2 << 24 | lo2 >>> 8) ^ // ROTR 8
          (hi2 << 25 | lo2 >>> 7)) >>> 0;
          w7 = w2[i2 - 7];
          w16 = w2[i2 - 16];
          lo2 = t1_lo + w7[1] + t2_lo + w16[1];
          w2[i2][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo2 / 4294967296 >>> 0) >>> 0;
          w2[i2][1] = lo2 >>> 0;
        }
        a_hi = s[0][0];
        a_lo = s[0][1];
        b_hi = s[1][0];
        b_lo = s[1][1];
        c_hi = s[2][0];
        c_lo = s[2][1];
        d_hi = s[3][0];
        d_lo = s[3][1];
        e_hi = s[4][0];
        e_lo = s[4][1];
        f_hi = s[5][0];
        f_lo = s[5][1];
        g_hi = s[6][0];
        g_lo = s[6][1];
        h_hi = s[7][0];
        h_lo = s[7][1];
        for (i2 = 0; i2 < 80; ++i2) {
          s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ // ROTR 14
          (e_hi >>> 18 | e_lo << 14) ^ // ROTR 18
          (e_lo >>> 9 | e_hi << 23)) >>> 0;
          s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ // ROTR 14
          (e_hi << 14 | e_lo >>> 18) ^ // ROTR 18
          (e_lo << 23 | e_hi >>> 9)) >>> 0;
          ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0;
          ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0;
          s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ // ROTR 28
          (a_lo >>> 2 | a_hi << 30) ^ // ROTR 34/(swap + ROTR 2)
          (a_lo >>> 7 | a_hi << 25)) >>> 0;
          s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ // ROTR 28
          (a_lo << 30 | a_hi >>> 2) ^ // ROTR 34/(swap + ROTR 2)
          (a_lo << 25 | a_hi >>> 7)) >>> 0;
          maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0;
          maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0;
          lo2 = h_lo + s1_lo + ch_lo + _k[i2][1] + w2[i2][1];
          t1_hi = h_hi + s1_hi + ch_hi + _k[i2][0] + w2[i2][0] + (lo2 / 4294967296 >>> 0) >>> 0;
          t1_lo = lo2 >>> 0;
          lo2 = s0_lo + maj_lo;
          t2_hi = s0_hi + maj_hi + (lo2 / 4294967296 >>> 0) >>> 0;
          t2_lo = lo2 >>> 0;
          h_hi = g_hi;
          h_lo = g_lo;
          g_hi = f_hi;
          g_lo = f_lo;
          f_hi = e_hi;
          f_lo = e_lo;
          lo2 = d_lo + t1_lo;
          e_hi = d_hi + t1_hi + (lo2 / 4294967296 >>> 0) >>> 0;
          e_lo = lo2 >>> 0;
          d_hi = c_hi;
          d_lo = c_lo;
          c_hi = b_hi;
          c_lo = b_lo;
          b_hi = a_hi;
          b_lo = a_lo;
          lo2 = t1_lo + t2_lo;
          a_hi = t1_hi + t2_hi + (lo2 / 4294967296 >>> 0) >>> 0;
          a_lo = lo2 >>> 0;
        }
        lo2 = s[0][1] + a_lo;
        s[0][0] = s[0][0] + a_hi + (lo2 / 4294967296 >>> 0) >>> 0;
        s[0][1] = lo2 >>> 0;
        lo2 = s[1][1] + b_lo;
        s[1][0] = s[1][0] + b_hi + (lo2 / 4294967296 >>> 0) >>> 0;
        s[1][1] = lo2 >>> 0;
        lo2 = s[2][1] + c_lo;
        s[2][0] = s[2][0] + c_hi + (lo2 / 4294967296 >>> 0) >>> 0;
        s[2][1] = lo2 >>> 0;
        lo2 = s[3][1] + d_lo;
        s[3][0] = s[3][0] + d_hi + (lo2 / 4294967296 >>> 0) >>> 0;
        s[3][1] = lo2 >>> 0;
        lo2 = s[4][1] + e_lo;
        s[4][0] = s[4][0] + e_hi + (lo2 / 4294967296 >>> 0) >>> 0;
        s[4][1] = lo2 >>> 0;
        lo2 = s[5][1] + f_lo;
        s[5][0] = s[5][0] + f_hi + (lo2 / 4294967296 >>> 0) >>> 0;
        s[5][1] = lo2 >>> 0;
        lo2 = s[6][1] + g_lo;
        s[6][0] = s[6][0] + g_hi + (lo2 / 4294967296 >>> 0) >>> 0;
        s[6][1] = lo2 >>> 0;
        lo2 = s[7][1] + h_lo;
        s[7][0] = s[7][0] + h_hi + (lo2 / 4294967296 >>> 0) >>> 0;
        s[7][1] = lo2 >>> 0;
        len -= 128;
      }
    }
  }
});

// node_modules/node-forge/lib/asn1-validator.js
var require_asn1_validator = __commonJS({
  "node_modules/node-forge/lib/asn1-validator.js"(exports) {
    var forge = require_forge();
    require_asn1();
    var asn1 = forge.asn1;
    exports.privateKeyValidator = {
      // PrivateKeyInfo
      name: "PrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // Version (INTEGER)
        name: "PrivateKeyInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        // privateKeyAlgorithm
        name: "PrivateKeyInfo.privateKeyAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "privateKeyOid"
        }]
      }, {
        // PrivateKey
        name: "PrivateKeyInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "privateKey"
      }]
    };
    exports.publicKeyValidator = {
      name: "SubjectPublicKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "subjectPublicKeyInfo",
      value: [
        {
          name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "publicKeyOid"
          }]
        },
        // capture group for ed25519PublicKey
        {
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.BITSTRING,
          constructed: false,
          composed: true,
          captureBitStringValue: "ed25519PublicKey"
        }
        // FIXME: this is capture group for rsaPublicKey, use it in this API or
        // discard?
        /* {
          // subjectPublicKey
          name: 'SubjectPublicKeyInfo.subjectPublicKey',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.BITSTRING,
          constructed: false,
          value: [{
            // RSAPublicKey
            name: 'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            optional: true,
            captureAsn1: 'rsaPublicKey'
          }]
        } */
      ]
    };
  }
});

// node_modules/node-forge/lib/ed25519.js
var require_ed25519 = __commonJS({
  "node_modules/node-forge/lib/ed25519.js"(exports, module) {
    var forge = require_forge();
    require_jsbn();
    require_random();
    require_sha512();
    require_util2();
    var asn1Validator = require_asn1_validator();
    var publicKeyValidator = asn1Validator.publicKeyValidator;
    var privateKeyValidator = asn1Validator.privateKeyValidator;
    if (typeof BigInteger === "undefined") {
      BigInteger = forge.jsbn.BigInteger;
    }
    var BigInteger;
    var ByteBuffer = forge.util.ByteBuffer;
    var NativeBuffer = typeof Buffer === "undefined" ? Uint8Array : Buffer;
    forge.pki = forge.pki || {};
    module.exports = forge.pki.ed25519 = forge.ed25519 = forge.ed25519 || {};
    var ed25519 = forge.ed25519;
    ed25519.constants = {};
    ed25519.constants.PUBLIC_KEY_BYTE_LENGTH = 32;
    ed25519.constants.PRIVATE_KEY_BYTE_LENGTH = 64;
    ed25519.constants.SEED_BYTE_LENGTH = 32;
    ed25519.constants.SIGN_BYTE_LENGTH = 64;
    ed25519.constants.HASH_BYTE_LENGTH = 64;
    ed25519.generateKeyPair = function(options) {
      options = options || {};
      var seed = options.seed;
      if (seed === void 0) {
        seed = forge.random.getBytesSync(ed25519.constants.SEED_BYTE_LENGTH);
      } else if (typeof seed === "string") {
        if (seed.length !== ed25519.constants.SEED_BYTE_LENGTH) {
          throw new TypeError(
            '"seed" must be ' + ed25519.constants.SEED_BYTE_LENGTH + " bytes in length."
          );
        }
      } else if (!(seed instanceof Uint8Array)) {
        throw new TypeError(
          '"seed" must be a node.js Buffer, Uint8Array, or a binary string.'
        );
      }
      seed = messageToNativeBuffer({ message: seed, encoding: "binary" });
      var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
      var sk = new NativeBuffer(ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
      for (var i2 = 0; i2 < 32; ++i2) {
        sk[i2] = seed[i2];
      }
      crypto_sign_keypair(pk, sk);
      return { publicKey: pk, privateKey: sk };
    };
    ed25519.privateKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      var valid = forge.asn1.validate(obj, privateKeyValidator, capture, errors);
      if (!valid) {
        var error = new Error("Invalid Key.");
        error.errors = errors;
        throw error;
      }
      var oid = forge.asn1.derToOid(capture.privateKeyOid);
      var ed25519Oid = forge.oids.EdDSA25519;
      if (oid !== ed25519Oid) {
        throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
      }
      var privateKey = capture.privateKey;
      var privateKeyBytes = messageToNativeBuffer({
        message: forge.asn1.fromDer(privateKey).value,
        encoding: "binary"
      });
      return { privateKeyBytes };
    };
    ed25519.publicKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      var valid = forge.asn1.validate(obj, publicKeyValidator, capture, errors);
      if (!valid) {
        var error = new Error("Invalid Key.");
        error.errors = errors;
        throw error;
      }
      var oid = forge.asn1.derToOid(capture.publicKeyOid);
      var ed25519Oid = forge.oids.EdDSA25519;
      if (oid !== ed25519Oid) {
        throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
      }
      var publicKeyBytes = capture.ed25519PublicKey;
      if (publicKeyBytes.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {
        throw new Error("Key length is invalid.");
      }
      return messageToNativeBuffer({
        message: publicKeyBytes,
        encoding: "binary"
      });
    };
    ed25519.publicKeyFromPrivateKey = function(options) {
      options = options || {};
      var privateKey = messageToNativeBuffer({
        message: options.privateKey,
        encoding: "binary"
      });
      if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {
        throw new TypeError(
          '"options.privateKey" must have a byte length of ' + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH
        );
      }
      var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
      for (var i2 = 0; i2 < pk.length; ++i2) {
        pk[i2] = privateKey[32 + i2];
      }
      return pk;
    };
    ed25519.sign = function(options) {
      options = options || {};
      var msg = messageToNativeBuffer(options);
      var privateKey = messageToNativeBuffer({
        message: options.privateKey,
        encoding: "binary"
      });
      if (privateKey.length === ed25519.constants.SEED_BYTE_LENGTH) {
        var keyPair = ed25519.generateKeyPair({ seed: privateKey });
        privateKey = keyPair.privateKey;
      } else if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {
        throw new TypeError(
          '"options.privateKey" must have a byte length of ' + ed25519.constants.SEED_BYTE_LENGTH + " or " + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH
        );
      }
      var signedMsg = new NativeBuffer(
        ed25519.constants.SIGN_BYTE_LENGTH + msg.length
      );
      crypto_sign(signedMsg, msg, msg.length, privateKey);
      var sig = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH);
      for (var i2 = 0; i2 < sig.length; ++i2) {
        sig[i2] = signedMsg[i2];
      }
      return sig;
    };
    ed25519.verify = function(options) {
      options = options || {};
      var msg = messageToNativeBuffer(options);
      if (options.signature === void 0) {
        throw new TypeError(
          '"options.signature" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.'
        );
      }
      var sig = messageToNativeBuffer({
        message: options.signature,
        encoding: "binary"
      });
      if (sig.length !== ed25519.constants.SIGN_BYTE_LENGTH) {
        throw new TypeError(
          '"options.signature" must have a byte length of ' + ed25519.constants.SIGN_BYTE_LENGTH
        );
      }
      var publicKey = messageToNativeBuffer({
        message: options.publicKey,
        encoding: "binary"
      });
      if (publicKey.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {
        throw new TypeError(
          '"options.publicKey" must have a byte length of ' + ed25519.constants.PUBLIC_KEY_BYTE_LENGTH
        );
      }
      var sm = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
      var m = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
      var i2;
      for (i2 = 0; i2 < ed25519.constants.SIGN_BYTE_LENGTH; ++i2) {
        sm[i2] = sig[i2];
      }
      for (i2 = 0; i2 < msg.length; ++i2) {
        sm[i2 + ed25519.constants.SIGN_BYTE_LENGTH] = msg[i2];
      }
      return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
    };
    function messageToNativeBuffer(options) {
      var message = options.message;
      if (message instanceof Uint8Array || message instanceof NativeBuffer) {
        return message;
      }
      var encoding = options.encoding;
      if (message === void 0) {
        if (options.md) {
          message = options.md.digest().getBytes();
          encoding = "binary";
        } else {
          throw new TypeError('"options.message" or "options.md" not specified.');
        }
      }
      if (typeof message === "string" && !encoding) {
        throw new TypeError('"options.encoding" must be "binary" or "utf8".');
      }
      if (typeof message === "string") {
        if (typeof Buffer !== "undefined") {
          return Buffer.from(message, encoding);
        }
        message = new ByteBuffer(message, encoding);
      } else if (!(message instanceof ByteBuffer)) {
        throw new TypeError(
          '"options.message" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with "options.encoding" specifying its encoding.'
        );
      }
      var buffer = new NativeBuffer(message.length());
      for (var i2 = 0; i2 < buffer.length; ++i2) {
        buffer[i2] = message.at(i2);
      }
      return buffer;
    }
    var gf0 = gf();
    var gf1 = gf([1]);
    var D3 = gf([
      30883,
      4953,
      19914,
      30187,
      55467,
      16705,
      2637,
      112,
      59544,
      30585,
      16505,
      36039,
      65139,
      11119,
      27886,
      20995
    ]);
    var D22 = gf([
      61785,
      9906,
      39828,
      60374,
      45398,
      33411,
      5274,
      224,
      53552,
      61171,
      33010,
      6542,
      64743,
      22239,
      55772,
      9222
    ]);
    var X3 = gf([
      54554,
      36645,
      11616,
      51542,
      42930,
      38181,
      51040,
      26924,
      56412,
      64982,
      57905,
      49316,
      21502,
      52590,
      14035,
      8553
    ]);
    var Y3 = gf([
      26200,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214
    ]);
    var L3 = new Float64Array([
      237,
      211,
      245,
      92,
      26,
      99,
      18,
      88,
      214,
      156,
      247,
      162,
      222,
      249,
      222,
      20,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      16
    ]);
    var I3 = gf([
      41136,
      18958,
      6951,
      50414,
      58488,
      44335,
      6150,
      12099,
      55207,
      15867,
      153,
      11085,
      57099,
      20417,
      9344,
      11139
    ]);
    function sha512(msg, msgLen) {
      var md2 = forge.md.sha512.create();
      var buffer = new ByteBuffer(msg);
      md2.update(buffer.getBytes(msgLen), "binary");
      var hash = md2.digest().getBytes();
      if (typeof Buffer !== "undefined") {
        return Buffer.from(hash, "binary");
      }
      var out = new NativeBuffer(ed25519.constants.HASH_BYTE_LENGTH);
      for (var i2 = 0; i2 < 64; ++i2) {
        out[i2] = hash.charCodeAt(i2);
      }
      return out;
    }
    function crypto_sign_keypair(pk, sk) {
      var p2 = [gf(), gf(), gf(), gf()];
      var i2;
      var d = sha512(sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      scalarbase(p2, d);
      pack(pk, p2);
      for (i2 = 0; i2 < 32; ++i2) {
        sk[i2 + 32] = pk[i2];
      }
      return 0;
    }
    function crypto_sign(sm, m, n2, sk) {
      var i2, j2, x3 = new Float64Array(64);
      var p2 = [gf(), gf(), gf(), gf()];
      var d = sha512(sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      var smlen = n2 + 64;
      for (i2 = 0; i2 < n2; ++i2) {
        sm[64 + i2] = m[i2];
      }
      for (i2 = 0; i2 < 32; ++i2) {
        sm[32 + i2] = d[32 + i2];
      }
      var r2 = sha512(sm.subarray(32), n2 + 32);
      reduce(r2);
      scalarbase(p2, r2);
      pack(sm, p2);
      for (i2 = 32; i2 < 64; ++i2) {
        sm[i2] = sk[i2];
      }
      var h = sha512(sm, n2 + 64);
      reduce(h);
      for (i2 = 32; i2 < 64; ++i2) {
        x3[i2] = 0;
      }
      for (i2 = 0; i2 < 32; ++i2) {
        x3[i2] = r2[i2];
      }
      for (i2 = 0; i2 < 32; ++i2) {
        for (j2 = 0; j2 < 32; j2++) {
          x3[i2 + j2] += h[i2] * d[j2];
        }
      }
      modL(sm.subarray(32), x3);
      return smlen;
    }
    function crypto_sign_open(m, sm, n2, pk) {
      var i2, mlen;
      var t = new NativeBuffer(32);
      var p2 = [gf(), gf(), gf(), gf()], q3 = [gf(), gf(), gf(), gf()];
      mlen = -1;
      if (n2 < 64) {
        return -1;
      }
      if (unpackneg(q3, pk)) {
        return -1;
      }
      for (i2 = 0; i2 < n2; ++i2) {
        m[i2] = sm[i2];
      }
      for (i2 = 0; i2 < 32; ++i2) {
        m[i2 + 32] = pk[i2];
      }
      var h = sha512(m, n2);
      reduce(h);
      scalarmult(p2, q3, h);
      scalarbase(q3, sm.subarray(32));
      add(p2, q3);
      pack(t, p2);
      n2 -= 64;
      if (crypto_verify_32(sm, 0, t, 0)) {
        for (i2 = 0; i2 < n2; ++i2) {
          m[i2] = 0;
        }
        return -1;
      }
      for (i2 = 0; i2 < n2; ++i2) {
        m[i2] = sm[i2 + 64];
      }
      mlen = n2;
      return mlen;
    }
    function modL(r2, x3) {
      var carry, i2, j2, k3;
      for (i2 = 63; i2 >= 32; --i2) {
        carry = 0;
        for (j2 = i2 - 32, k3 = i2 - 12; j2 < k3; ++j2) {
          x3[j2] += carry - 16 * x3[i2] * L3[j2 - (i2 - 32)];
          carry = x3[j2] + 128 >> 8;
          x3[j2] -= carry * 256;
        }
        x3[j2] += carry;
        x3[i2] = 0;
      }
      carry = 0;
      for (j2 = 0; j2 < 32; ++j2) {
        x3[j2] += carry - (x3[31] >> 4) * L3[j2];
        carry = x3[j2] >> 8;
        x3[j2] &= 255;
      }
      for (j2 = 0; j2 < 32; ++j2) {
        x3[j2] -= carry * L3[j2];
      }
      for (i2 = 0; i2 < 32; ++i2) {
        x3[i2 + 1] += x3[i2] >> 8;
        r2[i2] = x3[i2] & 255;
      }
    }
    function reduce(r2) {
      var x3 = new Float64Array(64);
      for (var i2 = 0; i2 < 64; ++i2) {
        x3[i2] = r2[i2];
        r2[i2] = 0;
      }
      modL(r2, x3);
    }
    function add(p2, q3) {
      var a = gf(), b2 = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g2 = gf(), h = gf(), t = gf();
      Z3(a, p2[1], p2[0]);
      Z3(t, q3[1], q3[0]);
      M3(a, a, t);
      A3(b2, p2[0], p2[1]);
      A3(t, q3[0], q3[1]);
      M3(b2, b2, t);
      M3(c, p2[3], q3[3]);
      M3(c, c, D22);
      M3(d, p2[2], q3[2]);
      A3(d, d, d);
      Z3(e, b2, a);
      Z3(f, d, c);
      A3(g2, d, c);
      A3(h, b2, a);
      M3(p2[0], e, f);
      M3(p2[1], h, g2);
      M3(p2[2], g2, f);
      M3(p2[3], e, h);
    }
    function cswap(p2, q3, b2) {
      for (var i2 = 0; i2 < 4; ++i2) {
        sel25519(p2[i2], q3[i2], b2);
      }
    }
    function pack(r2, p2) {
      var tx = gf(), ty = gf(), zi2 = gf();
      inv25519(zi2, p2[2]);
      M3(tx, p2[0], zi2);
      M3(ty, p2[1], zi2);
      pack25519(r2, ty);
      r2[31] ^= par25519(tx) << 7;
    }
    function pack25519(o, n2) {
      var i2, j2, b2;
      var m = gf(), t = gf();
      for (i2 = 0; i2 < 16; ++i2) {
        t[i2] = n2[i2];
      }
      car25519(t);
      car25519(t);
      car25519(t);
      for (j2 = 0; j2 < 2; ++j2) {
        m[0] = t[0] - 65517;
        for (i2 = 1; i2 < 15; ++i2) {
          m[i2] = t[i2] - 65535 - (m[i2 - 1] >> 16 & 1);
          m[i2 - 1] &= 65535;
        }
        m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
        b2 = m[15] >> 16 & 1;
        m[14] &= 65535;
        sel25519(t, m, 1 - b2);
      }
      for (i2 = 0; i2 < 16; i2++) {
        o[2 * i2] = t[i2] & 255;
        o[2 * i2 + 1] = t[i2] >> 8;
      }
    }
    function unpackneg(r2, p2) {
      var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
      set25519(r2[2], gf1);
      unpack25519(r2[1], p2);
      S3(num, r2[1]);
      M3(den, num, D3);
      Z3(num, num, r2[2]);
      A3(den, r2[2], den);
      S3(den2, den);
      S3(den4, den2);
      M3(den6, den4, den2);
      M3(t, den6, num);
      M3(t, t, den);
      pow2523(t, t);
      M3(t, t, num);
      M3(t, t, den);
      M3(t, t, den);
      M3(r2[0], t, den);
      S3(chk, r2[0]);
      M3(chk, chk, den);
      if (neq25519(chk, num)) {
        M3(r2[0], r2[0], I3);
      }
      S3(chk, r2[0]);
      M3(chk, chk, den);
      if (neq25519(chk, num)) {
        return -1;
      }
      if (par25519(r2[0]) === p2[31] >> 7) {
        Z3(r2[0], gf0, r2[0]);
      }
      M3(r2[3], r2[0], r2[1]);
      return 0;
    }
    function unpack25519(o, n2) {
      var i2;
      for (i2 = 0; i2 < 16; ++i2) {
        o[i2] = n2[2 * i2] + (n2[2 * i2 + 1] << 8);
      }
      o[15] &= 32767;
    }
    function pow2523(o, i2) {
      var c = gf();
      var a;
      for (a = 0; a < 16; ++a) {
        c[a] = i2[a];
      }
      for (a = 250; a >= 0; --a) {
        S3(c, c);
        if (a !== 1) {
          M3(c, c, i2);
        }
      }
      for (a = 0; a < 16; ++a) {
        o[a] = c[a];
      }
    }
    function neq25519(a, b2) {
      var c = new NativeBuffer(32);
      var d = new NativeBuffer(32);
      pack25519(c, a);
      pack25519(d, b2);
      return crypto_verify_32(c, 0, d, 0);
    }
    function crypto_verify_32(x3, xi2, y2, yi2) {
      return vn2(x3, xi2, y2, yi2, 32);
    }
    function vn2(x3, xi2, y2, yi2, n2) {
      var i2, d = 0;
      for (i2 = 0; i2 < n2; ++i2) {
        d |= x3[xi2 + i2] ^ y2[yi2 + i2];
      }
      return (1 & d - 1 >>> 8) - 1;
    }
    function par25519(a) {
      var d = new NativeBuffer(32);
      pack25519(d, a);
      return d[0] & 1;
    }
    function scalarmult(p2, q3, s) {
      var b2, i2;
      set25519(p2[0], gf0);
      set25519(p2[1], gf1);
      set25519(p2[2], gf1);
      set25519(p2[3], gf0);
      for (i2 = 255; i2 >= 0; --i2) {
        b2 = s[i2 / 8 | 0] >> (i2 & 7) & 1;
        cswap(p2, q3, b2);
        add(q3, p2);
        add(p2, p2);
        cswap(p2, q3, b2);
      }
    }
    function scalarbase(p2, s) {
      var q3 = [gf(), gf(), gf(), gf()];
      set25519(q3[0], X3);
      set25519(q3[1], Y3);
      set25519(q3[2], gf1);
      M3(q3[3], X3, Y3);
      scalarmult(p2, q3, s);
    }
    function set25519(r2, a) {
      var i2;
      for (i2 = 0; i2 < 16; i2++) {
        r2[i2] = a[i2] | 0;
      }
    }
    function inv25519(o, i2) {
      var c = gf();
      var a;
      for (a = 0; a < 16; ++a) {
        c[a] = i2[a];
      }
      for (a = 253; a >= 0; --a) {
        S3(c, c);
        if (a !== 2 && a !== 4) {
          M3(c, c, i2);
        }
      }
      for (a = 0; a < 16; ++a) {
        o[a] = c[a];
      }
    }
    function car25519(o) {
      var i2, v2, c = 1;
      for (i2 = 0; i2 < 16; ++i2) {
        v2 = o[i2] + c + 65535;
        c = Math.floor(v2 / 65536);
        o[i2] = v2 - c * 65536;
      }
      o[0] += c - 1 + 37 * (c - 1);
    }
    function sel25519(p2, q3, b2) {
      var t, c = ~(b2 - 1);
      for (var i2 = 0; i2 < 16; ++i2) {
        t = c & (p2[i2] ^ q3[i2]);
        p2[i2] ^= t;
        q3[i2] ^= t;
      }
    }
    function gf(init) {
      var i2, r2 = new Float64Array(16);
      if (init) {
        for (i2 = 0; i2 < init.length; ++i2) {
          r2[i2] = init[i2];
        }
      }
      return r2;
    }
    function A3(o, a, b2) {
      for (var i2 = 0; i2 < 16; ++i2) {
        o[i2] = a[i2] + b2[i2];
      }
    }
    function Z3(o, a, b2) {
      for (var i2 = 0; i2 < 16; ++i2) {
        o[i2] = a[i2] - b2[i2];
      }
    }
    function S3(o, a) {
      M3(o, a, a);
    }
    function M3(o, a, b2) {
      var v2, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3], b4 = b2[4], b5 = b2[5], b6 = b2[6], b7 = b2[7], b8 = b2[8], b9 = b2[9], b10 = b2[10], b11 = b2[11], b12 = b2[12], b13 = b2[13], b14 = b2[14], b15 = b2[15];
      v2 = a[0];
      t0 += v2 * b0;
      t1 += v2 * b1;
      t2 += v2 * b22;
      t3 += v2 * b3;
      t4 += v2 * b4;
      t5 += v2 * b5;
      t6 += v2 * b6;
      t7 += v2 * b7;
      t8 += v2 * b8;
      t9 += v2 * b9;
      t10 += v2 * b10;
      t11 += v2 * b11;
      t12 += v2 * b12;
      t13 += v2 * b13;
      t14 += v2 * b14;
      t15 += v2 * b15;
      v2 = a[1];
      t1 += v2 * b0;
      t2 += v2 * b1;
      t3 += v2 * b22;
      t4 += v2 * b3;
      t5 += v2 * b4;
      t6 += v2 * b5;
      t7 += v2 * b6;
      t8 += v2 * b7;
      t9 += v2 * b8;
      t10 += v2 * b9;
      t11 += v2 * b10;
      t12 += v2 * b11;
      t13 += v2 * b12;
      t14 += v2 * b13;
      t15 += v2 * b14;
      t16 += v2 * b15;
      v2 = a[2];
      t2 += v2 * b0;
      t3 += v2 * b1;
      t4 += v2 * b22;
      t5 += v2 * b3;
      t6 += v2 * b4;
      t7 += v2 * b5;
      t8 += v2 * b6;
      t9 += v2 * b7;
      t10 += v2 * b8;
      t11 += v2 * b9;
      t12 += v2 * b10;
      t13 += v2 * b11;
      t14 += v2 * b12;
      t15 += v2 * b13;
      t16 += v2 * b14;
      t17 += v2 * b15;
      v2 = a[3];
      t3 += v2 * b0;
      t4 += v2 * b1;
      t5 += v2 * b22;
      t6 += v2 * b3;
      t7 += v2 * b4;
      t8 += v2 * b5;
      t9 += v2 * b6;
      t10 += v2 * b7;
      t11 += v2 * b8;
      t12 += v2 * b9;
      t13 += v2 * b10;
      t14 += v2 * b11;
      t15 += v2 * b12;
      t16 += v2 * b13;
      t17 += v2 * b14;
      t18 += v2 * b15;
      v2 = a[4];
      t4 += v2 * b0;
      t5 += v2 * b1;
      t6 += v2 * b22;
      t7 += v2 * b3;
      t8 += v2 * b4;
      t9 += v2 * b5;
      t10 += v2 * b6;
      t11 += v2 * b7;
      t12 += v2 * b8;
      t13 += v2 * b9;
      t14 += v2 * b10;
      t15 += v2 * b11;
      t16 += v2 * b12;
      t17 += v2 * b13;
      t18 += v2 * b14;
      t19 += v2 * b15;
      v2 = a[5];
      t5 += v2 * b0;
      t6 += v2 * b1;
      t7 += v2 * b22;
      t8 += v2 * b3;
      t9 += v2 * b4;
      t10 += v2 * b5;
      t11 += v2 * b6;
      t12 += v2 * b7;
      t13 += v2 * b8;
      t14 += v2 * b9;
      t15 += v2 * b10;
      t16 += v2 * b11;
      t17 += v2 * b12;
      t18 += v2 * b13;
      t19 += v2 * b14;
      t20 += v2 * b15;
      v2 = a[6];
      t6 += v2 * b0;
      t7 += v2 * b1;
      t8 += v2 * b22;
      t9 += v2 * b3;
      t10 += v2 * b4;
      t11 += v2 * b5;
      t12 += v2 * b6;
      t13 += v2 * b7;
      t14 += v2 * b8;
      t15 += v2 * b9;
      t16 += v2 * b10;
      t17 += v2 * b11;
      t18 += v2 * b12;
      t19 += v2 * b13;
      t20 += v2 * b14;
      t21 += v2 * b15;
      v2 = a[7];
      t7 += v2 * b0;
      t8 += v2 * b1;
      t9 += v2 * b22;
      t10 += v2 * b3;
      t11 += v2 * b4;
      t12 += v2 * b5;
      t13 += v2 * b6;
      t14 += v2 * b7;
      t15 += v2 * b8;
      t16 += v2 * b9;
      t17 += v2 * b10;
      t18 += v2 * b11;
      t19 += v2 * b12;
      t20 += v2 * b13;
      t21 += v2 * b14;
      t22 += v2 * b15;
      v2 = a[8];
      t8 += v2 * b0;
      t9 += v2 * b1;
      t10 += v2 * b22;
      t11 += v2 * b3;
      t12 += v2 * b4;
      t13 += v2 * b5;
      t14 += v2 * b6;
      t15 += v2 * b7;
      t16 += v2 * b8;
      t17 += v2 * b9;
      t18 += v2 * b10;
      t19 += v2 * b11;
      t20 += v2 * b12;
      t21 += v2 * b13;
      t22 += v2 * b14;
      t23 += v2 * b15;
      v2 = a[9];
      t9 += v2 * b0;
      t10 += v2 * b1;
      t11 += v2 * b22;
      t12 += v2 * b3;
      t13 += v2 * b4;
      t14 += v2 * b5;
      t15 += v2 * b6;
      t16 += v2 * b7;
      t17 += v2 * b8;
      t18 += v2 * b9;
      t19 += v2 * b10;
      t20 += v2 * b11;
      t21 += v2 * b12;
      t22 += v2 * b13;
      t23 += v2 * b14;
      t24 += v2 * b15;
      v2 = a[10];
      t10 += v2 * b0;
      t11 += v2 * b1;
      t12 += v2 * b22;
      t13 += v2 * b3;
      t14 += v2 * b4;
      t15 += v2 * b5;
      t16 += v2 * b6;
      t17 += v2 * b7;
      t18 += v2 * b8;
      t19 += v2 * b9;
      t20 += v2 * b10;
      t21 += v2 * b11;
      t22 += v2 * b12;
      t23 += v2 * b13;
      t24 += v2 * b14;
      t25 += v2 * b15;
      v2 = a[11];
      t11 += v2 * b0;
      t12 += v2 * b1;
      t13 += v2 * b22;
      t14 += v2 * b3;
      t15 += v2 * b4;
      t16 += v2 * b5;
      t17 += v2 * b6;
      t18 += v2 * b7;
      t19 += v2 * b8;
      t20 += v2 * b9;
      t21 += v2 * b10;
      t22 += v2 * b11;
      t23 += v2 * b12;
      t24 += v2 * b13;
      t25 += v2 * b14;
      t26 += v2 * b15;
      v2 = a[12];
      t12 += v2 * b0;
      t13 += v2 * b1;
      t14 += v2 * b22;
      t15 += v2 * b3;
      t16 += v2 * b4;
      t17 += v2 * b5;
      t18 += v2 * b6;
      t19 += v2 * b7;
      t20 += v2 * b8;
      t21 += v2 * b9;
      t22 += v2 * b10;
      t23 += v2 * b11;
      t24 += v2 * b12;
      t25 += v2 * b13;
      t26 += v2 * b14;
      t27 += v2 * b15;
      v2 = a[13];
      t13 += v2 * b0;
      t14 += v2 * b1;
      t15 += v2 * b22;
      t16 += v2 * b3;
      t17 += v2 * b4;
      t18 += v2 * b5;
      t19 += v2 * b6;
      t20 += v2 * b7;
      t21 += v2 * b8;
      t22 += v2 * b9;
      t23 += v2 * b10;
      t24 += v2 * b11;
      t25 += v2 * b12;
      t26 += v2 * b13;
      t27 += v2 * b14;
      t28 += v2 * b15;
      v2 = a[14];
      t14 += v2 * b0;
      t15 += v2 * b1;
      t16 += v2 * b22;
      t17 += v2 * b3;
      t18 += v2 * b4;
      t19 += v2 * b5;
      t20 += v2 * b6;
      t21 += v2 * b7;
      t22 += v2 * b8;
      t23 += v2 * b9;
      t24 += v2 * b10;
      t25 += v2 * b11;
      t26 += v2 * b12;
      t27 += v2 * b13;
      t28 += v2 * b14;
      t29 += v2 * b15;
      v2 = a[15];
      t15 += v2 * b0;
      t16 += v2 * b1;
      t17 += v2 * b22;
      t18 += v2 * b3;
      t19 += v2 * b4;
      t20 += v2 * b5;
      t21 += v2 * b6;
      t22 += v2 * b7;
      t23 += v2 * b8;
      t24 += v2 * b9;
      t25 += v2 * b10;
      t26 += v2 * b11;
      t27 += v2 * b12;
      t28 += v2 * b13;
      t29 += v2 * b14;
      t30 += v2 * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c = 1;
      v2 = t0 + c + 65535;
      c = Math.floor(v2 / 65536);
      t0 = v2 - c * 65536;
      v2 = t1 + c + 65535;
      c = Math.floor(v2 / 65536);
      t1 = v2 - c * 65536;
      v2 = t2 + c + 65535;
      c = Math.floor(v2 / 65536);
      t2 = v2 - c * 65536;
      v2 = t3 + c + 65535;
      c = Math.floor(v2 / 65536);
      t3 = v2 - c * 65536;
      v2 = t4 + c + 65535;
      c = Math.floor(v2 / 65536);
      t4 = v2 - c * 65536;
      v2 = t5 + c + 65535;
      c = Math.floor(v2 / 65536);
      t5 = v2 - c * 65536;
      v2 = t6 + c + 65535;
      c = Math.floor(v2 / 65536);
      t6 = v2 - c * 65536;
      v2 = t7 + c + 65535;
      c = Math.floor(v2 / 65536);
      t7 = v2 - c * 65536;
      v2 = t8 + c + 65535;
      c = Math.floor(v2 / 65536);
      t8 = v2 - c * 65536;
      v2 = t9 + c + 65535;
      c = Math.floor(v2 / 65536);
      t9 = v2 - c * 65536;
      v2 = t10 + c + 65535;
      c = Math.floor(v2 / 65536);
      t10 = v2 - c * 65536;
      v2 = t11 + c + 65535;
      c = Math.floor(v2 / 65536);
      t11 = v2 - c * 65536;
      v2 = t12 + c + 65535;
      c = Math.floor(v2 / 65536);
      t12 = v2 - c * 65536;
      v2 = t13 + c + 65535;
      c = Math.floor(v2 / 65536);
      t13 = v2 - c * 65536;
      v2 = t14 + c + 65535;
      c = Math.floor(v2 / 65536);
      t14 = v2 - c * 65536;
      v2 = t15 + c + 65535;
      c = Math.floor(v2 / 65536);
      t15 = v2 - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      c = 1;
      v2 = t0 + c + 65535;
      c = Math.floor(v2 / 65536);
      t0 = v2 - c * 65536;
      v2 = t1 + c + 65535;
      c = Math.floor(v2 / 65536);
      t1 = v2 - c * 65536;
      v2 = t2 + c + 65535;
      c = Math.floor(v2 / 65536);
      t2 = v2 - c * 65536;
      v2 = t3 + c + 65535;
      c = Math.floor(v2 / 65536);
      t3 = v2 - c * 65536;
      v2 = t4 + c + 65535;
      c = Math.floor(v2 / 65536);
      t4 = v2 - c * 65536;
      v2 = t5 + c + 65535;
      c = Math.floor(v2 / 65536);
      t5 = v2 - c * 65536;
      v2 = t6 + c + 65535;
      c = Math.floor(v2 / 65536);
      t6 = v2 - c * 65536;
      v2 = t7 + c + 65535;
      c = Math.floor(v2 / 65536);
      t7 = v2 - c * 65536;
      v2 = t8 + c + 65535;
      c = Math.floor(v2 / 65536);
      t8 = v2 - c * 65536;
      v2 = t9 + c + 65535;
      c = Math.floor(v2 / 65536);
      t9 = v2 - c * 65536;
      v2 = t10 + c + 65535;
      c = Math.floor(v2 / 65536);
      t10 = v2 - c * 65536;
      v2 = t11 + c + 65535;
      c = Math.floor(v2 / 65536);
      t11 = v2 - c * 65536;
      v2 = t12 + c + 65535;
      c = Math.floor(v2 / 65536);
      t12 = v2 - c * 65536;
      v2 = t13 + c + 65535;
      c = Math.floor(v2 / 65536);
      t13 = v2 - c * 65536;
      v2 = t14 + c + 65535;
      c = Math.floor(v2 / 65536);
      t14 = v2 - c * 65536;
      v2 = t15 + c + 65535;
      c = Math.floor(v2 / 65536);
      t15 = v2 - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      o[0] = t0;
      o[1] = t1;
      o[2] = t2;
      o[3] = t3;
      o[4] = t4;
      o[5] = t5;
      o[6] = t6;
      o[7] = t7;
      o[8] = t8;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }
  }
});

// node_modules/node-forge/lib/kem.js
var require_kem = __commonJS({
  "node_modules/node-forge/lib/kem.js"(exports, module) {
    var forge = require_forge();
    require_util2();
    require_random();
    require_jsbn();
    module.exports = forge.kem = forge.kem || {};
    var BigInteger = forge.jsbn.BigInteger;
    forge.kem.rsa = {};
    forge.kem.rsa.create = function(kdf, options) {
      options = options || {};
      var prng = options.prng || forge.random;
      var kem = {};
      kem.encrypt = function(publicKey, keyLength) {
        var byteLength = Math.ceil(publicKey.n.bitLength() / 8);
        var r2;
        do {
          r2 = new BigInteger(
            forge.util.bytesToHex(prng.getBytesSync(byteLength)),
            16
          ).mod(publicKey.n);
        } while (r2.compareTo(BigInteger.ONE) <= 0);
        r2 = forge.util.hexToBytes(r2.toString(16));
        var zeros = byteLength - r2.length;
        if (zeros > 0) {
          r2 = forge.util.fillString(String.fromCharCode(0), zeros) + r2;
        }
        var encapsulation = publicKey.encrypt(r2, "NONE");
        var key = kdf.generate(r2, keyLength);
        return { encapsulation, key };
      };
      kem.decrypt = function(privateKey, encapsulation, keyLength) {
        var r2 = privateKey.decrypt(encapsulation, "NONE");
        return kdf.generate(r2, keyLength);
      };
      return kem;
    };
    forge.kem.kdf1 = function(md2, digestLength) {
      _createKDF(this, md2, 0, digestLength || md2.digestLength);
    };
    forge.kem.kdf2 = function(md2, digestLength) {
      _createKDF(this, md2, 1, digestLength || md2.digestLength);
    };
    function _createKDF(kdf, md2, counterStart, digestLength) {
      kdf.generate = function(x3, length) {
        var key = new forge.util.ByteBuffer();
        var k3 = Math.ceil(length / digestLength) + counterStart;
        var c = new forge.util.ByteBuffer();
        for (var i2 = counterStart; i2 < k3; ++i2) {
          c.putInt32(i2);
          md2.start();
          md2.update(x3 + c.getBytes());
          var hash = md2.digest();
          key.putBytes(hash.getBytes(digestLength));
        }
        key.truncate(key.length() - length);
        return key.getBytes();
      };
    }
  }
});

// node_modules/node-forge/lib/log.js
var require_log = __commonJS({
  "node_modules/node-forge/lib/log.js"(exports, module) {
    var forge = require_forge();
    require_util2();
    module.exports = forge.log = forge.log || {};
    forge.log.levels = [
      "none",
      "error",
      "warning",
      "info",
      "debug",
      "verbose",
      "max"
    ];
    var sLevelInfo = {};
    var sLoggers = [];
    var sConsoleLogger = null;
    forge.log.LEVEL_LOCKED = 1 << 1;
    forge.log.NO_LEVEL_CHECK = 1 << 2;
    forge.log.INTERPOLATE = 1 << 3;
    for (i2 = 0; i2 < forge.log.levels.length; ++i2) {
      level = forge.log.levels[i2];
      sLevelInfo[level] = {
        index: i2,
        name: level.toUpperCase()
      };
    }
    var level;
    var i2;
    forge.log.logMessage = function(message) {
      var messageLevelIndex = sLevelInfo[message.level].index;
      for (var i3 = 0; i3 < sLoggers.length; ++i3) {
        var logger2 = sLoggers[i3];
        if (logger2.flags & forge.log.NO_LEVEL_CHECK) {
          logger2.f(message);
        } else {
          var loggerLevelIndex = sLevelInfo[logger2.level].index;
          if (messageLevelIndex <= loggerLevelIndex) {
            logger2.f(logger2, message);
          }
        }
      }
    };
    forge.log.prepareStandard = function(message) {
      if (!("standard" in message)) {
        message.standard = sLevelInfo[message.level].name + //' ' + +message.timestamp +
        " [" + message.category + "] " + message.message;
      }
    };
    forge.log.prepareFull = function(message) {
      if (!("full" in message)) {
        var args = [message.message];
        args = args.concat([]);
        message.full = forge.util.format.apply(this, args);
      }
    };
    forge.log.prepareStandardFull = function(message) {
      if (!("standardFull" in message)) {
        forge.log.prepareStandard(message);
        message.standardFull = message.standard;
      }
    };
    if (true) {
      levels = ["error", "warning", "info", "debug", "verbose"];
      for (i2 = 0; i2 < levels.length; ++i2) {
        (function(level2) {
          forge.log[level2] = function(category, message) {
            var args = Array.prototype.slice.call(arguments).slice(2);
            var msg = {
              timestamp: /* @__PURE__ */ new Date(),
              level: level2,
              category,
              message,
              "arguments": args
              /*standard*/
              /*full*/
              /*fullMessage*/
            };
            forge.log.logMessage(msg);
          };
        })(levels[i2]);
      }
    }
    var levels;
    var i2;
    forge.log.makeLogger = function(logFunction) {
      var logger2 = {
        flags: 0,
        f: logFunction
      };
      forge.log.setLevel(logger2, "none");
      return logger2;
    };
    forge.log.setLevel = function(logger2, level2) {
      var rval = false;
      if (logger2 && !(logger2.flags & forge.log.LEVEL_LOCKED)) {
        for (var i3 = 0; i3 < forge.log.levels.length; ++i3) {
          var aValidLevel = forge.log.levels[i3];
          if (level2 == aValidLevel) {
            logger2.level = level2;
            rval = true;
            break;
          }
        }
      }
      return rval;
    };
    forge.log.lock = function(logger2, lock2) {
      if (typeof lock2 === "undefined" || lock2) {
        logger2.flags |= forge.log.LEVEL_LOCKED;
      } else {
        logger2.flags &= ~forge.log.LEVEL_LOCKED;
      }
    };
    forge.log.addLogger = function(logger2) {
      sLoggers.push(logger2);
    };
    if (typeof console !== "undefined" && "log" in console) {
      if (console.error && console.warn && console.info && console.debug) {
        levelHandlers = {
          error: console.error,
          warning: console.warn,
          info: console.info,
          debug: console.debug,
          verbose: console.debug
        };
        f = function(logger2, message) {
          forge.log.prepareStandard(message);
          var handler = levelHandlers[message.level];
          var args = [message.standard];
          args = args.concat(message["arguments"].slice());
          handler.apply(console, args);
        };
        logger = forge.log.makeLogger(f);
      } else {
        f = function(logger2, message) {
          forge.log.prepareStandardFull(message);
          console.log(message.standardFull);
        };
        logger = forge.log.makeLogger(f);
      }
      forge.log.setLevel(logger, "debug");
      forge.log.addLogger(logger);
      sConsoleLogger = logger;
    } else {
      console = {
        log: function() {
        }
      };
    }
    var logger;
    var levelHandlers;
    var f;
    if (sConsoleLogger !== null && typeof window !== "undefined" && window.location) {
      query = new URL(window.location.href).searchParams;
      if (query.has("console.level")) {
        forge.log.setLevel(
          sConsoleLogger,
          query.get("console.level").slice(-1)[0]
        );
      }
      if (query.has("console.lock")) {
        lock = query.get("console.lock").slice(-1)[0];
        if (lock == "true") {
          forge.log.lock(sConsoleLogger);
        }
      }
    }
    var query;
    var lock;
    forge.log.consoleLogger = sConsoleLogger;
  }
});

// node_modules/node-forge/lib/md.all.js
var require_md_all = __commonJS({
  "node_modules/node-forge/lib/md.all.js"(exports, module) {
    module.exports = require_md();
    require_md5();
    require_sha1();
    require_sha256();
    require_sha512();
  }
});

// node_modules/node-forge/lib/pkcs7.js
var require_pkcs7 = __commonJS({
  "node_modules/node-forge/lib/pkcs7.js"(exports, module) {
    var forge = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_oids();
    require_pem();
    require_pkcs7asn1();
    require_random();
    require_util2();
    require_x509();
    var asn1 = forge.asn1;
    var p7 = module.exports = forge.pkcs7 = forge.pkcs7 || {};
    p7.messageFromPem = function(pem) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== "PKCS7") {
        var error = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body);
      return p7.messageFromAsn1(obj);
    };
    p7.messageToPem = function(msg, maxline) {
      var pemObj = {
        type: "PKCS7",
        body: asn1.toDer(msg.toAsn1()).getBytes()
      };
      return forge.pem.encode(pemObj, { maxline });
    };
    p7.messageFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, p7.asn1.contentInfoValidator, capture, errors)) {
        var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
        error.errors = errors;
        throw error;
      }
      var contentType = asn1.derToOid(capture.contentType);
      var msg;
      switch (contentType) {
        case forge.pki.oids.envelopedData:
          msg = p7.createEnvelopedData();
          break;
        case forge.pki.oids.encryptedData:
          msg = p7.createEncryptedData();
          break;
        case forge.pki.oids.signedData:
          msg = p7.createSignedData();
          break;
        default:
          throw new Error("Cannot read PKCS#7 message. ContentType with OID " + contentType + " is not (yet) supported.");
      }
      msg.fromAsn1(capture.content.value[0]);
      return msg;
    };
    p7.createSignedData = function() {
      var msg = null;
      msg = {
        type: forge.pki.oids.signedData,
        version: 1,
        certificates: [],
        crls: [],
        // TODO: add json-formatted signer stuff here?
        signers: [],
        // populated during sign()
        digestAlgorithmIdentifiers: [],
        contentInfo: null,
        signerInfos: [],
        fromAsn1: function(obj) {
          _fromAsn1(msg, obj, p7.asn1.signedDataValidator);
          msg.certificates = [];
          msg.crls = [];
          msg.digestAlgorithmIdentifiers = [];
          msg.contentInfo = null;
          msg.signerInfos = [];
          if (msg.rawCapture.certificates) {
            var certs = msg.rawCapture.certificates.value;
            for (var i2 = 0; i2 < certs.length; ++i2) {
              msg.certificates.push(forge.pki.certificateFromAsn1(certs[i2]));
            }
          }
        },
        toAsn1: function() {
          if (!msg.contentInfo) {
            msg.sign();
          }
          var certs = [];
          for (var i2 = 0; i2 < msg.certificates.length; ++i2) {
            certs.push(forge.pki.certificateToAsn1(msg.certificates[i2]));
          }
          var crls = [];
          var signedData = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // Version
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                asn1.integerToDer(msg.version).getBytes()
              ),
              // DigestAlgorithmIdentifiers
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.SET,
                true,
                msg.digestAlgorithmIdentifiers
              ),
              // ContentInfo
              msg.contentInfo
            ])
          ]);
          if (certs.length > 0) {
            signedData.value[0].value.push(
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, certs)
            );
          }
          if (crls.length > 0) {
            signedData.value[0].value.push(
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, crls)
            );
          }
          signedData.value[0].value.push(
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SET,
              true,
              msg.signerInfos
            )
          );
          return asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.SEQUENCE,
            true,
            [
              // ContentType
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(msg.type).getBytes()
              ),
              // [0] SignedData
              signedData
            ]
          );
        },
        /**
         * Add (another) entity to list of signers.
         *
         * Note: If authenticatedAttributes are provided, then, per RFC 2315,
         * they must include at least two attributes: content type and
         * message digest. The message digest attribute value will be
         * auto-calculated during signing and will be ignored if provided.
         *
         * Here's an example of providing these two attributes:
         *
         * forge.pkcs7.createSignedData();
         * p7.addSigner({
         *   issuer: cert.issuer.attributes,
         *   serialNumber: cert.serialNumber,
         *   key: privateKey,
         *   digestAlgorithm: forge.pki.oids.sha1,
         *   authenticatedAttributes: [{
         *     type: forge.pki.oids.contentType,
         *     value: forge.pki.oids.data
         *   }, {
         *     type: forge.pki.oids.messageDigest
         *   }]
         * });
         *
         * TODO: Support [subjectKeyIdentifier] as signer's ID.
         *
         * @param signer the signer information:
         *          key the signer's private key.
         *          [certificate] a certificate containing the public key
         *            associated with the signer's private key; use this option as
         *            an alternative to specifying signer.issuer and
         *            signer.serialNumber.
         *          [issuer] the issuer attributes (eg: cert.issuer.attributes).
         *          [serialNumber] the signer's certificate's serial number in
         *           hexadecimal (eg: cert.serialNumber).
         *          [digestAlgorithm] the message digest OID, as a string, to use
         *            (eg: forge.pki.oids.sha1).
         *          [authenticatedAttributes] an optional array of attributes
         *            to also sign along with the content.
         */
        addSigner: function(signer) {
          var issuer = signer.issuer;
          var serialNumber = signer.serialNumber;
          if (signer.certificate) {
            var cert2 = signer.certificate;
            if (typeof cert2 === "string") {
              cert2 = forge.pki.certificateFromPem(cert2);
            }
            issuer = cert2.issuer.attributes;
            serialNumber = cert2.serialNumber;
          }
          var key = signer.key;
          if (!key) {
            throw new Error(
              "Could not add PKCS#7 signer; no private key specified."
            );
          }
          if (typeof key === "string") {
            key = forge.pki.privateKeyFromPem(key);
          }
          var digestAlgorithm = signer.digestAlgorithm || forge.pki.oids.sha1;
          switch (digestAlgorithm) {
            case forge.pki.oids.sha1:
            case forge.pki.oids.sha256:
            case forge.pki.oids.sha384:
            case forge.pki.oids.sha512:
            case forge.pki.oids.md5:
              break;
            default:
              throw new Error(
                "Could not add PKCS#7 signer; unknown message digest algorithm: " + digestAlgorithm
              );
          }
          var authenticatedAttributes = signer.authenticatedAttributes || [];
          if (authenticatedAttributes.length > 0) {
            var contentType = false;
            var messageDigest = false;
            for (var i2 = 0; i2 < authenticatedAttributes.length; ++i2) {
              var attr = authenticatedAttributes[i2];
              if (!contentType && attr.type === forge.pki.oids.contentType) {
                contentType = true;
                if (messageDigest) {
                  break;
                }
                continue;
              }
              if (!messageDigest && attr.type === forge.pki.oids.messageDigest) {
                messageDigest = true;
                if (contentType) {
                  break;
                }
                continue;
              }
            }
            if (!contentType || !messageDigest) {
              throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.");
            }
          }
          msg.signers.push({
            key,
            version: 1,
            issuer,
            serialNumber,
            digestAlgorithm,
            signatureAlgorithm: forge.pki.oids.rsaEncryption,
            signature: null,
            authenticatedAttributes,
            unauthenticatedAttributes: []
          });
        },
        /**
         * Signs the content.
         * @param options Options to apply when signing:
         *    [detached] boolean. If signing should be done in detached mode. Defaults to false.
         */
        sign: function(options) {
          options = options || {};
          if (typeof msg.content !== "object" || msg.contentInfo === null) {
            msg.contentInfo = asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SEQUENCE,
              true,
              [
                // ContentType
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(forge.pki.oids.data).getBytes()
                )
              ]
            );
            if ("content" in msg) {
              var content;
              if (msg.content instanceof forge.util.ByteBuffer) {
                content = msg.content.bytes();
              } else if (typeof msg.content === "string") {
                content = forge.util.encodeUtf8(msg.content);
              }
              if (options.detached) {
                msg.detachedContent = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content);
              } else {
                msg.contentInfo.value.push(
                  // [0] EXPLICIT content
                  asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                    asn1.create(
                      asn1.Class.UNIVERSAL,
                      asn1.Type.OCTETSTRING,
                      false,
                      content
                    )
                  ])
                );
              }
            }
          }
          if (msg.signers.length === 0) {
            return;
          }
          var mds = addDigestAlgorithmIds();
          addSignerInfos(mds);
        },
        verify: function() {
          throw new Error("PKCS#7 signature verification not yet implemented.");
        },
        /**
         * Add a certificate.
         *
         * @param cert the certificate to add.
         */
        addCertificate: function(cert2) {
          if (typeof cert2 === "string") {
            cert2 = forge.pki.certificateFromPem(cert2);
          }
          msg.certificates.push(cert2);
        },
        /**
         * Add a certificate revokation list.
         *
         * @param crl the certificate revokation list to add.
         */
        addCertificateRevokationList: function(crl) {
          throw new Error("PKCS#7 CRL support not yet implemented.");
        }
      };
      return msg;
      function addDigestAlgorithmIds() {
        var mds = {};
        for (var i2 = 0; i2 < msg.signers.length; ++i2) {
          var signer = msg.signers[i2];
          var oid = signer.digestAlgorithm;
          if (!(oid in mds)) {
            mds[oid] = forge.md[forge.pki.oids[oid]].create();
          }
          if (signer.authenticatedAttributes.length === 0) {
            signer.md = mds[oid];
          } else {
            signer.md = forge.md[forge.pki.oids[oid]].create();
          }
        }
        msg.digestAlgorithmIdentifiers = [];
        for (var oid in mds) {
          msg.digestAlgorithmIdentifiers.push(
            // AlgorithmIdentifier
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // algorithm
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(oid).getBytes()
              ),
              // parameters (null)
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
            ])
          );
        }
        return mds;
      }
      function addSignerInfos(mds) {
        var content;
        if (msg.detachedContent) {
          content = msg.detachedContent;
        } else {
          content = msg.contentInfo.value[1];
          content = content.value[0];
        }
        if (!content) {
          throw new Error(
            "Could not sign PKCS#7 message; there is no content to sign."
          );
        }
        var contentType = asn1.derToOid(msg.contentInfo.value[0].value);
        var bytes = asn1.toDer(content);
        bytes.getByte();
        asn1.getBerValueLength(bytes);
        bytes = bytes.getBytes();
        for (var oid in mds) {
          mds[oid].start().update(bytes);
        }
        var signingTime = /* @__PURE__ */ new Date();
        for (var i2 = 0; i2 < msg.signers.length; ++i2) {
          var signer = msg.signers[i2];
          if (signer.authenticatedAttributes.length === 0) {
            if (contentType !== forge.pki.oids.data) {
              throw new Error(
                "Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data."
              );
            }
          } else {
            signer.authenticatedAttributesAsn1 = asn1.create(
              asn1.Class.CONTEXT_SPECIFIC,
              0,
              true,
              []
            );
            var attrsAsn1 = asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SET,
              true,
              []
            );
            for (var ai2 = 0; ai2 < signer.authenticatedAttributes.length; ++ai2) {
              var attr = signer.authenticatedAttributes[ai2];
              if (attr.type === forge.pki.oids.messageDigest) {
                attr.value = mds[signer.digestAlgorithm].digest();
              } else if (attr.type === forge.pki.oids.signingTime) {
                if (!attr.value) {
                  attr.value = signingTime;
                }
              }
              attrsAsn1.value.push(_attributeToAsn1(attr));
              signer.authenticatedAttributesAsn1.value.push(_attributeToAsn1(attr));
            }
            bytes = asn1.toDer(attrsAsn1).getBytes();
            signer.md.start().update(bytes);
          }
          signer.signature = signer.key.sign(signer.md, "RSASSA-PKCS1-V1_5");
        }
        msg.signerInfos = _signersToAsn1(msg.signers);
      }
    };
    p7.createEncryptedData = function() {
      var msg = null;
      msg = {
        type: forge.pki.oids.encryptedData,
        version: 0,
        encryptedContent: {
          algorithm: forge.pki.oids["aes256-CBC"]
        },
        /**
         * Reads an EncryptedData content block (in ASN.1 format)
         *
         * @param obj The ASN.1 representation of the EncryptedData content block
         */
        fromAsn1: function(obj) {
          _fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);
        },
        /**
         * Decrypt encrypted content
         *
         * @param key The (symmetric) key as a byte buffer
         */
        decrypt: function(key) {
          if (key !== void 0) {
            msg.encryptedContent.key = key;
          }
          _decryptContent(msg);
        }
      };
      return msg;
    };
    p7.createEnvelopedData = function() {
      var msg = null;
      msg = {
        type: forge.pki.oids.envelopedData,
        version: 0,
        recipients: [],
        encryptedContent: {
          algorithm: forge.pki.oids["aes256-CBC"]
        },
        /**
         * Reads an EnvelopedData content block (in ASN.1 format)
         *
         * @param obj the ASN.1 representation of the EnvelopedData content block.
         */
        fromAsn1: function(obj) {
          var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);
          msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value);
        },
        toAsn1: function() {
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // ContentType
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(msg.type).getBytes()
            ),
            // [0] EnvelopedData
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                // Version
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.INTEGER,
                  false,
                  asn1.integerToDer(msg.version).getBytes()
                ),
                // RecipientInfos
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.SET,
                  true,
                  _recipientsToAsn1(msg.recipients)
                ),
                // EncryptedContentInfo
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.SEQUENCE,
                  true,
                  _encryptedContentToAsn1(msg.encryptedContent)
                )
              ])
            ])
          ]);
        },
        /**
         * Find recipient by X.509 certificate's issuer.
         *
         * @param cert the certificate with the issuer to look for.
         *
         * @return the recipient object.
         */
        findRecipient: function(cert2) {
          var sAttr = cert2.issuer.attributes;
          for (var i2 = 0; i2 < msg.recipients.length; ++i2) {
            var r2 = msg.recipients[i2];
            var rAttr = r2.issuer;
            if (r2.serialNumber !== cert2.serialNumber) {
              continue;
            }
            if (rAttr.length !== sAttr.length) {
              continue;
            }
            var match = true;
            for (var j2 = 0; j2 < sAttr.length; ++j2) {
              if (rAttr[j2].type !== sAttr[j2].type || rAttr[j2].value !== sAttr[j2].value) {
                match = false;
                break;
              }
            }
            if (match) {
              return r2;
            }
          }
          return null;
        },
        /**
         * Decrypt enveloped content
         *
         * @param recipient The recipient object related to the private key
         * @param privKey The (RSA) private key object
         */
        decrypt: function(recipient, privKey) {
          if (msg.encryptedContent.key === void 0 && recipient !== void 0 && privKey !== void 0) {
            switch (recipient.encryptedContent.algorithm) {
              case forge.pki.oids.rsaEncryption:
              case forge.pki.oids.desCBC:
                var key = privKey.decrypt(recipient.encryptedContent.content);
                msg.encryptedContent.key = forge.util.createBuffer(key);
                break;
              default:
                throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
            }
          }
          _decryptContent(msg);
        },
        /**
         * Add (another) entity to list of recipients.
         *
         * @param cert The certificate of the entity to add.
         */
        addRecipient: function(cert2) {
          msg.recipients.push({
            version: 0,
            issuer: cert2.issuer.attributes,
            serialNumber: cert2.serialNumber,
            encryptedContent: {
              // We simply assume rsaEncryption here, since forge.pki only
              // supports RSA so far.  If the PKI module supports other
              // ciphers one day, we need to modify this one as well.
              algorithm: forge.pki.oids.rsaEncryption,
              key: cert2.publicKey
            }
          });
        },
        /**
         * Encrypt enveloped content.
         *
         * This function supports two optional arguments, cipher and key, which
         * can be used to influence symmetric encryption.  Unless cipher is
         * provided, the cipher specified in encryptedContent.algorithm is used
         * (defaults to AES-256-CBC).  If no key is provided, encryptedContent.key
         * is (re-)used.  If that one's not set, a random key will be generated
         * automatically.
         *
         * @param [key] The key to be used for symmetric encryption.
         * @param [cipher] The OID of the symmetric cipher to use.
         */
        encrypt: function(key, cipher) {
          if (msg.encryptedContent.content === void 0) {
            cipher = cipher || msg.encryptedContent.algorithm;
            key = key || msg.encryptedContent.key;
            var keyLen, ivLen, ciphFn;
            switch (cipher) {
              case forge.pki.oids["aes128-CBC"]:
                keyLen = 16;
                ivLen = 16;
                ciphFn = forge.aes.createEncryptionCipher;
                break;
              case forge.pki.oids["aes192-CBC"]:
                keyLen = 24;
                ivLen = 16;
                ciphFn = forge.aes.createEncryptionCipher;
                break;
              case forge.pki.oids["aes256-CBC"]:
                keyLen = 32;
                ivLen = 16;
                ciphFn = forge.aes.createEncryptionCipher;
                break;
              case forge.pki.oids["des-EDE3-CBC"]:
                keyLen = 24;
                ivLen = 8;
                ciphFn = forge.des.createEncryptionCipher;
                break;
              default:
                throw new Error("Unsupported symmetric cipher, OID " + cipher);
            }
            if (key === void 0) {
              key = forge.util.createBuffer(forge.random.getBytes(keyLen));
            } else if (key.length() != keyLen) {
              throw new Error("Symmetric key has wrong length; got " + key.length() + " bytes, expected " + keyLen + ".");
            }
            msg.encryptedContent.algorithm = cipher;
            msg.encryptedContent.key = key;
            msg.encryptedContent.parameter = forge.util.createBuffer(
              forge.random.getBytes(ivLen)
            );
            var ciph = ciphFn(key);
            ciph.start(msg.encryptedContent.parameter.copy());
            ciph.update(msg.content);
            if (!ciph.finish()) {
              throw new Error("Symmetric encryption failed.");
            }
            msg.encryptedContent.content = ciph.output;
          }
          for (var i2 = 0; i2 < msg.recipients.length; ++i2) {
            var recipient = msg.recipients[i2];
            if (recipient.encryptedContent.content !== void 0) {
              continue;
            }
            switch (recipient.encryptedContent.algorithm) {
              case forge.pki.oids.rsaEncryption:
                recipient.encryptedContent.content = recipient.encryptedContent.key.encrypt(
                  msg.encryptedContent.key.data
                );
                break;
              default:
                throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
            }
          }
        }
      };
      return msg;
    };
    function _recipientFromAsn1(obj) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, p7.asn1.recipientInfoValidator, capture, errors)) {
        var error = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
        error.errors = errors;
        throw error;
      }
      return {
        version: capture.version.charCodeAt(0),
        issuer: forge.pki.RDNAttributesAsArray(capture.issuer),
        serialNumber: forge.util.createBuffer(capture.serial).toHex(),
        encryptedContent: {
          algorithm: asn1.derToOid(capture.encAlgorithm),
          parameter: capture.encParameter ? capture.encParameter.value : void 0,
          content: capture.encKey
        }
      };
    }
    function _recipientToAsn1(obj) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // Version
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(obj.version).getBytes()
        ),
        // IssuerAndSerialNumber
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // Name
          forge.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
          // Serial
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            forge.util.hexToBytes(obj.serialNumber)
          )
        ]),
        // KeyEncryptionAlgorithmIdentifier
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // Algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(obj.encryptedContent.algorithm).getBytes()
          ),
          // Parameter, force NULL, only RSA supported for now.
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        // EncryptedKey
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          obj.encryptedContent.content
        )
      ]);
    }
    function _recipientsFromAsn1(infos) {
      var ret = [];
      for (var i2 = 0; i2 < infos.length; ++i2) {
        ret.push(_recipientFromAsn1(infos[i2]));
      }
      return ret;
    }
    function _recipientsToAsn1(recipients) {
      var ret = [];
      for (var i2 = 0; i2 < recipients.length; ++i2) {
        ret.push(_recipientToAsn1(recipients[i2]));
      }
      return ret;
    }
    function _signerToAsn1(obj) {
      var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(obj.version).getBytes()
        ),
        // issuerAndSerialNumber
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // name
          forge.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
          // serial
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            forge.util.hexToBytes(obj.serialNumber)
          )
        ]),
        // digestAlgorithm
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(obj.digestAlgorithm).getBytes()
          ),
          // parameters (null)
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ])
      ]);
      if (obj.authenticatedAttributesAsn1) {
        rval.value.push(obj.authenticatedAttributesAsn1);
      }
      rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // algorithm
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(obj.signatureAlgorithm).getBytes()
        ),
        // parameters (null)
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
      ]));
      rval.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        obj.signature
      ));
      if (obj.unauthenticatedAttributes.length > 0) {
        var attrsAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, []);
        for (var i2 = 0; i2 < obj.unauthenticatedAttributes.length; ++i2) {
          var attr = obj.unauthenticatedAttributes[i2];
          attrsAsn1.values.push(_attributeToAsn1(attr));
        }
        rval.value.push(attrsAsn1);
      }
      return rval;
    }
    function _signersToAsn1(signers) {
      var ret = [];
      for (var i2 = 0; i2 < signers.length; ++i2) {
        ret.push(_signerToAsn1(signers[i2]));
      }
      return ret;
    }
    function _attributeToAsn1(attr) {
      var value;
      if (attr.type === forge.pki.oids.contentType) {
        value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(attr.value).getBytes()
        );
      } else if (attr.type === forge.pki.oids.messageDigest) {
        value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          attr.value.bytes()
        );
      } else if (attr.type === forge.pki.oids.signingTime) {
        var jan_1_1950 = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z");
        var jan_1_2050 = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z");
        var date = attr.value;
        if (typeof date === "string") {
          var timestamp = Date.parse(date);
          if (!isNaN(timestamp)) {
            date = new Date(timestamp);
          } else if (date.length === 13) {
            date = asn1.utcTimeToDate(date);
          } else {
            date = asn1.generalizedTimeToDate(date);
          }
        }
        if (date >= jan_1_1950 && date < jan_1_2050) {
          value = asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.UTCTIME,
            false,
            asn1.dateToUtcTime(date)
          );
        } else {
          value = asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.GENERALIZEDTIME,
            false,
            asn1.dateToGeneralizedTime(date)
          );
        }
      }
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // AttributeType
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(attr.type).getBytes()
        ),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
          // AttributeValue
          value
        ])
      ]);
    }
    function _encryptedContentToAsn1(ec2) {
      return [
        // ContentType, always Data for the moment
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(forge.pki.oids.data).getBytes()
        ),
        // ContentEncryptionAlgorithmIdentifier
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // Algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(ec2.algorithm).getBytes()
          ),
          // Parameters (IV)
          !ec2.parameter ? void 0 : asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OCTETSTRING,
            false,
            ec2.parameter.getBytes()
          )
        ]),
        // [0] EncryptedContent
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OCTETSTRING,
            false,
            ec2.content.getBytes()
          )
        ])
      ];
    }
    function _fromAsn1(msg, obj, validator) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, validator, capture, errors)) {
        var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
        error.errors = error;
        throw error;
      }
      var contentType = asn1.derToOid(capture.contentType);
      if (contentType !== forge.pki.oids.data) {
        throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
      }
      if (capture.encryptedContent) {
        var content = "";
        if (forge.util.isArray(capture.encryptedContent)) {
          for (var i2 = 0; i2 < capture.encryptedContent.length; ++i2) {
            if (capture.encryptedContent[i2].type !== asn1.Type.OCTETSTRING) {
              throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
            }
            content += capture.encryptedContent[i2].value;
          }
        } else {
          content = capture.encryptedContent;
        }
        msg.encryptedContent = {
          algorithm: asn1.derToOid(capture.encAlgorithm),
          parameter: forge.util.createBuffer(capture.encParameter.value),
          content: forge.util.createBuffer(content)
        };
      }
      if (capture.content) {
        var content = "";
        if (forge.util.isArray(capture.content)) {
          for (var i2 = 0; i2 < capture.content.length; ++i2) {
            if (capture.content[i2].type !== asn1.Type.OCTETSTRING) {
              throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
            }
            content += capture.content[i2].value;
          }
        } else {
          content = capture.content;
        }
        msg.content = forge.util.createBuffer(content);
      }
      msg.version = capture.version.charCodeAt(0);
      msg.rawCapture = capture;
      return capture;
    }
    function _decryptContent(msg) {
      if (msg.encryptedContent.key === void 0) {
        throw new Error("Symmetric key not available.");
      }
      if (msg.content === void 0) {
        var ciph;
        switch (msg.encryptedContent.algorithm) {
          case forge.pki.oids["aes128-CBC"]:
          case forge.pki.oids["aes192-CBC"]:
          case forge.pki.oids["aes256-CBC"]:
            ciph = forge.aes.createDecryptionCipher(msg.encryptedContent.key);
            break;
          case forge.pki.oids["desCBC"]:
          case forge.pki.oids["des-EDE3-CBC"]:
            ciph = forge.des.createDecryptionCipher(msg.encryptedContent.key);
            break;
          default:
            throw new Error("Unsupported symmetric cipher, OID " + msg.encryptedContent.algorithm);
        }
        ciph.start(msg.encryptedContent.parameter);
        ciph.update(msg.encryptedContent.content);
        if (!ciph.finish()) {
          throw new Error("Symmetric decryption failed.");
        }
        msg.content = ciph.output;
      }
    }
  }
});

// node_modules/node-forge/lib/ssh.js
var require_ssh = __commonJS({
  "node_modules/node-forge/lib/ssh.js"(exports, module) {
    var forge = require_forge();
    require_aes();
    require_hmac();
    require_md5();
    require_sha1();
    require_util2();
    var ssh = module.exports = forge.ssh = forge.ssh || {};
    ssh.privateKeyToPutty = function(privateKey, passphrase, comment) {
      comment = comment || "";
      passphrase = passphrase || "";
      var algorithm = "ssh-rsa";
      var encryptionAlgorithm = passphrase === "" ? "none" : "aes256-cbc";
      var ppk = "PuTTY-User-Key-File-2: " + algorithm + "\r\n";
      ppk += "Encryption: " + encryptionAlgorithm + "\r\n";
      ppk += "Comment: " + comment + "\r\n";
      var pubbuffer = forge.util.createBuffer();
      _addStringToBuffer(pubbuffer, algorithm);
      _addBigIntegerToBuffer(pubbuffer, privateKey.e);
      _addBigIntegerToBuffer(pubbuffer, privateKey.n);
      var pub = forge.util.encode64(pubbuffer.bytes(), 64);
      var length = Math.floor(pub.length / 66) + 1;
      ppk += "Public-Lines: " + length + "\r\n";
      ppk += pub;
      var privbuffer = forge.util.createBuffer();
      _addBigIntegerToBuffer(privbuffer, privateKey.d);
      _addBigIntegerToBuffer(privbuffer, privateKey.p);
      _addBigIntegerToBuffer(privbuffer, privateKey.q);
      _addBigIntegerToBuffer(privbuffer, privateKey.qInv);
      var priv;
      if (!passphrase) {
        priv = forge.util.encode64(privbuffer.bytes(), 64);
      } else {
        var encLen = privbuffer.length() + 16 - 1;
        encLen -= encLen % 16;
        var padding = _sha1(privbuffer.bytes());
        padding.truncate(padding.length() - encLen + privbuffer.length());
        privbuffer.putBuffer(padding);
        var aeskey = forge.util.createBuffer();
        aeskey.putBuffer(_sha1("\0\0\0\0", passphrase));
        aeskey.putBuffer(_sha1("\0\0\0", passphrase));
        var cipher = forge.aes.createEncryptionCipher(aeskey.truncate(8), "CBC");
        cipher.start(forge.util.createBuffer().fillWithByte(0, 16));
        cipher.update(privbuffer.copy());
        cipher.finish();
        var encrypted = cipher.output;
        encrypted.truncate(16);
        priv = forge.util.encode64(encrypted.bytes(), 64);
      }
      length = Math.floor(priv.length / 66) + 1;
      ppk += "\r\nPrivate-Lines: " + length + "\r\n";
      ppk += priv;
      var mackey = _sha1("putty-private-key-file-mac-key", passphrase);
      var macbuffer = forge.util.createBuffer();
      _addStringToBuffer(macbuffer, algorithm);
      _addStringToBuffer(macbuffer, encryptionAlgorithm);
      _addStringToBuffer(macbuffer, comment);
      macbuffer.putInt32(pubbuffer.length());
      macbuffer.putBuffer(pubbuffer);
      macbuffer.putInt32(privbuffer.length());
      macbuffer.putBuffer(privbuffer);
      var hmac = forge.hmac.create();
      hmac.start("sha1", mackey);
      hmac.update(macbuffer.bytes());
      ppk += "\r\nPrivate-MAC: " + hmac.digest().toHex() + "\r\n";
      return ppk;
    };
    ssh.publicKeyToOpenSSH = function(key, comment) {
      var type = "ssh-rsa";
      comment = comment || "";
      var buffer = forge.util.createBuffer();
      _addStringToBuffer(buffer, type);
      _addBigIntegerToBuffer(buffer, key.e);
      _addBigIntegerToBuffer(buffer, key.n);
      return type + " " + forge.util.encode64(buffer.bytes()) + " " + comment;
    };
    ssh.privateKeyToOpenSSH = function(privateKey, passphrase) {
      if (!passphrase) {
        return forge.pki.privateKeyToPem(privateKey);
      }
      return forge.pki.encryptRsaPrivateKey(
        privateKey,
        passphrase,
        { legacy: true, algorithm: "aes128" }
      );
    };
    ssh.getPublicKeyFingerprint = function(key, options) {
      options = options || {};
      var md2 = options.md || forge.md.md5.create();
      var type = "ssh-rsa";
      var buffer = forge.util.createBuffer();
      _addStringToBuffer(buffer, type);
      _addBigIntegerToBuffer(buffer, key.e);
      _addBigIntegerToBuffer(buffer, key.n);
      md2.start();
      md2.update(buffer.getBytes());
      var digest = md2.digest();
      if (options.encoding === "hex") {
        var hex = digest.toHex();
        if (options.delimiter) {
          return hex.match(/.{2}/g).join(options.delimiter);
        }
        return hex;
      } else if (options.encoding === "binary") {
        return digest.getBytes();
      } else if (options.encoding) {
        throw new Error('Unknown encoding "' + options.encoding + '".');
      }
      return digest;
    };
    function _addBigIntegerToBuffer(buffer, val) {
      var hexVal = val.toString(16);
      if (hexVal[0] >= "8") {
        hexVal = "00" + hexVal;
      }
      var bytes = forge.util.hexToBytes(hexVal);
      buffer.putInt32(bytes.length);
      buffer.putBytes(bytes);
    }
    function _addStringToBuffer(buffer, val) {
      buffer.putInt32(val.length);
      buffer.putString(val);
    }
    function _sha1() {
      var sha = forge.md.sha1.create();
      var num = arguments.length;
      for (var i2 = 0; i2 < num; ++i2) {
        sha.update(arguments[i2]);
      }
      return sha.digest();
    }
  }
});

// node_modules/node-forge/lib/index.js
var require_lib = __commonJS({
  "node_modules/node-forge/lib/index.js"(exports, module) {
    module.exports = require_forge();
    require_aes();
    require_aesCipherSuites();
    require_asn1();
    require_cipher();
    require_des();
    require_ed25519();
    require_hmac();
    require_kem();
    require_log();
    require_md_all();
    require_mgf1();
    require_pbkdf2();
    require_pem();
    require_pkcs1();
    require_pkcs12();
    require_pkcs7();
    require_pki();
    require_prime();
    require_prng();
    require_pss();
    require_random();
    require_rc2();
    require_ssh();
    require_tls();
    require_util2();
  }
});

// node_modules/firebase-admin/lib/app/credential-internal.js
var require_credential_internal = __commonJS({
  "node_modules/firebase-admin/lib/app/credential-internal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getApplicationDefault = exports.isApplicationDefault = exports.ImpersonatedServiceAccountCredential = exports.RefreshTokenCredential = exports.ComputeEngineCredential = exports.ServiceAccountCredential = void 0;
    var fs2 = require_fs();
    var os2 = require_os();
    var path = require_path();
    var error_1 = require_error();
    var api_request_1 = require_api_request();
    var util = require_validator();
    var GOOGLE_TOKEN_AUDIENCE = "https://accounts.google.com/o/oauth2/token";
    var GOOGLE_AUTH_TOKEN_HOST = "accounts.google.com";
    var GOOGLE_AUTH_TOKEN_PATH = "/o/oauth2/token";
    var GOOGLE_METADATA_SERVICE_HOST = "metadata.google.internal";
    var GOOGLE_METADATA_SERVICE_TOKEN_PATH = "/computeMetadata/v1/instance/service-accounts/default/token";
    var GOOGLE_METADATA_SERVICE_IDENTITY_PATH = "/computeMetadata/v1/instance/service-accounts/default/identity";
    var GOOGLE_METADATA_SERVICE_PROJECT_ID_PATH = "/computeMetadata/v1/project/project-id";
    var GOOGLE_METADATA_SERVICE_ACCOUNT_ID_PATH = "/computeMetadata/v1/instance/service-accounts/default/email";
    var configDir = (() => {
      const sys = os2.platform();
      if (sys && sys.length >= 3 && sys.substring(0, 3).toLowerCase() === "win") {
        return process.env.APPDATA;
      }
      return process.env.HOME && path.resolve(process.env.HOME, ".config");
    })();
    var GCLOUD_CREDENTIAL_SUFFIX = "gcloud/application_default_credentials.json";
    var GCLOUD_CREDENTIAL_PATH = configDir && path.resolve(configDir, GCLOUD_CREDENTIAL_SUFFIX);
    var REFRESH_TOKEN_HOST = "www.googleapis.com";
    var REFRESH_TOKEN_PATH = "/oauth2/v4/token";
    var ONE_HOUR_IN_SECONDS = 60 * 60;
    var JWT_ALGORITHM = "RS256";
    var ServiceAccountCredential = class {
      /**
       * Creates a new ServiceAccountCredential from the given parameters.
       *
       * @param serviceAccountPathOrObject - Service account json object or path to a service account json file.
       * @param httpAgent - Optional http.Agent to use when calling the remote token server.
       * @param implicit - An optinal boolean indicating whether this credential was implicitly discovered from the
       *   environment, as opposed to being explicitly specified by the developer.
       *
       * @constructor
       */
      constructor(serviceAccountPathOrObject, httpAgent, implicit = false) {
        this.httpAgent = httpAgent;
        this.implicit = implicit;
        const serviceAccount = typeof serviceAccountPathOrObject === "string" ? ServiceAccount.fromPath(serviceAccountPathOrObject) : new ServiceAccount(serviceAccountPathOrObject);
        this.projectId = serviceAccount.projectId;
        this.privateKey = serviceAccount.privateKey;
        this.clientEmail = serviceAccount.clientEmail;
        this.httpClient = new api_request_1.HttpClient();
      }
      getAccessToken() {
        const token = this.createAuthJwt_();
        const postData = "grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Ajwt-bearer&assertion=" + token;
        const request = {
          method: "POST",
          url: `https://${GOOGLE_AUTH_TOKEN_HOST}${GOOGLE_AUTH_TOKEN_PATH}`,
          headers: {
            "Content-Type": "application/x-www-form-urlencoded"
          },
          data: postData,
          httpAgent: this.httpAgent
        };
        return requestAccessToken(this.httpClient, request);
      }
      // eslint-disable-next-line @typescript-eslint/naming-convention
      createAuthJwt_() {
        const claims = {
          scope: [
            "https://www.googleapis.com/auth/cloud-platform",
            "https://www.googleapis.com/auth/firebase.database",
            "https://www.googleapis.com/auth/firebase.messaging",
            "https://www.googleapis.com/auth/identitytoolkit",
            "https://www.googleapis.com/auth/userinfo.email"
          ].join(" ")
        };
        const jwt = require_jsonwebtoken();
        return jwt.sign(claims, this.privateKey, {
          audience: GOOGLE_TOKEN_AUDIENCE,
          expiresIn: ONE_HOUR_IN_SECONDS,
          issuer: this.clientEmail,
          algorithm: JWT_ALGORITHM
        });
      }
    };
    exports.ServiceAccountCredential = ServiceAccountCredential;
    var ServiceAccount = class _ServiceAccount {
      static fromPath(filePath) {
        try {
          return new _ServiceAccount(JSON.parse(fs2.readFileSync(filePath, "utf8")));
        } catch (error) {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, "Failed to parse service account json file: " + error);
        }
      }
      constructor(json) {
        if (!util.isNonNullObject(json)) {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, "Service account must be an object.");
        }
        copyAttr(this, json, "projectId", "project_id");
        copyAttr(this, json, "privateKey", "private_key");
        copyAttr(this, json, "clientEmail", "client_email");
        let errorMessage;
        if (!util.isNonEmptyString(this.projectId)) {
          errorMessage = 'Service account object must contain a string "project_id" property.';
        } else if (!util.isNonEmptyString(this.privateKey)) {
          errorMessage = 'Service account object must contain a string "private_key" property.';
        } else if (!util.isNonEmptyString(this.clientEmail)) {
          errorMessage = 'Service account object must contain a string "client_email" property.';
        }
        if (typeof errorMessage !== "undefined") {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);
        }
        const forge = require_lib();
        try {
          forge.pki.privateKeyFromPem(this.privateKey);
        } catch (error) {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, "Failed to parse private key: " + error);
        }
      }
    };
    var ComputeEngineCredential = class {
      constructor(httpAgent) {
        this.httpClient = new api_request_1.HttpClient();
        this.httpAgent = httpAgent;
      }
      getAccessToken() {
        const request = this.buildRequest(GOOGLE_METADATA_SERVICE_TOKEN_PATH);
        return requestAccessToken(this.httpClient, request);
      }
      /**
       * getIDToken returns a OIDC token from the compute metadata service
       * that can be used to make authenticated calls to audience
       * @param audience the URL the returned ID token will be used to call.
      */
      getIDToken(audience) {
        const request = this.buildRequest(`${GOOGLE_METADATA_SERVICE_IDENTITY_PATH}?audience=${audience}`);
        return requestIDToken(this.httpClient, request);
      }
      getProjectId() {
        if (this.projectId) {
          return Promise.resolve(this.projectId);
        }
        const request = this.buildRequest(GOOGLE_METADATA_SERVICE_PROJECT_ID_PATH);
        return this.httpClient.send(request).then((resp) => {
          this.projectId = resp.text;
          return this.projectId;
        }).catch((err) => {
          const detail = err instanceof api_request_1.HttpError ? getDetailFromResponse(err.response) : err.message;
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, `Failed to determine project ID: ${detail}`);
        });
      }
      getServiceAccountEmail() {
        if (this.accountId) {
          return Promise.resolve(this.accountId);
        }
        const request = this.buildRequest(GOOGLE_METADATA_SERVICE_ACCOUNT_ID_PATH);
        return this.httpClient.send(request).then((resp) => {
          this.accountId = resp.text;
          return this.accountId;
        }).catch((err) => {
          const detail = err instanceof api_request_1.HttpError ? getDetailFromResponse(err.response) : err.message;
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, `Failed to determine service account email: ${detail}`);
        });
      }
      buildRequest(urlPath) {
        return {
          method: "GET",
          url: `http://${GOOGLE_METADATA_SERVICE_HOST}${urlPath}`,
          headers: {
            "Metadata-Flavor": "Google"
          },
          httpAgent: this.httpAgent
        };
      }
    };
    exports.ComputeEngineCredential = ComputeEngineCredential;
    var RefreshTokenCredential = class {
      /**
       * Creates a new RefreshTokenCredential from the given parameters.
       *
       * @param refreshTokenPathOrObject - Refresh token json object or path to a refresh token
       *   (user credentials) json file.
       * @param httpAgent - Optional http.Agent to use when calling the remote token server.
       * @param implicit - An optinal boolean indicating whether this credential was implicitly
       *   discovered from the environment, as opposed to being explicitly specified by the developer.
       *
       * @constructor
       */
      constructor(refreshTokenPathOrObject, httpAgent, implicit = false) {
        this.httpAgent = httpAgent;
        this.implicit = implicit;
        this.refreshToken = typeof refreshTokenPathOrObject === "string" ? RefreshToken.fromPath(refreshTokenPathOrObject) : new RefreshToken(refreshTokenPathOrObject);
        this.httpClient = new api_request_1.HttpClient();
      }
      getAccessToken() {
        const postData = "client_id=" + this.refreshToken.clientId + "&client_secret=" + this.refreshToken.clientSecret + "&refresh_token=" + this.refreshToken.refreshToken + "&grant_type=refresh_token";
        const request = {
          method: "POST",
          url: `https://${REFRESH_TOKEN_HOST}${REFRESH_TOKEN_PATH}`,
          headers: {
            "Content-Type": "application/x-www-form-urlencoded"
          },
          data: postData,
          httpAgent: this.httpAgent
        };
        return requestAccessToken(this.httpClient, request);
      }
    };
    exports.RefreshTokenCredential = RefreshTokenCredential;
    var RefreshToken = class _RefreshToken {
      /*
       * Tries to load a RefreshToken from a path. Throws if the path doesn't exist or the
       * data at the path is invalid.
       */
      static fromPath(filePath) {
        try {
          return new _RefreshToken(JSON.parse(fs2.readFileSync(filePath, "utf8")));
        } catch (error) {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, "Failed to parse refresh token file: " + error);
        }
      }
      constructor(json) {
        copyAttr(this, json, "clientId", "client_id");
        copyAttr(this, json, "clientSecret", "client_secret");
        copyAttr(this, json, "refreshToken", "refresh_token");
        copyAttr(this, json, "type", "type");
        let errorMessage;
        if (!util.isNonEmptyString(this.clientId)) {
          errorMessage = 'Refresh token must contain a "client_id" property.';
        } else if (!util.isNonEmptyString(this.clientSecret)) {
          errorMessage = 'Refresh token must contain a "client_secret" property.';
        } else if (!util.isNonEmptyString(this.refreshToken)) {
          errorMessage = 'Refresh token must contain a "refresh_token" property.';
        } else if (!util.isNonEmptyString(this.type)) {
          errorMessage = 'Refresh token must contain a "type" property.';
        }
        if (typeof errorMessage !== "undefined") {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);
        }
      }
    };
    var ImpersonatedServiceAccountCredential = class {
      /**
       * Creates a new ImpersonatedServiceAccountCredential from the given parameters.
       *
       * @param impersonatedServiceAccountPathOrObject - Impersonated Service account json object or
       * path to a service account json file.
       * @param httpAgent - Optional http.Agent to use when calling the remote token server.
       * @param implicit - An optional boolean indicating whether this credential was implicitly
       *   discovered from the environment, as opposed to being explicitly specified by the developer.
       *
       * @constructor
       */
      constructor(impersonatedServiceAccountPathOrObject, httpAgent, implicit = false) {
        this.httpAgent = httpAgent;
        this.implicit = implicit;
        this.impersonatedServiceAccount = typeof impersonatedServiceAccountPathOrObject === "string" ? ImpersonatedServiceAccount.fromPath(impersonatedServiceAccountPathOrObject) : new ImpersonatedServiceAccount(impersonatedServiceAccountPathOrObject);
        this.httpClient = new api_request_1.HttpClient();
      }
      getAccessToken() {
        const postData = "client_id=" + this.impersonatedServiceAccount.clientId + "&client_secret=" + this.impersonatedServiceAccount.clientSecret + "&refresh_token=" + this.impersonatedServiceAccount.refreshToken + "&grant_type=refresh_token";
        const request = {
          method: "POST",
          url: `https://${REFRESH_TOKEN_HOST}${REFRESH_TOKEN_PATH}`,
          headers: {
            "Content-Type": "application/x-www-form-urlencoded"
          },
          data: postData,
          httpAgent: this.httpAgent
        };
        return requestAccessToken(this.httpClient, request);
      }
    };
    exports.ImpersonatedServiceAccountCredential = ImpersonatedServiceAccountCredential;
    var ImpersonatedServiceAccount = class _ImpersonatedServiceAccount {
      /*
       * Tries to load a ImpersonatedServiceAccount from a path. Throws if the path doesn't exist or the
       * data at the path is invalid.
       */
      static fromPath(filePath) {
        try {
          return new _ImpersonatedServiceAccount(JSON.parse(fs2.readFileSync(filePath, "utf8")));
        } catch (error) {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, "Failed to parse impersonated service account file: " + error);
        }
      }
      constructor(json) {
        const sourceCredentials = json["source_credentials"];
        if (sourceCredentials) {
          copyAttr(this, sourceCredentials, "clientId", "client_id");
          copyAttr(this, sourceCredentials, "clientSecret", "client_secret");
          copyAttr(this, sourceCredentials, "refreshToken", "refresh_token");
          copyAttr(this, sourceCredentials, "type", "type");
        }
        let errorMessage;
        if (!util.isNonEmptyString(this.clientId)) {
          errorMessage = 'Impersonated Service Account must contain a "source_credentials.client_id" property.';
        } else if (!util.isNonEmptyString(this.clientSecret)) {
          errorMessage = 'Impersonated Service Account must contain a "source_credentials.client_secret" property.';
        } else if (!util.isNonEmptyString(this.refreshToken)) {
          errorMessage = 'Impersonated Service Account must contain a "source_credentials.refresh_token" property.';
        } else if (!util.isNonEmptyString(this.type)) {
          errorMessage = 'Impersonated Service Account must contain a "source_credentials.type" property.';
        }
        if (typeof errorMessage !== "undefined") {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);
        }
      }
    };
    function isApplicationDefault(credential) {
      return credential instanceof ComputeEngineCredential || credential instanceof ServiceAccountCredential && credential.implicit || credential instanceof RefreshTokenCredential && credential.implicit || credential instanceof ImpersonatedServiceAccountCredential && credential.implicit;
    }
    exports.isApplicationDefault = isApplicationDefault;
    function getApplicationDefault(httpAgent) {
      if (process.env.GOOGLE_APPLICATION_CREDENTIALS) {
        return credentialFromFile(process.env.GOOGLE_APPLICATION_CREDENTIALS, httpAgent, false);
      }
      if (GCLOUD_CREDENTIAL_PATH) {
        const credential = credentialFromFile(GCLOUD_CREDENTIAL_PATH, httpAgent, true);
        if (credential)
          return credential;
      }
      return new ComputeEngineCredential(httpAgent);
    }
    exports.getApplicationDefault = getApplicationDefault;
    function copyAttr(to2, from3, key, alt) {
      const tmp = from3[key] || from3[alt];
      if (typeof tmp !== "undefined") {
        to2[key] = tmp;
      }
    }
    function requestAccessToken(client, request) {
      return client.send(request).then((resp) => {
        const json = resp.data;
        if (!json.access_token || !json.expires_in) {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, `Unexpected response while fetching access token: ${JSON.stringify(json)}`);
        }
        return json;
      }).catch((err) => {
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, getErrorMessage(err));
      });
    }
    function requestIDToken(client, request) {
      return client.send(request).then((resp) => {
        if (!resp.text) {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, "Unexpected response while fetching id token: response.text is undefined");
        }
        return resp.text;
      }).catch((err) => {
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, getErrorMessage(err));
      });
    }
    function getErrorMessage(err) {
      const detail = err instanceof api_request_1.HttpError ? getDetailFromResponse(err.response) : err.message;
      return `Error fetching access token: ${detail}`;
    }
    function getDetailFromResponse(response) {
      if (response.isJson() && response.data.error) {
        const json = response.data;
        let detail = json.error;
        if (json.error_description) {
          detail += " (" + json.error_description + ")";
        }
        return detail;
      }
      return response.text || "Missing error payload";
    }
    function credentialFromFile(filePath, httpAgent, ignoreMissing) {
      const credentialsFile = readCredentialFile(filePath, ignoreMissing);
      if (typeof credentialsFile !== "object" || credentialsFile === null) {
        if (ignoreMissing) {
          return null;
        }
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, "Failed to parse contents of the credentials file as an object");
      }
      if (credentialsFile.type === "service_account") {
        return new ServiceAccountCredential(credentialsFile, httpAgent, true);
      }
      if (credentialsFile.type === "authorized_user") {
        return new RefreshTokenCredential(credentialsFile, httpAgent, true);
      }
      if (credentialsFile.type === "impersonated_service_account") {
        return new ImpersonatedServiceAccountCredential(credentialsFile, httpAgent, true);
      }
      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, "Invalid contents in the credentials file");
    }
    function readCredentialFile(filePath, ignoreMissing) {
      let fileText;
      try {
        fileText = fs2.readFileSync(filePath, "utf8");
      } catch (error) {
        if (ignoreMissing) {
          return null;
        }
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, `Failed to read credentials from file ${filePath}: ` + error);
      }
      try {
        return JSON.parse(fileText);
      } catch (error) {
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, "Failed to parse contents of the credentials file as an object: " + error);
      }
    }
  }
});

// node_modules/firebase-admin/package.json
var require_package = __commonJS({
  "node_modules/firebase-admin/package.json"(exports, module) {
    module.exports = {
      name: "firebase-admin",
      version: "12.1.0",
      description: "Firebase admin SDK for Node.js",
      author: "Firebase <firebase-support@google.com> (https://firebase.google.com/)",
      license: "Apache-2.0",
      homepage: "https://firebase.google.com/",
      engines: {
        node: ">=14"
      },
      scripts: {
        build: "gulp build",
        "build:tests": "gulp compile_test",
        prepare: "npm run build && npm run esm-wrap",
        lint: "run-p lint:src lint:test",
        test: "run-s lint test:unit",
        integration: "run-s build test:integration",
        "test:unit": "mocha test/unit/*.spec.ts --require ts-node/register",
        "test:integration": "mocha test/integration/*.ts --slow 5000 --timeout 20000 --require ts-node/register",
        "test:coverage": "nyc npm run test:unit",
        "lint:src": "eslint src/ --ext .ts",
        "lint:test": "eslint test/ --ext .ts",
        apidocs: "run-s api-extractor:local api-documenter",
        "api-extractor": "node generate-reports.js",
        "api-extractor:local": "npm run build && node generate-reports.js --local",
        "esm-wrap": "node generate-esm-wrapper.js",
        "api-documenter": "run-s api-documenter:markdown api-documenter:toc api-documenter:post",
        "api-documenter:markdown": "api-documenter-fire markdown --input temp --output docgen/markdown -s --project admin",
        "api-documenter:toc": "api-documenter-fire toc --input temp --output docgen/markdown -p /docs/reference/admin/node -s",
        "api-documenter:post": "node docgen/post-process.js"
      },
      nyc: {
        extension: [
          ".ts"
        ],
        include: [
          "src"
        ],
        exclude: [
          "**/*.d.ts"
        ],
        all: true
      },
      keywords: [
        "admin",
        "database",
        "Firebase",
        "realtime",
        "authentication"
      ],
      repository: {
        type: "git",
        url: "https://github.com/firebase/firebase-admin-node"
      },
      main: "lib/index.js",
      files: [
        "lib/",
        "LICENSE",
        "README.md",
        "package.json"
      ],
      types: "./lib/index.d.ts",
      typesVersions: {
        "*": {
          app: [
            "lib/app"
          ],
          "app-check": [
            "lib/app-check"
          ],
          auth: [
            "lib/auth"
          ],
          eventarc: [
            "lib/eventarc"
          ],
          extensions: [
            "lib/extensions"
          ],
          database: [
            "lib/database"
          ],
          firestore: [
            "lib/firestore"
          ],
          functions: [
            "lib/functions"
          ],
          installations: [
            "lib/installations"
          ],
          "instance-id": [
            "lib/instance-id"
          ],
          "machine-learning": [
            "lib/machine-learning"
          ],
          messaging: [
            "lib/messaging"
          ],
          "project-management": [
            "lib/project-management"
          ],
          "remote-config": [
            "lib/remote-config"
          ],
          "security-rules": [
            "lib/security-rules"
          ],
          storage: [
            "lib/storage"
          ]
        }
      },
      exports: {
        ".": "./lib/index.js",
        "./app": {
          types: "./lib/app/index.d.ts",
          require: "./lib/app/index.js",
          import: "./lib/esm/app/index.js"
        },
        "./app-check": {
          types: "./lib/app-check/index.d.ts",
          require: "./lib/app-check/index.js",
          import: "./lib/esm/app-check/index.js"
        },
        "./auth": {
          types: "./lib/auth/index.d.ts",
          require: "./lib/auth/index.js",
          import: "./lib/esm/auth/index.js"
        },
        "./database": {
          types: "./lib/database/index.d.ts",
          require: "./lib/database/index.js",
          import: "./lib/esm/database/index.js"
        },
        "./eventarc": {
          types: "./lib/eventarc/index.d.ts",
          require: "./lib/eventarc/index.js",
          import: "./lib/esm/eventarc/index.js"
        },
        "./extensions": {
          types: "./lib/extensions/index.d.ts",
          require: "./lib/extensions/index.js",
          import: "./lib/esm/extensions/index.js"
        },
        "./firestore": {
          types: "./lib/firestore/index.d.ts",
          require: "./lib/firestore/index.js",
          import: "./lib/esm/firestore/index.js"
        },
        "./functions": {
          types: "./lib/functions/index.d.ts",
          require: "./lib/functions/index.js",
          import: "./lib/esm/functions/index.js"
        },
        "./installations": {
          types: "./lib/installations/index.d.ts",
          require: "./lib/installations/index.js",
          import: "./lib/esm/installations/index.js"
        },
        "./instance-id": {
          types: "./lib/instance-id/index.d.ts",
          require: "./lib/instance-id/index.js",
          import: "./lib/esm/instance-id/index.js"
        },
        "./machine-learning": {
          types: "./lib/machine-learning/index.d.ts",
          require: "./lib/machine-learning/index.js",
          import: "./lib/esm/machine-learning/index.js"
        },
        "./messaging": {
          types: "./lib/messaging/index.d.ts",
          require: "./lib/messaging/index.js",
          import: "./lib/esm/messaging/index.js"
        },
        "./project-management": {
          types: "./lib/project-management/index.d.ts",
          require: "./lib/project-management/index.js",
          import: "./lib/esm/project-management/index.js"
        },
        "./remote-config": {
          types: "./lib/remote-config/index.d.ts",
          require: "./lib/remote-config/index.js",
          import: "./lib/esm/remote-config/index.js"
        },
        "./security-rules": {
          types: "./lib/security-rules/index.d.ts",
          require: "./lib/security-rules/index.js",
          import: "./lib/esm/security-rules/index.js"
        },
        "./storage": {
          types: "./lib/storage/index.d.ts",
          require: "./lib/storage/index.js",
          import: "./lib/esm/storage/index.js"
        }
      },
      dependencies: {
        "@fastify/busboy": "^2.1.0",
        "@firebase/database-compat": "^1.0.2",
        "@firebase/database-types": "^1.0.0",
        "@types/node": "^20.10.3",
        farmhash: "^3.3.0",
        jsonwebtoken: "^9.0.0",
        "jwks-rsa": "^3.0.1",
        long: "^5.2.3",
        "node-forge": "^1.3.1",
        uuid: "^9.0.0"
      },
      optionalDependencies: {
        "@google-cloud/firestore": "^7.1.0",
        "@google-cloud/storage": "^7.7.0"
      },
      devDependencies: {
        "@firebase/api-documenter": "^0.4.0",
        "@firebase/app-compat": "^0.2.1",
        "@firebase/auth-compat": "^0.4.1",
        "@firebase/auth-types": "^0.12.0",
        "@microsoft/api-extractor": "^7.11.2",
        "@types/bcrypt": "^5.0.0",
        "@types/chai": "^4.0.0",
        "@types/chai-as-promised": "^7.1.0",
        "@types/firebase-token-generator": "^2.0.28",
        "@types/jsonwebtoken": "8.5.1",
        "@types/lodash": "^4.14.104",
        "@types/minimist": "^1.2.2",
        "@types/mocha": "^10.0.0",
        "@types/nock": "^11.1.0",
        "@types/request": "^2.47.0",
        "@types/request-promise": "^4.1.41",
        "@types/sinon": "^17.0.2",
        "@types/sinon-chai": "^3.0.0",
        "@types/uuid": "^9.0.1",
        "@typescript-eslint/eslint-plugin": "^5.62.0",
        "@typescript-eslint/parser": "^5.62.0",
        bcrypt: "^5.0.0",
        chai: "^4.2.0",
        "chai-as-promised": "^7.0.0",
        "chai-exclude": "^2.1.0",
        chalk: "^4.1.1",
        "child-process-promise": "^2.2.1",
        del: "^6.0.0",
        eslint: "^8.12.0",
        "firebase-token-generator": "^2.0.0",
        gulp: "^5.0.0",
        "gulp-filter": "^7.0.0",
        "gulp-header": "^2.0.9",
        "gulp-typescript": "^5.0.1",
        "http-message-parser": "^0.0.34",
        lodash: "^4.17.15",
        minimist: "^1.2.6",
        mocha: "^10.0.0",
        mz: "^2.7.0",
        nock: "^13.0.0",
        "npm-run-all": "^4.1.5",
        nyc: "^15.1.0",
        request: "^2.75.0",
        "request-promise": "^4.1.1",
        "run-sequence": "^2.2.1",
        sinon: "^17.0.1",
        "sinon-chai": "^3.0.0",
        "ts-node": "^10.2.0",
        typescript: "5.1.6",
        yargs: "^17.0.1"
      }
    };
  }
});

// node_modules/firebase-admin/lib/utils/index.js
var require_utils = __commonJS({
  "node_modules/firebase-admin/lib/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseResourceName = exports.transformMillisecondsToSecondsString = exports.generateUpdateMask = exports.formatString = exports.toWebSafeBase64 = exports.findServiceAccountEmail = exports.getExplicitServiceAccountEmail = exports.findProjectId = exports.getExplicitProjectId = exports.addReadonlyGetter = exports.renameProperties = exports.getSdkVersion = void 0;
    var credential_internal_1 = require_credential_internal();
    var validator = require_validator();
    var sdkVersion;
    function getSdkVersion() {
      if (!sdkVersion) {
        const { version: version3 } = require_package();
        sdkVersion = version3;
      }
      return sdkVersion;
    }
    exports.getSdkVersion = getSdkVersion;
    function renameProperties(obj, keyMap) {
      Object.keys(keyMap).forEach((oldKey) => {
        if (oldKey in obj) {
          const newKey = keyMap[oldKey];
          obj[newKey] = obj[oldKey];
          delete obj[oldKey];
        }
      });
    }
    exports.renameProperties = renameProperties;
    function addReadonlyGetter(obj, prop, value) {
      Object.defineProperty(obj, prop, {
        value,
        // Make this property read-only.
        writable: false,
        // Include this property during enumeration of obj's properties.
        enumerable: true
      });
    }
    exports.addReadonlyGetter = addReadonlyGetter;
    function getExplicitProjectId(app) {
      const options = app.options;
      if (validator.isNonEmptyString(options.projectId)) {
        return options.projectId;
      }
      const credential = app.options.credential;
      if (credential instanceof credential_internal_1.ServiceAccountCredential) {
        return credential.projectId;
      }
      const projectId = process.env.GOOGLE_CLOUD_PROJECT || process.env.GCLOUD_PROJECT;
      if (validator.isNonEmptyString(projectId)) {
        return projectId;
      }
      return null;
    }
    exports.getExplicitProjectId = getExplicitProjectId;
    function findProjectId(app) {
      const projectId = getExplicitProjectId(app);
      if (projectId) {
        return Promise.resolve(projectId);
      }
      const credential = app.options.credential;
      if (credential instanceof credential_internal_1.ComputeEngineCredential) {
        return credential.getProjectId();
      }
      return Promise.resolve(null);
    }
    exports.findProjectId = findProjectId;
    function getExplicitServiceAccountEmail(app) {
      const options = app.options;
      if (validator.isNonEmptyString(options.serviceAccountId)) {
        return options.serviceAccountId;
      }
      const credential = app.options.credential;
      if (credential instanceof credential_internal_1.ServiceAccountCredential) {
        return credential.clientEmail;
      }
      return null;
    }
    exports.getExplicitServiceAccountEmail = getExplicitServiceAccountEmail;
    function findServiceAccountEmail(app) {
      const accountId = getExplicitServiceAccountEmail(app);
      if (accountId) {
        return Promise.resolve(accountId);
      }
      const credential = app.options.credential;
      if (credential instanceof credential_internal_1.ComputeEngineCredential) {
        return credential.getServiceAccountEmail();
      }
      return Promise.resolve(null);
    }
    exports.findServiceAccountEmail = findServiceAccountEmail;
    function toWebSafeBase64(data) {
      return data.toString("base64").replace(/\//g, "_").replace(/\+/g, "-");
    }
    exports.toWebSafeBase64 = toWebSafeBase64;
    function formatString(str, params) {
      let formatted = str;
      Object.keys(params || {}).forEach((key) => {
        formatted = formatted.replace(new RegExp("{" + key + "}", "g"), params[key]);
      });
      return formatted;
    }
    exports.formatString = formatString;
    function generateUpdateMask(obj, terminalPaths = [], root = "") {
      const updateMask = [];
      if (!validator.isNonNullObject(obj)) {
        return updateMask;
      }
      for (const key in obj) {
        if (typeof obj[key] !== "undefined") {
          const nextPath = root ? `${root}.${key}` : key;
          if (terminalPaths.indexOf(nextPath) !== -1) {
            updateMask.push(key);
          } else {
            const maskList = generateUpdateMask(obj[key], terminalPaths, nextPath);
            if (maskList.length > 0) {
              maskList.forEach((mask) => {
                updateMask.push(`${key}.${mask}`);
              });
            } else {
              updateMask.push(key);
            }
          }
        }
      }
      return updateMask;
    }
    exports.generateUpdateMask = generateUpdateMask;
    function transformMillisecondsToSecondsString(milliseconds) {
      let duration;
      const seconds = Math.floor(milliseconds / 1e3);
      const nanos = Math.floor((milliseconds - seconds * 1e3) * 1e6);
      if (nanos > 0) {
        let nanoString = nanos.toString();
        while (nanoString.length < 9) {
          nanoString = "0" + nanoString;
        }
        duration = `${seconds}.${nanoString}s`;
      } else {
        duration = `${seconds}s`;
      }
      return duration;
    }
    exports.transformMillisecondsToSecondsString = transformMillisecondsToSecondsString;
    function parseResourceName(resourceName, resourceIdKey) {
      if (!resourceName.includes("/")) {
        return { resourceId: resourceName };
      }
      const CHANNEL_NAME_REGEX = new RegExp(`^(projects/([^/]+)/)?locations/([^/]+)/${resourceIdKey}/([^/]+)$`);
      const match = CHANNEL_NAME_REGEX.exec(resourceName);
      if (match === null) {
        throw new Error("Invalid resource name format.");
      }
      const projectId = match[2];
      const locationId = match[3];
      const resourceId = match[4];
      return { projectId, locationId, resourceId };
    }
    exports.parseResourceName = parseResourceName;
  }
});

// node_modules/firebase-admin/lib/app/firebase-app.js
var require_firebase_app = __commonJS({
  "node_modules/firebase-admin/lib/app/firebase-app.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FirebaseApp = exports.FirebaseAppInternals = void 0;
    var credential_internal_1 = require_credential_internal();
    var validator = require_validator();
    var deep_copy_1 = require_deep_copy();
    var error_1 = require_error();
    var TOKEN_EXPIRY_THRESHOLD_MILLIS = 5 * 60 * 1e3;
    var FirebaseAppInternals = class {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      constructor(credential_) {
        this.credential_ = credential_;
        this.tokenListeners_ = [];
      }
      getToken(forceRefresh = false) {
        if (forceRefresh || this.shouldRefresh()) {
          return this.refreshToken();
        }
        return Promise.resolve(this.cachedToken_);
      }
      getCachedToken() {
        return this.cachedToken_ || null;
      }
      refreshToken() {
        return Promise.resolve(this.credential_.getAccessToken()).then((result) => {
          if (!validator.isNonNullObject(result) || typeof result.expires_in !== "number" || typeof result.access_token !== "string") {
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, `Invalid access token generated: "${JSON.stringify(result)}". Valid access tokens must be an object with the "expires_in" (number) and "access_token" (string) properties.`);
          }
          const token = {
            accessToken: result.access_token,
            expirationTime: Date.now() + result.expires_in * 1e3
          };
          if (!this.cachedToken_ || this.cachedToken_.accessToken !== token.accessToken || this.cachedToken_.expirationTime !== token.expirationTime) {
            this.cachedToken_ = token;
            this.tokenListeners_.forEach((listener) => {
              listener(token.accessToken);
            });
          }
          return token;
        }).catch((error) => {
          let errorMessage = typeof error === "string" ? error : error.message;
          errorMessage = `Credential implementation provided to initializeApp() via the "credential" property failed to fetch a valid Google OAuth2 access token with the following error: "${errorMessage}".`;
          if (errorMessage.indexOf("invalid_grant") !== -1) {
            errorMessage += " There are two likely causes: (1) your server time is not properly synced or (2) your certificate key file has been revoked. To solve (1), re-sync the time on your server. To solve (2), make sure the key ID for your key file is still present at https://console.firebase.google.com/iam-admin/serviceaccounts/project. If not, generate a new key file at https://console.firebase.google.com/project/_/settings/serviceaccounts/adminsdk.";
          }
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);
        });
      }
      shouldRefresh() {
        return !this.cachedToken_ || this.cachedToken_.expirationTime - Date.now() <= TOKEN_EXPIRY_THRESHOLD_MILLIS;
      }
      /**
       * Adds a listener that is called each time a token changes.
       *
       * @param listener - The listener that will be called with each new token.
       */
      addAuthTokenListener(listener) {
        this.tokenListeners_.push(listener);
        if (this.cachedToken_) {
          listener(this.cachedToken_.accessToken);
        }
      }
      /**
       * Removes a token listener.
       *
       * @param listener - The listener to remove.
       */
      removeAuthTokenListener(listener) {
        this.tokenListeners_ = this.tokenListeners_.filter((other) => other !== listener);
      }
    };
    exports.FirebaseAppInternals = FirebaseAppInternals;
    var FirebaseApp2 = class {
      constructor(options, name4, appStore) {
        this.appStore = appStore;
        this.services_ = {};
        this.isDeleted_ = false;
        this.name_ = name4;
        this.options_ = (0, deep_copy_1.deepCopy)(options);
        if (!validator.isNonNullObject(this.options_)) {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, `Invalid Firebase app options passed as the first argument to initializeApp() for the app named "${this.name_}". Options must be a non-null object.`);
        }
        const hasCredential = "credential" in this.options_;
        if (!hasCredential) {
          this.options_.credential = (0, credential_internal_1.getApplicationDefault)(this.options_.httpAgent);
        }
        const credential = this.options_.credential;
        if (typeof credential !== "object" || credential === null || typeof credential.getAccessToken !== "function") {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, `Invalid Firebase app options passed as the first argument to initializeApp() for the app named "${this.name_}". The "credential" property must be an object which implements the Credential interface.`);
        }
        this.INTERNAL = new FirebaseAppInternals(credential);
      }
      /**
       * Returns the name of the FirebaseApp instance.
       *
       * @returns The name of the FirebaseApp instance.
       */
      get name() {
        this.checkDestroyed_();
        return this.name_;
      }
      /**
       * Returns the options for the FirebaseApp instance.
       *
       * @returns The options for the FirebaseApp instance.
       */
      get options() {
        this.checkDestroyed_();
        return (0, deep_copy_1.deepCopy)(this.options_);
      }
      /**
       * @internal
       */
      getOrInitService(name4, init) {
        return this.ensureService_(name4, () => init(this));
      }
      /**
       * Deletes the FirebaseApp instance.
       *
       * @returns An empty Promise fulfilled once the FirebaseApp instance is deleted.
       */
      delete() {
        this.checkDestroyed_();
        this.appStore?.removeApp(this.name);
        return Promise.all(Object.keys(this.services_).map((serviceName) => {
          const service = this.services_[serviceName];
          if (isStateful(service)) {
            return service.delete();
          }
          return Promise.resolve();
        })).then(() => {
          this.services_ = {};
          this.isDeleted_ = true;
        });
      }
      // eslint-disable-next-line @typescript-eslint/naming-convention
      ensureService_(serviceName, initializer) {
        this.checkDestroyed_();
        if (!(serviceName in this.services_)) {
          this.services_[serviceName] = initializer();
        }
        return this.services_[serviceName];
      }
      /**
       * Throws an Error if the FirebaseApp instance has already been deleted.
       */
      // eslint-disable-next-line @typescript-eslint/naming-convention
      checkDestroyed_() {
        if (this.isDeleted_) {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.APP_DELETED, `Firebase app named "${this.name_}" has already been deleted.`);
        }
      }
    };
    exports.FirebaseApp = FirebaseApp2;
    function isStateful(service) {
      return typeof service.delete === "function";
    }
  }
});

// node_modules/firebase-admin/lib/app/lifecycle.js
var require_lifecycle = __commonJS({
  "node_modules/firebase-admin/lib/app/lifecycle.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FIREBASE_CONFIG_VAR = exports.deleteApp = exports.getApps = exports.getApp = exports.initializeApp = exports.defaultAppStore = exports.AppStore = void 0;
    var fs2 = require_fs();
    var validator = require_validator();
    var error_1 = require_error();
    var credential_internal_1 = require_credential_internal();
    var firebase_app_1 = require_firebase_app();
    var DEFAULT_APP_NAME = "[DEFAULT]";
    var AppStore = class {
      constructor() {
        this.appStore = /* @__PURE__ */ new Map();
      }
      initializeApp(options, appName = DEFAULT_APP_NAME) {
        if (typeof options === "undefined") {
          options = loadOptionsFromEnvVar();
          options.credential = (0, credential_internal_1.getApplicationDefault)();
        }
        if (typeof appName !== "string" || appName === "") {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_NAME, `Invalid Firebase app name "${appName}" provided. App name must be a non-empty string.`);
        } else if (this.appStore.has(appName)) {
          if (appName === DEFAULT_APP_NAME) {
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.DUPLICATE_APP, "The default Firebase app already exists. This means you called initializeApp() more than once without providing an app name as the second argument. In most cases you only need to call initializeApp() once. But if you do want to initialize multiple apps, pass a second argument to initializeApp() to give each app a unique name.");
          } else {
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.DUPLICATE_APP, `Firebase app named "${appName}" already exists. This means you called initializeApp() more than once with the same app name as the second argument. Make sure you provide a unique name every time you call initializeApp().`);
          }
        }
        const app = new firebase_app_1.FirebaseApp(options, appName, this);
        this.appStore.set(app.name, app);
        return app;
      }
      getApp(appName = DEFAULT_APP_NAME) {
        if (typeof appName !== "string" || appName === "") {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_NAME, `Invalid Firebase app name "${appName}" provided. App name must be a non-empty string.`);
        } else if (!this.appStore.has(appName)) {
          let errorMessage = appName === DEFAULT_APP_NAME ? "The default Firebase app does not exist. " : `Firebase app named "${appName}" does not exist. `;
          errorMessage += "Make sure you call initializeApp() before using any of the Firebase services.";
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NO_APP, errorMessage);
        }
        return this.appStore.get(appName);
      }
      getApps() {
        return Array.from(this.appStore.values());
      }
      deleteApp(app) {
        if (typeof app !== "object" || app === null || !("options" in app)) {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, "Invalid app argument.");
        }
        const existingApp = getApp2(app.name);
        return existingApp.delete();
      }
      clearAllApps() {
        const promises = [];
        this.getApps().forEach((app) => {
          promises.push(this.deleteApp(app));
        });
        return Promise.all(promises).then();
      }
      /**
       * Removes the specified App instance from the store. This is currently called by the
       * {@link FirebaseApp.delete} method. Can be removed once the app deletion is handled
       * entirely by the {@link deleteApp} top-level function.
       */
      removeApp(appName) {
        this.appStore.delete(appName);
      }
    };
    exports.AppStore = AppStore;
    exports.defaultAppStore = new AppStore();
    function initializeApp2(options, appName = DEFAULT_APP_NAME) {
      return exports.defaultAppStore.initializeApp(options, appName);
    }
    exports.initializeApp = initializeApp2;
    function getApp2(appName = DEFAULT_APP_NAME) {
      return exports.defaultAppStore.getApp(appName);
    }
    exports.getApp = getApp2;
    function getApps2() {
      return exports.defaultAppStore.getApps();
    }
    exports.getApps = getApps2;
    function deleteApp2(app) {
      return exports.defaultAppStore.deleteApp(app);
    }
    exports.deleteApp = deleteApp2;
    exports.FIREBASE_CONFIG_VAR = "FIREBASE_CONFIG";
    function loadOptionsFromEnvVar() {
      const config2 = process.env[exports.FIREBASE_CONFIG_VAR];
      if (!validator.isNonEmptyString(config2)) {
        return {};
      }
      try {
        const contents = config2.startsWith("{") ? config2 : fs2.readFileSync(config2, "utf8");
        return JSON.parse(contents);
      } catch (error) {
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, "Failed to parse app options file: " + error);
      }
    }
  }
});

// node_modules/firebase-admin/lib/app/credential-factory.js
var require_credential_factory = __commonJS({
  "node_modules/firebase-admin/lib/app/credential-factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.clearGlobalAppDefaultCred = exports.refreshToken = exports.cert = exports.applicationDefault = void 0;
    var credential_internal_1 = require_credential_internal();
    var globalAppDefaultCred;
    var globalCertCreds = {};
    var globalRefreshTokenCreds = {};
    function applicationDefault2(httpAgent) {
      if (typeof globalAppDefaultCred === "undefined") {
        globalAppDefaultCred = (0, credential_internal_1.getApplicationDefault)(httpAgent);
      }
      return globalAppDefaultCred;
    }
    exports.applicationDefault = applicationDefault2;
    function cert2(serviceAccountPathOrObject, httpAgent) {
      const stringifiedServiceAccount = JSON.stringify(serviceAccountPathOrObject);
      if (!(stringifiedServiceAccount in globalCertCreds)) {
        globalCertCreds[stringifiedServiceAccount] = new credential_internal_1.ServiceAccountCredential(serviceAccountPathOrObject, httpAgent);
      }
      return globalCertCreds[stringifiedServiceAccount];
    }
    exports.cert = cert2;
    function refreshToken2(refreshTokenPathOrObject, httpAgent) {
      const stringifiedRefreshToken = JSON.stringify(refreshTokenPathOrObject);
      if (!(stringifiedRefreshToken in globalRefreshTokenCreds)) {
        globalRefreshTokenCreds[stringifiedRefreshToken] = new credential_internal_1.RefreshTokenCredential(refreshTokenPathOrObject, httpAgent);
      }
      return globalRefreshTokenCreds[stringifiedRefreshToken];
    }
    exports.refreshToken = refreshToken2;
    function clearGlobalAppDefaultCred() {
      globalAppDefaultCred = void 0;
    }
    exports.clearGlobalAppDefaultCred = clearGlobalAppDefaultCred;
  }
});

// node_modules/firebase-admin/lib/app/index.js
var require_app = __commonJS({
  "node_modules/firebase-admin/lib/app/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SDK_VERSION = exports.refreshToken = exports.cert = exports.applicationDefault = exports.deleteApp = exports.getApps = exports.getApp = exports.initializeApp = void 0;
    var utils_1 = require_utils();
    var lifecycle_1 = require_lifecycle();
    Object.defineProperty(exports, "initializeApp", { enumerable: true, get: function() {
      return lifecycle_1.initializeApp;
    } });
    Object.defineProperty(exports, "getApp", { enumerable: true, get: function() {
      return lifecycle_1.getApp;
    } });
    Object.defineProperty(exports, "getApps", { enumerable: true, get: function() {
      return lifecycle_1.getApps;
    } });
    Object.defineProperty(exports, "deleteApp", { enumerable: true, get: function() {
      return lifecycle_1.deleteApp;
    } });
    var credential_factory_1 = require_credential_factory();
    Object.defineProperty(exports, "applicationDefault", { enumerable: true, get: function() {
      return credential_factory_1.applicationDefault;
    } });
    Object.defineProperty(exports, "cert", { enumerable: true, get: function() {
      return credential_factory_1.cert;
    } });
    Object.defineProperty(exports, "refreshToken", { enumerable: true, get: function() {
      return credential_factory_1.refreshToken;
    } });
    exports.SDK_VERSION = (0, utils_1.getSdkVersion)();
  }
});

// node_modules/jquery/dist/jquery.js
var require_jquery = __commonJS({
  "node_modules/jquery/dist/jquery.js"(exports, module) {
    (function(global2, factory2) {
      "use strict";
      if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = global2.document ? factory2(global2, true) : function(w2) {
          if (!w2.document) {
            throw new Error("jQuery requires a window with a document");
          }
          return factory2(w2);
        };
      } else {
        factory2(global2);
      }
    })(typeof window !== "undefined" ? window : exports, function(window2, noGlobal) {
      "use strict";
      var arr = [];
      var getProto = Object.getPrototypeOf;
      var slice = arr.slice;
      var flat = arr.flat ? function(array) {
        return arr.flat.call(array);
      } : function(array) {
        return arr.concat.apply([], array);
      };
      var push = arr.push;
      var indexOf = arr.indexOf;
      var class2type = {};
      var toString = class2type.toString;
      var hasOwn = class2type.hasOwnProperty;
      var fnToString = hasOwn.toString;
      var ObjectFunctionString = fnToString.call(Object);
      var support = {};
      var isFunction4 = function isFunction5(obj) {
        return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
      };
      var isWindow = function isWindow2(obj) {
        return obj != null && obj === obj.window;
      };
      var document2 = window2.document;
      var preservedScriptAttributes = {
        type: true,
        src: true,
        nonce: true,
        noModule: true
      };
      function DOMEval(code, node, doc) {
        doc = doc || document2;
        var i2, val, script = doc.createElement("script");
        script.text = code;
        if (node) {
          for (i2 in preservedScriptAttributes) {
            val = node[i2] || node.getAttribute && node.getAttribute(i2);
            if (val) {
              script.setAttribute(i2, val);
            }
          }
        }
        doc.head.appendChild(script).parentNode.removeChild(script);
      }
      function toType(obj) {
        if (obj == null) {
          return obj + "";
        }
        return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
      }
      var version3 = "3.7.1", rhtmlSuffix = /HTML$/i, jQuery2 = function(selector, context) {
        return new jQuery2.fn.init(selector, context);
      };
      jQuery2.fn = jQuery2.prototype = {
        // The current version of jQuery being used
        jquery: version3,
        constructor: jQuery2,
        // The default length of a jQuery object is 0
        length: 0,
        toArray: function() {
          return slice.call(this);
        },
        // Get the Nth element in the matched element set OR
        // Get the whole matched element set as a clean array
        get: function(num) {
          if (num == null) {
            return slice.call(this);
          }
          return num < 0 ? this[num + this.length] : this[num];
        },
        // Take an array of elements and push it onto the stack
        // (returning the new matched element set)
        pushStack: function(elems) {
          var ret = jQuery2.merge(this.constructor(), elems);
          ret.prevObject = this;
          return ret;
        },
        // Execute a callback for every element in the matched set.
        each: function(callback) {
          return jQuery2.each(this, callback);
        },
        map: function(callback) {
          return this.pushStack(jQuery2.map(this, function(elem, i2) {
            return callback.call(elem, i2, elem);
          }));
        },
        slice: function() {
          return this.pushStack(slice.apply(this, arguments));
        },
        first: function() {
          return this.eq(0);
        },
        last: function() {
          return this.eq(-1);
        },
        even: function() {
          return this.pushStack(jQuery2.grep(this, function(_elem, i2) {
            return (i2 + 1) % 2;
          }));
        },
        odd: function() {
          return this.pushStack(jQuery2.grep(this, function(_elem, i2) {
            return i2 % 2;
          }));
        },
        eq: function(i2) {
          var len = this.length, j2 = +i2 + (i2 < 0 ? len : 0);
          return this.pushStack(j2 >= 0 && j2 < len ? [this[j2]] : []);
        },
        end: function() {
          return this.prevObject || this.constructor();
        },
        // For internal use only.
        // Behaves like an Array's method, not like a jQuery method.
        push,
        sort: arr.sort,
        splice: arr.splice
      };
      jQuery2.extend = jQuery2.fn.extend = function() {
        var options, name4, src, copy, copyIsArray, clone, target = arguments[0] || {}, i2 = 1, length = arguments.length, deep = false;
        if (typeof target === "boolean") {
          deep = target;
          target = arguments[i2] || {};
          i2++;
        }
        if (typeof target !== "object" && !isFunction4(target)) {
          target = {};
        }
        if (i2 === length) {
          target = this;
          i2--;
        }
        for (; i2 < length; i2++) {
          if ((options = arguments[i2]) != null) {
            for (name4 in options) {
              copy = options[name4];
              if (name4 === "__proto__" || target === copy) {
                continue;
              }
              if (deep && copy && (jQuery2.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                src = target[name4];
                if (copyIsArray && !Array.isArray(src)) {
                  clone = [];
                } else if (!copyIsArray && !jQuery2.isPlainObject(src)) {
                  clone = {};
                } else {
                  clone = src;
                }
                copyIsArray = false;
                target[name4] = jQuery2.extend(deep, clone, copy);
              } else if (copy !== void 0) {
                target[name4] = copy;
              }
            }
          }
        }
        return target;
      };
      jQuery2.extend({
        // Unique for each copy of jQuery on the page
        expando: "jQuery" + (version3 + Math.random()).replace(/\D/g, ""),
        // Assume jQuery is ready without the ready module
        isReady: true,
        error: function(msg) {
          throw new Error(msg);
        },
        noop: function() {
        },
        isPlainObject: function(obj) {
          var proto, Ctor;
          if (!obj || toString.call(obj) !== "[object Object]") {
            return false;
          }
          proto = getProto(obj);
          if (!proto) {
            return true;
          }
          Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
          return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
        },
        isEmptyObject: function(obj) {
          var name4;
          for (name4 in obj) {
            return false;
          }
          return true;
        },
        // Evaluates a script in a provided context; falls back to the global one
        // if not specified.
        globalEval: function(code, options, doc) {
          DOMEval(code, { nonce: options && options.nonce }, doc);
        },
        each: function(obj, callback) {
          var length, i2 = 0;
          if (isArrayLike2(obj)) {
            length = obj.length;
            for (; i2 < length; i2++) {
              if (callback.call(obj[i2], i2, obj[i2]) === false) {
                break;
              }
            }
          } else {
            for (i2 in obj) {
              if (callback.call(obj[i2], i2, obj[i2]) === false) {
                break;
              }
            }
          }
          return obj;
        },
        // Retrieve the text value of an array of DOM nodes
        text: function(elem) {
          var node, ret = "", i2 = 0, nodeType = elem.nodeType;
          if (!nodeType) {
            while (node = elem[i2++]) {
              ret += jQuery2.text(node);
            }
          }
          if (nodeType === 1 || nodeType === 11) {
            return elem.textContent;
          }
          if (nodeType === 9) {
            return elem.documentElement.textContent;
          }
          if (nodeType === 3 || nodeType === 4) {
            return elem.nodeValue;
          }
          return ret;
        },
        // results is for internal usage only
        makeArray: function(arr2, results) {
          var ret = results || [];
          if (arr2 != null) {
            if (isArrayLike2(Object(arr2))) {
              jQuery2.merge(
                ret,
                typeof arr2 === "string" ? [arr2] : arr2
              );
            } else {
              push.call(ret, arr2);
            }
          }
          return ret;
        },
        inArray: function(elem, arr2, i2) {
          return arr2 == null ? -1 : indexOf.call(arr2, elem, i2);
        },
        isXMLDoc: function(elem) {
          var namespace = elem && elem.namespaceURI, docElem = elem && (elem.ownerDocument || elem).documentElement;
          return !rhtmlSuffix.test(namespace || docElem && docElem.nodeName || "HTML");
        },
        // Support: Android <=4.0 only, PhantomJS 1 only
        // push.apply(_, arraylike) throws on ancient WebKit
        merge: function(first2, second) {
          var len = +second.length, j2 = 0, i2 = first2.length;
          for (; j2 < len; j2++) {
            first2[i2++] = second[j2];
          }
          first2.length = i2;
          return first2;
        },
        grep: function(elems, callback, invert) {
          var callbackInverse, matches = [], i2 = 0, length = elems.length, callbackExpect = !invert;
          for (; i2 < length; i2++) {
            callbackInverse = !callback(elems[i2], i2);
            if (callbackInverse !== callbackExpect) {
              matches.push(elems[i2]);
            }
          }
          return matches;
        },
        // arg is for internal usage only
        map: function(elems, callback, arg) {
          var length, value, i2 = 0, ret = [];
          if (isArrayLike2(elems)) {
            length = elems.length;
            for (; i2 < length; i2++) {
              value = callback(elems[i2], i2, arg);
              if (value != null) {
                ret.push(value);
              }
            }
          } else {
            for (i2 in elems) {
              value = callback(elems[i2], i2, arg);
              if (value != null) {
                ret.push(value);
              }
            }
          }
          return flat(ret);
        },
        // A global GUID counter for objects
        guid: 1,
        // jQuery.support is not used in Core but other projects attach their
        // properties to it so it needs to exist.
        support
      });
      if (typeof Symbol === "function") {
        jQuery2.fn[Symbol.iterator] = arr[Symbol.iterator];
      }
      jQuery2.each(
        "Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
        function(_i2, name4) {
          class2type["[object " + name4 + "]"] = name4.toLowerCase();
        }
      );
      function isArrayLike2(obj) {
        var length = !!obj && "length" in obj && obj.length, type = toType(obj);
        if (isFunction4(obj) || isWindow(obj)) {
          return false;
        }
        return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
      }
      function nodeName(elem, name4) {
        return elem.nodeName && elem.nodeName.toLowerCase() === name4.toLowerCase();
      }
      var pop = arr.pop;
      var sort = arr.sort;
      var splice = arr.splice;
      var whitespace = "[\\x20\\t\\r\\n\\f]";
      var rtrimCSS = new RegExp(
        "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
        "g"
      );
      jQuery2.contains = function(a, b2) {
        var bup = b2 && b2.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && // Support: IE 9 - 11+
        // IE doesn't have `contains` on SVG.
        (a.contains ? a.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      };
      var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;
      function fcssescape(ch, asCodePoint) {
        if (asCodePoint) {
          if (ch === "\0") {
            return "�";
          }
          return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
        }
        return "\\" + ch;
      }
      jQuery2.escapeSelector = function(sel) {
        return (sel + "").replace(rcssescape, fcssescape);
      };
      var preferredDoc = document2, pushNative = push;
      (function() {
        var i2, Expr, outermostContext, sortInput, hasDuplicate, push2 = pushNative, document3, documentElement2, documentIsHTML, rbuggyQSA, matches, expando = jQuery2.expando, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function(a, b2) {
          if (a === b2) {
            hasDuplicate = true;
          }
          return 0;
        }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
        "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
        `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rleadingCombinator = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rdescend = new RegExp(whitespace + "|>"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
          ID: new RegExp("^#(" + identifier + ")"),
          CLASS: new RegExp("^\\.(" + identifier + ")"),
          TAG: new RegExp("^(" + identifier + "|[*])"),
          ATTR: new RegExp("^" + attributes),
          PSEUDO: new RegExp("^" + pseudos),
          CHILD: new RegExp(
            "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)",
            "i"
          ),
          bool: new RegExp("^(?:" + booleans + ")$", "i"),
          // For use in libraries implementing .is()
          // We use this for POS matching in `select`
          needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rquickExpr2 = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"), funescape = function(escape2, nonHex) {
          var high = "0x" + escape2.slice(1) - 65536;
          if (nonHex) {
            return nonHex;
          }
          return high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
        }, unloadHandler = function() {
          setDocument();
        }, inDisabledFieldset = addCombinator(
          function(elem) {
            return elem.disabled === true && nodeName(elem, "fieldset");
          },
          { dir: "parentNode", next: "legend" }
        );
        function safeActiveElement() {
          try {
            return document3.activeElement;
          } catch (err) {
          }
        }
        try {
          push2.apply(
            arr = slice.call(preferredDoc.childNodes),
            preferredDoc.childNodes
          );
          arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
          push2 = {
            apply: function(target, els) {
              pushNative.apply(target, slice.call(els));
            },
            call: function(target) {
              pushNative.apply(target, slice.call(arguments, 1));
            }
          };
        }
        function find2(selector, context, results, seed) {
          var m, i3, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
          results = results || [];
          if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
            return results;
          }
          if (!seed) {
            setDocument(context);
            context = context || document3;
            if (documentIsHTML) {
              if (nodeType !== 11 && (match = rquickExpr2.exec(selector))) {
                if (m = match[1]) {
                  if (nodeType === 9) {
                    if (elem = context.getElementById(m)) {
                      if (elem.id === m) {
                        push2.call(results, elem);
                        return results;
                      }
                    } else {
                      return results;
                    }
                  } else {
                    if (newContext && (elem = newContext.getElementById(m)) && find2.contains(context, elem) && elem.id === m) {
                      push2.call(results, elem);
                      return results;
                    }
                  }
                } else if (match[2]) {
                  push2.apply(results, context.getElementsByTagName(selector));
                  return results;
                } else if ((m = match[3]) && context.getElementsByClassName) {
                  push2.apply(results, context.getElementsByClassName(m));
                  return results;
                }
              }
              if (!nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                newSelector = selector;
                newContext = context;
                if (nodeType === 1 && (rdescend.test(selector) || rleadingCombinator.test(selector))) {
                  newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                  if (newContext != context || !support.scope) {
                    if (nid = context.getAttribute("id")) {
                      nid = jQuery2.escapeSelector(nid);
                    } else {
                      context.setAttribute("id", nid = expando);
                    }
                  }
                  groups = tokenize(selector);
                  i3 = groups.length;
                  while (i3--) {
                    groups[i3] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i3]);
                  }
                  newSelector = groups.join(",");
                }
                try {
                  push2.apply(
                    results,
                    newContext.querySelectorAll(newSelector)
                  );
                  return results;
                } catch (qsaError) {
                  nonnativeSelectorCache(selector, true);
                } finally {
                  if (nid === expando) {
                    context.removeAttribute("id");
                  }
                }
              }
            }
          }
          return select(selector.replace(rtrimCSS, "$1"), context, results, seed);
        }
        function createCache() {
          var keys = [];
          function cache(key, value) {
            if (keys.push(key + " ") > Expr.cacheLength) {
              delete cache[keys.shift()];
            }
            return cache[key + " "] = value;
          }
          return cache;
        }
        function markFunction(fn2) {
          fn2[expando] = true;
          return fn2;
        }
        function assert(fn2) {
          var el = document3.createElement("fieldset");
          try {
            return !!fn2(el);
          } catch (e) {
            return false;
          } finally {
            if (el.parentNode) {
              el.parentNode.removeChild(el);
            }
            el = null;
          }
        }
        function createInputPseudo(type) {
          return function(elem) {
            return nodeName(elem, "input") && elem.type === type;
          };
        }
        function createButtonPseudo(type) {
          return function(elem) {
            return (nodeName(elem, "input") || nodeName(elem, "button")) && elem.type === type;
          };
        }
        function createDisabledPseudo(disabled) {
          return function(elem) {
            if ("form" in elem) {
              if (elem.parentNode && elem.disabled === false) {
                if ("label" in elem) {
                  if ("label" in elem.parentNode) {
                    return elem.parentNode.disabled === disabled;
                  } else {
                    return elem.disabled === disabled;
                  }
                }
                return elem.isDisabled === disabled || // Where there is no isDisabled, check manually
                elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
              }
              return elem.disabled === disabled;
            } else if ("label" in elem) {
              return elem.disabled === disabled;
            }
            return false;
          };
        }
        function createPositionalPseudo(fn2) {
          return markFunction(function(argument) {
            argument = +argument;
            return markFunction(function(seed, matches2) {
              var j2, matchIndexes = fn2([], seed.length, argument), i3 = matchIndexes.length;
              while (i3--) {
                if (seed[j2 = matchIndexes[i3]]) {
                  seed[j2] = !(matches2[j2] = seed[j2]);
                }
              }
            });
          });
        }
        function testContext(context) {
          return context && typeof context.getElementsByTagName !== "undefined" && context;
        }
        function setDocument(node) {
          var subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
          if (doc == document3 || doc.nodeType !== 9 || !doc.documentElement) {
            return document3;
          }
          document3 = doc;
          documentElement2 = document3.documentElement;
          documentIsHTML = !jQuery2.isXMLDoc(document3);
          matches = documentElement2.matches || documentElement2.webkitMatchesSelector || documentElement2.msMatchesSelector;
          if (documentElement2.msMatchesSelector && // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq
          preferredDoc != document3 && (subWindow = document3.defaultView) && subWindow.top !== subWindow) {
            subWindow.addEventListener("unload", unloadHandler);
          }
          support.getById = assert(function(el) {
            documentElement2.appendChild(el).id = jQuery2.expando;
            return !document3.getElementsByName || !document3.getElementsByName(jQuery2.expando).length;
          });
          support.disconnectedMatch = assert(function(el) {
            return matches.call(el, "*");
          });
          support.scope = assert(function() {
            return document3.querySelectorAll(":scope");
          });
          support.cssHas = assert(function() {
            try {
              document3.querySelector(":has(*,:jqfake)");
              return false;
            } catch (e) {
              return true;
            }
          });
          if (support.getById) {
            Expr.filter.ID = function(id2) {
              var attrId = id2.replace(runescape, funescape);
              return function(elem) {
                return elem.getAttribute("id") === attrId;
              };
            };
            Expr.find.ID = function(id2, context) {
              if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                var elem = context.getElementById(id2);
                return elem ? [elem] : [];
              }
            };
          } else {
            Expr.filter.ID = function(id2) {
              var attrId = id2.replace(runescape, funescape);
              return function(elem) {
                var node2 = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                return node2 && node2.value === attrId;
              };
            };
            Expr.find.ID = function(id2, context) {
              if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                var node2, i3, elems, elem = context.getElementById(id2);
                if (elem) {
                  node2 = elem.getAttributeNode("id");
                  if (node2 && node2.value === id2) {
                    return [elem];
                  }
                  elems = context.getElementsByName(id2);
                  i3 = 0;
                  while (elem = elems[i3++]) {
                    node2 = elem.getAttributeNode("id");
                    if (node2 && node2.value === id2) {
                      return [elem];
                    }
                  }
                }
                return [];
              }
            };
          }
          Expr.find.TAG = function(tag, context) {
            if (typeof context.getElementsByTagName !== "undefined") {
              return context.getElementsByTagName(tag);
            } else {
              return context.querySelectorAll(tag);
            }
          };
          Expr.find.CLASS = function(className, context) {
            if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
              return context.getElementsByClassName(className);
            }
          };
          rbuggyQSA = [];
          assert(function(el) {
            var input;
            documentElement2.appendChild(el).innerHTML = "<a id='" + expando + "' href='' disabled='disabled'></a><select id='" + expando + "-\r\\' disabled='disabled'><option selected=''></option></select>";
            if (!el.querySelectorAll("[selected]").length) {
              rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
            }
            if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
              rbuggyQSA.push("~=");
            }
            if (!el.querySelectorAll("a#" + expando + "+*").length) {
              rbuggyQSA.push(".#.+[+~]");
            }
            if (!el.querySelectorAll(":checked").length) {
              rbuggyQSA.push(":checked");
            }
            input = document3.createElement("input");
            input.setAttribute("type", "hidden");
            el.appendChild(input).setAttribute("name", "D");
            documentElement2.appendChild(el).disabled = true;
            if (el.querySelectorAll(":disabled").length !== 2) {
              rbuggyQSA.push(":enabled", ":disabled");
            }
            input = document3.createElement("input");
            input.setAttribute("name", "");
            el.appendChild(input);
            if (!el.querySelectorAll("[name='']").length) {
              rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + `*(?:''|"")`);
            }
          });
          if (!support.cssHas) {
            rbuggyQSA.push(":has");
          }
          rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
          sortOrder = function(a, b2) {
            if (a === b2) {
              hasDuplicate = true;
              return 0;
            }
            var compare = !a.compareDocumentPosition - !b2.compareDocumentPosition;
            if (compare) {
              return compare;
            }
            compare = (a.ownerDocument || a) == (b2.ownerDocument || b2) ? a.compareDocumentPosition(b2) : (
              // Otherwise we know they are disconnected
              1
            );
            if (compare & 1 || !support.sortDetached && b2.compareDocumentPosition(a) === compare) {
              if (a === document3 || a.ownerDocument == preferredDoc && find2.contains(preferredDoc, a)) {
                return -1;
              }
              if (b2 === document3 || b2.ownerDocument == preferredDoc && find2.contains(preferredDoc, b2)) {
                return 1;
              }
              return sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b2) : 0;
            }
            return compare & 4 ? -1 : 1;
          };
          return document3;
        }
        find2.matches = function(expr, elements) {
          return find2(expr, null, null, elements);
        };
        find2.matchesSelector = function(elem, expr) {
          setDocument(elem);
          if (documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
            try {
              var ret = matches.call(elem, expr);
              if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
              // fragment in IE 9
              elem.document && elem.document.nodeType !== 11) {
                return ret;
              }
            } catch (e) {
              nonnativeSelectorCache(expr, true);
            }
          }
          return find2(expr, document3, null, [elem]).length > 0;
        };
        find2.contains = function(context, elem) {
          if ((context.ownerDocument || context) != document3) {
            setDocument(context);
          }
          return jQuery2.contains(context, elem);
        };
        find2.attr = function(elem, name4) {
          if ((elem.ownerDocument || elem) != document3) {
            setDocument(elem);
          }
          var fn2 = Expr.attrHandle[name4.toLowerCase()], val = fn2 && hasOwn.call(Expr.attrHandle, name4.toLowerCase()) ? fn2(elem, name4, !documentIsHTML) : void 0;
          if (val !== void 0) {
            return val;
          }
          return elem.getAttribute(name4);
        };
        find2.error = function(msg) {
          throw new Error("Syntax error, unrecognized expression: " + msg);
        };
        jQuery2.uniqueSort = function(results) {
          var elem, duplicates = [], j2 = 0, i3 = 0;
          hasDuplicate = !support.sortStable;
          sortInput = !support.sortStable && slice.call(results, 0);
          sort.call(results, sortOrder);
          if (hasDuplicate) {
            while (elem = results[i3++]) {
              if (elem === results[i3]) {
                j2 = duplicates.push(i3);
              }
            }
            while (j2--) {
              splice.call(results, duplicates[j2], 1);
            }
          }
          sortInput = null;
          return results;
        };
        jQuery2.fn.uniqueSort = function() {
          return this.pushStack(jQuery2.uniqueSort(slice.apply(this)));
        };
        Expr = jQuery2.expr = {
          // Can be adjusted by the user
          cacheLength: 50,
          createPseudo: markFunction,
          match: matchExpr,
          attrHandle: {},
          find: {},
          relative: {
            ">": { dir: "parentNode", first: true },
            " ": { dir: "parentNode" },
            "+": { dir: "previousSibling", first: true },
            "~": { dir: "previousSibling" }
          },
          preFilter: {
            ATTR: function(match) {
              match[1] = match[1].replace(runescape, funescape);
              match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
              if (match[2] === "~=") {
                match[3] = " " + match[3] + " ";
              }
              return match.slice(0, 4);
            },
            CHILD: function(match) {
              match[1] = match[1].toLowerCase();
              if (match[1].slice(0, 3) === "nth") {
                if (!match[3]) {
                  find2.error(match[0]);
                }
                match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                match[5] = +(match[7] + match[8] || match[3] === "odd");
              } else if (match[3]) {
                find2.error(match[0]);
              }
              return match;
            },
            PSEUDO: function(match) {
              var excess, unquoted = !match[6] && match[2];
              if (matchExpr.CHILD.test(match[0])) {
                return null;
              }
              if (match[3]) {
                match[2] = match[4] || match[5] || "";
              } else if (unquoted && rpseudo.test(unquoted) && // Get excess from tokenize (recursively)
              (excess = tokenize(unquoted, true)) && // advance to the next closing parenthesis
              (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                match[0] = match[0].slice(0, excess);
                match[2] = unquoted.slice(0, excess);
              }
              return match.slice(0, 3);
            }
          },
          filter: {
            TAG: function(nodeNameSelector) {
              var expectedNodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
              return nodeNameSelector === "*" ? function() {
                return true;
              } : function(elem) {
                return nodeName(elem, expectedNodeName);
              };
            },
            CLASS: function(className) {
              var pattern = classCache[className + " "];
              return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                return pattern.test(
                  typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || ""
                );
              });
            },
            ATTR: function(name4, operator, check) {
              return function(elem) {
                var result = find2.attr(elem, name4);
                if (result == null) {
                  return operator === "!=";
                }
                if (!operator) {
                  return true;
                }
                result += "";
                if (operator === "=") {
                  return result === check;
                }
                if (operator === "!=") {
                  return result !== check;
                }
                if (operator === "^=") {
                  return check && result.indexOf(check) === 0;
                }
                if (operator === "*=") {
                  return check && result.indexOf(check) > -1;
                }
                if (operator === "$=") {
                  return check && result.slice(-check.length) === check;
                }
                if (operator === "~=") {
                  return (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1;
                }
                if (operator === "|=") {
                  return result === check || result.slice(0, check.length + 1) === check + "-";
                }
                return false;
              };
            },
            CHILD: function(type, what, _argument, first2, last) {
              var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
              return first2 === 1 && last === 0 ? (
                // Shortcut for :nth-*(n)
                function(elem) {
                  return !!elem.parentNode;
                }
              ) : function(elem, _context, xml) {
                var cache, outerCache, node, nodeIndex, start2, dir2 = simple !== forward ? "nextSibling" : "previousSibling", parent2 = elem.parentNode, name4 = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                if (parent2) {
                  if (simple) {
                    while (dir2) {
                      node = elem;
                      while (node = node[dir2]) {
                        if (ofType ? nodeName(node, name4) : node.nodeType === 1) {
                          return false;
                        }
                      }
                      start2 = dir2 = type === "only" && !start2 && "nextSibling";
                    }
                    return true;
                  }
                  start2 = [forward ? parent2.firstChild : parent2.lastChild];
                  if (forward && useCache) {
                    outerCache = parent2[expando] || (parent2[expando] = {});
                    cache = outerCache[type] || [];
                    nodeIndex = cache[0] === dirruns && cache[1];
                    diff = nodeIndex && cache[2];
                    node = nodeIndex && parent2.childNodes[nodeIndex];
                    while (node = ++nodeIndex && node && node[dir2] || // Fallback to seeking `elem` from the start
                    (diff = nodeIndex = 0) || start2.pop()) {
                      if (node.nodeType === 1 && ++diff && node === elem) {
                        outerCache[type] = [dirruns, nodeIndex, diff];
                        break;
                      }
                    }
                  } else {
                    if (useCache) {
                      outerCache = elem[expando] || (elem[expando] = {});
                      cache = outerCache[type] || [];
                      nodeIndex = cache[0] === dirruns && cache[1];
                      diff = nodeIndex;
                    }
                    if (diff === false) {
                      while (node = ++nodeIndex && node && node[dir2] || (diff = nodeIndex = 0) || start2.pop()) {
                        if ((ofType ? nodeName(node, name4) : node.nodeType === 1) && ++diff) {
                          if (useCache) {
                            outerCache = node[expando] || (node[expando] = {});
                            outerCache[type] = [dirruns, diff];
                          }
                          if (node === elem) {
                            break;
                          }
                        }
                      }
                    }
                  }
                  diff -= last;
                  return diff === first2 || diff % first2 === 0 && diff / first2 >= 0;
                }
              };
            },
            PSEUDO: function(pseudo, argument) {
              var args, fn2 = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || find2.error("unsupported pseudo: " + pseudo);
              if (fn2[expando]) {
                return fn2(argument);
              }
              if (fn2.length > 1) {
                args = [pseudo, pseudo, "", argument];
                return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches2) {
                  var idx, matched = fn2(seed, argument), i3 = matched.length;
                  while (i3--) {
                    idx = indexOf.call(seed, matched[i3]);
                    seed[idx] = !(matches2[idx] = matched[i3]);
                  }
                }) : function(elem) {
                  return fn2(elem, 0, args);
                };
              }
              return fn2;
            }
          },
          pseudos: {
            // Potentially complex pseudos
            not: markFunction(function(selector) {
              var input = [], results = [], matcher = compile(selector.replace(rtrimCSS, "$1"));
              return matcher[expando] ? markFunction(function(seed, matches2, _context, xml) {
                var elem, unmatched = matcher(seed, null, xml, []), i3 = seed.length;
                while (i3--) {
                  if (elem = unmatched[i3]) {
                    seed[i3] = !(matches2[i3] = elem);
                  }
                }
              }) : function(elem, _context, xml) {
                input[0] = elem;
                matcher(input, null, xml, results);
                input[0] = null;
                return !results.pop();
              };
            }),
            has: markFunction(function(selector) {
              return function(elem) {
                return find2(selector, elem).length > 0;
              };
            }),
            contains: markFunction(function(text) {
              text = text.replace(runescape, funescape);
              return function(elem) {
                return (elem.textContent || jQuery2.text(elem)).indexOf(text) > -1;
              };
            }),
            // "Whether an element is represented by a :lang() selector
            // is based solely on the element's language value
            // being equal to the identifier C,
            // or beginning with the identifier C immediately followed by "-".
            // The matching of C against the element's language value is performed case-insensitively.
            // The identifier C does not have to be a valid language name."
            // https://www.w3.org/TR/selectors/#lang-pseudo
            lang: markFunction(function(lang) {
              if (!ridentifier.test(lang || "")) {
                find2.error("unsupported lang: " + lang);
              }
              lang = lang.replace(runescape, funescape).toLowerCase();
              return function(elem) {
                var elemLang;
                do {
                  if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                    elemLang = elemLang.toLowerCase();
                    return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                  }
                } while ((elem = elem.parentNode) && elem.nodeType === 1);
                return false;
              };
            }),
            // Miscellaneous
            target: function(elem) {
              var hash = window2.location && window2.location.hash;
              return hash && hash.slice(1) === elem.id;
            },
            root: function(elem) {
              return elem === documentElement2;
            },
            focus: function(elem) {
              return elem === safeActiveElement() && document3.hasFocus() && !!(elem.type || elem.href || ~elem.tabIndex);
            },
            // Boolean properties
            enabled: createDisabledPseudo(false),
            disabled: createDisabledPseudo(true),
            checked: function(elem) {
              return nodeName(elem, "input") && !!elem.checked || nodeName(elem, "option") && !!elem.selected;
            },
            selected: function(elem) {
              if (elem.parentNode) {
                elem.parentNode.selectedIndex;
              }
              return elem.selected === true;
            },
            // Contents
            empty: function(elem) {
              for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                if (elem.nodeType < 6) {
                  return false;
                }
              }
              return true;
            },
            parent: function(elem) {
              return !Expr.pseudos.empty(elem);
            },
            // Element/input types
            header: function(elem) {
              return rheader.test(elem.nodeName);
            },
            input: function(elem) {
              return rinputs.test(elem.nodeName);
            },
            button: function(elem) {
              return nodeName(elem, "input") && elem.type === "button" || nodeName(elem, "button");
            },
            text: function(elem) {
              var attr;
              return nodeName(elem, "input") && elem.type === "text" && // Support: IE <10 only
              // New HTML5 attribute values (e.g., "search") appear
              // with elem.type === "text"
              ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
            },
            // Position-in-collection
            first: createPositionalPseudo(function() {
              return [0];
            }),
            last: createPositionalPseudo(function(_matchIndexes, length) {
              return [length - 1];
            }),
            eq: createPositionalPseudo(function(_matchIndexes, length, argument) {
              return [argument < 0 ? argument + length : argument];
            }),
            even: createPositionalPseudo(function(matchIndexes, length) {
              var i3 = 0;
              for (; i3 < length; i3 += 2) {
                matchIndexes.push(i3);
              }
              return matchIndexes;
            }),
            odd: createPositionalPseudo(function(matchIndexes, length) {
              var i3 = 1;
              for (; i3 < length; i3 += 2) {
                matchIndexes.push(i3);
              }
              return matchIndexes;
            }),
            lt: createPositionalPseudo(function(matchIndexes, length, argument) {
              var i3;
              if (argument < 0) {
                i3 = argument + length;
              } else if (argument > length) {
                i3 = length;
              } else {
                i3 = argument;
              }
              for (; --i3 >= 0; ) {
                matchIndexes.push(i3);
              }
              return matchIndexes;
            }),
            gt: createPositionalPseudo(function(matchIndexes, length, argument) {
              var i3 = argument < 0 ? argument + length : argument;
              for (; ++i3 < length; ) {
                matchIndexes.push(i3);
              }
              return matchIndexes;
            })
          }
        };
        Expr.pseudos.nth = Expr.pseudos.eq;
        for (i2 in { radio: true, checkbox: true, file: true, password: true, image: true }) {
          Expr.pseudos[i2] = createInputPseudo(i2);
        }
        for (i2 in { submit: true, reset: true }) {
          Expr.pseudos[i2] = createButtonPseudo(i2);
        }
        function setFilters() {
        }
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        function tokenize(selector, parseOnly) {
          var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
          if (cached) {
            return parseOnly ? 0 : cached.slice(0);
          }
          soFar = selector;
          groups = [];
          preFilters = Expr.preFilter;
          while (soFar) {
            if (!matched || (match = rcomma.exec(soFar))) {
              if (match) {
                soFar = soFar.slice(match[0].length) || soFar;
              }
              groups.push(tokens = []);
            }
            matched = false;
            if (match = rleadingCombinator.exec(soFar)) {
              matched = match.shift();
              tokens.push({
                value: matched,
                // Cast descendant combinators to space
                type: match[0].replace(rtrimCSS, " ")
              });
              soFar = soFar.slice(matched.length);
            }
            for (type in Expr.filter) {
              if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                matched = match.shift();
                tokens.push({
                  value: matched,
                  type,
                  matches: match
                });
                soFar = soFar.slice(matched.length);
              }
            }
            if (!matched) {
              break;
            }
          }
          if (parseOnly) {
            return soFar.length;
          }
          return soFar ? find2.error(selector) : (
            // Cache the tokens
            tokenCache(selector, groups).slice(0)
          );
        }
        function toSelector(tokens) {
          var i3 = 0, len = tokens.length, selector = "";
          for (; i3 < len; i3++) {
            selector += tokens[i3].value;
          }
          return selector;
        }
        function addCombinator(matcher, combinator, base) {
          var dir2 = combinator.dir, skip = combinator.next, key = skip || dir2, checkNonElements = base && key === "parentNode", doneName = done++;
          return combinator.first ? (
            // Check against closest ancestor/preceding element
            function(elem, context, xml) {
              while (elem = elem[dir2]) {
                if (elem.nodeType === 1 || checkNonElements) {
                  return matcher(elem, context, xml);
                }
              }
              return false;
            }
          ) : (
            // Check against all ancestor/preceding elements
            function(elem, context, xml) {
              var oldCache, outerCache, newCache = [dirruns, doneName];
              if (xml) {
                while (elem = elem[dir2]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    if (matcher(elem, context, xml)) {
                      return true;
                    }
                  }
                }
              } else {
                while (elem = elem[dir2]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    outerCache = elem[expando] || (elem[expando] = {});
                    if (skip && nodeName(elem, skip)) {
                      elem = elem[dir2] || elem;
                    } else if ((oldCache = outerCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                      return newCache[2] = oldCache[2];
                    } else {
                      outerCache[key] = newCache;
                      if (newCache[2] = matcher(elem, context, xml)) {
                        return true;
                      }
                    }
                  }
                }
              }
              return false;
            }
          );
        }
        function elementMatcher(matchers) {
          return matchers.length > 1 ? function(elem, context, xml) {
            var i3 = matchers.length;
            while (i3--) {
              if (!matchers[i3](elem, context, xml)) {
                return false;
              }
            }
            return true;
          } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
          var i3 = 0, len = contexts.length;
          for (; i3 < len; i3++) {
            find2(selector, contexts[i3], results);
          }
          return results;
        }
        function condense(unmatched, map3, filter2, context, xml) {
          var elem, newUnmatched = [], i3 = 0, len = unmatched.length, mapped = map3 != null;
          for (; i3 < len; i3++) {
            if (elem = unmatched[i3]) {
              if (!filter2 || filter2(elem, context, xml)) {
                newUnmatched.push(elem);
                if (mapped) {
                  map3.push(i3);
                }
              }
            }
          }
          return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
          if (postFilter && !postFilter[expando]) {
            postFilter = setMatcher(postFilter);
          }
          if (postFinder && !postFinder[expando]) {
            postFinder = setMatcher(postFinder, postSelector);
          }
          return markFunction(function(seed, results, context, xml) {
            var temp, i3, elem, matcherOut, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(
              selector || "*",
              context.nodeType ? [context] : context,
              []
            ), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems;
            if (matcher) {
              matcherOut = postFinder || (seed ? preFilter : preexisting || postFilter) ? (
                // ...intermediate processing is necessary
                []
              ) : (
                // ...otherwise use results directly
                results
              );
              matcher(matcherIn, matcherOut, context, xml);
            } else {
              matcherOut = matcherIn;
            }
            if (postFilter) {
              temp = condense(matcherOut, postMap);
              postFilter(temp, [], context, xml);
              i3 = temp.length;
              while (i3--) {
                if (elem = temp[i3]) {
                  matcherOut[postMap[i3]] = !(matcherIn[postMap[i3]] = elem);
                }
              }
            }
            if (seed) {
              if (postFinder || preFilter) {
                if (postFinder) {
                  temp = [];
                  i3 = matcherOut.length;
                  while (i3--) {
                    if (elem = matcherOut[i3]) {
                      temp.push(matcherIn[i3] = elem);
                    }
                  }
                  postFinder(null, matcherOut = [], temp, xml);
                }
                i3 = matcherOut.length;
                while (i3--) {
                  if ((elem = matcherOut[i3]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i3]) > -1) {
                    seed[temp] = !(results[temp] = elem);
                  }
                }
              }
            } else {
              matcherOut = condense(
                matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut
              );
              if (postFinder) {
                postFinder(null, results, matcherOut, xml);
              } else {
                push2.apply(results, matcherOut);
              }
            }
          });
        }
        function matcherFromTokens(tokens) {
          var checkContext, matcher, j2, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i3 = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
            return elem === checkContext;
          }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
            return indexOf.call(checkContext, elem) > -1;
          }, implicitRelative, true), matchers = [function(elem, context, xml) {
            var ret = !leadingRelative && (xml || context != outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
            checkContext = null;
            return ret;
          }];
          for (; i3 < len; i3++) {
            if (matcher = Expr.relative[tokens[i3].type]) {
              matchers = [addCombinator(elementMatcher(matchers), matcher)];
            } else {
              matcher = Expr.filter[tokens[i3].type].apply(null, tokens[i3].matches);
              if (matcher[expando]) {
                j2 = ++i3;
                for (; j2 < len; j2++) {
                  if (Expr.relative[tokens[j2].type]) {
                    break;
                  }
                }
                return setMatcher(
                  i3 > 1 && elementMatcher(matchers),
                  i3 > 1 && toSelector(
                    // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                    tokens.slice(0, i3 - 1).concat({ value: tokens[i3 - 2].type === " " ? "*" : "" })
                  ).replace(rtrimCSS, "$1"),
                  matcher,
                  i3 < j2 && matcherFromTokens(tokens.slice(i3, j2)),
                  j2 < len && matcherFromTokens(tokens = tokens.slice(j2)),
                  j2 < len && toSelector(tokens)
                );
              }
              matchers.push(matcher);
            }
          }
          return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
          var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
            var elem, j2, matcher, matchedCount = 0, i3 = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find.TAG("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
            if (outermost) {
              outermostContext = context == document3 || context || outermost;
            }
            for (; i3 !== len && (elem = elems[i3]) != null; i3++) {
              if (byElement && elem) {
                j2 = 0;
                if (!context && elem.ownerDocument != document3) {
                  setDocument(elem);
                  xml = !documentIsHTML;
                }
                while (matcher = elementMatchers[j2++]) {
                  if (matcher(elem, context || document3, xml)) {
                    push2.call(results, elem);
                    break;
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                }
              }
              if (bySet) {
                if (elem = !matcher && elem) {
                  matchedCount--;
                }
                if (seed) {
                  unmatched.push(elem);
                }
              }
            }
            matchedCount += i3;
            if (bySet && i3 !== matchedCount) {
              j2 = 0;
              while (matcher = setMatchers[j2++]) {
                matcher(unmatched, setMatched, context, xml);
              }
              if (seed) {
                if (matchedCount > 0) {
                  while (i3--) {
                    if (!(unmatched[i3] || setMatched[i3])) {
                      setMatched[i3] = pop.call(results);
                    }
                  }
                }
                setMatched = condense(setMatched);
              }
              push2.apply(results, setMatched);
              if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                jQuery2.uniqueSort(results);
              }
            }
            if (outermost) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }
            return unmatched;
          };
          return bySet ? markFunction(superMatcher) : superMatcher;
        }
        function compile(selector, match) {
          var i3, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
          if (!cached) {
            if (!match) {
              match = tokenize(selector);
            }
            i3 = match.length;
            while (i3--) {
              cached = matcherFromTokens(match[i3]);
              if (cached[expando]) {
                setMatchers.push(cached);
              } else {
                elementMatchers.push(cached);
              }
            }
            cached = compilerCache(
              selector,
              matcherFromGroupMatchers(elementMatchers, setMatchers)
            );
            cached.selector = selector;
          }
          return cached;
        }
        function select(selector, context, results, seed) {
          var i3, tokens, token, type, find3, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
          results = results || [];
          if (match.length === 1) {
            tokens = match[0] = match[0].slice(0);
            if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
              context = (Expr.find.ID(
                token.matches[0].replace(runescape, funescape),
                context
              ) || [])[0];
              if (!context) {
                return results;
              } else if (compiled) {
                context = context.parentNode;
              }
              selector = selector.slice(tokens.shift().value.length);
            }
            i3 = matchExpr.needsContext.test(selector) ? 0 : tokens.length;
            while (i3--) {
              token = tokens[i3];
              if (Expr.relative[type = token.type]) {
                break;
              }
              if (find3 = Expr.find[type]) {
                if (seed = find3(
                  token.matches[0].replace(runescape, funescape),
                  rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
                )) {
                  tokens.splice(i3, 1);
                  selector = seed.length && toSelector(tokens);
                  if (!selector) {
                    push2.apply(results, seed);
                    return results;
                  }
                  break;
                }
              }
            }
          }
          (compiled || compile(selector, match))(
            seed,
            context,
            !documentIsHTML,
            results,
            !context || rsibling.test(selector) && testContext(context.parentNode) || context
          );
          return results;
        }
        support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
        setDocument();
        support.sortDetached = assert(function(el) {
          return el.compareDocumentPosition(document3.createElement("fieldset")) & 1;
        });
        jQuery2.find = find2;
        jQuery2.expr[":"] = jQuery2.expr.pseudos;
        jQuery2.unique = jQuery2.uniqueSort;
        find2.compile = compile;
        find2.select = select;
        find2.setDocument = setDocument;
        find2.tokenize = tokenize;
        find2.escape = jQuery2.escapeSelector;
        find2.getText = jQuery2.text;
        find2.isXML = jQuery2.isXMLDoc;
        find2.selectors = jQuery2.expr;
        find2.support = jQuery2.support;
        find2.uniqueSort = jQuery2.uniqueSort;
      })();
      var dir = function(elem, dir2, until) {
        var matched = [], truncate = until !== void 0;
        while ((elem = elem[dir2]) && elem.nodeType !== 9) {
          if (elem.nodeType === 1) {
            if (truncate && jQuery2(elem).is(until)) {
              break;
            }
            matched.push(elem);
          }
        }
        return matched;
      };
      var siblings = function(n2, elem) {
        var matched = [];
        for (; n2; n2 = n2.nextSibling) {
          if (n2.nodeType === 1 && n2 !== elem) {
            matched.push(n2);
          }
        }
        return matched;
      };
      var rneedsContext = jQuery2.expr.match.needsContext;
      var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
      function winnow(elements, qualifier, not) {
        if (isFunction4(qualifier)) {
          return jQuery2.grep(elements, function(elem, i2) {
            return !!qualifier.call(elem, i2, elem) !== not;
          });
        }
        if (qualifier.nodeType) {
          return jQuery2.grep(elements, function(elem) {
            return elem === qualifier !== not;
          });
        }
        if (typeof qualifier !== "string") {
          return jQuery2.grep(elements, function(elem) {
            return indexOf.call(qualifier, elem) > -1 !== not;
          });
        }
        return jQuery2.filter(qualifier, elements, not);
      }
      jQuery2.filter = function(expr, elems, not) {
        var elem = elems[0];
        if (not) {
          expr = ":not(" + expr + ")";
        }
        if (elems.length === 1 && elem.nodeType === 1) {
          return jQuery2.find.matchesSelector(elem, expr) ? [elem] : [];
        }
        return jQuery2.find.matches(expr, jQuery2.grep(elems, function(elem2) {
          return elem2.nodeType === 1;
        }));
      };
      jQuery2.fn.extend({
        find: function(selector) {
          var i2, ret, len = this.length, self2 = this;
          if (typeof selector !== "string") {
            return this.pushStack(jQuery2(selector).filter(function() {
              for (i2 = 0; i2 < len; i2++) {
                if (jQuery2.contains(self2[i2], this)) {
                  return true;
                }
              }
            }));
          }
          ret = this.pushStack([]);
          for (i2 = 0; i2 < len; i2++) {
            jQuery2.find(selector, self2[i2], ret);
          }
          return len > 1 ? jQuery2.uniqueSort(ret) : ret;
        },
        filter: function(selector) {
          return this.pushStack(winnow(this, selector || [], false));
        },
        not: function(selector) {
          return this.pushStack(winnow(this, selector || [], true));
        },
        is: function(selector) {
          return !!winnow(
            this,
            // If this is a positional/relative selector, check membership in the returned set
            // so $("p:first").is("p:last") won't return true for a doc with two "p".
            typeof selector === "string" && rneedsContext.test(selector) ? jQuery2(selector) : selector || [],
            false
          ).length;
        }
      });
      var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init = jQuery2.fn.init = function(selector, context, root) {
        var match, elem;
        if (!selector) {
          return this;
        }
        root = root || rootjQuery;
        if (typeof selector === "string") {
          if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
            match = [null, selector, null];
          } else {
            match = rquickExpr.exec(selector);
          }
          if (match && (match[1] || !context)) {
            if (match[1]) {
              context = context instanceof jQuery2 ? context[0] : context;
              jQuery2.merge(this, jQuery2.parseHTML(
                match[1],
                context && context.nodeType ? context.ownerDocument || context : document2,
                true
              ));
              if (rsingleTag.test(match[1]) && jQuery2.isPlainObject(context)) {
                for (match in context) {
                  if (isFunction4(this[match])) {
                    this[match](context[match]);
                  } else {
                    this.attr(match, context[match]);
                  }
                }
              }
              return this;
            } else {
              elem = document2.getElementById(match[2]);
              if (elem) {
                this[0] = elem;
                this.length = 1;
              }
              return this;
            }
          } else if (!context || context.jquery) {
            return (context || root).find(selector);
          } else {
            return this.constructor(context).find(selector);
          }
        } else if (selector.nodeType) {
          this[0] = selector;
          this.length = 1;
          return this;
        } else if (isFunction4(selector)) {
          return root.ready !== void 0 ? root.ready(selector) : (
            // Execute immediately if ready is not present
            selector(jQuery2)
          );
        }
        return jQuery2.makeArray(selector, this);
      };
      init.prototype = jQuery2.fn;
      rootjQuery = jQuery2(document2);
      var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
      };
      jQuery2.fn.extend({
        has: function(target) {
          var targets = jQuery2(target, this), l = targets.length;
          return this.filter(function() {
            var i2 = 0;
            for (; i2 < l; i2++) {
              if (jQuery2.contains(this, targets[i2])) {
                return true;
              }
            }
          });
        },
        closest: function(selectors, context) {
          var cur, i2 = 0, l = this.length, matched = [], targets = typeof selectors !== "string" && jQuery2(selectors);
          if (!rneedsContext.test(selectors)) {
            for (; i2 < l; i2++) {
              for (cur = this[i2]; cur && cur !== context; cur = cur.parentNode) {
                if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : (
                  // Don't pass non-elements to jQuery#find
                  cur.nodeType === 1 && jQuery2.find.matchesSelector(cur, selectors)
                ))) {
                  matched.push(cur);
                  break;
                }
              }
            }
          }
          return this.pushStack(matched.length > 1 ? jQuery2.uniqueSort(matched) : matched);
        },
        // Determine the position of an element within the set
        index: function(elem) {
          if (!elem) {
            return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
          }
          if (typeof elem === "string") {
            return indexOf.call(jQuery2(elem), this[0]);
          }
          return indexOf.call(
            this,
            // If it receives a jQuery object, the first element is used
            elem.jquery ? elem[0] : elem
          );
        },
        add: function(selector, context) {
          return this.pushStack(
            jQuery2.uniqueSort(
              jQuery2.merge(this.get(), jQuery2(selector, context))
            )
          );
        },
        addBack: function(selector) {
          return this.add(
            selector == null ? this.prevObject : this.prevObject.filter(selector)
          );
        }
      });
      function sibling(cur, dir2) {
        while ((cur = cur[dir2]) && cur.nodeType !== 1) {
        }
        return cur;
      }
      jQuery2.each({
        parent: function(elem) {
          var parent2 = elem.parentNode;
          return parent2 && parent2.nodeType !== 11 ? parent2 : null;
        },
        parents: function(elem) {
          return dir(elem, "parentNode");
        },
        parentsUntil: function(elem, _i2, until) {
          return dir(elem, "parentNode", until);
        },
        next: function(elem) {
          return sibling(elem, "nextSibling");
        },
        prev: function(elem) {
          return sibling(elem, "previousSibling");
        },
        nextAll: function(elem) {
          return dir(elem, "nextSibling");
        },
        prevAll: function(elem) {
          return dir(elem, "previousSibling");
        },
        nextUntil: function(elem, _i2, until) {
          return dir(elem, "nextSibling", until);
        },
        prevUntil: function(elem, _i2, until) {
          return dir(elem, "previousSibling", until);
        },
        siblings: function(elem) {
          return siblings((elem.parentNode || {}).firstChild, elem);
        },
        children: function(elem) {
          return siblings(elem.firstChild);
        },
        contents: function(elem) {
          if (elem.contentDocument != null && // Support: IE 11+
          // <object> elements with no `data` attribute has an object
          // `contentDocument` with a `null` prototype.
          getProto(elem.contentDocument)) {
            return elem.contentDocument;
          }
          if (nodeName(elem, "template")) {
            elem = elem.content || elem;
          }
          return jQuery2.merge([], elem.childNodes);
        }
      }, function(name4, fn2) {
        jQuery2.fn[name4] = function(until, selector) {
          var matched = jQuery2.map(this, fn2, until);
          if (name4.slice(-5) !== "Until") {
            selector = until;
          }
          if (selector && typeof selector === "string") {
            matched = jQuery2.filter(selector, matched);
          }
          if (this.length > 1) {
            if (!guaranteedUnique[name4]) {
              jQuery2.uniqueSort(matched);
            }
            if (rparentsprev.test(name4)) {
              matched.reverse();
            }
          }
          return this.pushStack(matched);
        };
      });
      var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
      function createOptions(options) {
        var object = {};
        jQuery2.each(options.match(rnothtmlwhite) || [], function(_2, flag) {
          object[flag] = true;
        });
        return object;
      }
      jQuery2.Callbacks = function(options) {
        options = typeof options === "string" ? createOptions(options) : jQuery2.extend({}, options);
        var firing, memory, fired, locked, list2 = [], queue2 = [], firingIndex = -1, fire = function() {
          locked = locked || options.once;
          fired = firing = true;
          for (; queue2.length; firingIndex = -1) {
            memory = queue2.shift();
            while (++firingIndex < list2.length) {
              if (list2[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                firingIndex = list2.length;
                memory = false;
              }
            }
          }
          if (!options.memory) {
            memory = false;
          }
          firing = false;
          if (locked) {
            if (memory) {
              list2 = [];
            } else {
              list2 = "";
            }
          }
        }, self2 = {
          // Add a callback or a collection of callbacks to the list
          add: function() {
            if (list2) {
              if (memory && !firing) {
                firingIndex = list2.length - 1;
                queue2.push(memory);
              }
              (function add(args) {
                jQuery2.each(args, function(_2, arg) {
                  if (isFunction4(arg)) {
                    if (!options.unique || !self2.has(arg)) {
                      list2.push(arg);
                    }
                  } else if (arg && arg.length && toType(arg) !== "string") {
                    add(arg);
                  }
                });
              })(arguments);
              if (memory && !firing) {
                fire();
              }
            }
            return this;
          },
          // Remove a callback from the list
          remove: function() {
            jQuery2.each(arguments, function(_2, arg) {
              var index;
              while ((index = jQuery2.inArray(arg, list2, index)) > -1) {
                list2.splice(index, 1);
                if (index <= firingIndex) {
                  firingIndex--;
                }
              }
            });
            return this;
          },
          // Check if a given callback is in the list.
          // If no argument is given, return whether or not list has callbacks attached.
          has: function(fn2) {
            return fn2 ? jQuery2.inArray(fn2, list2) > -1 : list2.length > 0;
          },
          // Remove all callbacks from the list
          empty: function() {
            if (list2) {
              list2 = [];
            }
            return this;
          },
          // Disable .fire and .add
          // Abort any current/pending executions
          // Clear all callbacks and values
          disable: function() {
            locked = queue2 = [];
            list2 = memory = "";
            return this;
          },
          disabled: function() {
            return !list2;
          },
          // Disable .fire
          // Also disable .add unless we have memory (since it would have no effect)
          // Abort any pending executions
          lock: function() {
            locked = queue2 = [];
            if (!memory && !firing) {
              list2 = memory = "";
            }
            return this;
          },
          locked: function() {
            return !!locked;
          },
          // Call all callbacks with the given context and arguments
          fireWith: function(context, args) {
            if (!locked) {
              args = args || [];
              args = [context, args.slice ? args.slice() : args];
              queue2.push(args);
              if (!firing) {
                fire();
              }
            }
            return this;
          },
          // Call all the callbacks with the given arguments
          fire: function() {
            self2.fireWith(this, arguments);
            return this;
          },
          // To know if the callbacks have already been called at least once
          fired: function() {
            return !!fired;
          }
        };
        return self2;
      };
      function Identity(v2) {
        return v2;
      }
      function Thrower(ex) {
        throw ex;
      }
      function adoptValue(value, resolve2, reject, noValue) {
        var method;
        try {
          if (value && isFunction4(method = value.promise)) {
            method.call(value).done(resolve2).fail(reject);
          } else if (value && isFunction4(method = value.then)) {
            method.call(value, resolve2, reject);
          } else {
            resolve2.apply(void 0, [value].slice(noValue));
          }
        } catch (value2) {
          reject.apply(void 0, [value2]);
        }
      }
      jQuery2.extend({
        Deferred: function(func) {
          var tuples = [
            // action, add listener, callbacks,
            // ... .then handlers, argument index, [final state]
            [
              "notify",
              "progress",
              jQuery2.Callbacks("memory"),
              jQuery2.Callbacks("memory"),
              2
            ],
            [
              "resolve",
              "done",
              jQuery2.Callbacks("once memory"),
              jQuery2.Callbacks("once memory"),
              0,
              "resolved"
            ],
            [
              "reject",
              "fail",
              jQuery2.Callbacks("once memory"),
              jQuery2.Callbacks("once memory"),
              1,
              "rejected"
            ]
          ], state = "pending", promise = {
            state: function() {
              return state;
            },
            always: function() {
              deferred.done(arguments).fail(arguments);
              return this;
            },
            "catch": function(fn2) {
              return promise.then(null, fn2);
            },
            // Keep pipe for back-compat
            pipe: function() {
              var fns = arguments;
              return jQuery2.Deferred(function(newDefer) {
                jQuery2.each(tuples, function(_i2, tuple) {
                  var fn2 = isFunction4(fns[tuple[4]]) && fns[tuple[4]];
                  deferred[tuple[1]](function() {
                    var returned = fn2 && fn2.apply(this, arguments);
                    if (returned && isFunction4(returned.promise)) {
                      returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                    } else {
                      newDefer[tuple[0] + "With"](
                        this,
                        fn2 ? [returned] : arguments
                      );
                    }
                  });
                });
                fns = null;
              }).promise();
            },
            then: function(onFulfilled, onRejected, onProgress) {
              var maxDepth = 0;
              function resolve2(depth, deferred2, handler, special) {
                return function() {
                  var that = this, args = arguments, mightThrow = function() {
                    var returned, then;
                    if (depth < maxDepth) {
                      return;
                    }
                    returned = handler.apply(that, args);
                    if (returned === deferred2.promise()) {
                      throw new TypeError("Thenable self-resolution");
                    }
                    then = returned && // Support: Promises/A+ section 2.3.4
                    // https://promisesaplus.com/#point-64
                    // Only check objects and functions for thenability
                    (typeof returned === "object" || typeof returned === "function") && returned.then;
                    if (isFunction4(then)) {
                      if (special) {
                        then.call(
                          returned,
                          resolve2(maxDepth, deferred2, Identity, special),
                          resolve2(maxDepth, deferred2, Thrower, special)
                        );
                      } else {
                        maxDepth++;
                        then.call(
                          returned,
                          resolve2(maxDepth, deferred2, Identity, special),
                          resolve2(maxDepth, deferred2, Thrower, special),
                          resolve2(
                            maxDepth,
                            deferred2,
                            Identity,
                            deferred2.notifyWith
                          )
                        );
                      }
                    } else {
                      if (handler !== Identity) {
                        that = void 0;
                        args = [returned];
                      }
                      (special || deferred2.resolveWith)(that, args);
                    }
                  }, process2 = special ? mightThrow : function() {
                    try {
                      mightThrow();
                    } catch (e) {
                      if (jQuery2.Deferred.exceptionHook) {
                        jQuery2.Deferred.exceptionHook(
                          e,
                          process2.error
                        );
                      }
                      if (depth + 1 >= maxDepth) {
                        if (handler !== Thrower) {
                          that = void 0;
                          args = [e];
                        }
                        deferred2.rejectWith(that, args);
                      }
                    }
                  };
                  if (depth) {
                    process2();
                  } else {
                    if (jQuery2.Deferred.getErrorHook) {
                      process2.error = jQuery2.Deferred.getErrorHook();
                    } else if (jQuery2.Deferred.getStackHook) {
                      process2.error = jQuery2.Deferred.getStackHook();
                    }
                    window2.setTimeout(process2);
                  }
                };
              }
              return jQuery2.Deferred(function(newDefer) {
                tuples[0][3].add(
                  resolve2(
                    0,
                    newDefer,
                    isFunction4(onProgress) ? onProgress : Identity,
                    newDefer.notifyWith
                  )
                );
                tuples[1][3].add(
                  resolve2(
                    0,
                    newDefer,
                    isFunction4(onFulfilled) ? onFulfilled : Identity
                  )
                );
                tuples[2][3].add(
                  resolve2(
                    0,
                    newDefer,
                    isFunction4(onRejected) ? onRejected : Thrower
                  )
                );
              }).promise();
            },
            // Get a promise for this deferred
            // If obj is provided, the promise aspect is added to the object
            promise: function(obj) {
              return obj != null ? jQuery2.extend(obj, promise) : promise;
            }
          }, deferred = {};
          jQuery2.each(tuples, function(i2, tuple) {
            var list2 = tuple[2], stateString = tuple[5];
            promise[tuple[1]] = list2.add;
            if (stateString) {
              list2.add(
                function() {
                  state = stateString;
                },
                // rejected_callbacks.disable
                // fulfilled_callbacks.disable
                tuples[3 - i2][2].disable,
                // rejected_handlers.disable
                // fulfilled_handlers.disable
                tuples[3 - i2][3].disable,
                // progress_callbacks.lock
                tuples[0][2].lock,
                // progress_handlers.lock
                tuples[0][3].lock
              );
            }
            list2.add(tuple[3].fire);
            deferred[tuple[0]] = function() {
              deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments);
              return this;
            };
            deferred[tuple[0] + "With"] = list2.fireWith;
          });
          promise.promise(deferred);
          if (func) {
            func.call(deferred, deferred);
          }
          return deferred;
        },
        // Deferred helper
        when: function(singleValue) {
          var remaining = arguments.length, i2 = remaining, resolveContexts = Array(i2), resolveValues = slice.call(arguments), primary = jQuery2.Deferred(), updateFunc = function(i3) {
            return function(value) {
              resolveContexts[i3] = this;
              resolveValues[i3] = arguments.length > 1 ? slice.call(arguments) : value;
              if (!--remaining) {
                primary.resolveWith(resolveContexts, resolveValues);
              }
            };
          };
          if (remaining <= 1) {
            adoptValue(
              singleValue,
              primary.done(updateFunc(i2)).resolve,
              primary.reject,
              !remaining
            );
            if (primary.state() === "pending" || isFunction4(resolveValues[i2] && resolveValues[i2].then)) {
              return primary.then();
            }
          }
          while (i2--) {
            adoptValue(resolveValues[i2], updateFunc(i2), primary.reject);
          }
          return primary.promise();
        }
      });
      var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
      jQuery2.Deferred.exceptionHook = function(error, asyncError) {
        if (window2.console && window2.console.warn && error && rerrorNames.test(error.name)) {
          window2.console.warn(
            "jQuery.Deferred exception: " + error.message,
            error.stack,
            asyncError
          );
        }
      };
      jQuery2.readyException = function(error) {
        window2.setTimeout(function() {
          throw error;
        });
      };
      var readyList = jQuery2.Deferred();
      jQuery2.fn.ready = function(fn2) {
        readyList.then(fn2).catch(function(error) {
          jQuery2.readyException(error);
        });
        return this;
      };
      jQuery2.extend({
        // Is the DOM ready to be used? Set to true once it occurs.
        isReady: false,
        // A counter to track how many items to wait for before
        // the ready event fires. See trac-6781
        readyWait: 1,
        // Handle when the DOM is ready
        ready: function(wait) {
          if (wait === true ? --jQuery2.readyWait : jQuery2.isReady) {
            return;
          }
          jQuery2.isReady = true;
          if (wait !== true && --jQuery2.readyWait > 0) {
            return;
          }
          readyList.resolveWith(document2, [jQuery2]);
        }
      });
      jQuery2.ready.then = readyList.then;
      function completed() {
        document2.removeEventListener("DOMContentLoaded", completed);
        window2.removeEventListener("load", completed);
        jQuery2.ready();
      }
      if (document2.readyState === "complete" || document2.readyState !== "loading" && !document2.documentElement.doScroll) {
        window2.setTimeout(jQuery2.ready);
      } else {
        document2.addEventListener("DOMContentLoaded", completed);
        window2.addEventListener("load", completed);
      }
      var access = function(elems, fn2, key, value, chainable, emptyGet, raw) {
        var i2 = 0, len = elems.length, bulk = key == null;
        if (toType(key) === "object") {
          chainable = true;
          for (i2 in key) {
            access(elems, fn2, i2, key[i2], true, emptyGet, raw);
          }
        } else if (value !== void 0) {
          chainable = true;
          if (!isFunction4(value)) {
            raw = true;
          }
          if (bulk) {
            if (raw) {
              fn2.call(elems, value);
              fn2 = null;
            } else {
              bulk = fn2;
              fn2 = function(elem, _key, value2) {
                return bulk.call(jQuery2(elem), value2);
              };
            }
          }
          if (fn2) {
            for (; i2 < len; i2++) {
              fn2(
                elems[i2],
                key,
                raw ? value : value.call(elems[i2], i2, fn2(elems[i2], key))
              );
            }
          }
        }
        if (chainable) {
          return elems;
        }
        if (bulk) {
          return fn2.call(elems);
        }
        return len ? fn2(elems[0], key) : emptyGet;
      };
      var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
      function fcamelCase(_all, letter) {
        return letter.toUpperCase();
      }
      function camelCase(string) {
        return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
      }
      var acceptData = function(owner) {
        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
      };
      function Data() {
        this.expando = jQuery2.expando + Data.uid++;
      }
      Data.uid = 1;
      Data.prototype = {
        cache: function(owner) {
          var value = owner[this.expando];
          if (!value) {
            value = {};
            if (acceptData(owner)) {
              if (owner.nodeType) {
                owner[this.expando] = value;
              } else {
                Object.defineProperty(owner, this.expando, {
                  value,
                  configurable: true
                });
              }
            }
          }
          return value;
        },
        set: function(owner, data, value) {
          var prop, cache = this.cache(owner);
          if (typeof data === "string") {
            cache[camelCase(data)] = value;
          } else {
            for (prop in data) {
              cache[camelCase(prop)] = data[prop];
            }
          }
          return cache;
        },
        get: function(owner, key) {
          return key === void 0 ? this.cache(owner) : (
            // Always use camelCase key (gh-2257)
            owner[this.expando] && owner[this.expando][camelCase(key)]
          );
        },
        access: function(owner, key, value) {
          if (key === void 0 || key && typeof key === "string" && value === void 0) {
            return this.get(owner, key);
          }
          this.set(owner, key, value);
          return value !== void 0 ? value : key;
        },
        remove: function(owner, key) {
          var i2, cache = owner[this.expando];
          if (cache === void 0) {
            return;
          }
          if (key !== void 0) {
            if (Array.isArray(key)) {
              key = key.map(camelCase);
            } else {
              key = camelCase(key);
              key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
            }
            i2 = key.length;
            while (i2--) {
              delete cache[key[i2]];
            }
          }
          if (key === void 0 || jQuery2.isEmptyObject(cache)) {
            if (owner.nodeType) {
              owner[this.expando] = void 0;
            } else {
              delete owner[this.expando];
            }
          }
        },
        hasData: function(owner) {
          var cache = owner[this.expando];
          return cache !== void 0 && !jQuery2.isEmptyObject(cache);
        }
      };
      var dataPriv = new Data();
      var dataUser = new Data();
      var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
      function getData(data) {
        if (data === "true") {
          return true;
        }
        if (data === "false") {
          return false;
        }
        if (data === "null") {
          return null;
        }
        if (data === +data + "") {
          return +data;
        }
        if (rbrace.test(data)) {
          return JSON.parse(data);
        }
        return data;
      }
      function dataAttr(elem, key, data) {
        var name4;
        if (data === void 0 && elem.nodeType === 1) {
          name4 = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
          data = elem.getAttribute(name4);
          if (typeof data === "string") {
            try {
              data = getData(data);
            } catch (e) {
            }
            dataUser.set(elem, key, data);
          } else {
            data = void 0;
          }
        }
        return data;
      }
      jQuery2.extend({
        hasData: function(elem) {
          return dataUser.hasData(elem) || dataPriv.hasData(elem);
        },
        data: function(elem, name4, data) {
          return dataUser.access(elem, name4, data);
        },
        removeData: function(elem, name4) {
          dataUser.remove(elem, name4);
        },
        // TODO: Now that all calls to _data and _removeData have been replaced
        // with direct calls to dataPriv methods, these can be deprecated.
        _data: function(elem, name4, data) {
          return dataPriv.access(elem, name4, data);
        },
        _removeData: function(elem, name4) {
          dataPriv.remove(elem, name4);
        }
      });
      jQuery2.fn.extend({
        data: function(key, value) {
          var i2, name4, data, elem = this[0], attrs = elem && elem.attributes;
          if (key === void 0) {
            if (this.length) {
              data = dataUser.get(elem);
              if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                i2 = attrs.length;
                while (i2--) {
                  if (attrs[i2]) {
                    name4 = attrs[i2].name;
                    if (name4.indexOf("data-") === 0) {
                      name4 = camelCase(name4.slice(5));
                      dataAttr(elem, name4, data[name4]);
                    }
                  }
                }
                dataPriv.set(elem, "hasDataAttrs", true);
              }
            }
            return data;
          }
          if (typeof key === "object") {
            return this.each(function() {
              dataUser.set(this, key);
            });
          }
          return access(this, function(value2) {
            var data2;
            if (elem && value2 === void 0) {
              data2 = dataUser.get(elem, key);
              if (data2 !== void 0) {
                return data2;
              }
              data2 = dataAttr(elem, key);
              if (data2 !== void 0) {
                return data2;
              }
              return;
            }
            this.each(function() {
              dataUser.set(this, key, value2);
            });
          }, null, value, arguments.length > 1, null, true);
        },
        removeData: function(key) {
          return this.each(function() {
            dataUser.remove(this, key);
          });
        }
      });
      jQuery2.extend({
        queue: function(elem, type, data) {
          var queue2;
          if (elem) {
            type = (type || "fx") + "queue";
            queue2 = dataPriv.get(elem, type);
            if (data) {
              if (!queue2 || Array.isArray(data)) {
                queue2 = dataPriv.access(elem, type, jQuery2.makeArray(data));
              } else {
                queue2.push(data);
              }
            }
            return queue2 || [];
          }
        },
        dequeue: function(elem, type) {
          type = type || "fx";
          var queue2 = jQuery2.queue(elem, type), startLength = queue2.length, fn2 = queue2.shift(), hooks = jQuery2._queueHooks(elem, type), next = function() {
            jQuery2.dequeue(elem, type);
          };
          if (fn2 === "inprogress") {
            fn2 = queue2.shift();
            startLength--;
          }
          if (fn2) {
            if (type === "fx") {
              queue2.unshift("inprogress");
            }
            delete hooks.stop;
            fn2.call(elem, next, hooks);
          }
          if (!startLength && hooks) {
            hooks.empty.fire();
          }
        },
        // Not public - generate a queueHooks object, or return the current one
        _queueHooks: function(elem, type) {
          var key = type + "queueHooks";
          return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
            empty: jQuery2.Callbacks("once memory").add(function() {
              dataPriv.remove(elem, [type + "queue", key]);
            })
          });
        }
      });
      jQuery2.fn.extend({
        queue: function(type, data) {
          var setter = 2;
          if (typeof type !== "string") {
            data = type;
            type = "fx";
            setter--;
          }
          if (arguments.length < setter) {
            return jQuery2.queue(this[0], type);
          }
          return data === void 0 ? this : this.each(function() {
            var queue2 = jQuery2.queue(this, type, data);
            jQuery2._queueHooks(this, type);
            if (type === "fx" && queue2[0] !== "inprogress") {
              jQuery2.dequeue(this, type);
            }
          });
        },
        dequeue: function(type) {
          return this.each(function() {
            jQuery2.dequeue(this, type);
          });
        },
        clearQueue: function(type) {
          return this.queue(type || "fx", []);
        },
        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function(type, obj) {
          var tmp, count = 1, defer2 = jQuery2.Deferred(), elements = this, i2 = this.length, resolve2 = function() {
            if (!--count) {
              defer2.resolveWith(elements, [elements]);
            }
          };
          if (typeof type !== "string") {
            obj = type;
            type = void 0;
          }
          type = type || "fx";
          while (i2--) {
            tmp = dataPriv.get(elements[i2], type + "queueHooks");
            if (tmp && tmp.empty) {
              count++;
              tmp.empty.add(resolve2);
            }
          }
          resolve2();
          return defer2.promise(obj);
        }
      });
      var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
      var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
      var cssExpand = ["Top", "Right", "Bottom", "Left"];
      var documentElement = document2.documentElement;
      var isAttached = function(elem) {
        return jQuery2.contains(elem.ownerDocument, elem);
      }, composed = { composed: true };
      if (documentElement.getRootNode) {
        isAttached = function(elem) {
          return jQuery2.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
        };
      }
      var isHiddenWithinTree = function(elem, el) {
        elem = el || elem;
        return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
        // Support: Firefox <=43 - 45
        // Disconnected elements can have computed display: none, so first confirm that elem is
        // in the document.
        isAttached(elem) && jQuery2.css(elem, "display") === "none";
      };
      function adjustCSS(elem, prop, valueParts, tween) {
        var adjusted, scale, maxIterations = 20, currentValue = tween ? function() {
          return tween.cur();
        } : function() {
          return jQuery2.css(elem, prop, "");
        }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery2.cssNumber[prop] ? "" : "px"), initialInUnit = elem.nodeType && (jQuery2.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery2.css(elem, prop));
        if (initialInUnit && initialInUnit[3] !== unit) {
          initial = initial / 2;
          unit = unit || initialInUnit[3];
          initialInUnit = +initial || 1;
          while (maxIterations--) {
            jQuery2.style(elem, prop, initialInUnit + unit);
            if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
              maxIterations = 0;
            }
            initialInUnit = initialInUnit / scale;
          }
          initialInUnit = initialInUnit * 2;
          jQuery2.style(elem, prop, initialInUnit + unit);
          valueParts = valueParts || [];
        }
        if (valueParts) {
          initialInUnit = +initialInUnit || +initial || 0;
          adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
          if (tween) {
            tween.unit = unit;
            tween.start = initialInUnit;
            tween.end = adjusted;
          }
        }
        return adjusted;
      }
      var defaultDisplayMap = {};
      function getDefaultDisplay(elem) {
        var temp, doc = elem.ownerDocument, nodeName2 = elem.nodeName, display = defaultDisplayMap[nodeName2];
        if (display) {
          return display;
        }
        temp = doc.body.appendChild(doc.createElement(nodeName2));
        display = jQuery2.css(temp, "display");
        temp.parentNode.removeChild(temp);
        if (display === "none") {
          display = "block";
        }
        defaultDisplayMap[nodeName2] = display;
        return display;
      }
      function showHide(elements, show) {
        var display, elem, values = [], index = 0, length = elements.length;
        for (; index < length; index++) {
          elem = elements[index];
          if (!elem.style) {
            continue;
          }
          display = elem.style.display;
          if (show) {
            if (display === "none") {
              values[index] = dataPriv.get(elem, "display") || null;
              if (!values[index]) {
                elem.style.display = "";
              }
            }
            if (elem.style.display === "" && isHiddenWithinTree(elem)) {
              values[index] = getDefaultDisplay(elem);
            }
          } else {
            if (display !== "none") {
              values[index] = "none";
              dataPriv.set(elem, "display", display);
            }
          }
        }
        for (index = 0; index < length; index++) {
          if (values[index] != null) {
            elements[index].style.display = values[index];
          }
        }
        return elements;
      }
      jQuery2.fn.extend({
        show: function() {
          return showHide(this, true);
        },
        hide: function() {
          return showHide(this);
        },
        toggle: function(state) {
          if (typeof state === "boolean") {
            return state ? this.show() : this.hide();
          }
          return this.each(function() {
            if (isHiddenWithinTree(this)) {
              jQuery2(this).show();
            } else {
              jQuery2(this).hide();
            }
          });
        }
      });
      var rcheckableType = /^(?:checkbox|radio)$/i;
      var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
      var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
      (function() {
        var fragment = document2.createDocumentFragment(), div = fragment.appendChild(document2.createElement("div")), input = document2.createElement("input");
        input.setAttribute("type", "radio");
        input.setAttribute("checked", "checked");
        input.setAttribute("name", "t");
        div.appendChild(input);
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
        div.innerHTML = "<option></option>";
        support.option = !!div.lastChild;
      })();
      var wrapMap = {
        // XHTML parsers do not magically insert elements in the
        // same way that tag soup parsers do. So we cannot shorten
        // this by omitting <tbody> or other required elements.
        thead: [1, "<table>", "</table>"],
        col: [2, "<table><colgroup>", "</colgroup></table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
        _default: [0, "", ""]
      };
      wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
      wrapMap.th = wrapMap.td;
      if (!support.option) {
        wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
      }
      function getAll(context, tag) {
        var ret;
        if (typeof context.getElementsByTagName !== "undefined") {
          ret = context.getElementsByTagName(tag || "*");
        } else if (typeof context.querySelectorAll !== "undefined") {
          ret = context.querySelectorAll(tag || "*");
        } else {
          ret = [];
        }
        if (tag === void 0 || tag && nodeName(context, tag)) {
          return jQuery2.merge([context], ret);
        }
        return ret;
      }
      function setGlobalEval(elems, refElements) {
        var i2 = 0, l = elems.length;
        for (; i2 < l; i2++) {
          dataPriv.set(
            elems[i2],
            "globalEval",
            !refElements || dataPriv.get(refElements[i2], "globalEval")
          );
        }
      }
      var rhtml = /<|&#?\w+;/;
      function buildFragment(elems, context, scripts, selection, ignored) {
        var elem, tmp, tag, wrap, attached, j2, fragment = context.createDocumentFragment(), nodes = [], i2 = 0, l = elems.length;
        for (; i2 < l; i2++) {
          elem = elems[i2];
          if (elem || elem === 0) {
            if (toType(elem) === "object") {
              jQuery2.merge(nodes, elem.nodeType ? [elem] : elem);
            } else if (!rhtml.test(elem)) {
              nodes.push(context.createTextNode(elem));
            } else {
              tmp = tmp || fragment.appendChild(context.createElement("div"));
              tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
              wrap = wrapMap[tag] || wrapMap._default;
              tmp.innerHTML = wrap[1] + jQuery2.htmlPrefilter(elem) + wrap[2];
              j2 = wrap[0];
              while (j2--) {
                tmp = tmp.lastChild;
              }
              jQuery2.merge(nodes, tmp.childNodes);
              tmp = fragment.firstChild;
              tmp.textContent = "";
            }
          }
        }
        fragment.textContent = "";
        i2 = 0;
        while (elem = nodes[i2++]) {
          if (selection && jQuery2.inArray(elem, selection) > -1) {
            if (ignored) {
              ignored.push(elem);
            }
            continue;
          }
          attached = isAttached(elem);
          tmp = getAll(fragment.appendChild(elem), "script");
          if (attached) {
            setGlobalEval(tmp);
          }
          if (scripts) {
            j2 = 0;
            while (elem = tmp[j2++]) {
              if (rscriptType.test(elem.type || "")) {
                scripts.push(elem);
              }
            }
          }
        }
        return fragment;
      }
      var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
      function returnTrue() {
        return true;
      }
      function returnFalse() {
        return false;
      }
      function on2(elem, types, selector, data, fn2, one) {
        var origFn, type;
        if (typeof types === "object") {
          if (typeof selector !== "string") {
            data = data || selector;
            selector = void 0;
          }
          for (type in types) {
            on2(elem, type, selector, data, types[type], one);
          }
          return elem;
        }
        if (data == null && fn2 == null) {
          fn2 = selector;
          data = selector = void 0;
        } else if (fn2 == null) {
          if (typeof selector === "string") {
            fn2 = data;
            data = void 0;
          } else {
            fn2 = data;
            data = selector;
            selector = void 0;
          }
        }
        if (fn2 === false) {
          fn2 = returnFalse;
        } else if (!fn2) {
          return elem;
        }
        if (one === 1) {
          origFn = fn2;
          fn2 = function(event) {
            jQuery2().off(event);
            return origFn.apply(this, arguments);
          };
          fn2.guid = origFn.guid || (origFn.guid = jQuery2.guid++);
        }
        return elem.each(function() {
          jQuery2.event.add(this, types, fn2, data, selector);
        });
      }
      jQuery2.event = {
        global: {},
        add: function(elem, types, handler, data, selector) {
          var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
          if (!acceptData(elem)) {
            return;
          }
          if (handler.handler) {
            handleObjIn = handler;
            handler = handleObjIn.handler;
            selector = handleObjIn.selector;
          }
          if (selector) {
            jQuery2.find.matchesSelector(documentElement, selector);
          }
          if (!handler.guid) {
            handler.guid = jQuery2.guid++;
          }
          if (!(events = elemData.events)) {
            events = elemData.events = /* @__PURE__ */ Object.create(null);
          }
          if (!(eventHandle = elemData.handle)) {
            eventHandle = elemData.handle = function(e) {
              return typeof jQuery2 !== "undefined" && jQuery2.event.triggered !== e.type ? jQuery2.event.dispatch.apply(elem, arguments) : void 0;
            };
          }
          types = (types || "").match(rnothtmlwhite) || [""];
          t = types.length;
          while (t--) {
            tmp = rtypenamespace.exec(types[t]) || [];
            type = origType = tmp[1];
            namespaces = (tmp[2] || "").split(".").sort();
            if (!type) {
              continue;
            }
            special = jQuery2.event.special[type] || {};
            type = (selector ? special.delegateType : special.bindType) || type;
            special = jQuery2.event.special[type] || {};
            handleObj = jQuery2.extend({
              type,
              origType,
              data,
              handler,
              guid: handler.guid,
              selector,
              needsContext: selector && jQuery2.expr.match.needsContext.test(selector),
              namespace: namespaces.join(".")
            }, handleObjIn);
            if (!(handlers = events[type])) {
              handlers = events[type] = [];
              handlers.delegateCount = 0;
              if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                if (elem.addEventListener) {
                  elem.addEventListener(type, eventHandle);
                }
              }
            }
            if (special.add) {
              special.add.call(elem, handleObj);
              if (!handleObj.handler.guid) {
                handleObj.handler.guid = handler.guid;
              }
            }
            if (selector) {
              handlers.splice(handlers.delegateCount++, 0, handleObj);
            } else {
              handlers.push(handleObj);
            }
            jQuery2.event.global[type] = true;
          }
        },
        // Detach an event or set of events from an element
        remove: function(elem, types, handler, selector, mappedTypes) {
          var j2, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
          if (!elemData || !(events = elemData.events)) {
            return;
          }
          types = (types || "").match(rnothtmlwhite) || [""];
          t = types.length;
          while (t--) {
            tmp = rtypenamespace.exec(types[t]) || [];
            type = origType = tmp[1];
            namespaces = (tmp[2] || "").split(".").sort();
            if (!type) {
              for (type in events) {
                jQuery2.event.remove(elem, type + types[t], handler, selector, true);
              }
              continue;
            }
            special = jQuery2.event.special[type] || {};
            type = (selector ? special.delegateType : special.bindType) || type;
            handlers = events[type] || [];
            tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
            origCount = j2 = handlers.length;
            while (j2--) {
              handleObj = handlers[j2];
              if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                handlers.splice(j2, 1);
                if (handleObj.selector) {
                  handlers.delegateCount--;
                }
                if (special.remove) {
                  special.remove.call(elem, handleObj);
                }
              }
            }
            if (origCount && !handlers.length) {
              if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                jQuery2.removeEvent(elem, type, elemData.handle);
              }
              delete events[type];
            }
          }
          if (jQuery2.isEmptyObject(events)) {
            dataPriv.remove(elem, "handle events");
          }
        },
        dispatch: function(nativeEvent) {
          var i2, j2, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), event = jQuery2.event.fix(nativeEvent), handlers = (dataPriv.get(this, "events") || /* @__PURE__ */ Object.create(null))[event.type] || [], special = jQuery2.event.special[event.type] || {};
          args[0] = event;
          for (i2 = 1; i2 < arguments.length; i2++) {
            args[i2] = arguments[i2];
          }
          event.delegateTarget = this;
          if (special.preDispatch && special.preDispatch.call(this, event) === false) {
            return;
          }
          handlerQueue = jQuery2.event.handlers.call(this, event, handlers);
          i2 = 0;
          while ((matched = handlerQueue[i2++]) && !event.isPropagationStopped()) {
            event.currentTarget = matched.elem;
            j2 = 0;
            while ((handleObj = matched.handlers[j2++]) && !event.isImmediatePropagationStopped()) {
              if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
                event.handleObj = handleObj;
                event.data = handleObj.data;
                ret = ((jQuery2.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                if (ret !== void 0) {
                  if ((event.result = ret) === false) {
                    event.preventDefault();
                    event.stopPropagation();
                  }
                }
              }
            }
          }
          if (special.postDispatch) {
            special.postDispatch.call(this, event);
          }
          return event.result;
        },
        handlers: function(event, handlers) {
          var i2, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
          if (delegateCount && // Support: IE <=9
          // Black-hole SVG <use> instance trees (trac-13180)
          cur.nodeType && // Support: Firefox <=42
          // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
          // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
          // Support: IE 11 only
          // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
          !(event.type === "click" && event.button >= 1)) {
            for (; cur !== this; cur = cur.parentNode || this) {
              if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
                matchedHandlers = [];
                matchedSelectors = {};
                for (i2 = 0; i2 < delegateCount; i2++) {
                  handleObj = handlers[i2];
                  sel = handleObj.selector + " ";
                  if (matchedSelectors[sel] === void 0) {
                    matchedSelectors[sel] = handleObj.needsContext ? jQuery2(sel, this).index(cur) > -1 : jQuery2.find(sel, this, null, [cur]).length;
                  }
                  if (matchedSelectors[sel]) {
                    matchedHandlers.push(handleObj);
                  }
                }
                if (matchedHandlers.length) {
                  handlerQueue.push({ elem: cur, handlers: matchedHandlers });
                }
              }
            }
          }
          cur = this;
          if (delegateCount < handlers.length) {
            handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });
          }
          return handlerQueue;
        },
        addProp: function(name4, hook) {
          Object.defineProperty(jQuery2.Event.prototype, name4, {
            enumerable: true,
            configurable: true,
            get: isFunction4(hook) ? function() {
              if (this.originalEvent) {
                return hook(this.originalEvent);
              }
            } : function() {
              if (this.originalEvent) {
                return this.originalEvent[name4];
              }
            },
            set: function(value) {
              Object.defineProperty(this, name4, {
                enumerable: true,
                configurable: true,
                writable: true,
                value
              });
            }
          });
        },
        fix: function(originalEvent) {
          return originalEvent[jQuery2.expando] ? originalEvent : new jQuery2.Event(originalEvent);
        },
        special: {
          load: {
            // Prevent triggered image.load events from bubbling to window.load
            noBubble: true
          },
          click: {
            // Utilize native event to ensure correct state for checkable inputs
            setup: function(data) {
              var el = this || data;
              if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                leverageNative(el, "click", true);
              }
              return false;
            },
            trigger: function(data) {
              var el = this || data;
              if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                leverageNative(el, "click");
              }
              return true;
            },
            // For cross-browser consistency, suppress native .click() on links
            // Also prevent it if we're currently inside a leveraged native-event stack
            _default: function(event) {
              var target = event.target;
              return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
            }
          },
          beforeunload: {
            postDispatch: function(event) {
              if (event.result !== void 0 && event.originalEvent) {
                event.originalEvent.returnValue = event.result;
              }
            }
          }
        }
      };
      function leverageNative(el, type, isSetup) {
        if (!isSetup) {
          if (dataPriv.get(el, type) === void 0) {
            jQuery2.event.add(el, type, returnTrue);
          }
          return;
        }
        dataPriv.set(el, type, false);
        jQuery2.event.add(el, type, {
          namespace: false,
          handler: function(event) {
            var result, saved = dataPriv.get(this, type);
            if (event.isTrigger & 1 && this[type]) {
              if (!saved) {
                saved = slice.call(arguments);
                dataPriv.set(this, type, saved);
                this[type]();
                result = dataPriv.get(this, type);
                dataPriv.set(this, type, false);
                if (saved !== result) {
                  event.stopImmediatePropagation();
                  event.preventDefault();
                  return result;
                }
              } else if ((jQuery2.event.special[type] || {}).delegateType) {
                event.stopPropagation();
              }
            } else if (saved) {
              dataPriv.set(this, type, jQuery2.event.trigger(
                saved[0],
                saved.slice(1),
                this
              ));
              event.stopPropagation();
              event.isImmediatePropagationStopped = returnTrue;
            }
          }
        });
      }
      jQuery2.removeEvent = function(elem, type, handle) {
        if (elem.removeEventListener) {
          elem.removeEventListener(type, handle);
        }
      };
      jQuery2.Event = function(src, props) {
        if (!(this instanceof jQuery2.Event)) {
          return new jQuery2.Event(src, props);
        }
        if (src && src.type) {
          this.originalEvent = src;
          this.type = src.type;
          this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === void 0 && // Support: Android <=2.3 only
          src.returnValue === false ? returnTrue : returnFalse;
          this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
          this.currentTarget = src.currentTarget;
          this.relatedTarget = src.relatedTarget;
        } else {
          this.type = src;
        }
        if (props) {
          jQuery2.extend(this, props);
        }
        this.timeStamp = src && src.timeStamp || Date.now();
        this[jQuery2.expando] = true;
      };
      jQuery2.Event.prototype = {
        constructor: jQuery2.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        isSimulated: false,
        preventDefault: function() {
          var e = this.originalEvent;
          this.isDefaultPrevented = returnTrue;
          if (e && !this.isSimulated) {
            e.preventDefault();
          }
        },
        stopPropagation: function() {
          var e = this.originalEvent;
          this.isPropagationStopped = returnTrue;
          if (e && !this.isSimulated) {
            e.stopPropagation();
          }
        },
        stopImmediatePropagation: function() {
          var e = this.originalEvent;
          this.isImmediatePropagationStopped = returnTrue;
          if (e && !this.isSimulated) {
            e.stopImmediatePropagation();
          }
          this.stopPropagation();
        }
      };
      jQuery2.each({
        altKey: true,
        bubbles: true,
        cancelable: true,
        changedTouches: true,
        ctrlKey: true,
        detail: true,
        eventPhase: true,
        metaKey: true,
        pageX: true,
        pageY: true,
        shiftKey: true,
        view: true,
        "char": true,
        code: true,
        charCode: true,
        key: true,
        keyCode: true,
        button: true,
        buttons: true,
        clientX: true,
        clientY: true,
        offsetX: true,
        offsetY: true,
        pointerId: true,
        pointerType: true,
        screenX: true,
        screenY: true,
        targetTouches: true,
        toElement: true,
        touches: true,
        which: true
      }, jQuery2.event.addProp);
      jQuery2.each({ focus: "focusin", blur: "focusout" }, function(type, delegateType) {
        function focusMappedHandler(nativeEvent) {
          if (document2.documentMode) {
            var handle = dataPriv.get(this, "handle"), event = jQuery2.event.fix(nativeEvent);
            event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
            event.isSimulated = true;
            handle(nativeEvent);
            if (event.target === event.currentTarget) {
              handle(event);
            }
          } else {
            jQuery2.event.simulate(
              delegateType,
              nativeEvent.target,
              jQuery2.event.fix(nativeEvent)
            );
          }
        }
        jQuery2.event.special[type] = {
          // Utilize native event if possible so blur/focus sequence is correct
          setup: function() {
            var attaches;
            leverageNative(this, type, true);
            if (document2.documentMode) {
              attaches = dataPriv.get(this, delegateType);
              if (!attaches) {
                this.addEventListener(delegateType, focusMappedHandler);
              }
              dataPriv.set(this, delegateType, (attaches || 0) + 1);
            } else {
              return false;
            }
          },
          trigger: function() {
            leverageNative(this, type);
            return true;
          },
          teardown: function() {
            var attaches;
            if (document2.documentMode) {
              attaches = dataPriv.get(this, delegateType) - 1;
              if (!attaches) {
                this.removeEventListener(delegateType, focusMappedHandler);
                dataPriv.remove(this, delegateType);
              } else {
                dataPriv.set(this, delegateType, attaches);
              }
            } else {
              return false;
            }
          },
          // Suppress native focus or blur if we're currently inside
          // a leveraged native-event stack
          _default: function(event) {
            return dataPriv.get(event.target, type);
          },
          delegateType
        };
        jQuery2.event.special[delegateType] = {
          setup: function() {
            var doc = this.ownerDocument || this.document || this, dataHolder = document2.documentMode ? this : doc, attaches = dataPriv.get(dataHolder, delegateType);
            if (!attaches) {
              if (document2.documentMode) {
                this.addEventListener(delegateType, focusMappedHandler);
              } else {
                doc.addEventListener(type, focusMappedHandler, true);
              }
            }
            dataPriv.set(dataHolder, delegateType, (attaches || 0) + 1);
          },
          teardown: function() {
            var doc = this.ownerDocument || this.document || this, dataHolder = document2.documentMode ? this : doc, attaches = dataPriv.get(dataHolder, delegateType) - 1;
            if (!attaches) {
              if (document2.documentMode) {
                this.removeEventListener(delegateType, focusMappedHandler);
              } else {
                doc.removeEventListener(type, focusMappedHandler, true);
              }
              dataPriv.remove(dataHolder, delegateType);
            } else {
              dataPriv.set(dataHolder, delegateType, attaches);
            }
          }
        };
      });
      jQuery2.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
      }, function(orig, fix) {
        jQuery2.event.special[orig] = {
          delegateType: fix,
          bindType: fix,
          handle: function(event) {
            var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
            if (!related || related !== target && !jQuery2.contains(target, related)) {
              event.type = handleObj.origType;
              ret = handleObj.handler.apply(this, arguments);
              event.type = fix;
            }
            return ret;
          }
        };
      });
      jQuery2.fn.extend({
        on: function(types, selector, data, fn2) {
          return on2(this, types, selector, data, fn2);
        },
        one: function(types, selector, data, fn2) {
          return on2(this, types, selector, data, fn2, 1);
        },
        off: function(types, selector, fn2) {
          var handleObj, type;
          if (types && types.preventDefault && types.handleObj) {
            handleObj = types.handleObj;
            jQuery2(types.delegateTarget).off(
              handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
              handleObj.selector,
              handleObj.handler
            );
            return this;
          }
          if (typeof types === "object") {
            for (type in types) {
              this.off(type, selector, types[type]);
            }
            return this;
          }
          if (selector === false || typeof selector === "function") {
            fn2 = selector;
            selector = void 0;
          }
          if (fn2 === false) {
            fn2 = returnFalse;
          }
          return this.each(function() {
            jQuery2.event.remove(this, types, fn2, selector);
          });
        }
      });
      var rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;
      function manipulationTarget(elem, content) {
        if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
          return jQuery2(elem).children("tbody")[0] || elem;
        }
        return elem;
      }
      function disableScript(elem) {
        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
        return elem;
      }
      function restoreScript(elem) {
        if ((elem.type || "").slice(0, 5) === "true/") {
          elem.type = elem.type.slice(5);
        } else {
          elem.removeAttribute("type");
        }
        return elem;
      }
      function cloneCopyEvent(src, dest) {
        var i2, l, type, pdataOld, udataOld, udataCur, events;
        if (dest.nodeType !== 1) {
          return;
        }
        if (dataPriv.hasData(src)) {
          pdataOld = dataPriv.get(src);
          events = pdataOld.events;
          if (events) {
            dataPriv.remove(dest, "handle events");
            for (type in events) {
              for (i2 = 0, l = events[type].length; i2 < l; i2++) {
                jQuery2.event.add(dest, type, events[type][i2]);
              }
            }
          }
        }
        if (dataUser.hasData(src)) {
          udataOld = dataUser.access(src);
          udataCur = jQuery2.extend({}, udataOld);
          dataUser.set(dest, udataCur);
        }
      }
      function fixInput(src, dest) {
        var nodeName2 = dest.nodeName.toLowerCase();
        if (nodeName2 === "input" && rcheckableType.test(src.type)) {
          dest.checked = src.checked;
        } else if (nodeName2 === "input" || nodeName2 === "textarea") {
          dest.defaultValue = src.defaultValue;
        }
      }
      function domManip(collection, args, callback, ignored) {
        args = flat(args);
        var fragment, first2, scripts, hasScripts, node, doc, i2 = 0, l = collection.length, iNoClone = l - 1, value = args[0], valueIsFunction = isFunction4(value);
        if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
          return collection.each(function(index) {
            var self2 = collection.eq(index);
            if (valueIsFunction) {
              args[0] = value.call(this, index, self2.html());
            }
            domManip(self2, args, callback, ignored);
          });
        }
        if (l) {
          fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
          first2 = fragment.firstChild;
          if (fragment.childNodes.length === 1) {
            fragment = first2;
          }
          if (first2 || ignored) {
            scripts = jQuery2.map(getAll(fragment, "script"), disableScript);
            hasScripts = scripts.length;
            for (; i2 < l; i2++) {
              node = fragment;
              if (i2 !== iNoClone) {
                node = jQuery2.clone(node, true, true);
                if (hasScripts) {
                  jQuery2.merge(scripts, getAll(node, "script"));
                }
              }
              callback.call(collection[i2], node, i2);
            }
            if (hasScripts) {
              doc = scripts[scripts.length - 1].ownerDocument;
              jQuery2.map(scripts, restoreScript);
              for (i2 = 0; i2 < hasScripts; i2++) {
                node = scripts[i2];
                if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery2.contains(doc, node)) {
                  if (node.src && (node.type || "").toLowerCase() !== "module") {
                    if (jQuery2._evalUrl && !node.noModule) {
                      jQuery2._evalUrl(node.src, {
                        nonce: node.nonce || node.getAttribute("nonce")
                      }, doc);
                    }
                  } else {
                    DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
                  }
                }
              }
            }
          }
        }
        return collection;
      }
      function remove(elem, selector, keepData) {
        var node, nodes = selector ? jQuery2.filter(selector, elem) : elem, i2 = 0;
        for (; (node = nodes[i2]) != null; i2++) {
          if (!keepData && node.nodeType === 1) {
            jQuery2.cleanData(getAll(node));
          }
          if (node.parentNode) {
            if (keepData && isAttached(node)) {
              setGlobalEval(getAll(node, "script"));
            }
            node.parentNode.removeChild(node);
          }
        }
        return elem;
      }
      jQuery2.extend({
        htmlPrefilter: function(html) {
          return html;
        },
        clone: function(elem, dataAndEvents, deepDataAndEvents) {
          var i2, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = isAttached(elem);
          if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery2.isXMLDoc(elem)) {
            destElements = getAll(clone);
            srcElements = getAll(elem);
            for (i2 = 0, l = srcElements.length; i2 < l; i2++) {
              fixInput(srcElements[i2], destElements[i2]);
            }
          }
          if (dataAndEvents) {
            if (deepDataAndEvents) {
              srcElements = srcElements || getAll(elem);
              destElements = destElements || getAll(clone);
              for (i2 = 0, l = srcElements.length; i2 < l; i2++) {
                cloneCopyEvent(srcElements[i2], destElements[i2]);
              }
            } else {
              cloneCopyEvent(elem, clone);
            }
          }
          destElements = getAll(clone, "script");
          if (destElements.length > 0) {
            setGlobalEval(destElements, !inPage && getAll(elem, "script"));
          }
          return clone;
        },
        cleanData: function(elems) {
          var data, elem, type, special = jQuery2.event.special, i2 = 0;
          for (; (elem = elems[i2]) !== void 0; i2++) {
            if (acceptData(elem)) {
              if (data = elem[dataPriv.expando]) {
                if (data.events) {
                  for (type in data.events) {
                    if (special[type]) {
                      jQuery2.event.remove(elem, type);
                    } else {
                      jQuery2.removeEvent(elem, type, data.handle);
                    }
                  }
                }
                elem[dataPriv.expando] = void 0;
              }
              if (elem[dataUser.expando]) {
                elem[dataUser.expando] = void 0;
              }
            }
          }
        }
      });
      jQuery2.fn.extend({
        detach: function(selector) {
          return remove(this, selector, true);
        },
        remove: function(selector) {
          return remove(this, selector);
        },
        text: function(value) {
          return access(this, function(value2) {
            return value2 === void 0 ? jQuery2.text(this) : this.empty().each(function() {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                this.textContent = value2;
              }
            });
          }, null, value, arguments.length);
        },
        append: function() {
          return domManip(this, arguments, function(elem) {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              var target = manipulationTarget(this, elem);
              target.appendChild(elem);
            }
          });
        },
        prepend: function() {
          return domManip(this, arguments, function(elem) {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              var target = manipulationTarget(this, elem);
              target.insertBefore(elem, target.firstChild);
            }
          });
        },
        before: function() {
          return domManip(this, arguments, function(elem) {
            if (this.parentNode) {
              this.parentNode.insertBefore(elem, this);
            }
          });
        },
        after: function() {
          return domManip(this, arguments, function(elem) {
            if (this.parentNode) {
              this.parentNode.insertBefore(elem, this.nextSibling);
            }
          });
        },
        empty: function() {
          var elem, i2 = 0;
          for (; (elem = this[i2]) != null; i2++) {
            if (elem.nodeType === 1) {
              jQuery2.cleanData(getAll(elem, false));
              elem.textContent = "";
            }
          }
          return this;
        },
        clone: function(dataAndEvents, deepDataAndEvents) {
          dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
          deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
          return this.map(function() {
            return jQuery2.clone(this, dataAndEvents, deepDataAndEvents);
          });
        },
        html: function(value) {
          return access(this, function(value2) {
            var elem = this[0] || {}, i2 = 0, l = this.length;
            if (value2 === void 0 && elem.nodeType === 1) {
              return elem.innerHTML;
            }
            if (typeof value2 === "string" && !rnoInnerhtml.test(value2) && !wrapMap[(rtagName.exec(value2) || ["", ""])[1].toLowerCase()]) {
              value2 = jQuery2.htmlPrefilter(value2);
              try {
                for (; i2 < l; i2++) {
                  elem = this[i2] || {};
                  if (elem.nodeType === 1) {
                    jQuery2.cleanData(getAll(elem, false));
                    elem.innerHTML = value2;
                  }
                }
                elem = 0;
              } catch (e) {
              }
            }
            if (elem) {
              this.empty().append(value2);
            }
          }, null, value, arguments.length);
        },
        replaceWith: function() {
          var ignored = [];
          return domManip(this, arguments, function(elem) {
            var parent2 = this.parentNode;
            if (jQuery2.inArray(this, ignored) < 0) {
              jQuery2.cleanData(getAll(this));
              if (parent2) {
                parent2.replaceChild(elem, this);
              }
            }
          }, ignored);
        }
      });
      jQuery2.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
      }, function(name4, original) {
        jQuery2.fn[name4] = function(selector) {
          var elems, ret = [], insert = jQuery2(selector), last = insert.length - 1, i2 = 0;
          for (; i2 <= last; i2++) {
            elems = i2 === last ? this : this.clone(true);
            jQuery2(insert[i2])[original](elems);
            push.apply(ret, elems.get());
          }
          return this.pushStack(ret);
        };
      });
      var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
      var rcustomProp = /^--/;
      var getStyles = function(elem) {
        var view = elem.ownerDocument.defaultView;
        if (!view || !view.opener) {
          view = window2;
        }
        return view.getComputedStyle(elem);
      };
      var swap = function(elem, options, callback) {
        var ret, name4, old = {};
        for (name4 in options) {
          old[name4] = elem.style[name4];
          elem.style[name4] = options[name4];
        }
        ret = callback.call(elem);
        for (name4 in options) {
          elem.style[name4] = old[name4];
        }
        return ret;
      };
      var rboxStyle = new RegExp(cssExpand.join("|"), "i");
      (function() {
        function computeStyleTests() {
          if (!div) {
            return;
          }
          container.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0";
          div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%";
          documentElement.appendChild(container).appendChild(div);
          var divStyle = window2.getComputedStyle(div);
          pixelPositionVal = divStyle.top !== "1%";
          reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
          div.style.right = "60%";
          pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
          boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
          div.style.position = "absolute";
          scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
          documentElement.removeChild(container);
          div = null;
        }
        function roundPixelMeasures(measure) {
          return Math.round(parseFloat(measure));
        }
        var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container = document2.createElement("div"), div = document2.createElement("div");
        if (!div.style) {
          return;
        }
        div.style.backgroundClip = "content-box";
        div.cloneNode(true).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";
        jQuery2.extend(support, {
          boxSizingReliable: function() {
            computeStyleTests();
            return boxSizingReliableVal;
          },
          pixelBoxStyles: function() {
            computeStyleTests();
            return pixelBoxStylesVal;
          },
          pixelPosition: function() {
            computeStyleTests();
            return pixelPositionVal;
          },
          reliableMarginLeft: function() {
            computeStyleTests();
            return reliableMarginLeftVal;
          },
          scrollboxSize: function() {
            computeStyleTests();
            return scrollboxSizeVal;
          },
          // Support: IE 9 - 11+, Edge 15 - 18+
          // IE/Edge misreport `getComputedStyle` of table rows with width/height
          // set in CSS while `offset*` properties report correct values.
          // Behavior in IE 9 is more subtle than in newer versions & it passes
          // some versions of this test; make sure not to make it pass there!
          //
          // Support: Firefox 70+
          // Only Firefox includes border widths
          // in computed dimensions. (gh-4529)
          reliableTrDimensions: function() {
            var table, tr2, trChild, trStyle;
            if (reliableTrDimensionsVal == null) {
              table = document2.createElement("table");
              tr2 = document2.createElement("tr");
              trChild = document2.createElement("div");
              table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
              tr2.style.cssText = "box-sizing:content-box;border:1px solid";
              tr2.style.height = "1px";
              trChild.style.height = "9px";
              trChild.style.display = "block";
              documentElement.appendChild(table).appendChild(tr2).appendChild(trChild);
              trStyle = window2.getComputedStyle(tr2);
              reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr2.offsetHeight;
              documentElement.removeChild(table);
            }
            return reliableTrDimensionsVal;
          }
        });
      })();
      function curCSS(elem, name4, computed) {
        var width, minWidth, maxWidth, ret, isCustomProp = rcustomProp.test(name4), style = elem.style;
        computed = computed || getStyles(elem);
        if (computed) {
          ret = computed.getPropertyValue(name4) || computed[name4];
          if (isCustomProp && ret) {
            ret = ret.replace(rtrimCSS, "$1") || void 0;
          }
          if (ret === "" && !isAttached(elem)) {
            ret = jQuery2.style(elem, name4);
          }
          if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name4)) {
            width = style.width;
            minWidth = style.minWidth;
            maxWidth = style.maxWidth;
            style.minWidth = style.maxWidth = style.width = ret;
            ret = computed.width;
            style.width = width;
            style.minWidth = minWidth;
            style.maxWidth = maxWidth;
          }
        }
        return ret !== void 0 ? (
          // Support: IE <=9 - 11 only
          // IE returns zIndex value as an integer.
          ret + ""
        ) : ret;
      }
      function addGetHookIf(conditionFn, hookFn) {
        return {
          get: function() {
            if (conditionFn()) {
              delete this.get;
              return;
            }
            return (this.get = hookFn).apply(this, arguments);
          }
        };
      }
      var cssPrefixes = ["Webkit", "Moz", "ms"], emptyStyle = document2.createElement("div").style, vendorProps = {};
      function vendorPropName(name4) {
        var capName = name4[0].toUpperCase() + name4.slice(1), i2 = cssPrefixes.length;
        while (i2--) {
          name4 = cssPrefixes[i2] + capName;
          if (name4 in emptyStyle) {
            return name4;
          }
        }
      }
      function finalPropName(name4) {
        var final = jQuery2.cssProps[name4] || vendorProps[name4];
        if (final) {
          return final;
        }
        if (name4 in emptyStyle) {
          return name4;
        }
        return vendorProps[name4] = vendorPropName(name4) || name4;
      }
      var rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow = { position: "absolute", visibility: "hidden", display: "block" }, cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
      };
      function setPositiveNumber(_elem, value, subtract) {
        var matches = rcssNum.exec(value);
        return matches ? (
          // Guard against undefined "subtract", e.g., when used as in cssHooks
          Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px")
        ) : value;
      }
      function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
        var i2 = dimension === "width" ? 1 : 0, extra = 0, delta = 0, marginDelta = 0;
        if (box === (isBorderBox ? "border" : "content")) {
          return 0;
        }
        for (; i2 < 4; i2 += 2) {
          if (box === "margin") {
            marginDelta += jQuery2.css(elem, box + cssExpand[i2], true, styles);
          }
          if (!isBorderBox) {
            delta += jQuery2.css(elem, "padding" + cssExpand[i2], true, styles);
            if (box !== "padding") {
              delta += jQuery2.css(elem, "border" + cssExpand[i2] + "Width", true, styles);
            } else {
              extra += jQuery2.css(elem, "border" + cssExpand[i2] + "Width", true, styles);
            }
          } else {
            if (box === "content") {
              delta -= jQuery2.css(elem, "padding" + cssExpand[i2], true, styles);
            }
            if (box !== "margin") {
              delta -= jQuery2.css(elem, "border" + cssExpand[i2] + "Width", true, styles);
            }
          }
        }
        if (!isBorderBox && computedVal >= 0) {
          delta += Math.max(0, Math.ceil(
            elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5
            // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
            // Use an explicit zero to avoid NaN (gh-3964)
          )) || 0;
        }
        return delta + marginDelta;
      }
      function getWidthOrHeight(elem, dimension, extra) {
        var styles = getStyles(elem), boxSizingNeeded = !support.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && jQuery2.css(elem, "boxSizing", false, styles) === "border-box", valueIsBorderBox = isBorderBox, val = curCSS(elem, dimension, styles), offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
        if (rnumnonpx.test(val)) {
          if (!extra) {
            return val;
          }
          val = "auto";
        }
        if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
        // IE/Edge misreport `getComputedStyle` of table rows with width/height
        // set in CSS while `offset*` properties report correct values.
        // Interestingly, in some cases IE 9 doesn't suffer from this issue.
        !support.reliableTrDimensions() && nodeName(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
        // This happens for inline elements with no explicit setting (gh-3571)
        val === "auto" || // Support: Android <=4.1 - 4.3 only
        // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
        !parseFloat(val) && jQuery2.css(elem, "display", false, styles) === "inline") && // Make sure the element is visible & connected
        elem.getClientRects().length) {
          isBorderBox = jQuery2.css(elem, "boxSizing", false, styles) === "border-box";
          valueIsBorderBox = offsetProp in elem;
          if (valueIsBorderBox) {
            val = elem[offsetProp];
          }
        }
        val = parseFloat(val) || 0;
        return val + boxModelAdjustment(
          elem,
          dimension,
          extra || (isBorderBox ? "border" : "content"),
          valueIsBorderBox,
          styles,
          // Provide the current computed size to request scroll gutter calculation (gh-3589)
          val
        ) + "px";
      }
      jQuery2.extend({
        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
          opacity: {
            get: function(elem, computed) {
              if (computed) {
                var ret = curCSS(elem, "opacity");
                return ret === "" ? "1" : ret;
              }
            }
          }
        },
        // Don't automatically add "px" to these possibly-unitless properties
        cssNumber: {
          animationIterationCount: true,
          aspectRatio: true,
          borderImageSlice: true,
          columnCount: true,
          flexGrow: true,
          flexShrink: true,
          fontWeight: true,
          gridArea: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnStart: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowStart: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          scale: true,
          widows: true,
          zIndex: true,
          zoom: true,
          // SVG-related
          fillOpacity: true,
          floodOpacity: true,
          stopOpacity: true,
          strokeMiterlimit: true,
          strokeOpacity: true
        },
        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {},
        // Get and set the style property on a DOM Node
        style: function(elem, name4, value, extra) {
          if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
            return;
          }
          var ret, type, hooks, origName = camelCase(name4), isCustomProp = rcustomProp.test(name4), style = elem.style;
          if (!isCustomProp) {
            name4 = finalPropName(origName);
          }
          hooks = jQuery2.cssHooks[name4] || jQuery2.cssHooks[origName];
          if (value !== void 0) {
            type = typeof value;
            if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
              value = adjustCSS(elem, name4, ret);
              type = "number";
            }
            if (value == null || value !== value) {
              return;
            }
            if (type === "number" && !isCustomProp) {
              value += ret && ret[3] || (jQuery2.cssNumber[origName] ? "" : "px");
            }
            if (!support.clearCloneStyle && value === "" && name4.indexOf("background") === 0) {
              style[name4] = "inherit";
            }
            if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== void 0) {
              if (isCustomProp) {
                style.setProperty(name4, value);
              } else {
                style[name4] = value;
              }
            }
          } else {
            if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== void 0) {
              return ret;
            }
            return style[name4];
          }
        },
        css: function(elem, name4, extra, styles) {
          var val, num, hooks, origName = camelCase(name4), isCustomProp = rcustomProp.test(name4);
          if (!isCustomProp) {
            name4 = finalPropName(origName);
          }
          hooks = jQuery2.cssHooks[name4] || jQuery2.cssHooks[origName];
          if (hooks && "get" in hooks) {
            val = hooks.get(elem, true, extra);
          }
          if (val === void 0) {
            val = curCSS(elem, name4, styles);
          }
          if (val === "normal" && name4 in cssNormalTransform) {
            val = cssNormalTransform[name4];
          }
          if (extra === "" || extra) {
            num = parseFloat(val);
            return extra === true || isFinite(num) ? num || 0 : val;
          }
          return val;
        }
      });
      jQuery2.each(["height", "width"], function(_i2, dimension) {
        jQuery2.cssHooks[dimension] = {
          get: function(elem, computed, extra) {
            if (computed) {
              return rdisplayswap.test(jQuery2.css(elem, "display")) && // Support: Safari 8+
              // Table columns in Safari have non-zero offsetWidth & zero
              // getBoundingClientRect().width unless display is changed.
              // Support: IE <=11 only
              // Running getBoundingClientRect on a disconnected node
              // in IE throws an error.
              (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {
                return getWidthOrHeight(elem, dimension, extra);
              }) : getWidthOrHeight(elem, dimension, extra);
            }
          },
          set: function(elem, value, extra) {
            var matches, styles = getStyles(elem), scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute", boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && jQuery2.css(elem, "boxSizing", false, styles) === "border-box", subtract = extra ? boxModelAdjustment(
              elem,
              dimension,
              extra,
              isBorderBox,
              styles
            ) : 0;
            if (isBorderBox && scrollboxSizeBuggy) {
              subtract -= Math.ceil(
                elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5
              );
            }
            if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
              elem.style[dimension] = value;
              value = jQuery2.css(elem, dimension);
            }
            return setPositiveNumber(elem, value, subtract);
          }
        };
      });
      jQuery2.cssHooks.marginLeft = addGetHookIf(
        support.reliableMarginLeft,
        function(elem, computed) {
          if (computed) {
            return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function() {
              return elem.getBoundingClientRect().left;
            })) + "px";
          }
        }
      );
      jQuery2.each({
        margin: "",
        padding: "",
        border: "Width"
      }, function(prefix, suffix) {
        jQuery2.cssHooks[prefix + suffix] = {
          expand: function(value) {
            var i2 = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [value];
            for (; i2 < 4; i2++) {
              expanded[prefix + cssExpand[i2] + suffix] = parts[i2] || parts[i2 - 2] || parts[0];
            }
            return expanded;
          }
        };
        if (prefix !== "margin") {
          jQuery2.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
      });
      jQuery2.fn.extend({
        css: function(name4, value) {
          return access(this, function(elem, name5, value2) {
            var styles, len, map3 = {}, i2 = 0;
            if (Array.isArray(name5)) {
              styles = getStyles(elem);
              len = name5.length;
              for (; i2 < len; i2++) {
                map3[name5[i2]] = jQuery2.css(elem, name5[i2], false, styles);
              }
              return map3;
            }
            return value2 !== void 0 ? jQuery2.style(elem, name5, value2) : jQuery2.css(elem, name5);
          }, name4, value, arguments.length > 1);
        }
      });
      function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
      }
      jQuery2.Tween = Tween;
      Tween.prototype = {
        constructor: Tween,
        init: function(elem, options, prop, end, easing, unit) {
          this.elem = elem;
          this.prop = prop;
          this.easing = easing || jQuery2.easing._default;
          this.options = options;
          this.start = this.now = this.cur();
          this.end = end;
          this.unit = unit || (jQuery2.cssNumber[prop] ? "" : "px");
        },
        cur: function() {
          var hooks = Tween.propHooks[this.prop];
          return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function(percent) {
          var eased, hooks = Tween.propHooks[this.prop];
          if (this.options.duration) {
            this.pos = eased = jQuery2.easing[this.easing](
              percent,
              this.options.duration * percent,
              0,
              1,
              this.options.duration
            );
          } else {
            this.pos = eased = percent;
          }
          this.now = (this.end - this.start) * eased + this.start;
          if (this.options.step) {
            this.options.step.call(this.elem, this.now, this);
          }
          if (hooks && hooks.set) {
            hooks.set(this);
          } else {
            Tween.propHooks._default.set(this);
          }
          return this;
        }
      };
      Tween.prototype.init.prototype = Tween.prototype;
      Tween.propHooks = {
        _default: {
          get: function(tween) {
            var result;
            if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
              return tween.elem[tween.prop];
            }
            result = jQuery2.css(tween.elem, tween.prop, "");
            return !result || result === "auto" ? 0 : result;
          },
          set: function(tween) {
            if (jQuery2.fx.step[tween.prop]) {
              jQuery2.fx.step[tween.prop](tween);
            } else if (tween.elem.nodeType === 1 && (jQuery2.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
              jQuery2.style(tween.elem, tween.prop, tween.now + tween.unit);
            } else {
              tween.elem[tween.prop] = tween.now;
            }
          }
        }
      };
      Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function(tween) {
          if (tween.elem.nodeType && tween.elem.parentNode) {
            tween.elem[tween.prop] = tween.now;
          }
        }
      };
      jQuery2.easing = {
        linear: function(p2) {
          return p2;
        },
        swing: function(p2) {
          return 0.5 - Math.cos(p2 * Math.PI) / 2;
        },
        _default: "swing"
      };
      jQuery2.fx = Tween.prototype.init;
      jQuery2.fx.step = {};
      var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
      function schedule() {
        if (inProgress) {
          if (document2.hidden === false && window2.requestAnimationFrame) {
            window2.requestAnimationFrame(schedule);
          } else {
            window2.setTimeout(schedule, jQuery2.fx.interval);
          }
          jQuery2.fx.tick();
        }
      }
      function createFxNow() {
        window2.setTimeout(function() {
          fxNow = void 0;
        });
        return fxNow = Date.now();
      }
      function genFx(type, includeWidth) {
        var which, i2 = 0, attrs = { height: type };
        includeWidth = includeWidth ? 1 : 0;
        for (; i2 < 4; i2 += 2 - includeWidth) {
          which = cssExpand[i2];
          attrs["margin" + which] = attrs["padding" + which] = type;
        }
        if (includeWidth) {
          attrs.opacity = attrs.width = type;
        }
        return attrs;
      }
      function createTween(value, prop, animation) {
        var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length;
        for (; index < length; index++) {
          if (tween = collection[index].call(animation, prop, value)) {
            return tween;
          }
        }
      }
      function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
        if (!opts.queue) {
          hooks = jQuery2._queueHooks(elem, "fx");
          if (hooks.unqueued == null) {
            hooks.unqueued = 0;
            oldfire = hooks.empty.fire;
            hooks.empty.fire = function() {
              if (!hooks.unqueued) {
                oldfire();
              }
            };
          }
          hooks.unqueued++;
          anim.always(function() {
            anim.always(function() {
              hooks.unqueued--;
              if (!jQuery2.queue(elem, "fx").length) {
                hooks.empty.fire();
              }
            });
          });
        }
        for (prop in props) {
          value = props[prop];
          if (rfxtypes.test(value)) {
            delete props[prop];
            toggle = toggle || value === "toggle";
            if (value === (hidden ? "hide" : "show")) {
              if (value === "show" && dataShow && dataShow[prop] !== void 0) {
                hidden = true;
              } else {
                continue;
              }
            }
            orig[prop] = dataShow && dataShow[prop] || jQuery2.style(elem, prop);
          }
        }
        propTween = !jQuery2.isEmptyObject(props);
        if (!propTween && jQuery2.isEmptyObject(orig)) {
          return;
        }
        if (isBox && elem.nodeType === 1) {
          opts.overflow = [style.overflow, style.overflowX, style.overflowY];
          restoreDisplay = dataShow && dataShow.display;
          if (restoreDisplay == null) {
            restoreDisplay = dataPriv.get(elem, "display");
          }
          display = jQuery2.css(elem, "display");
          if (display === "none") {
            if (restoreDisplay) {
              display = restoreDisplay;
            } else {
              showHide([elem], true);
              restoreDisplay = elem.style.display || restoreDisplay;
              display = jQuery2.css(elem, "display");
              showHide([elem]);
            }
          }
          if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
            if (jQuery2.css(elem, "float") === "none") {
              if (!propTween) {
                anim.done(function() {
                  style.display = restoreDisplay;
                });
                if (restoreDisplay == null) {
                  display = style.display;
                  restoreDisplay = display === "none" ? "" : display;
                }
              }
              style.display = "inline-block";
            }
          }
        }
        if (opts.overflow) {
          style.overflow = "hidden";
          anim.always(function() {
            style.overflow = opts.overflow[0];
            style.overflowX = opts.overflow[1];
            style.overflowY = opts.overflow[2];
          });
        }
        propTween = false;
        for (prop in orig) {
          if (!propTween) {
            if (dataShow) {
              if ("hidden" in dataShow) {
                hidden = dataShow.hidden;
              }
            } else {
              dataShow = dataPriv.access(elem, "fxshow", { display: restoreDisplay });
            }
            if (toggle) {
              dataShow.hidden = !hidden;
            }
            if (hidden) {
              showHide([elem], true);
            }
            anim.done(function() {
              if (!hidden) {
                showHide([elem]);
              }
              dataPriv.remove(elem, "fxshow");
              for (prop in orig) {
                jQuery2.style(elem, prop, orig[prop]);
              }
            });
          }
          propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
          if (!(prop in dataShow)) {
            dataShow[prop] = propTween.start;
            if (hidden) {
              propTween.end = propTween.start;
              propTween.start = 0;
            }
          }
        }
      }
      function propFilter(props, specialEasing) {
        var index, name4, easing, value, hooks;
        for (index in props) {
          name4 = camelCase(index);
          easing = specialEasing[name4];
          value = props[index];
          if (Array.isArray(value)) {
            easing = value[1];
            value = props[index] = value[0];
          }
          if (index !== name4) {
            props[name4] = value;
            delete props[index];
          }
          hooks = jQuery2.cssHooks[name4];
          if (hooks && "expand" in hooks) {
            value = hooks.expand(value);
            delete props[name4];
            for (index in value) {
              if (!(index in props)) {
                props[index] = value[index];
                specialEasing[index] = easing;
              }
            }
          } else {
            specialEasing[name4] = easing;
          }
        }
      }
      function Animation(elem, properties, options) {
        var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery2.Deferred().always(function() {
          delete tick.elem;
        }), tick = function() {
          if (stopped) {
            return false;
          }
          var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index2 = 0, length2 = animation.tweens.length;
          for (; index2 < length2; index2++) {
            animation.tweens[index2].run(percent);
          }
          deferred.notifyWith(elem, [animation, percent, remaining]);
          if (percent < 1 && length2) {
            return remaining;
          }
          if (!length2) {
            deferred.notifyWith(elem, [animation, 1, 0]);
          }
          deferred.resolveWith(elem, [animation]);
          return false;
        }, animation = deferred.promise({
          elem,
          props: jQuery2.extend({}, properties),
          opts: jQuery2.extend(true, {
            specialEasing: {},
            easing: jQuery2.easing._default
          }, options),
          originalProperties: properties,
          originalOptions: options,
          startTime: fxNow || createFxNow(),
          duration: options.duration,
          tweens: [],
          createTween: function(prop, end) {
            var tween = jQuery2.Tween(
              elem,
              animation.opts,
              prop,
              end,
              animation.opts.specialEasing[prop] || animation.opts.easing
            );
            animation.tweens.push(tween);
            return tween;
          },
          stop: function(gotoEnd) {
            var index2 = 0, length2 = gotoEnd ? animation.tweens.length : 0;
            if (stopped) {
              return this;
            }
            stopped = true;
            for (; index2 < length2; index2++) {
              animation.tweens[index2].run(1);
            }
            if (gotoEnd) {
              deferred.notifyWith(elem, [animation, 1, 0]);
              deferred.resolveWith(elem, [animation, gotoEnd]);
            } else {
              deferred.rejectWith(elem, [animation, gotoEnd]);
            }
            return this;
          }
        }), props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for (; index < length; index++) {
          result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
          if (result) {
            if (isFunction4(result.stop)) {
              jQuery2._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
            }
            return result;
          }
        }
        jQuery2.map(props, createTween, animation);
        if (isFunction4(animation.opts.start)) {
          animation.opts.start.call(elem, animation);
        }
        animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
        jQuery2.fx.timer(
          jQuery2.extend(tick, {
            elem,
            anim: animation,
            queue: animation.opts.queue
          })
        );
        return animation;
      }
      jQuery2.Animation = jQuery2.extend(Animation, {
        tweeners: {
          "*": [function(prop, value) {
            var tween = this.createTween(prop, value);
            adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
            return tween;
          }]
        },
        tweener: function(props, callback) {
          if (isFunction4(props)) {
            callback = props;
            props = ["*"];
          } else {
            props = props.match(rnothtmlwhite);
          }
          var prop, index = 0, length = props.length;
          for (; index < length; index++) {
            prop = props[index];
            Animation.tweeners[prop] = Animation.tweeners[prop] || [];
            Animation.tweeners[prop].unshift(callback);
          }
        },
        prefilters: [defaultPrefilter],
        prefilter: function(callback, prepend) {
          if (prepend) {
            Animation.prefilters.unshift(callback);
          } else {
            Animation.prefilters.push(callback);
          }
        }
      });
      jQuery2.speed = function(speed, easing, fn2) {
        var opt = speed && typeof speed === "object" ? jQuery2.extend({}, speed) : {
          complete: fn2 || !fn2 && easing || isFunction4(speed) && speed,
          duration: speed,
          easing: fn2 && easing || easing && !isFunction4(easing) && easing
        };
        if (jQuery2.fx.off) {
          opt.duration = 0;
        } else {
          if (typeof opt.duration !== "number") {
            if (opt.duration in jQuery2.fx.speeds) {
              opt.duration = jQuery2.fx.speeds[opt.duration];
            } else {
              opt.duration = jQuery2.fx.speeds._default;
            }
          }
        }
        if (opt.queue == null || opt.queue === true) {
          opt.queue = "fx";
        }
        opt.old = opt.complete;
        opt.complete = function() {
          if (isFunction4(opt.old)) {
            opt.old.call(this);
          }
          if (opt.queue) {
            jQuery2.dequeue(this, opt.queue);
          }
        };
        return opt;
      };
      jQuery2.fn.extend({
        fadeTo: function(speed, to2, easing, callback) {
          return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({ opacity: to2 }, speed, easing, callback);
        },
        animate: function(prop, speed, easing, callback) {
          var empty3 = jQuery2.isEmptyObject(prop), optall = jQuery2.speed(speed, easing, callback), doAnimation = function() {
            var anim = Animation(this, jQuery2.extend({}, prop), optall);
            if (empty3 || dataPriv.get(this, "finish")) {
              anim.stop(true);
            }
          };
          doAnimation.finish = doAnimation;
          return empty3 || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function(type, clearQueue, gotoEnd) {
          var stopQueue = function(hooks) {
            var stop2 = hooks.stop;
            delete hooks.stop;
            stop2(gotoEnd);
          };
          if (typeof type !== "string") {
            gotoEnd = clearQueue;
            clearQueue = type;
            type = void 0;
          }
          if (clearQueue) {
            this.queue(type || "fx", []);
          }
          return this.each(function() {
            var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery2.timers, data = dataPriv.get(this);
            if (index) {
              if (data[index] && data[index].stop) {
                stopQueue(data[index]);
              }
            } else {
              for (index in data) {
                if (data[index] && data[index].stop && rrun.test(index)) {
                  stopQueue(data[index]);
                }
              }
            }
            for (index = timers.length; index--; ) {
              if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                timers[index].anim.stop(gotoEnd);
                dequeue = false;
                timers.splice(index, 1);
              }
            }
            if (dequeue || !gotoEnd) {
              jQuery2.dequeue(this, type);
            }
          });
        },
        finish: function(type) {
          if (type !== false) {
            type = type || "fx";
          }
          return this.each(function() {
            var index, data = dataPriv.get(this), queue2 = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery2.timers, length = queue2 ? queue2.length : 0;
            data.finish = true;
            jQuery2.queue(this, type, []);
            if (hooks && hooks.stop) {
              hooks.stop.call(this, true);
            }
            for (index = timers.length; index--; ) {
              if (timers[index].elem === this && timers[index].queue === type) {
                timers[index].anim.stop(true);
                timers.splice(index, 1);
              }
            }
            for (index = 0; index < length; index++) {
              if (queue2[index] && queue2[index].finish) {
                queue2[index].finish.call(this);
              }
            }
            delete data.finish;
          });
        }
      });
      jQuery2.each(["toggle", "show", "hide"], function(_i2, name4) {
        var cssFn = jQuery2.fn[name4];
        jQuery2.fn[name4] = function(speed, easing, callback) {
          return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name4, true), speed, easing, callback);
        };
      });
      jQuery2.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: { opacity: "show" },
        fadeOut: { opacity: "hide" },
        fadeToggle: { opacity: "toggle" }
      }, function(name4, props) {
        jQuery2.fn[name4] = function(speed, easing, callback) {
          return this.animate(props, speed, easing, callback);
        };
      });
      jQuery2.timers = [];
      jQuery2.fx.tick = function() {
        var timer2, i2 = 0, timers = jQuery2.timers;
        fxNow = Date.now();
        for (; i2 < timers.length; i2++) {
          timer2 = timers[i2];
          if (!timer2() && timers[i2] === timer2) {
            timers.splice(i2--, 1);
          }
        }
        if (!timers.length) {
          jQuery2.fx.stop();
        }
        fxNow = void 0;
      };
      jQuery2.fx.timer = function(timer2) {
        jQuery2.timers.push(timer2);
        jQuery2.fx.start();
      };
      jQuery2.fx.interval = 13;
      jQuery2.fx.start = function() {
        if (inProgress) {
          return;
        }
        inProgress = true;
        schedule();
      };
      jQuery2.fx.stop = function() {
        inProgress = null;
      };
      jQuery2.fx.speeds = {
        slow: 600,
        fast: 200,
        // Default speed
        _default: 400
      };
      jQuery2.fn.delay = function(time, type) {
        time = jQuery2.fx ? jQuery2.fx.speeds[time] || time : time;
        type = type || "fx";
        return this.queue(type, function(next, hooks) {
          var timeout = window2.setTimeout(next, time);
          hooks.stop = function() {
            window2.clearTimeout(timeout);
          };
        });
      };
      (function() {
        var input = document2.createElement("input"), select = document2.createElement("select"), opt = select.appendChild(document2.createElement("option"));
        input.type = "checkbox";
        support.checkOn = input.value !== "";
        support.optSelected = opt.selected;
        input = document2.createElement("input");
        input.value = "t";
        input.type = "radio";
        support.radioValue = input.value === "t";
      })();
      var boolHook, attrHandle = jQuery2.expr.attrHandle;
      jQuery2.fn.extend({
        attr: function(name4, value) {
          return access(this, jQuery2.attr, name4, value, arguments.length > 1);
        },
        removeAttr: function(name4) {
          return this.each(function() {
            jQuery2.removeAttr(this, name4);
          });
        }
      });
      jQuery2.extend({
        attr: function(elem, name4, value) {
          var ret, hooks, nType = elem.nodeType;
          if (nType === 3 || nType === 8 || nType === 2) {
            return;
          }
          if (typeof elem.getAttribute === "undefined") {
            return jQuery2.prop(elem, name4, value);
          }
          if (nType !== 1 || !jQuery2.isXMLDoc(elem)) {
            hooks = jQuery2.attrHooks[name4.toLowerCase()] || (jQuery2.expr.match.bool.test(name4) ? boolHook : void 0);
          }
          if (value !== void 0) {
            if (value === null) {
              jQuery2.removeAttr(elem, name4);
              return;
            }
            if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name4)) !== void 0) {
              return ret;
            }
            elem.setAttribute(name4, value + "");
            return value;
          }
          if (hooks && "get" in hooks && (ret = hooks.get(elem, name4)) !== null) {
            return ret;
          }
          ret = jQuery2.find.attr(elem, name4);
          return ret == null ? void 0 : ret;
        },
        attrHooks: {
          type: {
            set: function(elem, value) {
              if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
                var val = elem.value;
                elem.setAttribute("type", value);
                if (val) {
                  elem.value = val;
                }
                return value;
              }
            }
          }
        },
        removeAttr: function(elem, value) {
          var name4, i2 = 0, attrNames = value && value.match(rnothtmlwhite);
          if (attrNames && elem.nodeType === 1) {
            while (name4 = attrNames[i2++]) {
              elem.removeAttribute(name4);
            }
          }
        }
      });
      boolHook = {
        set: function(elem, value, name4) {
          if (value === false) {
            jQuery2.removeAttr(elem, name4);
          } else {
            elem.setAttribute(name4, name4);
          }
          return name4;
        }
      };
      jQuery2.each(jQuery2.expr.match.bool.source.match(/\w+/g), function(_i2, name4) {
        var getter = attrHandle[name4] || jQuery2.find.attr;
        attrHandle[name4] = function(elem, name5, isXML) {
          var ret, handle, lowercaseName = name5.toLowerCase();
          if (!isXML) {
            handle = attrHandle[lowercaseName];
            attrHandle[lowercaseName] = ret;
            ret = getter(elem, name5, isXML) != null ? lowercaseName : null;
            attrHandle[lowercaseName] = handle;
          }
          return ret;
        };
      });
      var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
      jQuery2.fn.extend({
        prop: function(name4, value) {
          return access(this, jQuery2.prop, name4, value, arguments.length > 1);
        },
        removeProp: function(name4) {
          return this.each(function() {
            delete this[jQuery2.propFix[name4] || name4];
          });
        }
      });
      jQuery2.extend({
        prop: function(elem, name4, value) {
          var ret, hooks, nType = elem.nodeType;
          if (nType === 3 || nType === 8 || nType === 2) {
            return;
          }
          if (nType !== 1 || !jQuery2.isXMLDoc(elem)) {
            name4 = jQuery2.propFix[name4] || name4;
            hooks = jQuery2.propHooks[name4];
          }
          if (value !== void 0) {
            if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name4)) !== void 0) {
              return ret;
            }
            return elem[name4] = value;
          }
          if (hooks && "get" in hooks && (ret = hooks.get(elem, name4)) !== null) {
            return ret;
          }
          return elem[name4];
        },
        propHooks: {
          tabIndex: {
            get: function(elem) {
              var tabindex = jQuery2.find.attr(elem, "tabindex");
              if (tabindex) {
                return parseInt(tabindex, 10);
              }
              if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
                return 0;
              }
              return -1;
            }
          }
        },
        propFix: {
          "for": "htmlFor",
          "class": "className"
        }
      });
      if (!support.optSelected) {
        jQuery2.propHooks.selected = {
          get: function(elem) {
            var parent2 = elem.parentNode;
            if (parent2 && parent2.parentNode) {
              parent2.parentNode.selectedIndex;
            }
            return null;
          },
          set: function(elem) {
            var parent2 = elem.parentNode;
            if (parent2) {
              parent2.selectedIndex;
              if (parent2.parentNode) {
                parent2.parentNode.selectedIndex;
              }
            }
          }
        };
      }
      jQuery2.each([
        "tabIndex",
        "readOnly",
        "maxLength",
        "cellSpacing",
        "cellPadding",
        "rowSpan",
        "colSpan",
        "useMap",
        "frameBorder",
        "contentEditable"
      ], function() {
        jQuery2.propFix[this.toLowerCase()] = this;
      });
      function stripAndCollapse(value) {
        var tokens = value.match(rnothtmlwhite) || [];
        return tokens.join(" ");
      }
      function getClass(elem) {
        return elem.getAttribute && elem.getAttribute("class") || "";
      }
      function classesToArray(value) {
        if (Array.isArray(value)) {
          return value;
        }
        if (typeof value === "string") {
          return value.match(rnothtmlwhite) || [];
        }
        return [];
      }
      jQuery2.fn.extend({
        addClass: function(value) {
          var classNames, cur, curValue, className, i2, finalValue;
          if (isFunction4(value)) {
            return this.each(function(j2) {
              jQuery2(this).addClass(value.call(this, j2, getClass(this)));
            });
          }
          classNames = classesToArray(value);
          if (classNames.length) {
            return this.each(function() {
              curValue = getClass(this);
              cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
              if (cur) {
                for (i2 = 0; i2 < classNames.length; i2++) {
                  className = classNames[i2];
                  if (cur.indexOf(" " + className + " ") < 0) {
                    cur += className + " ";
                  }
                }
                finalValue = stripAndCollapse(cur);
                if (curValue !== finalValue) {
                  this.setAttribute("class", finalValue);
                }
              }
            });
          }
          return this;
        },
        removeClass: function(value) {
          var classNames, cur, curValue, className, i2, finalValue;
          if (isFunction4(value)) {
            return this.each(function(j2) {
              jQuery2(this).removeClass(value.call(this, j2, getClass(this)));
            });
          }
          if (!arguments.length) {
            return this.attr("class", "");
          }
          classNames = classesToArray(value);
          if (classNames.length) {
            return this.each(function() {
              curValue = getClass(this);
              cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
              if (cur) {
                for (i2 = 0; i2 < classNames.length; i2++) {
                  className = classNames[i2];
                  while (cur.indexOf(" " + className + " ") > -1) {
                    cur = cur.replace(" " + className + " ", " ");
                  }
                }
                finalValue = stripAndCollapse(cur);
                if (curValue !== finalValue) {
                  this.setAttribute("class", finalValue);
                }
              }
            });
          }
          return this;
        },
        toggleClass: function(value, stateVal) {
          var classNames, className, i2, self2, type = typeof value, isValidValue = type === "string" || Array.isArray(value);
          if (isFunction4(value)) {
            return this.each(function(i3) {
              jQuery2(this).toggleClass(
                value.call(this, i3, getClass(this), stateVal),
                stateVal
              );
            });
          }
          if (typeof stateVal === "boolean" && isValidValue) {
            return stateVal ? this.addClass(value) : this.removeClass(value);
          }
          classNames = classesToArray(value);
          return this.each(function() {
            if (isValidValue) {
              self2 = jQuery2(this);
              for (i2 = 0; i2 < classNames.length; i2++) {
                className = classNames[i2];
                if (self2.hasClass(className)) {
                  self2.removeClass(className);
                } else {
                  self2.addClass(className);
                }
              }
            } else if (value === void 0 || type === "boolean") {
              className = getClass(this);
              if (className) {
                dataPriv.set(this, "__className__", className);
              }
              if (this.setAttribute) {
                this.setAttribute(
                  "class",
                  className || value === false ? "" : dataPriv.get(this, "__className__") || ""
                );
              }
            }
          });
        },
        hasClass: function(selector) {
          var className, elem, i2 = 0;
          className = " " + selector + " ";
          while (elem = this[i2++]) {
            if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
              return true;
            }
          }
          return false;
        }
      });
      var rreturn = /\r/g;
      jQuery2.fn.extend({
        val: function(value) {
          var hooks, ret, valueIsFunction, elem = this[0];
          if (!arguments.length) {
            if (elem) {
              hooks = jQuery2.valHooks[elem.type] || jQuery2.valHooks[elem.nodeName.toLowerCase()];
              if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== void 0) {
                return ret;
              }
              ret = elem.value;
              if (typeof ret === "string") {
                return ret.replace(rreturn, "");
              }
              return ret == null ? "" : ret;
            }
            return;
          }
          valueIsFunction = isFunction4(value);
          return this.each(function(i2) {
            var val;
            if (this.nodeType !== 1) {
              return;
            }
            if (valueIsFunction) {
              val = value.call(this, i2, jQuery2(this).val());
            } else {
              val = value;
            }
            if (val == null) {
              val = "";
            } else if (typeof val === "number") {
              val += "";
            } else if (Array.isArray(val)) {
              val = jQuery2.map(val, function(value2) {
                return value2 == null ? "" : value2 + "";
              });
            }
            hooks = jQuery2.valHooks[this.type] || jQuery2.valHooks[this.nodeName.toLowerCase()];
            if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === void 0) {
              this.value = val;
            }
          });
        }
      });
      jQuery2.extend({
        valHooks: {
          option: {
            get: function(elem) {
              var val = jQuery2.find.attr(elem, "value");
              return val != null ? val : (
                // Support: IE <=10 - 11 only
                // option.text throws exceptions (trac-14686, trac-14858)
                // Strip and collapse whitespace
                // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                stripAndCollapse(jQuery2.text(elem))
              );
            }
          },
          select: {
            get: function(elem) {
              var value, option, i2, options = elem.options, index = elem.selectedIndex, one = elem.type === "select-one", values = one ? null : [], max = one ? index + 1 : options.length;
              if (index < 0) {
                i2 = max;
              } else {
                i2 = one ? index : 0;
              }
              for (; i2 < max; i2++) {
                option = options[i2];
                if ((option.selected || i2 === index) && // Don't return options that are disabled or in a disabled optgroup
                !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                  value = jQuery2(option).val();
                  if (one) {
                    return value;
                  }
                  values.push(value);
                }
              }
              return values;
            },
            set: function(elem, value) {
              var optionSet, option, options = elem.options, values = jQuery2.makeArray(value), i2 = options.length;
              while (i2--) {
                option = options[i2];
                if (option.selected = jQuery2.inArray(jQuery2.valHooks.option.get(option), values) > -1) {
                  optionSet = true;
                }
              }
              if (!optionSet) {
                elem.selectedIndex = -1;
              }
              return values;
            }
          }
        }
      });
      jQuery2.each(["radio", "checkbox"], function() {
        jQuery2.valHooks[this] = {
          set: function(elem, value) {
            if (Array.isArray(value)) {
              return elem.checked = jQuery2.inArray(jQuery2(elem).val(), value) > -1;
            }
          }
        };
        if (!support.checkOn) {
          jQuery2.valHooks[this].get = function(elem) {
            return elem.getAttribute("value") === null ? "on" : elem.value;
          };
        }
      });
      var location = window2.location;
      var nonce = { guid: Date.now() };
      var rquery = /\?/;
      jQuery2.parseXML = function(data) {
        var xml, parserErrorElem;
        if (!data || typeof data !== "string") {
          return null;
        }
        try {
          xml = new window2.DOMParser().parseFromString(data, "text/xml");
        } catch (e) {
        }
        parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];
        if (!xml || parserErrorElem) {
          jQuery2.error("Invalid XML: " + (parserErrorElem ? jQuery2.map(parserErrorElem.childNodes, function(el) {
            return el.textContent;
          }).join("\n") : data));
        }
        return xml;
      };
      var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e) {
        e.stopPropagation();
      };
      jQuery2.extend(jQuery2.event, {
        trigger: function(event, data, elem, onlyHandlers) {
          var i2, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [elem || document2], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
          cur = lastElement = tmp = elem = elem || document2;
          if (elem.nodeType === 3 || elem.nodeType === 8) {
            return;
          }
          if (rfocusMorph.test(type + jQuery2.event.triggered)) {
            return;
          }
          if (type.indexOf(".") > -1) {
            namespaces = type.split(".");
            type = namespaces.shift();
            namespaces.sort();
          }
          ontype = type.indexOf(":") < 0 && "on" + type;
          event = event[jQuery2.expando] ? event : new jQuery2.Event(type, typeof event === "object" && event);
          event.isTrigger = onlyHandlers ? 2 : 3;
          event.namespace = namespaces.join(".");
          event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
          event.result = void 0;
          if (!event.target) {
            event.target = elem;
          }
          data = data == null ? [event] : jQuery2.makeArray(data, [event]);
          special = jQuery2.event.special[type] || {};
          if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
            return;
          }
          if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
            bubbleType = special.delegateType || type;
            if (!rfocusMorph.test(bubbleType + type)) {
              cur = cur.parentNode;
            }
            for (; cur; cur = cur.parentNode) {
              eventPath.push(cur);
              tmp = cur;
            }
            if (tmp === (elem.ownerDocument || document2)) {
              eventPath.push(tmp.defaultView || tmp.parentWindow || window2);
            }
          }
          i2 = 0;
          while ((cur = eventPath[i2++]) && !event.isPropagationStopped()) {
            lastElement = cur;
            event.type = i2 > 1 ? bubbleType : special.bindType || type;
            handle = (dataPriv.get(cur, "events") || /* @__PURE__ */ Object.create(null))[event.type] && dataPriv.get(cur, "handle");
            if (handle) {
              handle.apply(cur, data);
            }
            handle = ontype && cur[ontype];
            if (handle && handle.apply && acceptData(cur)) {
              event.result = handle.apply(cur, data);
              if (event.result === false) {
                event.preventDefault();
              }
            }
          }
          event.type = type;
          if (!onlyHandlers && !event.isDefaultPrevented()) {
            if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
              if (ontype && isFunction4(elem[type]) && !isWindow(elem)) {
                tmp = elem[ontype];
                if (tmp) {
                  elem[ontype] = null;
                }
                jQuery2.event.triggered = type;
                if (event.isPropagationStopped()) {
                  lastElement.addEventListener(type, stopPropagationCallback);
                }
                elem[type]();
                if (event.isPropagationStopped()) {
                  lastElement.removeEventListener(type, stopPropagationCallback);
                }
                jQuery2.event.triggered = void 0;
                if (tmp) {
                  elem[ontype] = tmp;
                }
              }
            }
          }
          return event.result;
        },
        // Piggyback on a donor event to simulate a different one
        // Used only for `focus(in | out)` events
        simulate: function(type, elem, event) {
          var e = jQuery2.extend(
            new jQuery2.Event(),
            event,
            {
              type,
              isSimulated: true
            }
          );
          jQuery2.event.trigger(e, null, elem);
        }
      });
      jQuery2.fn.extend({
        trigger: function(type, data) {
          return this.each(function() {
            jQuery2.event.trigger(type, data, this);
          });
        },
        triggerHandler: function(type, data) {
          var elem = this[0];
          if (elem) {
            return jQuery2.event.trigger(type, data, elem, true);
          }
        }
      });
      var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
      function buildParams(prefix, obj, traditional, add) {
        var name4;
        if (Array.isArray(obj)) {
          jQuery2.each(obj, function(i2, v2) {
            if (traditional || rbracket.test(prefix)) {
              add(prefix, v2);
            } else {
              buildParams(
                prefix + "[" + (typeof v2 === "object" && v2 != null ? i2 : "") + "]",
                v2,
                traditional,
                add
              );
            }
          });
        } else if (!traditional && toType(obj) === "object") {
          for (name4 in obj) {
            buildParams(prefix + "[" + name4 + "]", obj[name4], traditional, add);
          }
        } else {
          add(prefix, obj);
        }
      }
      jQuery2.param = function(a, traditional) {
        var prefix, s = [], add = function(key, valueOrFunction) {
          var value = isFunction4(valueOrFunction) ? valueOrFunction() : valueOrFunction;
          s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
        };
        if (a == null) {
          return "";
        }
        if (Array.isArray(a) || a.jquery && !jQuery2.isPlainObject(a)) {
          jQuery2.each(a, function() {
            add(this.name, this.value);
          });
        } else {
          for (prefix in a) {
            buildParams(prefix, a[prefix], traditional, add);
          }
        }
        return s.join("&");
      };
      jQuery2.fn.extend({
        serialize: function() {
          return jQuery2.param(this.serializeArray());
        },
        serializeArray: function() {
          return this.map(function() {
            var elements = jQuery2.prop(this, "elements");
            return elements ? jQuery2.makeArray(elements) : this;
          }).filter(function() {
            var type = this.type;
            return this.name && !jQuery2(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
          }).map(function(_i2, elem) {
            var val = jQuery2(this).val();
            if (val == null) {
              return null;
            }
            if (Array.isArray(val)) {
              return jQuery2.map(val, function(val2) {
                return { name: elem.name, value: val2.replace(rCRLF, "\r\n") };
              });
            }
            return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
          }).get();
        }
      });
      var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), originAnchor = document2.createElement("a");
      originAnchor.href = location.href;
      function addToPrefiltersOrTransports(structure) {
        return function(dataTypeExpression, func) {
          if (typeof dataTypeExpression !== "string") {
            func = dataTypeExpression;
            dataTypeExpression = "*";
          }
          var dataType, i2 = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
          if (isFunction4(func)) {
            while (dataType = dataTypes[i2++]) {
              if (dataType[0] === "+") {
                dataType = dataType.slice(1) || "*";
                (structure[dataType] = structure[dataType] || []).unshift(func);
              } else {
                (structure[dataType] = structure[dataType] || []).push(func);
              }
            }
          }
        };
      }
      function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {}, seekingTransport = structure === transports;
        function inspect(dataType) {
          var selected;
          inspected[dataType] = true;
          jQuery2.each(structure[dataType] || [], function(_2, prefilterOrFactory) {
            var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
            if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
              options.dataTypes.unshift(dataTypeOrTransport);
              inspect(dataTypeOrTransport);
              return false;
            } else if (seekingTransport) {
              return !(selected = dataTypeOrTransport);
            }
          });
          return selected;
        }
        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
      }
      function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery2.ajaxSettings.flatOptions || {};
        for (key in src) {
          if (src[key] !== void 0) {
            (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
          }
        }
        if (deep) {
          jQuery2.extend(true, target, deep);
        }
        return target;
      }
      function ajaxHandleResponses(s, jqXHR, responses) {
        var ct2, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
        while (dataTypes[0] === "*") {
          dataTypes.shift();
          if (ct2 === void 0) {
            ct2 = s.mimeType || jqXHR.getResponseHeader("Content-Type");
          }
        }
        if (ct2) {
          for (type in contents) {
            if (contents[type] && contents[type].test(ct2)) {
              dataTypes.unshift(type);
              break;
            }
          }
        }
        if (dataTypes[0] in responses) {
          finalDataType = dataTypes[0];
        } else {
          for (type in responses) {
            if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
              finalDataType = type;
              break;
            }
            if (!firstDataType) {
              firstDataType = type;
            }
          }
          finalDataType = finalDataType || firstDataType;
        }
        if (finalDataType) {
          if (finalDataType !== dataTypes[0]) {
            dataTypes.unshift(finalDataType);
          }
          return responses[finalDataType];
        }
      }
      function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
        if (dataTypes[1]) {
          for (conv in s.converters) {
            converters[conv.toLowerCase()] = s.converters[conv];
          }
        }
        current = dataTypes.shift();
        while (current) {
          if (s.responseFields[current]) {
            jqXHR[s.responseFields[current]] = response;
          }
          if (!prev && isSuccess && s.dataFilter) {
            response = s.dataFilter(response, s.dataType);
          }
          prev = current;
          current = dataTypes.shift();
          if (current) {
            if (current === "*") {
              current = prev;
            } else if (prev !== "*" && prev !== current) {
              conv = converters[prev + " " + current] || converters["* " + current];
              if (!conv) {
                for (conv2 in converters) {
                  tmp = conv2.split(" ");
                  if (tmp[1] === current) {
                    conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                    if (conv) {
                      if (conv === true) {
                        conv = converters[conv2];
                      } else if (converters[conv2] !== true) {
                        current = tmp[0];
                        dataTypes.unshift(tmp[1]);
                      }
                      break;
                    }
                  }
                }
              }
              if (conv !== true) {
                if (conv && s.throws) {
                  response = conv(response);
                } else {
                  try {
                    response = conv(response);
                  } catch (e) {
                    return {
                      state: "parsererror",
                      error: conv ? e : "No conversion from " + prev + " to " + current
                    };
                  }
                }
              }
            }
          }
        }
        return { state: "success", data: response };
      }
      jQuery2.extend({
        // Counter for holding the number of active queries
        active: 0,
        // Last-Modified header cache for next request
        lastModified: {},
        etag: {},
        ajaxSettings: {
          url: location.href,
          type: "GET",
          isLocal: rlocalProtocol.test(location.protocol),
          global: true,
          processData: true,
          async: true,
          contentType: "application/x-www-form-urlencoded; charset=UTF-8",
          /*
          timeout: 0,
          data: null,
          dataType: null,
          username: null,
          password: null,
          cache: null,
          throws: false,
          traditional: false,
          headers: {},
          */
          accepts: {
            "*": allTypes,
            text: "text/plain",
            html: "text/html",
            xml: "application/xml, text/xml",
            json: "application/json, text/javascript"
          },
          contents: {
            xml: /\bxml\b/,
            html: /\bhtml/,
            json: /\bjson\b/
          },
          responseFields: {
            xml: "responseXML",
            text: "responseText",
            json: "responseJSON"
          },
          // Data converters
          // Keys separate source (or catchall "*") and destination types with a single space
          converters: {
            // Convert anything to text
            "* text": String,
            // Text to html (true = no transformation)
            "text html": true,
            // Evaluate text as a json expression
            "text json": JSON.parse,
            // Parse text as xml
            "text xml": jQuery2.parseXML
          },
          // For options that shouldn't be deep extended:
          // you can add your own custom options here if
          // and when you create one that shouldn't be
          // deep extended (see ajaxExtend)
          flatOptions: {
            url: true,
            context: true
          }
        },
        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function(target, settings) {
          return settings ? (
            // Building a settings object
            ajaxExtend(ajaxExtend(target, jQuery2.ajaxSettings), settings)
          ) : (
            // Extending ajaxSettings
            ajaxExtend(jQuery2.ajaxSettings, target)
          );
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        // Main method
        ajax: function(url, options) {
          if (typeof url === "object") {
            options = url;
            url = void 0;
          }
          options = options || {};
          var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed2, fireGlobals, i2, uncached, s = jQuery2.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery2(callbackContext) : jQuery2.event, deferred = jQuery2.Deferred(), completeDeferred = jQuery2.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
            readyState: 0,
            // Builds headers hashtable if needed
            getResponseHeader: function(key) {
              var match;
              if (completed2) {
                if (!responseHeaders) {
                  responseHeaders = {};
                  while (match = rheaders.exec(responseHeadersString)) {
                    responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
                  }
                }
                match = responseHeaders[key.toLowerCase() + " "];
              }
              return match == null ? null : match.join(", ");
            },
            // Raw string
            getAllResponseHeaders: function() {
              return completed2 ? responseHeadersString : null;
            },
            // Caches the header
            setRequestHeader: function(name4, value) {
              if (completed2 == null) {
                name4 = requestHeadersNames[name4.toLowerCase()] = requestHeadersNames[name4.toLowerCase()] || name4;
                requestHeaders[name4] = value;
              }
              return this;
            },
            // Overrides response content-type header
            overrideMimeType: function(type) {
              if (completed2 == null) {
                s.mimeType = type;
              }
              return this;
            },
            // Status-dependent callbacks
            statusCode: function(map3) {
              var code;
              if (map3) {
                if (completed2) {
                  jqXHR.always(map3[jqXHR.status]);
                } else {
                  for (code in map3) {
                    statusCode[code] = [statusCode[code], map3[code]];
                  }
                }
              }
              return this;
            },
            // Cancel the request
            abort: function(statusText) {
              var finalText = statusText || strAbort;
              if (transport) {
                transport.abort(finalText);
              }
              done(0, finalText);
              return this;
            }
          };
          deferred.promise(jqXHR);
          s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//");
          s.type = options.method || options.type || s.method || s.type;
          s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
          if (s.crossDomain == null) {
            urlAnchor = document2.createElement("a");
            try {
              urlAnchor.href = s.url;
              urlAnchor.href = urlAnchor.href;
              s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
            } catch (e) {
              s.crossDomain = true;
            }
          }
          if (s.data && s.processData && typeof s.data !== "string") {
            s.data = jQuery2.param(s.data, s.traditional);
          }
          inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
          if (completed2) {
            return jqXHR;
          }
          fireGlobals = jQuery2.event && s.global;
          if (fireGlobals && jQuery2.active++ === 0) {
            jQuery2.event.trigger("ajaxStart");
          }
          s.type = s.type.toUpperCase();
          s.hasContent = !rnoContent.test(s.type);
          cacheURL = s.url.replace(rhash, "");
          if (!s.hasContent) {
            uncached = s.url.slice(cacheURL.length);
            if (s.data && (s.processData || typeof s.data === "string")) {
              cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;
              delete s.data;
            }
            if (s.cache === false) {
              cacheURL = cacheURL.replace(rantiCache, "$1");
              uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
            }
            s.url = cacheURL + uncached;
          } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
            s.data = s.data.replace(r20, "+");
          }
          if (s.ifModified) {
            if (jQuery2.lastModified[cacheURL]) {
              jqXHR.setRequestHeader("If-Modified-Since", jQuery2.lastModified[cacheURL]);
            }
            if (jQuery2.etag[cacheURL]) {
              jqXHR.setRequestHeader("If-None-Match", jQuery2.etag[cacheURL]);
            }
          }
          if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
            jqXHR.setRequestHeader("Content-Type", s.contentType);
          }
          jqXHR.setRequestHeader(
            "Accept",
            s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]
          );
          for (i2 in s.headers) {
            jqXHR.setRequestHeader(i2, s.headers[i2]);
          }
          if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed2)) {
            return jqXHR.abort();
          }
          strAbort = "abort";
          completeDeferred.add(s.complete);
          jqXHR.done(s.success);
          jqXHR.fail(s.error);
          transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
          if (!transport) {
            done(-1, "No Transport");
          } else {
            jqXHR.readyState = 1;
            if (fireGlobals) {
              globalEventContext.trigger("ajaxSend", [jqXHR, s]);
            }
            if (completed2) {
              return jqXHR;
            }
            if (s.async && s.timeout > 0) {
              timeoutTimer = window2.setTimeout(function() {
                jqXHR.abort("timeout");
              }, s.timeout);
            }
            try {
              completed2 = false;
              transport.send(requestHeaders, done);
            } catch (e) {
              if (completed2) {
                throw e;
              }
              done(-1, e);
            }
          }
          function done(status, nativeStatusText, responses, headers) {
            var isSuccess, success, error, response, modified, statusText = nativeStatusText;
            if (completed2) {
              return;
            }
            completed2 = true;
            if (timeoutTimer) {
              window2.clearTimeout(timeoutTimer);
            }
            transport = void 0;
            responseHeadersString = headers || "";
            jqXHR.readyState = status > 0 ? 4 : 0;
            isSuccess = status >= 200 && status < 300 || status === 304;
            if (responses) {
              response = ajaxHandleResponses(s, jqXHR, responses);
            }
            if (!isSuccess && jQuery2.inArray("script", s.dataTypes) > -1 && jQuery2.inArray("json", s.dataTypes) < 0) {
              s.converters["text script"] = function() {
              };
            }
            response = ajaxConvert(s, response, jqXHR, isSuccess);
            if (isSuccess) {
              if (s.ifModified) {
                modified = jqXHR.getResponseHeader("Last-Modified");
                if (modified) {
                  jQuery2.lastModified[cacheURL] = modified;
                }
                modified = jqXHR.getResponseHeader("etag");
                if (modified) {
                  jQuery2.etag[cacheURL] = modified;
                }
              }
              if (status === 204 || s.type === "HEAD") {
                statusText = "nocontent";
              } else if (status === 304) {
                statusText = "notmodified";
              } else {
                statusText = response.state;
                success = response.data;
                error = response.error;
                isSuccess = !error;
              }
            } else {
              error = statusText;
              if (status || !statusText) {
                statusText = "error";
                if (status < 0) {
                  status = 0;
                }
              }
            }
            jqXHR.status = status;
            jqXHR.statusText = (nativeStatusText || statusText) + "";
            if (isSuccess) {
              deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
            } else {
              deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
            }
            jqXHR.statusCode(statusCode);
            statusCode = void 0;
            if (fireGlobals) {
              globalEventContext.trigger(
                isSuccess ? "ajaxSuccess" : "ajaxError",
                [jqXHR, s, isSuccess ? success : error]
              );
            }
            completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
            if (fireGlobals) {
              globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
              if (!--jQuery2.active) {
                jQuery2.event.trigger("ajaxStop");
              }
            }
          }
          return jqXHR;
        },
        getJSON: function(url, data, callback) {
          return jQuery2.get(url, data, callback, "json");
        },
        getScript: function(url, callback) {
          return jQuery2.get(url, void 0, callback, "script");
        }
      });
      jQuery2.each(["get", "post"], function(_i2, method) {
        jQuery2[method] = function(url, data, callback, type) {
          if (isFunction4(data)) {
            type = type || callback;
            callback = data;
            data = void 0;
          }
          return jQuery2.ajax(jQuery2.extend({
            url,
            type: method,
            dataType: type,
            data,
            success: callback
          }, jQuery2.isPlainObject(url) && url));
        };
      });
      jQuery2.ajaxPrefilter(function(s) {
        var i2;
        for (i2 in s.headers) {
          if (i2.toLowerCase() === "content-type") {
            s.contentType = s.headers[i2] || "";
          }
        }
      });
      jQuery2._evalUrl = function(url, options, doc) {
        return jQuery2.ajax({
          url,
          // Make this explicit, since user can override this through ajaxSetup (trac-11264)
          type: "GET",
          dataType: "script",
          cache: true,
          async: false,
          global: false,
          // Only evaluate the response if it is successful (gh-4126)
          // dataFilter is not invoked for failure responses, so using it instead
          // of the default converter is kludgy but it works.
          converters: {
            "text script": function() {
            }
          },
          dataFilter: function(response) {
            jQuery2.globalEval(response, options, doc);
          }
        });
      };
      jQuery2.fn.extend({
        wrapAll: function(html) {
          var wrap;
          if (this[0]) {
            if (isFunction4(html)) {
              html = html.call(this[0]);
            }
            wrap = jQuery2(html, this[0].ownerDocument).eq(0).clone(true);
            if (this[0].parentNode) {
              wrap.insertBefore(this[0]);
            }
            wrap.map(function() {
              var elem = this;
              while (elem.firstElementChild) {
                elem = elem.firstElementChild;
              }
              return elem;
            }).append(this);
          }
          return this;
        },
        wrapInner: function(html) {
          if (isFunction4(html)) {
            return this.each(function(i2) {
              jQuery2(this).wrapInner(html.call(this, i2));
            });
          }
          return this.each(function() {
            var self2 = jQuery2(this), contents = self2.contents();
            if (contents.length) {
              contents.wrapAll(html);
            } else {
              self2.append(html);
            }
          });
        },
        wrap: function(html) {
          var htmlIsFunction = isFunction4(html);
          return this.each(function(i2) {
            jQuery2(this).wrapAll(htmlIsFunction ? html.call(this, i2) : html);
          });
        },
        unwrap: function(selector) {
          this.parent(selector).not("body").each(function() {
            jQuery2(this).replaceWith(this.childNodes);
          });
          return this;
        }
      });
      jQuery2.expr.pseudos.hidden = function(elem) {
        return !jQuery2.expr.pseudos.visible(elem);
      };
      jQuery2.expr.pseudos.visible = function(elem) {
        return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
      };
      jQuery2.ajaxSettings.xhr = function() {
        try {
          return new window2.XMLHttpRequest();
        } catch (e) {
        }
      };
      var xhrSuccessStatus = {
        // File protocol always yields status code 0, assume 200
        0: 200,
        // Support: IE <=9 only
        // trac-1450: sometimes IE returns 1223 when it should be 204
        1223: 204
      }, xhrSupported = jQuery2.ajaxSettings.xhr();
      support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
      support.ajax = xhrSupported = !!xhrSupported;
      jQuery2.ajaxTransport(function(options) {
        var callback, errorCallback;
        if (support.cors || xhrSupported && !options.crossDomain) {
          return {
            send: function(headers, complete) {
              var i2, xhr = options.xhr();
              xhr.open(
                options.type,
                options.url,
                options.async,
                options.username,
                options.password
              );
              if (options.xhrFields) {
                for (i2 in options.xhrFields) {
                  xhr[i2] = options.xhrFields[i2];
                }
              }
              if (options.mimeType && xhr.overrideMimeType) {
                xhr.overrideMimeType(options.mimeType);
              }
              if (!options.crossDomain && !headers["X-Requested-With"]) {
                headers["X-Requested-With"] = "XMLHttpRequest";
              }
              for (i2 in headers) {
                xhr.setRequestHeader(i2, headers[i2]);
              }
              callback = function(type) {
                return function() {
                  if (callback) {
                    callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                    if (type === "abort") {
                      xhr.abort();
                    } else if (type === "error") {
                      if (typeof xhr.status !== "number") {
                        complete(0, "error");
                      } else {
                        complete(
                          // File: protocol always yields status 0; see trac-8605, trac-14207
                          xhr.status,
                          xhr.statusText
                        );
                      }
                    } else {
                      complete(
                        xhrSuccessStatus[xhr.status] || xhr.status,
                        xhr.statusText,
                        // Support: IE <=9 only
                        // IE9 has no XHR2 but throws on binary (trac-11426)
                        // For XHR2 non-text, let the caller handle it (gh-2498)
                        (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText },
                        xhr.getAllResponseHeaders()
                      );
                    }
                  }
                };
              };
              xhr.onload = callback();
              errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
              if (xhr.onabort !== void 0) {
                xhr.onabort = errorCallback;
              } else {
                xhr.onreadystatechange = function() {
                  if (xhr.readyState === 4) {
                    window2.setTimeout(function() {
                      if (callback) {
                        errorCallback();
                      }
                    });
                  }
                };
              }
              callback = callback("abort");
              try {
                xhr.send(options.hasContent && options.data || null);
              } catch (e) {
                if (callback) {
                  throw e;
                }
              }
            },
            abort: function() {
              if (callback) {
                callback();
              }
            }
          };
        }
      });
      jQuery2.ajaxPrefilter(function(s) {
        if (s.crossDomain) {
          s.contents.script = false;
        }
      });
      jQuery2.ajaxSetup({
        accepts: {
          script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
          script: /\b(?:java|ecma)script\b/
        },
        converters: {
          "text script": function(text) {
            jQuery2.globalEval(text);
            return text;
          }
        }
      });
      jQuery2.ajaxPrefilter("script", function(s) {
        if (s.cache === void 0) {
          s.cache = false;
        }
        if (s.crossDomain) {
          s.type = "GET";
        }
      });
      jQuery2.ajaxTransport("script", function(s) {
        if (s.crossDomain || s.scriptAttrs) {
          var script, callback;
          return {
            send: function(_2, complete) {
              script = jQuery2("<script>").attr(s.scriptAttrs || {}).prop({ charset: s.scriptCharset, src: s.url }).on("load error", callback = function(evt) {
                script.remove();
                callback = null;
                if (evt) {
                  complete(evt.type === "error" ? 404 : 200, evt.type);
                }
              });
              document2.head.appendChild(script[0]);
            },
            abort: function() {
              if (callback) {
                callback();
              }
            }
          };
        }
      });
      var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
      jQuery2.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
          var callback = oldCallbacks.pop() || jQuery2.expando + "_" + nonce.guid++;
          this[callback] = true;
          return callback;
        }
      });
      jQuery2.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
        if (jsonProp || s.dataTypes[0] === "jsonp") {
          callbackName = s.jsonpCallback = isFunction4(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
          if (jsonProp) {
            s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
          } else if (s.jsonp !== false) {
            s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
          }
          s.converters["script json"] = function() {
            if (!responseContainer) {
              jQuery2.error(callbackName + " was not called");
            }
            return responseContainer[0];
          };
          s.dataTypes[0] = "json";
          overwritten = window2[callbackName];
          window2[callbackName] = function() {
            responseContainer = arguments;
          };
          jqXHR.always(function() {
            if (overwritten === void 0) {
              jQuery2(window2).removeProp(callbackName);
            } else {
              window2[callbackName] = overwritten;
            }
            if (s[callbackName]) {
              s.jsonpCallback = originalSettings.jsonpCallback;
              oldCallbacks.push(callbackName);
            }
            if (responseContainer && isFunction4(overwritten)) {
              overwritten(responseContainer[0]);
            }
            responseContainer = overwritten = void 0;
          });
          return "script";
        }
      });
      support.createHTMLDocument = function() {
        var body = document2.implementation.createHTMLDocument("").body;
        body.innerHTML = "<form></form><form></form>";
        return body.childNodes.length === 2;
      }();
      jQuery2.parseHTML = function(data, context, keepScripts) {
        if (typeof data !== "string") {
          return [];
        }
        if (typeof context === "boolean") {
          keepScripts = context;
          context = false;
        }
        var base, parsed, scripts;
        if (!context) {
          if (support.createHTMLDocument) {
            context = document2.implementation.createHTMLDocument("");
            base = context.createElement("base");
            base.href = document2.location.href;
            context.head.appendChild(base);
          } else {
            context = document2;
          }
        }
        parsed = rsingleTag.exec(data);
        scripts = !keepScripts && [];
        if (parsed) {
          return [context.createElement(parsed[1])];
        }
        parsed = buildFragment([data], context, scripts);
        if (scripts && scripts.length) {
          jQuery2(scripts).remove();
        }
        return jQuery2.merge([], parsed.childNodes);
      };
      jQuery2.fn.load = function(url, params, callback) {
        var selector, type, response, self2 = this, off = url.indexOf(" ");
        if (off > -1) {
          selector = stripAndCollapse(url.slice(off));
          url = url.slice(0, off);
        }
        if (isFunction4(params)) {
          callback = params;
          params = void 0;
        } else if (params && typeof params === "object") {
          type = "POST";
        }
        if (self2.length > 0) {
          jQuery2.ajax({
            url,
            // If "type" variable is undefined, then "GET" method will be used.
            // Make value of this field explicit since
            // user can override it through ajaxSetup method
            type: type || "GET",
            dataType: "html",
            data: params
          }).done(function(responseText) {
            response = arguments;
            self2.html(selector ? (
              // If a selector was specified, locate the right elements in a dummy div
              // Exclude scripts to avoid IE 'Permission Denied' errors
              jQuery2("<div>").append(jQuery2.parseHTML(responseText)).find(selector)
            ) : (
              // Otherwise use the full result
              responseText
            ));
          }).always(callback && function(jqXHR, status) {
            self2.each(function() {
              callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
            });
          });
        }
        return this;
      };
      jQuery2.expr.pseudos.animated = function(elem) {
        return jQuery2.grep(jQuery2.timers, function(fn2) {
          return elem === fn2.elem;
        }).length;
      };
      jQuery2.offset = {
        setOffset: function(elem, options, i2) {
          var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery2.css(elem, "position"), curElem = jQuery2(elem), props = {};
          if (position === "static") {
            elem.style.position = "relative";
          }
          curOffset = curElem.offset();
          curCSSTop = jQuery2.css(elem, "top");
          curCSSLeft = jQuery2.css(elem, "left");
          calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
          if (calculatePosition) {
            curPosition = curElem.position();
            curTop = curPosition.top;
            curLeft = curPosition.left;
          } else {
            curTop = parseFloat(curCSSTop) || 0;
            curLeft = parseFloat(curCSSLeft) || 0;
          }
          if (isFunction4(options)) {
            options = options.call(elem, i2, jQuery2.extend({}, curOffset));
          }
          if (options.top != null) {
            props.top = options.top - curOffset.top + curTop;
          }
          if (options.left != null) {
            props.left = options.left - curOffset.left + curLeft;
          }
          if ("using" in options) {
            options.using.call(elem, props);
          } else {
            curElem.css(props);
          }
        }
      };
      jQuery2.fn.extend({
        // offset() relates an element's border box to the document origin
        offset: function(options) {
          if (arguments.length) {
            return options === void 0 ? this : this.each(function(i2) {
              jQuery2.offset.setOffset(this, options, i2);
            });
          }
          var rect, win, elem = this[0];
          if (!elem) {
            return;
          }
          if (!elem.getClientRects().length) {
            return { top: 0, left: 0 };
          }
          rect = elem.getBoundingClientRect();
          win = elem.ownerDocument.defaultView;
          return {
            top: rect.top + win.pageYOffset,
            left: rect.left + win.pageXOffset
          };
        },
        // position() relates an element's margin box to its offset parent's padding box
        // This corresponds to the behavior of CSS absolute positioning
        position: function() {
          if (!this[0]) {
            return;
          }
          var offsetParent, offset2, doc, elem = this[0], parentOffset = { top: 0, left: 0 };
          if (jQuery2.css(elem, "position") === "fixed") {
            offset2 = elem.getBoundingClientRect();
          } else {
            offset2 = this.offset();
            doc = elem.ownerDocument;
            offsetParent = elem.offsetParent || doc.documentElement;
            while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery2.css(offsetParent, "position") === "static") {
              offsetParent = offsetParent.parentNode;
            }
            if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
              parentOffset = jQuery2(offsetParent).offset();
              parentOffset.top += jQuery2.css(offsetParent, "borderTopWidth", true);
              parentOffset.left += jQuery2.css(offsetParent, "borderLeftWidth", true);
            }
          }
          return {
            top: offset2.top - parentOffset.top - jQuery2.css(elem, "marginTop", true),
            left: offset2.left - parentOffset.left - jQuery2.css(elem, "marginLeft", true)
          };
        },
        // This method will return documentElement in the following cases:
        // 1) For the element inside the iframe without offsetParent, this method will return
        //    documentElement of the parent window
        // 2) For the hidden or detached element
        // 3) For body or html element, i.e. in case of the html node - it will return itself
        //
        // but those exceptions were never presented as a real life use-cases
        // and might be considered as more preferable results.
        //
        // This logic, however, is not guaranteed and can change at any point in the future
        offsetParent: function() {
          return this.map(function() {
            var offsetParent = this.offsetParent;
            while (offsetParent && jQuery2.css(offsetParent, "position") === "static") {
              offsetParent = offsetParent.offsetParent;
            }
            return offsetParent || documentElement;
          });
        }
      });
      jQuery2.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(method, prop) {
        var top = "pageYOffset" === prop;
        jQuery2.fn[method] = function(val) {
          return access(this, function(elem, method2, val2) {
            var win;
            if (isWindow(elem)) {
              win = elem;
            } else if (elem.nodeType === 9) {
              win = elem.defaultView;
            }
            if (val2 === void 0) {
              return win ? win[prop] : elem[method2];
            }
            if (win) {
              win.scrollTo(
                !top ? val2 : win.pageXOffset,
                top ? val2 : win.pageYOffset
              );
            } else {
              elem[method2] = val2;
            }
          }, method, val, arguments.length);
        };
      });
      jQuery2.each(["top", "left"], function(_i2, prop) {
        jQuery2.cssHooks[prop] = addGetHookIf(
          support.pixelPosition,
          function(elem, computed) {
            if (computed) {
              computed = curCSS(elem, prop);
              return rnumnonpx.test(computed) ? jQuery2(elem).position()[prop] + "px" : computed;
            }
          }
        );
      });
      jQuery2.each({ Height: "height", Width: "width" }, function(name4, type) {
        jQuery2.each({
          padding: "inner" + name4,
          content: type,
          "": "outer" + name4
        }, function(defaultExtra, funcName) {
          jQuery2.fn[funcName] = function(margin, value) {
            var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
            return access(this, function(elem, type2, value2) {
              var doc;
              if (isWindow(elem)) {
                return funcName.indexOf("outer") === 0 ? elem["inner" + name4] : elem.document.documentElement["client" + name4];
              }
              if (elem.nodeType === 9) {
                doc = elem.documentElement;
                return Math.max(
                  elem.body["scroll" + name4],
                  doc["scroll" + name4],
                  elem.body["offset" + name4],
                  doc["offset" + name4],
                  doc["client" + name4]
                );
              }
              return value2 === void 0 ? (
                // Get width or height on the element, requesting but not forcing parseFloat
                jQuery2.css(elem, type2, extra)
              ) : (
                // Set width or height on the element
                jQuery2.style(elem, type2, value2, extra)
              );
            }, type, chainable ? margin : void 0, chainable);
          };
        });
      });
      jQuery2.each([
        "ajaxStart",
        "ajaxStop",
        "ajaxComplete",
        "ajaxError",
        "ajaxSuccess",
        "ajaxSend"
      ], function(_i2, type) {
        jQuery2.fn[type] = function(fn2) {
          return this.on(type, fn2);
        };
      });
      jQuery2.fn.extend({
        bind: function(types, data, fn2) {
          return this.on(types, null, data, fn2);
        },
        unbind: function(types, fn2) {
          return this.off(types, null, fn2);
        },
        delegate: function(selector, types, data, fn2) {
          return this.on(types, selector, data, fn2);
        },
        undelegate: function(selector, types, fn2) {
          return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn2);
        },
        hover: function(fnOver, fnOut) {
          return this.on("mouseenter", fnOver).on("mouseleave", fnOut || fnOver);
        }
      });
      jQuery2.each(
        "blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),
        function(_i2, name4) {
          jQuery2.fn[name4] = function(data, fn2) {
            return arguments.length > 0 ? this.on(name4, null, data, fn2) : this.trigger(name4);
          };
        }
      );
      var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
      jQuery2.proxy = function(fn2, context) {
        var tmp, args, proxy;
        if (typeof context === "string") {
          tmp = fn2[context];
          context = fn2;
          fn2 = tmp;
        }
        if (!isFunction4(fn2)) {
          return void 0;
        }
        args = slice.call(arguments, 2);
        proxy = function() {
          return fn2.apply(context || this, args.concat(slice.call(arguments)));
        };
        proxy.guid = fn2.guid = fn2.guid || jQuery2.guid++;
        return proxy;
      };
      jQuery2.holdReady = function(hold) {
        if (hold) {
          jQuery2.readyWait++;
        } else {
          jQuery2.ready(true);
        }
      };
      jQuery2.isArray = Array.isArray;
      jQuery2.parseJSON = JSON.parse;
      jQuery2.nodeName = nodeName;
      jQuery2.isFunction = isFunction4;
      jQuery2.isWindow = isWindow;
      jQuery2.camelCase = camelCase;
      jQuery2.type = toType;
      jQuery2.now = Date.now;
      jQuery2.isNumeric = function(obj) {
        var type = jQuery2.type(obj);
        return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
        // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
        // subtraction forces infinities to NaN
        !isNaN(obj - parseFloat(obj));
      };
      jQuery2.trim = function(text) {
        return text == null ? "" : (text + "").replace(rtrim, "$1");
      };
      if (typeof define === "function" && define.amd) {
        define("jquery", [], function() {
          return jQuery2;
        });
      }
      var _jQuery = window2.jQuery, _$ = window2.$;
      jQuery2.noConflict = function(deep) {
        if (window2.$ === jQuery2) {
          window2.$ = _$;
        }
        if (deep && window2.jQuery === jQuery2) {
          window2.jQuery = _jQuery;
        }
        return jQuery2;
      };
      if (typeof noGlobal === "undefined") {
        window2.jQuery = window2.$ = jQuery2;
      }
      return jQuery2;
    });
  }
});

// node_modules/popper.js/dist/esm/popper.js
var popper_exports = {};
__export(popper_exports, {
  default: () => popper_default
});
function microtaskDebounce(fn2) {
  var called = false;
  return function() {
    if (called) {
      return;
    }
    called = true;
    window.Promise.resolve().then(function() {
      called = false;
      fn2();
    });
  };
}
function taskDebounce(fn2) {
  var scheduled = false;
  return function() {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function() {
        scheduled = false;
        fn2();
      }, timeoutDuration);
    }
  };
}
function isFunction3(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === "[object Function]";
}
function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  }
  var window2 = element.ownerDocument.defaultView;
  var css = window2.getComputedStyle(element, null);
  return property ? css[property] : css;
}
function getParentNode(element) {
  if (element.nodeName === "HTML") {
    return element;
  }
  return element.parentNode || element.host;
}
function getScrollParent(element) {
  if (!element) {
    return document.body;
  }
  switch (element.nodeName) {
    case "HTML":
    case "BODY":
      return element.ownerDocument.body;
    case "#document":
      return element.body;
  }
  var _getStyleComputedProp = getStyleComputedProperty(element), overflow = _getStyleComputedProp.overflow, overflowX = _getStyleComputedProp.overflowX, overflowY = _getStyleComputedProp.overflowY;
  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return element;
  }
  return getScrollParent(getParentNode(element));
}
function getReferenceNode(reference) {
  return reference && reference.referenceNode ? reference.referenceNode : reference;
}
function isIE2(version3) {
  if (version3 === 11) {
    return isIE11;
  }
  if (version3 === 10) {
    return isIE10;
  }
  return isIE11 || isIE10;
}
function getOffsetParent(element) {
  if (!element) {
    return document.documentElement;
  }
  var noOffsetParent = isIE2(10) ? document.body : null;
  var offsetParent = element.offsetParent || null;
  while (offsetParent === noOffsetParent && element.nextElementSibling) {
    offsetParent = (element = element.nextElementSibling).offsetParent;
  }
  var nodeName = offsetParent && offsetParent.nodeName;
  if (!nodeName || nodeName === "BODY" || nodeName === "HTML") {
    return element ? element.ownerDocument.documentElement : document.documentElement;
  }
  if (["TH", "TD", "TABLE"].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, "position") === "static") {
    return getOffsetParent(offsetParent);
  }
  return offsetParent;
}
function isOffsetContainer(element) {
  var nodeName = element.nodeName;
  if (nodeName === "BODY") {
    return false;
  }
  return nodeName === "HTML" || getOffsetParent(element.firstElementChild) === element;
}
function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }
  return node;
}
function findCommonOffsetParent(element1, element2) {
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  }
  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start2 = order ? element1 : element2;
  var end = order ? element2 : element1;
  var range2 = document.createRange();
  range2.setStart(start2, 0);
  range2.setEnd(end, 0);
  var commonAncestorContainer = range2.commonAncestorContainer;
  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start2.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }
    return getOffsetParent(commonAncestorContainer);
  }
  var element1root = getRoot(element1);
  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}
function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "top";
  var upperSide = side === "top" ? "scrollTop" : "scrollLeft";
  var nodeName = element.nodeName;
  if (nodeName === "BODY" || nodeName === "HTML") {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }
  return element[upperSide];
}
function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var scrollTop = getScroll(element, "top");
  var scrollLeft = getScroll(element, "left");
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}
function getBordersSize(styles, axis) {
  var sideA = axis === "x" ? "Left" : "Top";
  var sideB = sideA === "Left" ? "Right" : "Bottom";
  return parseFloat(styles["border" + sideA + "Width"]) + parseFloat(styles["border" + sideB + "Width"]);
}
function getSize(axis, body, html, computedStyle) {
  return Math.max(body["offset" + axis], body["scroll" + axis], html["client" + axis], html["offset" + axis], html["scroll" + axis], isIE2(10) ? parseInt(html["offset" + axis]) + parseInt(computedStyle["margin" + (axis === "Height" ? "Top" : "Left")]) + parseInt(computedStyle["margin" + (axis === "Height" ? "Bottom" : "Right")]) : 0);
}
function getWindowSizes(document2) {
  var body = document2.body;
  var html = document2.documentElement;
  var computedStyle = isIE2(10) && getComputedStyle(html);
  return {
    height: getSize("Height", body, html, computedStyle),
    width: getSize("Width", body, html, computedStyle)
  };
}
function getClientRect(offsets) {
  return _extends({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}
function getBoundingClientRect(element) {
  var rect = {};
  try {
    if (isIE2(10)) {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, "top");
      var scrollLeft = getScroll(element, "left");
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } else {
      rect = element.getBoundingClientRect();
    }
  } catch (e) {
  }
  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };
  var sizes = element.nodeName === "HTML" ? getWindowSizes(element.ownerDocument) : {};
  var width = sizes.width || element.clientWidth || result.width;
  var height = sizes.height || element.clientHeight || result.height;
  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height;
  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, "x");
    vertScrollbar -= getBordersSize(styles, "y");
    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }
  return getClientRect(result);
}
function getOffsetRectRelativeToArbitraryNode(children, parent2) {
  var fixedPosition = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var isIE102 = isIE2(10);
  var isHTML = parent2.nodeName === "HTML";
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent2);
  var scrollParent = getScrollParent(children);
  var styles = getStyleComputedProperty(parent2);
  var borderTopWidth = parseFloat(styles.borderTopWidth);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth);
  if (fixedPosition && isHTML) {
    parentRect.top = Math.max(parentRect.top, 0);
    parentRect.left = Math.max(parentRect.left, 0);
  }
  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0;
  if (!isIE102 && isHTML) {
    var marginTop = parseFloat(styles.marginTop);
    var marginLeft = parseFloat(styles.marginLeft);
    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft;
    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }
  if (isIE102 && !fixedPosition ? parent2.contains(scrollParent) : parent2 === scrollParent && scrollParent.nodeName !== "BODY") {
    offsets = includeScroll(offsets, parent2);
  }
  return offsets;
}
function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var excludeScroll = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);
  var scrollTop = !excludeScroll ? getScroll(html) : 0;
  var scrollLeft = !excludeScroll ? getScroll(html, "left") : 0;
  var offset2 = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width,
    height
  };
  return getClientRect(offset2);
}
function isFixed(element) {
  var nodeName = element.nodeName;
  if (nodeName === "BODY" || nodeName === "HTML") {
    return false;
  }
  if (getStyleComputedProperty(element, "position") === "fixed") {
    return true;
  }
  var parentNode = getParentNode(element);
  if (!parentNode) {
    return false;
  }
  return isFixed(parentNode);
}
function getFixedPositionOffsetParent(element) {
  if (!element || !element.parentElement || isIE2()) {
    return document.documentElement;
  }
  var el = element.parentElement;
  while (el && getStyleComputedProperty(el, "transform") === "none") {
    el = el.parentElement;
  }
  return el || document.documentElement;
}
function getBoundaries(popper, reference, padding, boundariesElement) {
  var fixedPosition = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
  var boundaries = { top: 0, left: 0 };
  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
  if (boundariesElement === "viewport") {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
  } else {
    var boundariesNode = void 0;
    if (boundariesElement === "scrollParent") {
      boundariesNode = getScrollParent(getParentNode(reference));
      if (boundariesNode.nodeName === "BODY") {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === "window") {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }
    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);
    if (boundariesNode.nodeName === "HTML" && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(popper.ownerDocument), height = _getWindowSizes.height, width = _getWindowSizes.width;
      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      boundaries = offsets;
    }
  }
  padding = padding || 0;
  var isPaddingNumber = typeof padding === "number";
  boundaries.left += isPaddingNumber ? padding : padding.left || 0;
  boundaries.top += isPaddingNumber ? padding : padding.top || 0;
  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
  return boundaries;
}
function getArea(_ref) {
  var width = _ref.width, height = _ref.height;
  return width * height;
}
function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0;
  if (placement.indexOf("auto") === -1) {
    return placement;
  }
  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);
  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };
  var sortedAreas = Object.keys(rects).map(function(key) {
    return _extends({
      key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function(a, b2) {
    return b2.area - a.area;
  });
  var filteredAreas = sortedAreas.filter(function(_ref2) {
    var width = _ref2.width, height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });
  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
  var variation = placement.split("-")[1];
  return computedPlacement + (variation ? "-" + variation : "");
}
function getReferenceOffsets(state, popper, reference) {
  var fixedPosition = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
}
function getOuterSizes(element) {
  var window2 = element.ownerDocument.defaultView;
  var styles = window2.getComputedStyle(element);
  var x3 = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
  var y2 = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
  var result = {
    width: element.offsetWidth + y2,
    height: element.offsetHeight + x3
  };
  return result;
}
function getOppositePlacement(placement) {
  var hash = { left: "right", right: "left", bottom: "top", top: "bottom" };
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}
function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split("-")[0];
  var popperRect = getOuterSizes(popper);
  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  };
  var isHoriz = ["right", "left"].indexOf(placement) !== -1;
  var mainSide = isHoriz ? "top" : "left";
  var secondarySide = isHoriz ? "left" : "top";
  var measurement = isHoriz ? "height" : "width";
  var secondaryMeasurement = !isHoriz ? "height" : "width";
  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }
  return popperOffsets;
}
function find(arr, check) {
  if (Array.prototype.find) {
    return arr.find(check);
  }
  return arr.filter(check)[0];
}
function findIndex(arr, prop, value) {
  if (Array.prototype.findIndex) {
    return arr.findIndex(function(cur) {
      return cur[prop] === value;
    });
  }
  var match = find(arr, function(obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}
function runModifiers(modifiers2, data, ends) {
  var modifiersToRun = ends === void 0 ? modifiers2 : modifiers2.slice(0, findIndex(modifiers2, "name", ends));
  modifiersToRun.forEach(function(modifier) {
    if (modifier["function"]) {
      console.warn("`modifier.function` is deprecated, use `modifier.fn`!");
    }
    var fn2 = modifier["function"] || modifier.fn;
    if (modifier.enabled && isFunction3(fn2)) {
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);
      data = fn2(data, modifier);
    }
  });
  return data;
}
function update() {
  if (this.state.isDestroyed) {
    return;
  }
  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  };
  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);
  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);
  data.originalPlacement = data.placement;
  data.positionFixed = this.options.positionFixed;
  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
  data.offsets.popper.position = this.options.positionFixed ? "fixed" : "absolute";
  data = runModifiers(this.modifiers, data);
  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}
function isModifierEnabled(modifiers2, modifierName) {
  return modifiers2.some(function(_ref) {
    var name4 = _ref.name, enabled = _ref.enabled;
    return enabled && name4 === modifierName;
  });
}
function getSupportedPropertyName(property) {
  var prefixes = [false, "ms", "Webkit", "Moz", "O"];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);
  for (var i2 = 0; i2 < prefixes.length; i2++) {
    var prefix = prefixes[i2];
    var toCheck = prefix ? "" + prefix + upperProp : property;
    if (typeof document.body.style[toCheck] !== "undefined") {
      return toCheck;
    }
  }
  return null;
}
function destroy() {
  this.state.isDestroyed = true;
  if (isModifierEnabled(this.modifiers, "applyStyle")) {
    this.popper.removeAttribute("x-placement");
    this.popper.style.position = "";
    this.popper.style.top = "";
    this.popper.style.left = "";
    this.popper.style.right = "";
    this.popper.style.bottom = "";
    this.popper.style.willChange = "";
    this.popper.style[getSupportedPropertyName("transform")] = "";
  }
  this.disableEventListeners();
  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }
  return this;
}
function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}
function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === "BODY";
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, { passive: true });
  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }
  scrollParents.push(target);
}
function setupEventListeners(reference, options, state, updateBound) {
  state.updateBound = updateBound;
  getWindow(reference).addEventListener("resize", state.updateBound, { passive: true });
  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, "scroll", state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;
  return state;
}
function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}
function removeEventListeners(reference, state) {
  getWindow(reference).removeEventListener("resize", state.updateBound);
  state.scrollParents.forEach(function(target) {
    target.removeEventListener("scroll", state.updateBound);
  });
  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}
function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}
function isNumeric2(n2) {
  return n2 !== "" && !isNaN(parseFloat(n2)) && isFinite(n2);
}
function setStyles(element, styles) {
  Object.keys(styles).forEach(function(prop) {
    var unit = "";
    if (["width", "height", "top", "right", "bottom", "left"].indexOf(prop) !== -1 && isNumeric2(styles[prop])) {
      unit = "px";
    }
    element.style[prop] = styles[prop] + unit;
  });
}
function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function(prop) {
    var value = attributes[prop];
    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}
function applyStyle(data) {
  setStyles(data.instance.popper, data.styles);
  setAttributes(data.instance.popper, data.attributes);
  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }
  return data;
}
function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);
  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
  popper.setAttribute("x-placement", placement);
  setStyles(popper, { position: options.positionFixed ? "fixed" : "absolute" });
  return options;
}
function getRoundedOffsets(data, shouldRound) {
  var _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
  var round = Math.round, floor = Math.floor;
  var noRound = function noRound2(v2) {
    return v2;
  };
  var referenceWidth = round(reference.width);
  var popperWidth = round(popper.width);
  var isVertical = ["left", "right"].indexOf(data.placement) !== -1;
  var isVariation = data.placement.indexOf("-") !== -1;
  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;
  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
  var verticalToInteger = !shouldRound ? noRound : round;
  return {
    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
    top: verticalToInteger(popper.top),
    bottom: verticalToInteger(popper.bottom),
    right: horizontalToInteger(popper.right)
  };
}
function computeStyle(data, options) {
  var x3 = options.x, y2 = options.y;
  var popper = data.offsets.popper;
  var legacyGpuAccelerationOption = find(data.instance.modifiers, function(modifier) {
    return modifier.name === "applyStyle";
  }).gpuAcceleration;
  if (legacyGpuAccelerationOption !== void 0) {
    console.warn("WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!");
  }
  var gpuAcceleration = legacyGpuAccelerationOption !== void 0 ? legacyGpuAccelerationOption : options.gpuAcceleration;
  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent);
  var styles = {
    position: popper.position
  };
  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);
  var sideA = x3 === "bottom" ? "top" : "bottom";
  var sideB = y2 === "right" ? "left" : "right";
  var prefixedProperty = getSupportedPropertyName("transform");
  var left = void 0, top = void 0;
  if (sideA === "bottom") {
    if (offsetParent.nodeName === "HTML") {
      top = -offsetParent.clientHeight + offsets.bottom;
    } else {
      top = -offsetParentRect.height + offsets.bottom;
    }
  } else {
    top = offsets.top;
  }
  if (sideB === "right") {
    if (offsetParent.nodeName === "HTML") {
      left = -offsetParent.clientWidth + offsets.right;
    } else {
      left = -offsetParentRect.width + offsets.right;
    }
  } else {
    left = offsets.left;
  }
  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = "translate3d(" + left + "px, " + top + "px, 0)";
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = "transform";
  } else {
    var invertTop = sideA === "bottom" ? -1 : 1;
    var invertLeft = sideB === "right" ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ", " + sideB;
  }
  var attributes = {
    "x-placement": data.placement
  };
  data.attributes = _extends({}, attributes, data.attributes);
  data.styles = _extends({}, styles, data.styles);
  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);
  return data;
}
function isModifierRequired(modifiers2, requestingName, requestedName) {
  var requesting = find(modifiers2, function(_ref) {
    var name4 = _ref.name;
    return name4 === requestingName;
  });
  var isRequired = !!requesting && modifiers2.some(function(modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });
  if (!isRequired) {
    var _requesting = "`" + requestingName + "`";
    var requested = "`" + requestedName + "`";
    console.warn(requested + " modifier is required by " + _requesting + " modifier in order to work, be sure to include it before " + _requesting + "!");
  }
  return isRequired;
}
function arrow(data, options) {
  var _data$offsets$arrow;
  if (!isModifierRequired(data.instance.modifiers, "arrow", "keepTogether")) {
    return data;
  }
  var arrowElement = options.element;
  if (typeof arrowElement === "string") {
    arrowElement = data.instance.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return data;
    }
  } else {
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn("WARNING: `arrow.element` must be child of its popper element!");
      return data;
    }
  }
  var placement = data.placement.split("-")[0];
  var _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
  var isVertical = ["left", "right"].indexOf(placement) !== -1;
  var len = isVertical ? "height" : "width";
  var sideCapitalized = isVertical ? "Top" : "Left";
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? "left" : "top";
  var opSide = isVertical ? "bottom" : "right";
  var arrowElementSize = getOuterSizes(arrowElement)[len];
  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  }
  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }
  data.offsets.popper = getClientRect(data.offsets.popper);
  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;
  var css = getStyleComputedProperty(data.instance.popper);
  var popperMarginSide = parseFloat(css["margin" + sideCapitalized]);
  var popperBorderSide = parseFloat(css["border" + sideCapitalized + "Width"]);
  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;
  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);
  data.arrowElement = arrowElement;
  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ""), _data$offsets$arrow);
  return data;
}
function getOppositeVariation(variation) {
  if (variation === "end") {
    return "start";
  } else if (variation === "start") {
    return "end";
  }
  return variation;
}
function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}
function flip(data, options) {
  if (isModifierEnabled(data.instance.modifiers, "inner")) {
    return data;
  }
  if (data.flipped && data.placement === data.originalPlacement) {
    return data;
  }
  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);
  var placement = data.placement.split("-")[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split("-")[1] || "";
  var flipOrder = [];
  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;
    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;
    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;
    default:
      flipOrder = options.behavior;
  }
  flipOrder.forEach(function(step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data;
    }
    placement = data.placement.split("-")[0];
    placementOpposite = getOppositePlacement(placement);
    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference;
    var floor = Math.floor;
    var overlapsRef = placement === "left" && floor(popperOffsets.right) > floor(refOffsets.left) || placement === "right" && floor(popperOffsets.left) < floor(refOffsets.right) || placement === "top" && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === "bottom" && floor(popperOffsets.top) < floor(refOffsets.bottom);
    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);
    var overflowsBoundaries = placement === "left" && overflowsLeft || placement === "right" && overflowsRight || placement === "top" && overflowsTop || placement === "bottom" && overflowsBottom;
    var isVertical = ["top", "bottom"].indexOf(placement) !== -1;
    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === "start" && overflowsLeft || isVertical && variation === "end" && overflowsRight || !isVertical && variation === "start" && overflowsTop || !isVertical && variation === "end" && overflowsBottom);
    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === "start" && overflowsRight || isVertical && variation === "end" && overflowsLeft || !isVertical && variation === "start" && overflowsBottom || !isVertical && variation === "end" && overflowsTop);
    var flippedVariation = flippedVariationByRef || flippedVariationByContent;
    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      data.flipped = true;
      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }
      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }
      data.placement = placement + (variation ? "-" + variation : "");
      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));
      data = runModifiers(data.instance.modifiers, data, "flip");
    }
  });
  return data;
}
function keepTogether(data) {
  var _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
  var placement = data.placement.split("-")[0];
  var floor = Math.floor;
  var isVertical = ["top", "bottom"].indexOf(placement) !== -1;
  var side = isVertical ? "right" : "bottom";
  var opSide = isVertical ? "left" : "top";
  var measurement = isVertical ? "width" : "height";
  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }
  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }
  return data;
}
function toValue(str, measurement, popperOffsets, referenceOffsets) {
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2];
  if (!value) {
    return str;
  }
  if (unit.indexOf("%") === 0) {
    var element = void 0;
    switch (unit) {
      case "%p":
        element = popperOffsets;
        break;
      case "%":
      case "%r":
      default:
        element = referenceOffsets;
    }
    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === "vh" || unit === "vw") {
    var size = void 0;
    if (unit === "vh") {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }
    return size / 100 * value;
  } else {
    return value;
  }
}
function parseOffset(offset2, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0];
  var useHeight = ["right", "left"].indexOf(basePlacement) !== -1;
  var fragments = offset2.split(/(\+|\-)/).map(function(frag) {
    return frag.trim();
  });
  var divider = fragments.indexOf(find(fragments, function(frag) {
    return frag.search(/,|\s/) !== -1;
  }));
  if (fragments[divider] && fragments[divider].indexOf(",") === -1) {
    console.warn("Offsets separated by white space(s) are deprecated, use a comma (,) instead.");
  }
  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];
  ops = ops.map(function(op, index) {
    var measurement = (index === 1 ? !useHeight : useHeight) ? "height" : "width";
    var mergeWithPrevious = false;
    return op.reduce(function(a, b2) {
      if (a[a.length - 1] === "" && ["+", "-"].indexOf(b2) !== -1) {
        a[a.length - 1] = b2;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b2;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b2);
      }
    }, []).map(function(str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  });
  ops.forEach(function(op, index) {
    op.forEach(function(frag, index2) {
      if (isNumeric2(frag)) {
        offsets[index] += frag * (op[index2 - 1] === "-" ? -1 : 1);
      }
    });
  });
  return offsets;
}
function offset(data, _ref) {
  var offset2 = _ref.offset;
  var placement = data.placement, _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
  var basePlacement = placement.split("-")[0];
  var offsets = void 0;
  if (isNumeric2(+offset2)) {
    offsets = [+offset2, 0];
  } else {
    offsets = parseOffset(offset2, popper, reference, basePlacement);
  }
  if (basePlacement === "left") {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === "right") {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === "top") {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === "bottom") {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }
  data.popper = popper;
  return data;
}
function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);
  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  }
  var transformProp = getSupportedPropertyName("transform");
  var popperStyles = data.instance.popper.style;
  var top = popperStyles.top, left = popperStyles.left, transform = popperStyles[transformProp];
  popperStyles.top = "";
  popperStyles.left = "";
  popperStyles[transformProp] = "";
  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);
  popperStyles.top = top;
  popperStyles.left = left;
  popperStyles[transformProp] = transform;
  options.boundaries = boundaries;
  var order = options.priority;
  var popper = data.offsets.popper;
  var check = {
    primary: function primary(placement) {
      var value = popper[placement];
      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }
      return defineProperty({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === "right" ? "left" : "top";
      var value = popper[mainSide];
      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === "right" ? popper.width : popper.height));
      }
      return defineProperty({}, mainSide, value);
    }
  };
  order.forEach(function(placement) {
    var side = ["left", "top"].indexOf(placement) !== -1 ? "primary" : "secondary";
    popper = _extends({}, popper, check[side](placement));
  });
  data.offsets.popper = popper;
  return data;
}
function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split("-")[0];
  var shiftvariation = placement.split("-")[1];
  if (shiftvariation) {
    var _data$offsets = data.offsets, reference = _data$offsets.reference, popper = _data$offsets.popper;
    var isVertical = ["bottom", "top"].indexOf(basePlacement) !== -1;
    var side = isVertical ? "left" : "top";
    var measurement = isVertical ? "width" : "height";
    var shiftOffsets = {
      start: defineProperty({}, side, reference[side]),
      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
    };
    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
  }
  return data;
}
function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, "hide", "preventOverflow")) {
    return data;
  }
  var refRect = data.offsets.reference;
  var bound = find(data.instance.modifiers, function(modifier) {
    return modifier.name === "preventOverflow";
  }).boundaries;
  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    if (data.hide === true) {
      return data;
    }
    data.hide = true;
    data.attributes["x-out-of-boundaries"] = "";
  } else {
    if (data.hide === false) {
      return data;
    }
    data.hide = false;
    data.attributes["x-out-of-boundaries"] = false;
  }
  return data;
}
function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split("-")[0];
  var _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
  var isHoriz = ["left", "right"].indexOf(basePlacement) !== -1;
  var subtractLength = ["top", "left"].indexOf(basePlacement) === -1;
  popper[isHoriz ? "left" : "top"] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? "width" : "height"] : 0);
  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper);
  return data;
}
var isBrowser, timeoutDuration, supportsMicroTasks, debounce, isIE11, isIE10, classCallCheck, createClass, defineProperty, _extends, isFirefox, placements, validPlacements, BEHAVIORS, modifiers, Defaults, Popper, popper_default;
var init_popper = __esm({
  "node_modules/popper.js/dist/esm/popper.js"() {
    isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && typeof navigator !== "undefined";
    timeoutDuration = function() {
      var longerTimeoutBrowsers = ["Edge", "Trident", "Firefox"];
      for (var i2 = 0; i2 < longerTimeoutBrowsers.length; i2 += 1) {
        if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i2]) >= 0) {
          return 1;
        }
      }
      return 0;
    }();
    supportsMicroTasks = isBrowser && window.Promise;
    debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;
    isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
    isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);
    classCallCheck = function(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    };
    createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    defineProperty = function(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    };
    _extends = Object.assign || function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);
    placements = ["auto-start", "auto", "auto-end", "top-start", "top", "top-end", "right-start", "right", "right-end", "bottom-end", "bottom", "bottom-start", "left-end", "left", "left-start"];
    validPlacements = placements.slice(3);
    BEHAVIORS = {
      FLIP: "flip",
      CLOCKWISE: "clockwise",
      COUNTERCLOCKWISE: "counterclockwise"
    };
    modifiers = {
      /**
       * Modifier used to shift the popper on the start or end of its reference
       * element.<br />
       * It will read the variation of the `placement` property.<br />
       * It can be one either `-end` or `-start`.
       * @memberof modifiers
       * @inner
       */
      shift: {
        /** @prop {number} order=100 - Index used to define the order of execution */
        order: 100,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: shift
      },
      /**
       * The `offset` modifier can shift your popper on both its axis.
       *
       * It accepts the following units:
       * - `px` or unit-less, interpreted as pixels
       * - `%` or `%r`, percentage relative to the length of the reference element
       * - `%p`, percentage relative to the length of the popper element
       * - `vw`, CSS viewport width unit
       * - `vh`, CSS viewport height unit
       *
       * For length is intended the main axis relative to the placement of the popper.<br />
       * This means that if the placement is `top` or `bottom`, the length will be the
       * `width`. In case of `left` or `right`, it will be the `height`.
       *
       * You can provide a single value (as `Number` or `String`), or a pair of values
       * as `String` divided by a comma or one (or more) white spaces.<br />
       * The latter is a deprecated method because it leads to confusion and will be
       * removed in v2.<br />
       * Additionally, it accepts additions and subtractions between different units.
       * Note that multiplications and divisions aren't supported.
       *
       * Valid examples are:
       * ```
       * 10
       * '10%'
       * '10, 10'
       * '10%, 10'
       * '10 + 10%'
       * '10 - 5vh + 3%'
       * '-10px + 5vh, 5px - 6%'
       * ```
       * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
       * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
       * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
       *
       * @memberof modifiers
       * @inner
       */
      offset: {
        /** @prop {number} order=200 - Index used to define the order of execution */
        order: 200,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: offset,
        /** @prop {Number|String} offset=0
         * The offset value as described in the modifier description
         */
        offset: 0
      },
      /**
       * Modifier used to prevent the popper from being positioned outside the boundary.
       *
       * A scenario exists where the reference itself is not within the boundaries.<br />
       * We can say it has "escaped the boundaries" — or just "escaped".<br />
       * In this case we need to decide whether the popper should either:
       *
       * - detach from the reference and remain "trapped" in the boundaries, or
       * - if it should ignore the boundary and "escape with its reference"
       *
       * When `escapeWithReference` is set to`true` and reference is completely
       * outside its boundaries, the popper will overflow (or completely leave)
       * the boundaries in order to remain attached to the edge of the reference.
       *
       * @memberof modifiers
       * @inner
       */
      preventOverflow: {
        /** @prop {number} order=300 - Index used to define the order of execution */
        order: 300,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: preventOverflow,
        /**
         * @prop {Array} [priority=['left','right','top','bottom']]
         * Popper will try to prevent overflow following these priorities by default,
         * then, it could overflow on the left and on top of the `boundariesElement`
         */
        priority: ["left", "right", "top", "bottom"],
        /**
         * @prop {number} padding=5
         * Amount of pixel used to define a minimum distance between the boundaries
         * and the popper. This makes sure the popper always has a little padding
         * between the edges of its container
         */
        padding: 5,
        /**
         * @prop {String|HTMLElement} boundariesElement='scrollParent'
         * Boundaries used by the modifier. Can be `scrollParent`, `window`,
         * `viewport` or any DOM element.
         */
        boundariesElement: "scrollParent"
      },
      /**
       * Modifier used to make sure the reference and its popper stay near each other
       * without leaving any gap between the two. Especially useful when the arrow is
       * enabled and you want to ensure that it points to its reference element.
       * It cares only about the first axis. You can still have poppers with margin
       * between the popper and its reference element.
       * @memberof modifiers
       * @inner
       */
      keepTogether: {
        /** @prop {number} order=400 - Index used to define the order of execution */
        order: 400,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: keepTogether
      },
      /**
       * This modifier is used to move the `arrowElement` of the popper to make
       * sure it is positioned between the reference element and its popper element.
       * It will read the outer size of the `arrowElement` node to detect how many
       * pixels of conjunction are needed.
       *
       * It has no effect if no `arrowElement` is provided.
       * @memberof modifiers
       * @inner
       */
      arrow: {
        /** @prop {number} order=500 - Index used to define the order of execution */
        order: 500,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: arrow,
        /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
        element: "[x-arrow]"
      },
      /**
       * Modifier used to flip the popper's placement when it starts to overlap its
       * reference element.
       *
       * Requires the `preventOverflow` modifier before it in order to work.
       *
       * **NOTE:** this modifier will interrupt the current update cycle and will
       * restart it if it detects the need to flip the placement.
       * @memberof modifiers
       * @inner
       */
      flip: {
        /** @prop {number} order=600 - Index used to define the order of execution */
        order: 600,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: flip,
        /**
         * @prop {String|Array} behavior='flip'
         * The behavior used to change the popper's placement. It can be one of
         * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
         * placements (with optional variations)
         */
        behavior: "flip",
        /**
         * @prop {number} padding=5
         * The popper will flip if it hits the edges of the `boundariesElement`
         */
        padding: 5,
        /**
         * @prop {String|HTMLElement} boundariesElement='viewport'
         * The element which will define the boundaries of the popper position.
         * The popper will never be placed outside of the defined boundaries
         * (except if `keepTogether` is enabled)
         */
        boundariesElement: "viewport",
        /**
         * @prop {Boolean} flipVariations=false
         * The popper will switch placement variation between `-start` and `-end` when
         * the reference element overlaps its boundaries.
         *
         * The original placement should have a set variation.
         */
        flipVariations: false,
        /**
         * @prop {Boolean} flipVariationsByContent=false
         * The popper will switch placement variation between `-start` and `-end` when
         * the popper element overlaps its reference boundaries.
         *
         * The original placement should have a set variation.
         */
        flipVariationsByContent: false
      },
      /**
       * Modifier used to make the popper flow toward the inner of the reference element.
       * By default, when this modifier is disabled, the popper will be placed outside
       * the reference element.
       * @memberof modifiers
       * @inner
       */
      inner: {
        /** @prop {number} order=700 - Index used to define the order of execution */
        order: 700,
        /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
        enabled: false,
        /** @prop {ModifierFn} */
        fn: inner
      },
      /**
       * Modifier used to hide the popper when its reference element is outside of the
       * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
       * be used to hide with a CSS selector the popper when its reference is
       * out of boundaries.
       *
       * Requires the `preventOverflow` modifier before it in order to work.
       * @memberof modifiers
       * @inner
       */
      hide: {
        /** @prop {number} order=800 - Index used to define the order of execution */
        order: 800,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: hide
      },
      /**
       * Computes the style that will be applied to the popper element to gets
       * properly positioned.
       *
       * Note that this modifier will not touch the DOM, it just prepares the styles
       * so that `applyStyle` modifier can apply it. This separation is useful
       * in case you need to replace `applyStyle` with a custom implementation.
       *
       * This modifier has `850` as `order` value to maintain backward compatibility
       * with previous versions of Popper.js. Expect the modifiers ordering method
       * to change in future major versions of the library.
       *
       * @memberof modifiers
       * @inner
       */
      computeStyle: {
        /** @prop {number} order=850 - Index used to define the order of execution */
        order: 850,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: computeStyle,
        /**
         * @prop {Boolean} gpuAcceleration=true
         * If true, it uses the CSS 3D transformation to position the popper.
         * Otherwise, it will use the `top` and `left` properties
         */
        gpuAcceleration: true,
        /**
         * @prop {string} [x='bottom']
         * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
         * Change this if your popper should grow in a direction different from `bottom`
         */
        x: "bottom",
        /**
         * @prop {string} [x='left']
         * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
         * Change this if your popper should grow in a direction different from `right`
         */
        y: "right"
      },
      /**
       * Applies the computed styles to the popper element.
       *
       * All the DOM manipulations are limited to this modifier. This is useful in case
       * you want to integrate Popper.js inside a framework or view library and you
       * want to delegate all the DOM manipulations to it.
       *
       * Note that if you disable this modifier, you must make sure the popper element
       * has its position set to `absolute` before Popper.js can do its work!
       *
       * Just disable this modifier and define your own to achieve the desired effect.
       *
       * @memberof modifiers
       * @inner
       */
      applyStyle: {
        /** @prop {number} order=900 - Index used to define the order of execution */
        order: 900,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: applyStyle,
        /** @prop {Function} */
        onLoad: applyStyleOnLoad,
        /**
         * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
         * @prop {Boolean} gpuAcceleration=true
         * If true, it uses the CSS 3D transformation to position the popper.
         * Otherwise, it will use the `top` and `left` properties
         */
        gpuAcceleration: void 0
      }
    };
    Defaults = {
      /**
       * Popper's placement.
       * @prop {Popper.placements} placement='bottom'
       */
      placement: "bottom",
      /**
       * Set this to true if you want popper to position it self in 'fixed' mode
       * @prop {Boolean} positionFixed=false
       */
      positionFixed: false,
      /**
       * Whether events (resize, scroll) are initially enabled.
       * @prop {Boolean} eventsEnabled=true
       */
      eventsEnabled: true,
      /**
       * Set to true if you want to automatically remove the popper when
       * you call the `destroy` method.
       * @prop {Boolean} removeOnDestroy=false
       */
      removeOnDestroy: false,
      /**
       * Callback called when the popper is created.<br />
       * By default, it is set to no-op.<br />
       * Access Popper.js instance with `data.instance`.
       * @prop {onCreate}
       */
      onCreate: function onCreate() {
      },
      /**
       * Callback called when the popper is updated. This callback is not called
       * on the initialization/creation of the popper, but only on subsequent
       * updates.<br />
       * By default, it is set to no-op.<br />
       * Access Popper.js instance with `data.instance`.
       * @prop {onUpdate}
       */
      onUpdate: function onUpdate() {
      },
      /**
       * List of modifiers used to modify the offsets before they are applied to the popper.
       * They provide most of the functionalities of Popper.js.
       * @prop {modifiers}
       */
      modifiers
    };
    Popper = function() {
      function Popper2(reference, popper) {
        var _this = this;
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        classCallCheck(this, Popper2);
        this.scheduleUpdate = function() {
          return requestAnimationFrame(_this.update);
        };
        this.update = debounce(this.update.bind(this));
        this.options = _extends({}, Popper2.Defaults, options);
        this.state = {
          isDestroyed: false,
          isCreated: false,
          scrollParents: []
        };
        this.reference = reference && reference.jquery ? reference[0] : reference;
        this.popper = popper && popper.jquery ? popper[0] : popper;
        this.options.modifiers = {};
        Object.keys(_extends({}, Popper2.Defaults.modifiers, options.modifiers)).forEach(function(name4) {
          _this.options.modifiers[name4] = _extends({}, Popper2.Defaults.modifiers[name4] || {}, options.modifiers ? options.modifiers[name4] : {});
        });
        this.modifiers = Object.keys(this.options.modifiers).map(function(name4) {
          return _extends({
            name: name4
          }, _this.options.modifiers[name4]);
        }).sort(function(a, b2) {
          return a.order - b2.order;
        });
        this.modifiers.forEach(function(modifierOptions) {
          if (modifierOptions.enabled && isFunction3(modifierOptions.onLoad)) {
            modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
          }
        });
        this.update();
        var eventsEnabled = this.options.eventsEnabled;
        if (eventsEnabled) {
          this.enableEventListeners();
        }
        this.state.eventsEnabled = eventsEnabled;
      }
      createClass(Popper2, [{
        key: "update",
        value: function update$$1() {
          return update.call(this);
        }
      }, {
        key: "destroy",
        value: function destroy$$1() {
          return destroy.call(this);
        }
      }, {
        key: "enableEventListeners",
        value: function enableEventListeners$$1() {
          return enableEventListeners.call(this);
        }
      }, {
        key: "disableEventListeners",
        value: function disableEventListeners$$1() {
          return disableEventListeners.call(this);
        }
        /**
         * Schedules an update. It will run on the next UI update available.
         * @method scheduleUpdate
         * @memberof Popper
         */
        /**
         * Collection of utilities useful when writing custom modifiers.
         * Starting from version 1.7, this method is available only if you
         * include `popper-utils.js` before `popper.js`.
         *
         * **DEPRECATION**: This way to access PopperUtils is deprecated
         * and will be removed in v2! Use the PopperUtils module directly instead.
         * Due to the high instability of the methods contained in Utils, we can't
         * guarantee them to follow semver. Use them at your own risk!
         * @static
         * @private
         * @type {Object}
         * @deprecated since version 1.8
         * @member Utils
         * @memberof Popper
         */
      }]);
      return Popper2;
    }();
    Popper.Utils = (typeof window !== "undefined" ? window : global).PopperUtils;
    Popper.placements = placements;
    Popper.Defaults = Defaults;
    popper_default = Popper;
  }
});

// node_modules/ng-fire-admin/node_modules/bootstrap/dist/js/bootstrap.js
var require_bootstrap = __commonJS({
  "node_modules/ng-fire-admin/node_modules/bootstrap/dist/js/bootstrap.js"(exports, module) {
    (function(global2, factory2) {
      typeof exports === "object" && typeof module !== "undefined" ? factory2(exports, require_jquery(), (init_popper(), __toCommonJS(popper_exports))) : typeof define === "function" && define.amd ? define(["exports", "jquery", "popper.js"], factory2) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory2(global2.bootstrap = {}, global2.jQuery, global2.Popper));
    })(exports, function(exports2, $3, Popper2) {
      "use strict";
      function _interopDefaultLegacy(e) {
        return e && typeof e === "object" && "default" in e ? e : { "default": e };
      }
      var $__default = _interopDefaultLegacy($3);
      var Popper__default = _interopDefaultLegacy(Popper2);
      function _defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", {
          writable: false
        });
        return Constructor;
      }
      function _extends2() {
        _extends2 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i2 = 1; i2 < arguments.length; i2++) {
            var source = arguments[i2];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends2.apply(this, arguments);
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p2) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
          o2.__proto__ = p3;
          return o2;
        };
        return _setPrototypeOf(o, p2);
      }
      var TRANSITION_END = "transitionend";
      var MAX_UID = 1e6;
      var MILLISECONDS_MULTIPLIER = 1e3;
      function toType(obj) {
        if (obj === null || typeof obj === "undefined") {
          return "" + obj;
        }
        return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
      }
      function getSpecialTransitionEndEvent() {
        return {
          bindType: TRANSITION_END,
          delegateType: TRANSITION_END,
          handle: function handle(event) {
            if ($__default["default"](event.target).is(this)) {
              return event.handleObj.handler.apply(this, arguments);
            }
            return void 0;
          }
        };
      }
      function transitionEndEmulator(duration) {
        var _this = this;
        var called = false;
        $__default["default"](this).one(Util.TRANSITION_END, function() {
          called = true;
        });
        setTimeout(function() {
          if (!called) {
            Util.triggerTransitionEnd(_this);
          }
        }, duration);
        return this;
      }
      function setTransitionEndSupport() {
        $__default["default"].fn.emulateTransitionEnd = transitionEndEmulator;
        $__default["default"].event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();
      }
      var Util = {
        TRANSITION_END: "bsTransitionEnd",
        getUID: function getUID(prefix) {
          do {
            prefix += ~~(Math.random() * MAX_UID);
          } while (document.getElementById(prefix));
          return prefix;
        },
        getSelectorFromElement: function getSelectorFromElement(element) {
          var selector = element.getAttribute("data-target");
          if (!selector || selector === "#") {
            var hrefAttr = element.getAttribute("href");
            selector = hrefAttr && hrefAttr !== "#" ? hrefAttr.trim() : "";
          }
          try {
            return document.querySelector(selector) ? selector : null;
          } catch (_2) {
            return null;
          }
        },
        getTransitionDurationFromElement: function getTransitionDurationFromElement(element) {
          if (!element) {
            return 0;
          }
          var transitionDuration = $__default["default"](element).css("transition-duration");
          var transitionDelay = $__default["default"](element).css("transition-delay");
          var floatTransitionDuration = parseFloat(transitionDuration);
          var floatTransitionDelay = parseFloat(transitionDelay);
          if (!floatTransitionDuration && !floatTransitionDelay) {
            return 0;
          }
          transitionDuration = transitionDuration.split(",")[0];
          transitionDelay = transitionDelay.split(",")[0];
          return (parseFloat(transitionDuration) + parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
        },
        reflow: function reflow(element) {
          return element.offsetHeight;
        },
        triggerTransitionEnd: function triggerTransitionEnd(element) {
          $__default["default"](element).trigger(TRANSITION_END);
        },
        supportsTransitionEnd: function supportsTransitionEnd() {
          return Boolean(TRANSITION_END);
        },
        isElement: function isElement(obj) {
          return (obj[0] || obj).nodeType;
        },
        typeCheckConfig: function typeCheckConfig(componentName, config2, configTypes) {
          for (var property in configTypes) {
            if (Object.prototype.hasOwnProperty.call(configTypes, property)) {
              var expectedTypes = configTypes[property];
              var value = config2[property];
              var valueType = value && Util.isElement(value) ? "element" : toType(value);
              if (!new RegExp(expectedTypes).test(valueType)) {
                throw new Error(componentName.toUpperCase() + ": " + ('Option "' + property + '" provided type "' + valueType + '" ') + ('but expected type "' + expectedTypes + '".'));
              }
            }
          }
        },
        findShadowRoot: function findShadowRoot(element) {
          if (!document.documentElement.attachShadow) {
            return null;
          }
          if (typeof element.getRootNode === "function") {
            var root = element.getRootNode();
            return root instanceof ShadowRoot ? root : null;
          }
          if (element instanceof ShadowRoot) {
            return element;
          }
          if (!element.parentNode) {
            return null;
          }
          return Util.findShadowRoot(element.parentNode);
        },
        jQueryDetection: function jQueryDetection() {
          if (typeof $__default["default"] === "undefined") {
            throw new TypeError("Bootstrap's JavaScript requires jQuery. jQuery must be included before Bootstrap's JavaScript.");
          }
          var version3 = $__default["default"].fn.jquery.split(" ")[0].split(".");
          var minMajor = 1;
          var ltMajor = 2;
          var minMinor = 9;
          var minPatch = 1;
          var maxMajor = 4;
          if (version3[0] < ltMajor && version3[1] < minMinor || version3[0] === minMajor && version3[1] === minMinor && version3[2] < minPatch || version3[0] >= maxMajor) {
            throw new Error("Bootstrap's JavaScript requires at least jQuery v1.9.1 but less than v4.0.0");
          }
        }
      };
      Util.jQueryDetection();
      setTransitionEndSupport();
      var NAME$a = "alert";
      var VERSION$a = "4.6.2";
      var DATA_KEY$a = "bs.alert";
      var EVENT_KEY$a = "." + DATA_KEY$a;
      var DATA_API_KEY$7 = ".data-api";
      var JQUERY_NO_CONFLICT$a = $__default["default"].fn[NAME$a];
      var CLASS_NAME_ALERT = "alert";
      var CLASS_NAME_FADE$5 = "fade";
      var CLASS_NAME_SHOW$7 = "show";
      var EVENT_CLOSE = "close" + EVENT_KEY$a;
      var EVENT_CLOSED = "closed" + EVENT_KEY$a;
      var EVENT_CLICK_DATA_API$6 = "click" + EVENT_KEY$a + DATA_API_KEY$7;
      var SELECTOR_DISMISS = '[data-dismiss="alert"]';
      var Alert = function() {
        function Alert2(element) {
          this._element = element;
        }
        var _proto = Alert2.prototype;
        _proto.close = function close(element) {
          var rootElement = this._element;
          if (element) {
            rootElement = this._getRootElement(element);
          }
          var customEvent = this._triggerCloseEvent(rootElement);
          if (customEvent.isDefaultPrevented()) {
            return;
          }
          this._removeElement(rootElement);
        };
        _proto.dispose = function dispose() {
          $__default["default"].removeData(this._element, DATA_KEY$a);
          this._element = null;
        };
        _proto._getRootElement = function _getRootElement(element) {
          var selector = Util.getSelectorFromElement(element);
          var parent2 = false;
          if (selector) {
            parent2 = document.querySelector(selector);
          }
          if (!parent2) {
            parent2 = $__default["default"](element).closest("." + CLASS_NAME_ALERT)[0];
          }
          return parent2;
        };
        _proto._triggerCloseEvent = function _triggerCloseEvent(element) {
          var closeEvent = $__default["default"].Event(EVENT_CLOSE);
          $__default["default"](element).trigger(closeEvent);
          return closeEvent;
        };
        _proto._removeElement = function _removeElement(element) {
          var _this = this;
          $__default["default"](element).removeClass(CLASS_NAME_SHOW$7);
          if (!$__default["default"](element).hasClass(CLASS_NAME_FADE$5)) {
            this._destroyElement(element);
            return;
          }
          var transitionDuration = Util.getTransitionDurationFromElement(element);
          $__default["default"](element).one(Util.TRANSITION_END, function(event) {
            return _this._destroyElement(element, event);
          }).emulateTransitionEnd(transitionDuration);
        };
        _proto._destroyElement = function _destroyElement(element) {
          $__default["default"](element).detach().trigger(EVENT_CLOSED).remove();
        };
        Alert2._jQueryInterface = function _jQueryInterface(config2) {
          return this.each(function() {
            var $element = $__default["default"](this);
            var data = $element.data(DATA_KEY$a);
            if (!data) {
              data = new Alert2(this);
              $element.data(DATA_KEY$a, data);
            }
            if (config2 === "close") {
              data[config2](this);
            }
          });
        };
        Alert2._handleDismiss = function _handleDismiss(alertInstance) {
          return function(event) {
            if (event) {
              event.preventDefault();
            }
            alertInstance.close(this);
          };
        };
        _createClass(Alert2, null, [{
          key: "VERSION",
          get: function get() {
            return VERSION$a;
          }
        }]);
        return Alert2;
      }();
      $__default["default"](document).on(EVENT_CLICK_DATA_API$6, SELECTOR_DISMISS, Alert._handleDismiss(new Alert()));
      $__default["default"].fn[NAME$a] = Alert._jQueryInterface;
      $__default["default"].fn[NAME$a].Constructor = Alert;
      $__default["default"].fn[NAME$a].noConflict = function() {
        $__default["default"].fn[NAME$a] = JQUERY_NO_CONFLICT$a;
        return Alert._jQueryInterface;
      };
      var NAME$9 = "button";
      var VERSION$9 = "4.6.2";
      var DATA_KEY$9 = "bs.button";
      var EVENT_KEY$9 = "." + DATA_KEY$9;
      var DATA_API_KEY$6 = ".data-api";
      var JQUERY_NO_CONFLICT$9 = $__default["default"].fn[NAME$9];
      var CLASS_NAME_ACTIVE$3 = "active";
      var CLASS_NAME_BUTTON = "btn";
      var CLASS_NAME_FOCUS = "focus";
      var EVENT_CLICK_DATA_API$5 = "click" + EVENT_KEY$9 + DATA_API_KEY$6;
      var EVENT_FOCUS_BLUR_DATA_API = "focus" + EVENT_KEY$9 + DATA_API_KEY$6 + " " + ("blur" + EVENT_KEY$9 + DATA_API_KEY$6);
      var EVENT_LOAD_DATA_API$2 = "load" + EVENT_KEY$9 + DATA_API_KEY$6;
      var SELECTOR_DATA_TOGGLE_CARROT = '[data-toggle^="button"]';
      var SELECTOR_DATA_TOGGLES = '[data-toggle="buttons"]';
      var SELECTOR_DATA_TOGGLE$4 = '[data-toggle="button"]';
      var SELECTOR_DATA_TOGGLES_BUTTONS = '[data-toggle="buttons"] .btn';
      var SELECTOR_INPUT = 'input:not([type="hidden"])';
      var SELECTOR_ACTIVE$2 = ".active";
      var SELECTOR_BUTTON = ".btn";
      var Button = function() {
        function Button2(element) {
          this._element = element;
          this.shouldAvoidTriggerChange = false;
        }
        var _proto = Button2.prototype;
        _proto.toggle = function toggle() {
          var triggerChangeEvent = true;
          var addAriaPressed = true;
          var rootElement = $__default["default"](this._element).closest(SELECTOR_DATA_TOGGLES)[0];
          if (rootElement) {
            var input = this._element.querySelector(SELECTOR_INPUT);
            if (input) {
              if (input.type === "radio") {
                if (input.checked && this._element.classList.contains(CLASS_NAME_ACTIVE$3)) {
                  triggerChangeEvent = false;
                } else {
                  var activeElement = rootElement.querySelector(SELECTOR_ACTIVE$2);
                  if (activeElement) {
                    $__default["default"](activeElement).removeClass(CLASS_NAME_ACTIVE$3);
                  }
                }
              }
              if (triggerChangeEvent) {
                if (input.type === "checkbox" || input.type === "radio") {
                  input.checked = !this._element.classList.contains(CLASS_NAME_ACTIVE$3);
                }
                if (!this.shouldAvoidTriggerChange) {
                  $__default["default"](input).trigger("change");
                }
              }
              input.focus();
              addAriaPressed = false;
            }
          }
          if (!(this._element.hasAttribute("disabled") || this._element.classList.contains("disabled"))) {
            if (addAriaPressed) {
              this._element.setAttribute("aria-pressed", !this._element.classList.contains(CLASS_NAME_ACTIVE$3));
            }
            if (triggerChangeEvent) {
              $__default["default"](this._element).toggleClass(CLASS_NAME_ACTIVE$3);
            }
          }
        };
        _proto.dispose = function dispose() {
          $__default["default"].removeData(this._element, DATA_KEY$9);
          this._element = null;
        };
        Button2._jQueryInterface = function _jQueryInterface(config2, avoidTriggerChange) {
          return this.each(function() {
            var $element = $__default["default"](this);
            var data = $element.data(DATA_KEY$9);
            if (!data) {
              data = new Button2(this);
              $element.data(DATA_KEY$9, data);
            }
            data.shouldAvoidTriggerChange = avoidTriggerChange;
            if (config2 === "toggle") {
              data[config2]();
            }
          });
        };
        _createClass(Button2, null, [{
          key: "VERSION",
          get: function get() {
            return VERSION$9;
          }
        }]);
        return Button2;
      }();
      $__default["default"](document).on(EVENT_CLICK_DATA_API$5, SELECTOR_DATA_TOGGLE_CARROT, function(event) {
        var button = event.target;
        var initialButton = button;
        if (!$__default["default"](button).hasClass(CLASS_NAME_BUTTON)) {
          button = $__default["default"](button).closest(SELECTOR_BUTTON)[0];
        }
        if (!button || button.hasAttribute("disabled") || button.classList.contains("disabled")) {
          event.preventDefault();
        } else {
          var inputBtn = button.querySelector(SELECTOR_INPUT);
          if (inputBtn && (inputBtn.hasAttribute("disabled") || inputBtn.classList.contains("disabled"))) {
            event.preventDefault();
            return;
          }
          if (initialButton.tagName === "INPUT" || button.tagName !== "LABEL") {
            Button._jQueryInterface.call($__default["default"](button), "toggle", initialButton.tagName === "INPUT");
          }
        }
      }).on(EVENT_FOCUS_BLUR_DATA_API, SELECTOR_DATA_TOGGLE_CARROT, function(event) {
        var button = $__default["default"](event.target).closest(SELECTOR_BUTTON)[0];
        $__default["default"](button).toggleClass(CLASS_NAME_FOCUS, /^focus(in)?$/.test(event.type));
      });
      $__default["default"](window).on(EVENT_LOAD_DATA_API$2, function() {
        var buttons = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLES_BUTTONS));
        for (var i2 = 0, len = buttons.length; i2 < len; i2++) {
          var button = buttons[i2];
          var input = button.querySelector(SELECTOR_INPUT);
          if (input.checked || input.hasAttribute("checked")) {
            button.classList.add(CLASS_NAME_ACTIVE$3);
          } else {
            button.classList.remove(CLASS_NAME_ACTIVE$3);
          }
        }
        buttons = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLE$4));
        for (var _i2 = 0, _len = buttons.length; _i2 < _len; _i2++) {
          var _button = buttons[_i2];
          if (_button.getAttribute("aria-pressed") === "true") {
            _button.classList.add(CLASS_NAME_ACTIVE$3);
          } else {
            _button.classList.remove(CLASS_NAME_ACTIVE$3);
          }
        }
      });
      $__default["default"].fn[NAME$9] = Button._jQueryInterface;
      $__default["default"].fn[NAME$9].Constructor = Button;
      $__default["default"].fn[NAME$9].noConflict = function() {
        $__default["default"].fn[NAME$9] = JQUERY_NO_CONFLICT$9;
        return Button._jQueryInterface;
      };
      var NAME$8 = "carousel";
      var VERSION$8 = "4.6.2";
      var DATA_KEY$8 = "bs.carousel";
      var EVENT_KEY$8 = "." + DATA_KEY$8;
      var DATA_API_KEY$5 = ".data-api";
      var JQUERY_NO_CONFLICT$8 = $__default["default"].fn[NAME$8];
      var ARROW_LEFT_KEYCODE = 37;
      var ARROW_RIGHT_KEYCODE = 39;
      var TOUCHEVENT_COMPAT_WAIT = 500;
      var SWIPE_THRESHOLD = 40;
      var CLASS_NAME_CAROUSEL = "carousel";
      var CLASS_NAME_ACTIVE$2 = "active";
      var CLASS_NAME_SLIDE = "slide";
      var CLASS_NAME_RIGHT = "carousel-item-right";
      var CLASS_NAME_LEFT = "carousel-item-left";
      var CLASS_NAME_NEXT = "carousel-item-next";
      var CLASS_NAME_PREV = "carousel-item-prev";
      var CLASS_NAME_POINTER_EVENT = "pointer-event";
      var DIRECTION_NEXT = "next";
      var DIRECTION_PREV = "prev";
      var DIRECTION_LEFT = "left";
      var DIRECTION_RIGHT = "right";
      var EVENT_SLIDE = "slide" + EVENT_KEY$8;
      var EVENT_SLID = "slid" + EVENT_KEY$8;
      var EVENT_KEYDOWN = "keydown" + EVENT_KEY$8;
      var EVENT_MOUSEENTER = "mouseenter" + EVENT_KEY$8;
      var EVENT_MOUSELEAVE = "mouseleave" + EVENT_KEY$8;
      var EVENT_TOUCHSTART = "touchstart" + EVENT_KEY$8;
      var EVENT_TOUCHMOVE = "touchmove" + EVENT_KEY$8;
      var EVENT_TOUCHEND = "touchend" + EVENT_KEY$8;
      var EVENT_POINTERDOWN = "pointerdown" + EVENT_KEY$8;
      var EVENT_POINTERUP = "pointerup" + EVENT_KEY$8;
      var EVENT_DRAG_START = "dragstart" + EVENT_KEY$8;
      var EVENT_LOAD_DATA_API$1 = "load" + EVENT_KEY$8 + DATA_API_KEY$5;
      var EVENT_CLICK_DATA_API$4 = "click" + EVENT_KEY$8 + DATA_API_KEY$5;
      var SELECTOR_ACTIVE$1 = ".active";
      var SELECTOR_ACTIVE_ITEM = ".active.carousel-item";
      var SELECTOR_ITEM = ".carousel-item";
      var SELECTOR_ITEM_IMG = ".carousel-item img";
      var SELECTOR_NEXT_PREV = ".carousel-item-next, .carousel-item-prev";
      var SELECTOR_INDICATORS = ".carousel-indicators";
      var SELECTOR_DATA_SLIDE = "[data-slide], [data-slide-to]";
      var SELECTOR_DATA_RIDE = '[data-ride="carousel"]';
      var Default$7 = {
        interval: 5e3,
        keyboard: true,
        slide: false,
        pause: "hover",
        wrap: true,
        touch: true
      };
      var DefaultType$7 = {
        interval: "(number|boolean)",
        keyboard: "boolean",
        slide: "(boolean|string)",
        pause: "(string|boolean)",
        wrap: "boolean",
        touch: "boolean"
      };
      var PointerType = {
        TOUCH: "touch",
        PEN: "pen"
      };
      var Carousel = function() {
        function Carousel2(element, config2) {
          this._items = null;
          this._interval = null;
          this._activeElement = null;
          this._isPaused = false;
          this._isSliding = false;
          this.touchTimeout = null;
          this.touchStartX = 0;
          this.touchDeltaX = 0;
          this._config = this._getConfig(config2);
          this._element = element;
          this._indicatorsElement = this._element.querySelector(SELECTOR_INDICATORS);
          this._touchSupported = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
          this._pointerEvent = Boolean(window.PointerEvent || window.MSPointerEvent);
          this._addEventListeners();
        }
        var _proto = Carousel2.prototype;
        _proto.next = function next() {
          if (!this._isSliding) {
            this._slide(DIRECTION_NEXT);
          }
        };
        _proto.nextWhenVisible = function nextWhenVisible() {
          var $element = $__default["default"](this._element);
          if (!document.hidden && $element.is(":visible") && $element.css("visibility") !== "hidden") {
            this.next();
          }
        };
        _proto.prev = function prev() {
          if (!this._isSliding) {
            this._slide(DIRECTION_PREV);
          }
        };
        _proto.pause = function pause(event) {
          if (!event) {
            this._isPaused = true;
          }
          if (this._element.querySelector(SELECTOR_NEXT_PREV)) {
            Util.triggerTransitionEnd(this._element);
            this.cycle(true);
          }
          clearInterval(this._interval);
          this._interval = null;
        };
        _proto.cycle = function cycle(event) {
          if (!event) {
            this._isPaused = false;
          }
          if (this._interval) {
            clearInterval(this._interval);
            this._interval = null;
          }
          if (this._config.interval && !this._isPaused) {
            this._updateInterval();
            this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);
          }
        };
        _proto.to = function to2(index) {
          var _this = this;
          this._activeElement = this._element.querySelector(SELECTOR_ACTIVE_ITEM);
          var activeIndex = this._getItemIndex(this._activeElement);
          if (index > this._items.length - 1 || index < 0) {
            return;
          }
          if (this._isSliding) {
            $__default["default"](this._element).one(EVENT_SLID, function() {
              return _this.to(index);
            });
            return;
          }
          if (activeIndex === index) {
            this.pause();
            this.cycle();
            return;
          }
          var direction = index > activeIndex ? DIRECTION_NEXT : DIRECTION_PREV;
          this._slide(direction, this._items[index]);
        };
        _proto.dispose = function dispose() {
          $__default["default"](this._element).off(EVENT_KEY$8);
          $__default["default"].removeData(this._element, DATA_KEY$8);
          this._items = null;
          this._config = null;
          this._element = null;
          this._interval = null;
          this._isPaused = null;
          this._isSliding = null;
          this._activeElement = null;
          this._indicatorsElement = null;
        };
        _proto._getConfig = function _getConfig(config2) {
          config2 = _extends2({}, Default$7, config2);
          Util.typeCheckConfig(NAME$8, config2, DefaultType$7);
          return config2;
        };
        _proto._handleSwipe = function _handleSwipe() {
          var absDeltax = Math.abs(this.touchDeltaX);
          if (absDeltax <= SWIPE_THRESHOLD) {
            return;
          }
          var direction = absDeltax / this.touchDeltaX;
          this.touchDeltaX = 0;
          if (direction > 0) {
            this.prev();
          }
          if (direction < 0) {
            this.next();
          }
        };
        _proto._addEventListeners = function _addEventListeners() {
          var _this2 = this;
          if (this._config.keyboard) {
            $__default["default"](this._element).on(EVENT_KEYDOWN, function(event) {
              return _this2._keydown(event);
            });
          }
          if (this._config.pause === "hover") {
            $__default["default"](this._element).on(EVENT_MOUSEENTER, function(event) {
              return _this2.pause(event);
            }).on(EVENT_MOUSELEAVE, function(event) {
              return _this2.cycle(event);
            });
          }
          if (this._config.touch) {
            this._addTouchEventListeners();
          }
        };
        _proto._addTouchEventListeners = function _addTouchEventListeners() {
          var _this3 = this;
          if (!this._touchSupported) {
            return;
          }
          var start2 = function start3(event) {
            if (_this3._pointerEvent && PointerType[event.originalEvent.pointerType.toUpperCase()]) {
              _this3.touchStartX = event.originalEvent.clientX;
            } else if (!_this3._pointerEvent) {
              _this3.touchStartX = event.originalEvent.touches[0].clientX;
            }
          };
          var move = function move2(event) {
            _this3.touchDeltaX = event.originalEvent.touches && event.originalEvent.touches.length > 1 ? 0 : event.originalEvent.touches[0].clientX - _this3.touchStartX;
          };
          var end = function end2(event) {
            if (_this3._pointerEvent && PointerType[event.originalEvent.pointerType.toUpperCase()]) {
              _this3.touchDeltaX = event.originalEvent.clientX - _this3.touchStartX;
            }
            _this3._handleSwipe();
            if (_this3._config.pause === "hover") {
              _this3.pause();
              if (_this3.touchTimeout) {
                clearTimeout(_this3.touchTimeout);
              }
              _this3.touchTimeout = setTimeout(function(event2) {
                return _this3.cycle(event2);
              }, TOUCHEVENT_COMPAT_WAIT + _this3._config.interval);
            }
          };
          $__default["default"](this._element.querySelectorAll(SELECTOR_ITEM_IMG)).on(EVENT_DRAG_START, function(e) {
            return e.preventDefault();
          });
          if (this._pointerEvent) {
            $__default["default"](this._element).on(EVENT_POINTERDOWN, function(event) {
              return start2(event);
            });
            $__default["default"](this._element).on(EVENT_POINTERUP, function(event) {
              return end(event);
            });
            this._element.classList.add(CLASS_NAME_POINTER_EVENT);
          } else {
            $__default["default"](this._element).on(EVENT_TOUCHSTART, function(event) {
              return start2(event);
            });
            $__default["default"](this._element).on(EVENT_TOUCHMOVE, function(event) {
              return move(event);
            });
            $__default["default"](this._element).on(EVENT_TOUCHEND, function(event) {
              return end(event);
            });
          }
        };
        _proto._keydown = function _keydown(event) {
          if (/input|textarea/i.test(event.target.tagName)) {
            return;
          }
          switch (event.which) {
            case ARROW_LEFT_KEYCODE:
              event.preventDefault();
              this.prev();
              break;
            case ARROW_RIGHT_KEYCODE:
              event.preventDefault();
              this.next();
              break;
          }
        };
        _proto._getItemIndex = function _getItemIndex(element) {
          this._items = element && element.parentNode ? [].slice.call(element.parentNode.querySelectorAll(SELECTOR_ITEM)) : [];
          return this._items.indexOf(element);
        };
        _proto._getItemByDirection = function _getItemByDirection(direction, activeElement) {
          var isNextDirection = direction === DIRECTION_NEXT;
          var isPrevDirection = direction === DIRECTION_PREV;
          var activeIndex = this._getItemIndex(activeElement);
          var lastItemIndex = this._items.length - 1;
          var isGoingToWrap = isPrevDirection && activeIndex === 0 || isNextDirection && activeIndex === lastItemIndex;
          if (isGoingToWrap && !this._config.wrap) {
            return activeElement;
          }
          var delta = direction === DIRECTION_PREV ? -1 : 1;
          var itemIndex = (activeIndex + delta) % this._items.length;
          return itemIndex === -1 ? this._items[this._items.length - 1] : this._items[itemIndex];
        };
        _proto._triggerSlideEvent = function _triggerSlideEvent(relatedTarget, eventDirectionName) {
          var targetIndex = this._getItemIndex(relatedTarget);
          var fromIndex = this._getItemIndex(this._element.querySelector(SELECTOR_ACTIVE_ITEM));
          var slideEvent = $__default["default"].Event(EVENT_SLIDE, {
            relatedTarget,
            direction: eventDirectionName,
            from: fromIndex,
            to: targetIndex
          });
          $__default["default"](this._element).trigger(slideEvent);
          return slideEvent;
        };
        _proto._setActiveIndicatorElement = function _setActiveIndicatorElement(element) {
          if (this._indicatorsElement) {
            var indicators = [].slice.call(this._indicatorsElement.querySelectorAll(SELECTOR_ACTIVE$1));
            $__default["default"](indicators).removeClass(CLASS_NAME_ACTIVE$2);
            var nextIndicator = this._indicatorsElement.children[this._getItemIndex(element)];
            if (nextIndicator) {
              $__default["default"](nextIndicator).addClass(CLASS_NAME_ACTIVE$2);
            }
          }
        };
        _proto._updateInterval = function _updateInterval() {
          var element = this._activeElement || this._element.querySelector(SELECTOR_ACTIVE_ITEM);
          if (!element) {
            return;
          }
          var elementInterval = parseInt(element.getAttribute("data-interval"), 10);
          if (elementInterval) {
            this._config.defaultInterval = this._config.defaultInterval || this._config.interval;
            this._config.interval = elementInterval;
          } else {
            this._config.interval = this._config.defaultInterval || this._config.interval;
          }
        };
        _proto._slide = function _slide(direction, element) {
          var _this4 = this;
          var activeElement = this._element.querySelector(SELECTOR_ACTIVE_ITEM);
          var activeElementIndex = this._getItemIndex(activeElement);
          var nextElement = element || activeElement && this._getItemByDirection(direction, activeElement);
          var nextElementIndex = this._getItemIndex(nextElement);
          var isCycling = Boolean(this._interval);
          var directionalClassName;
          var orderClassName;
          var eventDirectionName;
          if (direction === DIRECTION_NEXT) {
            directionalClassName = CLASS_NAME_LEFT;
            orderClassName = CLASS_NAME_NEXT;
            eventDirectionName = DIRECTION_LEFT;
          } else {
            directionalClassName = CLASS_NAME_RIGHT;
            orderClassName = CLASS_NAME_PREV;
            eventDirectionName = DIRECTION_RIGHT;
          }
          if (nextElement && $__default["default"](nextElement).hasClass(CLASS_NAME_ACTIVE$2)) {
            this._isSliding = false;
            return;
          }
          var slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);
          if (slideEvent.isDefaultPrevented()) {
            return;
          }
          if (!activeElement || !nextElement) {
            return;
          }
          this._isSliding = true;
          if (isCycling) {
            this.pause();
          }
          this._setActiveIndicatorElement(nextElement);
          this._activeElement = nextElement;
          var slidEvent = $__default["default"].Event(EVENT_SLID, {
            relatedTarget: nextElement,
            direction: eventDirectionName,
            from: activeElementIndex,
            to: nextElementIndex
          });
          if ($__default["default"](this._element).hasClass(CLASS_NAME_SLIDE)) {
            $__default["default"](nextElement).addClass(orderClassName);
            Util.reflow(nextElement);
            $__default["default"](activeElement).addClass(directionalClassName);
            $__default["default"](nextElement).addClass(directionalClassName);
            var transitionDuration = Util.getTransitionDurationFromElement(activeElement);
            $__default["default"](activeElement).one(Util.TRANSITION_END, function() {
              $__default["default"](nextElement).removeClass(directionalClassName + " " + orderClassName).addClass(CLASS_NAME_ACTIVE$2);
              $__default["default"](activeElement).removeClass(CLASS_NAME_ACTIVE$2 + " " + orderClassName + " " + directionalClassName);
              _this4._isSliding = false;
              setTimeout(function() {
                return $__default["default"](_this4._element).trigger(slidEvent);
              }, 0);
            }).emulateTransitionEnd(transitionDuration);
          } else {
            $__default["default"](activeElement).removeClass(CLASS_NAME_ACTIVE$2);
            $__default["default"](nextElement).addClass(CLASS_NAME_ACTIVE$2);
            this._isSliding = false;
            $__default["default"](this._element).trigger(slidEvent);
          }
          if (isCycling) {
            this.cycle();
          }
        };
        Carousel2._jQueryInterface = function _jQueryInterface(config2) {
          return this.each(function() {
            var data = $__default["default"](this).data(DATA_KEY$8);
            var _config = _extends2({}, Default$7, $__default["default"](this).data());
            if (typeof config2 === "object") {
              _config = _extends2({}, _config, config2);
            }
            var action = typeof config2 === "string" ? config2 : _config.slide;
            if (!data) {
              data = new Carousel2(this, _config);
              $__default["default"](this).data(DATA_KEY$8, data);
            }
            if (typeof config2 === "number") {
              data.to(config2);
            } else if (typeof action === "string") {
              if (typeof data[action] === "undefined") {
                throw new TypeError('No method named "' + action + '"');
              }
              data[action]();
            } else if (_config.interval && _config.ride) {
              data.pause();
              data.cycle();
            }
          });
        };
        Carousel2._dataApiClickHandler = function _dataApiClickHandler(event) {
          var selector = Util.getSelectorFromElement(this);
          if (!selector) {
            return;
          }
          var target = $__default["default"](selector)[0];
          if (!target || !$__default["default"](target).hasClass(CLASS_NAME_CAROUSEL)) {
            return;
          }
          var config2 = _extends2({}, $__default["default"](target).data(), $__default["default"](this).data());
          var slideIndex = this.getAttribute("data-slide-to");
          if (slideIndex) {
            config2.interval = false;
          }
          Carousel2._jQueryInterface.call($__default["default"](target), config2);
          if (slideIndex) {
            $__default["default"](target).data(DATA_KEY$8).to(slideIndex);
          }
          event.preventDefault();
        };
        _createClass(Carousel2, null, [{
          key: "VERSION",
          get: function get() {
            return VERSION$8;
          }
        }, {
          key: "Default",
          get: function get() {
            return Default$7;
          }
        }]);
        return Carousel2;
      }();
      $__default["default"](document).on(EVENT_CLICK_DATA_API$4, SELECTOR_DATA_SLIDE, Carousel._dataApiClickHandler);
      $__default["default"](window).on(EVENT_LOAD_DATA_API$1, function() {
        var carousels = [].slice.call(document.querySelectorAll(SELECTOR_DATA_RIDE));
        for (var i2 = 0, len = carousels.length; i2 < len; i2++) {
          var $carousel = $__default["default"](carousels[i2]);
          Carousel._jQueryInterface.call($carousel, $carousel.data());
        }
      });
      $__default["default"].fn[NAME$8] = Carousel._jQueryInterface;
      $__default["default"].fn[NAME$8].Constructor = Carousel;
      $__default["default"].fn[NAME$8].noConflict = function() {
        $__default["default"].fn[NAME$8] = JQUERY_NO_CONFLICT$8;
        return Carousel._jQueryInterface;
      };
      var NAME$7 = "collapse";
      var VERSION$7 = "4.6.2";
      var DATA_KEY$7 = "bs.collapse";
      var EVENT_KEY$7 = "." + DATA_KEY$7;
      var DATA_API_KEY$4 = ".data-api";
      var JQUERY_NO_CONFLICT$7 = $__default["default"].fn[NAME$7];
      var CLASS_NAME_SHOW$6 = "show";
      var CLASS_NAME_COLLAPSE = "collapse";
      var CLASS_NAME_COLLAPSING = "collapsing";
      var CLASS_NAME_COLLAPSED = "collapsed";
      var DIMENSION_WIDTH = "width";
      var DIMENSION_HEIGHT = "height";
      var EVENT_SHOW$4 = "show" + EVENT_KEY$7;
      var EVENT_SHOWN$4 = "shown" + EVENT_KEY$7;
      var EVENT_HIDE$4 = "hide" + EVENT_KEY$7;
      var EVENT_HIDDEN$4 = "hidden" + EVENT_KEY$7;
      var EVENT_CLICK_DATA_API$3 = "click" + EVENT_KEY$7 + DATA_API_KEY$4;
      var SELECTOR_ACTIVES = ".show, .collapsing";
      var SELECTOR_DATA_TOGGLE$3 = '[data-toggle="collapse"]';
      var Default$6 = {
        toggle: true,
        parent: ""
      };
      var DefaultType$6 = {
        toggle: "boolean",
        parent: "(string|element)"
      };
      var Collapse = function() {
        function Collapse2(element, config2) {
          this._isTransitioning = false;
          this._element = element;
          this._config = this._getConfig(config2);
          this._triggerArray = [].slice.call(document.querySelectorAll('[data-toggle="collapse"][href="#' + element.id + '"],' + ('[data-toggle="collapse"][data-target="#' + element.id + '"]')));
          var toggleList = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLE$3));
          for (var i2 = 0, len = toggleList.length; i2 < len; i2++) {
            var elem = toggleList[i2];
            var selector = Util.getSelectorFromElement(elem);
            var filterElement = [].slice.call(document.querySelectorAll(selector)).filter(function(foundElem) {
              return foundElem === element;
            });
            if (selector !== null && filterElement.length > 0) {
              this._selector = selector;
              this._triggerArray.push(elem);
            }
          }
          this._parent = this._config.parent ? this._getParent() : null;
          if (!this._config.parent) {
            this._addAriaAndCollapsedClass(this._element, this._triggerArray);
          }
          if (this._config.toggle) {
            this.toggle();
          }
        }
        var _proto = Collapse2.prototype;
        _proto.toggle = function toggle() {
          if ($__default["default"](this._element).hasClass(CLASS_NAME_SHOW$6)) {
            this.hide();
          } else {
            this.show();
          }
        };
        _proto.show = function show() {
          var _this = this;
          if (this._isTransitioning || $__default["default"](this._element).hasClass(CLASS_NAME_SHOW$6)) {
            return;
          }
          var actives;
          var activesData;
          if (this._parent) {
            actives = [].slice.call(this._parent.querySelectorAll(SELECTOR_ACTIVES)).filter(function(elem) {
              if (typeof _this._config.parent === "string") {
                return elem.getAttribute("data-parent") === _this._config.parent;
              }
              return elem.classList.contains(CLASS_NAME_COLLAPSE);
            });
            if (actives.length === 0) {
              actives = null;
            }
          }
          if (actives) {
            activesData = $__default["default"](actives).not(this._selector).data(DATA_KEY$7);
            if (activesData && activesData._isTransitioning) {
              return;
            }
          }
          var startEvent = $__default["default"].Event(EVENT_SHOW$4);
          $__default["default"](this._element).trigger(startEvent);
          if (startEvent.isDefaultPrevented()) {
            return;
          }
          if (actives) {
            Collapse2._jQueryInterface.call($__default["default"](actives).not(this._selector), "hide");
            if (!activesData) {
              $__default["default"](actives).data(DATA_KEY$7, null);
            }
          }
          var dimension = this._getDimension();
          $__default["default"](this._element).removeClass(CLASS_NAME_COLLAPSE).addClass(CLASS_NAME_COLLAPSING);
          this._element.style[dimension] = 0;
          if (this._triggerArray.length) {
            $__default["default"](this._triggerArray).removeClass(CLASS_NAME_COLLAPSED).attr("aria-expanded", true);
          }
          this.setTransitioning(true);
          var complete = function complete2() {
            $__default["default"](_this._element).removeClass(CLASS_NAME_COLLAPSING).addClass(CLASS_NAME_COLLAPSE + " " + CLASS_NAME_SHOW$6);
            _this._element.style[dimension] = "";
            _this.setTransitioning(false);
            $__default["default"](_this._element).trigger(EVENT_SHOWN$4);
          };
          var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
          var scrollSize = "scroll" + capitalizedDimension;
          var transitionDuration = Util.getTransitionDurationFromElement(this._element);
          $__default["default"](this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
          this._element.style[dimension] = this._element[scrollSize] + "px";
        };
        _proto.hide = function hide2() {
          var _this2 = this;
          if (this._isTransitioning || !$__default["default"](this._element).hasClass(CLASS_NAME_SHOW$6)) {
            return;
          }
          var startEvent = $__default["default"].Event(EVENT_HIDE$4);
          $__default["default"](this._element).trigger(startEvent);
          if (startEvent.isDefaultPrevented()) {
            return;
          }
          var dimension = this._getDimension();
          this._element.style[dimension] = this._element.getBoundingClientRect()[dimension] + "px";
          Util.reflow(this._element);
          $__default["default"](this._element).addClass(CLASS_NAME_COLLAPSING).removeClass(CLASS_NAME_COLLAPSE + " " + CLASS_NAME_SHOW$6);
          var triggerArrayLength = this._triggerArray.length;
          if (triggerArrayLength > 0) {
            for (var i2 = 0; i2 < triggerArrayLength; i2++) {
              var trigger = this._triggerArray[i2];
              var selector = Util.getSelectorFromElement(trigger);
              if (selector !== null) {
                var $elem = $__default["default"]([].slice.call(document.querySelectorAll(selector)));
                if (!$elem.hasClass(CLASS_NAME_SHOW$6)) {
                  $__default["default"](trigger).addClass(CLASS_NAME_COLLAPSED).attr("aria-expanded", false);
                }
              }
            }
          }
          this.setTransitioning(true);
          var complete = function complete2() {
            _this2.setTransitioning(false);
            $__default["default"](_this2._element).removeClass(CLASS_NAME_COLLAPSING).addClass(CLASS_NAME_COLLAPSE).trigger(EVENT_HIDDEN$4);
          };
          this._element.style[dimension] = "";
          var transitionDuration = Util.getTransitionDurationFromElement(this._element);
          $__default["default"](this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
        };
        _proto.setTransitioning = function setTransitioning(isTransitioning) {
          this._isTransitioning = isTransitioning;
        };
        _proto.dispose = function dispose() {
          $__default["default"].removeData(this._element, DATA_KEY$7);
          this._config = null;
          this._parent = null;
          this._element = null;
          this._triggerArray = null;
          this._isTransitioning = null;
        };
        _proto._getConfig = function _getConfig(config2) {
          config2 = _extends2({}, Default$6, config2);
          config2.toggle = Boolean(config2.toggle);
          Util.typeCheckConfig(NAME$7, config2, DefaultType$6);
          return config2;
        };
        _proto._getDimension = function _getDimension() {
          var hasWidth = $__default["default"](this._element).hasClass(DIMENSION_WIDTH);
          return hasWidth ? DIMENSION_WIDTH : DIMENSION_HEIGHT;
        };
        _proto._getParent = function _getParent() {
          var _this3 = this;
          var parent2;
          if (Util.isElement(this._config.parent)) {
            parent2 = this._config.parent;
            if (typeof this._config.parent.jquery !== "undefined") {
              parent2 = this._config.parent[0];
            }
          } else {
            parent2 = document.querySelector(this._config.parent);
          }
          var selector = '[data-toggle="collapse"][data-parent="' + this._config.parent + '"]';
          var children = [].slice.call(parent2.querySelectorAll(selector));
          $__default["default"](children).each(function(i2, element) {
            _this3._addAriaAndCollapsedClass(Collapse2._getTargetFromElement(element), [element]);
          });
          return parent2;
        };
        _proto._addAriaAndCollapsedClass = function _addAriaAndCollapsedClass(element, triggerArray) {
          var isOpen = $__default["default"](element).hasClass(CLASS_NAME_SHOW$6);
          if (triggerArray.length) {
            $__default["default"](triggerArray).toggleClass(CLASS_NAME_COLLAPSED, !isOpen).attr("aria-expanded", isOpen);
          }
        };
        Collapse2._getTargetFromElement = function _getTargetFromElement(element) {
          var selector = Util.getSelectorFromElement(element);
          return selector ? document.querySelector(selector) : null;
        };
        Collapse2._jQueryInterface = function _jQueryInterface(config2) {
          return this.each(function() {
            var $element = $__default["default"](this);
            var data = $element.data(DATA_KEY$7);
            var _config = _extends2({}, Default$6, $element.data(), typeof config2 === "object" && config2 ? config2 : {});
            if (!data && _config.toggle && typeof config2 === "string" && /show|hide/.test(config2)) {
              _config.toggle = false;
            }
            if (!data) {
              data = new Collapse2(this, _config);
              $element.data(DATA_KEY$7, data);
            }
            if (typeof config2 === "string") {
              if (typeof data[config2] === "undefined") {
                throw new TypeError('No method named "' + config2 + '"');
              }
              data[config2]();
            }
          });
        };
        _createClass(Collapse2, null, [{
          key: "VERSION",
          get: function get() {
            return VERSION$7;
          }
        }, {
          key: "Default",
          get: function get() {
            return Default$6;
          }
        }]);
        return Collapse2;
      }();
      $__default["default"](document).on(EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function(event) {
        if (event.currentTarget.tagName === "A") {
          event.preventDefault();
        }
        var $trigger = $__default["default"](this);
        var selector = Util.getSelectorFromElement(this);
        var selectors = [].slice.call(document.querySelectorAll(selector));
        $__default["default"](selectors).each(function() {
          var $target = $__default["default"](this);
          var data = $target.data(DATA_KEY$7);
          var config2 = data ? "toggle" : $trigger.data();
          Collapse._jQueryInterface.call($target, config2);
        });
      });
      $__default["default"].fn[NAME$7] = Collapse._jQueryInterface;
      $__default["default"].fn[NAME$7].Constructor = Collapse;
      $__default["default"].fn[NAME$7].noConflict = function() {
        $__default["default"].fn[NAME$7] = JQUERY_NO_CONFLICT$7;
        return Collapse._jQueryInterface;
      };
      var NAME$6 = "dropdown";
      var VERSION$6 = "4.6.2";
      var DATA_KEY$6 = "bs.dropdown";
      var EVENT_KEY$6 = "." + DATA_KEY$6;
      var DATA_API_KEY$3 = ".data-api";
      var JQUERY_NO_CONFLICT$6 = $__default["default"].fn[NAME$6];
      var ESCAPE_KEYCODE$1 = 27;
      var SPACE_KEYCODE = 32;
      var TAB_KEYCODE = 9;
      var ARROW_UP_KEYCODE = 38;
      var ARROW_DOWN_KEYCODE = 40;
      var RIGHT_MOUSE_BUTTON_WHICH = 3;
      var REGEXP_KEYDOWN = new RegExp(ARROW_UP_KEYCODE + "|" + ARROW_DOWN_KEYCODE + "|" + ESCAPE_KEYCODE$1);
      var CLASS_NAME_DISABLED$1 = "disabled";
      var CLASS_NAME_SHOW$5 = "show";
      var CLASS_NAME_DROPUP = "dropup";
      var CLASS_NAME_DROPRIGHT = "dropright";
      var CLASS_NAME_DROPLEFT = "dropleft";
      var CLASS_NAME_MENURIGHT = "dropdown-menu-right";
      var CLASS_NAME_POSITION_STATIC = "position-static";
      var EVENT_HIDE$3 = "hide" + EVENT_KEY$6;
      var EVENT_HIDDEN$3 = "hidden" + EVENT_KEY$6;
      var EVENT_SHOW$3 = "show" + EVENT_KEY$6;
      var EVENT_SHOWN$3 = "shown" + EVENT_KEY$6;
      var EVENT_CLICK = "click" + EVENT_KEY$6;
      var EVENT_CLICK_DATA_API$2 = "click" + EVENT_KEY$6 + DATA_API_KEY$3;
      var EVENT_KEYDOWN_DATA_API = "keydown" + EVENT_KEY$6 + DATA_API_KEY$3;
      var EVENT_KEYUP_DATA_API = "keyup" + EVENT_KEY$6 + DATA_API_KEY$3;
      var SELECTOR_DATA_TOGGLE$2 = '[data-toggle="dropdown"]';
      var SELECTOR_FORM_CHILD = ".dropdown form";
      var SELECTOR_MENU = ".dropdown-menu";
      var SELECTOR_NAVBAR_NAV = ".navbar-nav";
      var SELECTOR_VISIBLE_ITEMS = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)";
      var PLACEMENT_TOP = "top-start";
      var PLACEMENT_TOPEND = "top-end";
      var PLACEMENT_BOTTOM = "bottom-start";
      var PLACEMENT_BOTTOMEND = "bottom-end";
      var PLACEMENT_RIGHT = "right-start";
      var PLACEMENT_LEFT = "left-start";
      var Default$5 = {
        offset: 0,
        flip: true,
        boundary: "scrollParent",
        reference: "toggle",
        display: "dynamic",
        popperConfig: null
      };
      var DefaultType$5 = {
        offset: "(number|string|function)",
        flip: "boolean",
        boundary: "(string|element)",
        reference: "(string|element)",
        display: "string",
        popperConfig: "(null|object)"
      };
      var Dropdown = function() {
        function Dropdown2(element, config2) {
          this._element = element;
          this._popper = null;
          this._config = this._getConfig(config2);
          this._menu = this._getMenuElement();
          this._inNavbar = this._detectNavbar();
          this._addEventListeners();
        }
        var _proto = Dropdown2.prototype;
        _proto.toggle = function toggle() {
          if (this._element.disabled || $__default["default"](this._element).hasClass(CLASS_NAME_DISABLED$1)) {
            return;
          }
          var isActive = $__default["default"](this._menu).hasClass(CLASS_NAME_SHOW$5);
          Dropdown2._clearMenus();
          if (isActive) {
            return;
          }
          this.show(true);
        };
        _proto.show = function show(usePopper) {
          if (usePopper === void 0) {
            usePopper = false;
          }
          if (this._element.disabled || $__default["default"](this._element).hasClass(CLASS_NAME_DISABLED$1) || $__default["default"](this._menu).hasClass(CLASS_NAME_SHOW$5)) {
            return;
          }
          var relatedTarget = {
            relatedTarget: this._element
          };
          var showEvent = $__default["default"].Event(EVENT_SHOW$3, relatedTarget);
          var parent2 = Dropdown2._getParentFromElement(this._element);
          $__default["default"](parent2).trigger(showEvent);
          if (showEvent.isDefaultPrevented()) {
            return;
          }
          if (!this._inNavbar && usePopper) {
            if (typeof Popper__default["default"] === "undefined") {
              throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
            }
            var referenceElement = this._element;
            if (this._config.reference === "parent") {
              referenceElement = parent2;
            } else if (Util.isElement(this._config.reference)) {
              referenceElement = this._config.reference;
              if (typeof this._config.reference.jquery !== "undefined") {
                referenceElement = this._config.reference[0];
              }
            }
            if (this._config.boundary !== "scrollParent") {
              $__default["default"](parent2).addClass(CLASS_NAME_POSITION_STATIC);
            }
            this._popper = new Popper__default["default"](referenceElement, this._menu, this._getPopperConfig());
          }
          if ("ontouchstart" in document.documentElement && $__default["default"](parent2).closest(SELECTOR_NAVBAR_NAV).length === 0) {
            $__default["default"](document.body).children().on("mouseover", null, $__default["default"].noop);
          }
          this._element.focus();
          this._element.setAttribute("aria-expanded", true);
          $__default["default"](this._menu).toggleClass(CLASS_NAME_SHOW$5);
          $__default["default"](parent2).toggleClass(CLASS_NAME_SHOW$5).trigger($__default["default"].Event(EVENT_SHOWN$3, relatedTarget));
        };
        _proto.hide = function hide2() {
          if (this._element.disabled || $__default["default"](this._element).hasClass(CLASS_NAME_DISABLED$1) || !$__default["default"](this._menu).hasClass(CLASS_NAME_SHOW$5)) {
            return;
          }
          var relatedTarget = {
            relatedTarget: this._element
          };
          var hideEvent = $__default["default"].Event(EVENT_HIDE$3, relatedTarget);
          var parent2 = Dropdown2._getParentFromElement(this._element);
          $__default["default"](parent2).trigger(hideEvent);
          if (hideEvent.isDefaultPrevented()) {
            return;
          }
          if (this._popper) {
            this._popper.destroy();
          }
          $__default["default"](this._menu).toggleClass(CLASS_NAME_SHOW$5);
          $__default["default"](parent2).toggleClass(CLASS_NAME_SHOW$5).trigger($__default["default"].Event(EVENT_HIDDEN$3, relatedTarget));
        };
        _proto.dispose = function dispose() {
          $__default["default"].removeData(this._element, DATA_KEY$6);
          $__default["default"](this._element).off(EVENT_KEY$6);
          this._element = null;
          this._menu = null;
          if (this._popper !== null) {
            this._popper.destroy();
            this._popper = null;
          }
        };
        _proto.update = function update2() {
          this._inNavbar = this._detectNavbar();
          if (this._popper !== null) {
            this._popper.scheduleUpdate();
          }
        };
        _proto._addEventListeners = function _addEventListeners() {
          var _this = this;
          $__default["default"](this._element).on(EVENT_CLICK, function(event) {
            event.preventDefault();
            event.stopPropagation();
            _this.toggle();
          });
        };
        _proto._getConfig = function _getConfig(config2) {
          config2 = _extends2({}, this.constructor.Default, $__default["default"](this._element).data(), config2);
          Util.typeCheckConfig(NAME$6, config2, this.constructor.DefaultType);
          return config2;
        };
        _proto._getMenuElement = function _getMenuElement() {
          if (!this._menu) {
            var parent2 = Dropdown2._getParentFromElement(this._element);
            if (parent2) {
              this._menu = parent2.querySelector(SELECTOR_MENU);
            }
          }
          return this._menu;
        };
        _proto._getPlacement = function _getPlacement() {
          var $parentDropdown = $__default["default"](this._element.parentNode);
          var placement = PLACEMENT_BOTTOM;
          if ($parentDropdown.hasClass(CLASS_NAME_DROPUP)) {
            placement = $__default["default"](this._menu).hasClass(CLASS_NAME_MENURIGHT) ? PLACEMENT_TOPEND : PLACEMENT_TOP;
          } else if ($parentDropdown.hasClass(CLASS_NAME_DROPRIGHT)) {
            placement = PLACEMENT_RIGHT;
          } else if ($parentDropdown.hasClass(CLASS_NAME_DROPLEFT)) {
            placement = PLACEMENT_LEFT;
          } else if ($__default["default"](this._menu).hasClass(CLASS_NAME_MENURIGHT)) {
            placement = PLACEMENT_BOTTOMEND;
          }
          return placement;
        };
        _proto._detectNavbar = function _detectNavbar() {
          return $__default["default"](this._element).closest(".navbar").length > 0;
        };
        _proto._getOffset = function _getOffset() {
          var _this2 = this;
          var offset2 = {};
          if (typeof this._config.offset === "function") {
            offset2.fn = function(data) {
              data.offsets = _extends2({}, data.offsets, _this2._config.offset(data.offsets, _this2._element));
              return data;
            };
          } else {
            offset2.offset = this._config.offset;
          }
          return offset2;
        };
        _proto._getPopperConfig = function _getPopperConfig() {
          var popperConfig = {
            placement: this._getPlacement(),
            modifiers: {
              offset: this._getOffset(),
              flip: {
                enabled: this._config.flip
              },
              preventOverflow: {
                boundariesElement: this._config.boundary
              }
            }
          };
          if (this._config.display === "static") {
            popperConfig.modifiers.applyStyle = {
              enabled: false
            };
          }
          return _extends2({}, popperConfig, this._config.popperConfig);
        };
        Dropdown2._jQueryInterface = function _jQueryInterface(config2) {
          return this.each(function() {
            var data = $__default["default"](this).data(DATA_KEY$6);
            var _config = typeof config2 === "object" ? config2 : null;
            if (!data) {
              data = new Dropdown2(this, _config);
              $__default["default"](this).data(DATA_KEY$6, data);
            }
            if (typeof config2 === "string") {
              if (typeof data[config2] === "undefined") {
                throw new TypeError('No method named "' + config2 + '"');
              }
              data[config2]();
            }
          });
        };
        Dropdown2._clearMenus = function _clearMenus(event) {
          if (event && (event.which === RIGHT_MOUSE_BUTTON_WHICH || event.type === "keyup" && event.which !== TAB_KEYCODE)) {
            return;
          }
          var toggles = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLE$2));
          for (var i2 = 0, len = toggles.length; i2 < len; i2++) {
            var parent2 = Dropdown2._getParentFromElement(toggles[i2]);
            var context = $__default["default"](toggles[i2]).data(DATA_KEY$6);
            var relatedTarget = {
              relatedTarget: toggles[i2]
            };
            if (event && event.type === "click") {
              relatedTarget.clickEvent = event;
            }
            if (!context) {
              continue;
            }
            var dropdownMenu = context._menu;
            if (!$__default["default"](parent2).hasClass(CLASS_NAME_SHOW$5)) {
              continue;
            }
            if (event && (event.type === "click" && /input|textarea/i.test(event.target.tagName) || event.type === "keyup" && event.which === TAB_KEYCODE) && $__default["default"].contains(parent2, event.target)) {
              continue;
            }
            var hideEvent = $__default["default"].Event(EVENT_HIDE$3, relatedTarget);
            $__default["default"](parent2).trigger(hideEvent);
            if (hideEvent.isDefaultPrevented()) {
              continue;
            }
            if ("ontouchstart" in document.documentElement) {
              $__default["default"](document.body).children().off("mouseover", null, $__default["default"].noop);
            }
            toggles[i2].setAttribute("aria-expanded", "false");
            if (context._popper) {
              context._popper.destroy();
            }
            $__default["default"](dropdownMenu).removeClass(CLASS_NAME_SHOW$5);
            $__default["default"](parent2).removeClass(CLASS_NAME_SHOW$5).trigger($__default["default"].Event(EVENT_HIDDEN$3, relatedTarget));
          }
        };
        Dropdown2._getParentFromElement = function _getParentFromElement(element) {
          var parent2;
          var selector = Util.getSelectorFromElement(element);
          if (selector) {
            parent2 = document.querySelector(selector);
          }
          return parent2 || element.parentNode;
        };
        Dropdown2._dataApiKeydownHandler = function _dataApiKeydownHandler(event) {
          if (/input|textarea/i.test(event.target.tagName) ? event.which === SPACE_KEYCODE || event.which !== ESCAPE_KEYCODE$1 && (event.which !== ARROW_DOWN_KEYCODE && event.which !== ARROW_UP_KEYCODE || $__default["default"](event.target).closest(SELECTOR_MENU).length) : !REGEXP_KEYDOWN.test(event.which)) {
            return;
          }
          if (this.disabled || $__default["default"](this).hasClass(CLASS_NAME_DISABLED$1)) {
            return;
          }
          var parent2 = Dropdown2._getParentFromElement(this);
          var isActive = $__default["default"](parent2).hasClass(CLASS_NAME_SHOW$5);
          if (!isActive && event.which === ESCAPE_KEYCODE$1) {
            return;
          }
          event.preventDefault();
          event.stopPropagation();
          if (!isActive || event.which === ESCAPE_KEYCODE$1 || event.which === SPACE_KEYCODE) {
            if (event.which === ESCAPE_KEYCODE$1) {
              $__default["default"](parent2.querySelector(SELECTOR_DATA_TOGGLE$2)).trigger("focus");
            }
            $__default["default"](this).trigger("click");
            return;
          }
          var items = [].slice.call(parent2.querySelectorAll(SELECTOR_VISIBLE_ITEMS)).filter(function(item) {
            return $__default["default"](item).is(":visible");
          });
          if (items.length === 0) {
            return;
          }
          var index = items.indexOf(event.target);
          if (event.which === ARROW_UP_KEYCODE && index > 0) {
            index--;
          }
          if (event.which === ARROW_DOWN_KEYCODE && index < items.length - 1) {
            index++;
          }
          if (index < 0) {
            index = 0;
          }
          items[index].focus();
        };
        _createClass(Dropdown2, null, [{
          key: "VERSION",
          get: function get() {
            return VERSION$6;
          }
        }, {
          key: "Default",
          get: function get() {
            return Default$5;
          }
        }, {
          key: "DefaultType",
          get: function get() {
            return DefaultType$5;
          }
        }]);
        return Dropdown2;
      }();
      $__default["default"](document).on(EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$2, Dropdown._dataApiKeydownHandler).on(EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown._dataApiKeydownHandler).on(EVENT_CLICK_DATA_API$2 + " " + EVENT_KEYUP_DATA_API, Dropdown._clearMenus).on(EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function(event) {
        event.preventDefault();
        event.stopPropagation();
        Dropdown._jQueryInterface.call($__default["default"](this), "toggle");
      }).on(EVENT_CLICK_DATA_API$2, SELECTOR_FORM_CHILD, function(e) {
        e.stopPropagation();
      });
      $__default["default"].fn[NAME$6] = Dropdown._jQueryInterface;
      $__default["default"].fn[NAME$6].Constructor = Dropdown;
      $__default["default"].fn[NAME$6].noConflict = function() {
        $__default["default"].fn[NAME$6] = JQUERY_NO_CONFLICT$6;
        return Dropdown._jQueryInterface;
      };
      var NAME$5 = "modal";
      var VERSION$5 = "4.6.2";
      var DATA_KEY$5 = "bs.modal";
      var EVENT_KEY$5 = "." + DATA_KEY$5;
      var DATA_API_KEY$2 = ".data-api";
      var JQUERY_NO_CONFLICT$5 = $__default["default"].fn[NAME$5];
      var ESCAPE_KEYCODE = 27;
      var CLASS_NAME_SCROLLABLE = "modal-dialog-scrollable";
      var CLASS_NAME_SCROLLBAR_MEASURER = "modal-scrollbar-measure";
      var CLASS_NAME_BACKDROP = "modal-backdrop";
      var CLASS_NAME_OPEN = "modal-open";
      var CLASS_NAME_FADE$4 = "fade";
      var CLASS_NAME_SHOW$4 = "show";
      var CLASS_NAME_STATIC = "modal-static";
      var EVENT_HIDE$2 = "hide" + EVENT_KEY$5;
      var EVENT_HIDE_PREVENTED = "hidePrevented" + EVENT_KEY$5;
      var EVENT_HIDDEN$2 = "hidden" + EVENT_KEY$5;
      var EVENT_SHOW$2 = "show" + EVENT_KEY$5;
      var EVENT_SHOWN$2 = "shown" + EVENT_KEY$5;
      var EVENT_FOCUSIN = "focusin" + EVENT_KEY$5;
      var EVENT_RESIZE = "resize" + EVENT_KEY$5;
      var EVENT_CLICK_DISMISS$1 = "click.dismiss" + EVENT_KEY$5;
      var EVENT_KEYDOWN_DISMISS = "keydown.dismiss" + EVENT_KEY$5;
      var EVENT_MOUSEUP_DISMISS = "mouseup.dismiss" + EVENT_KEY$5;
      var EVENT_MOUSEDOWN_DISMISS = "mousedown.dismiss" + EVENT_KEY$5;
      var EVENT_CLICK_DATA_API$1 = "click" + EVENT_KEY$5 + DATA_API_KEY$2;
      var SELECTOR_DIALOG = ".modal-dialog";
      var SELECTOR_MODAL_BODY = ".modal-body";
      var SELECTOR_DATA_TOGGLE$1 = '[data-toggle="modal"]';
      var SELECTOR_DATA_DISMISS$1 = '[data-dismiss="modal"]';
      var SELECTOR_FIXED_CONTENT = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top";
      var SELECTOR_STICKY_CONTENT = ".sticky-top";
      var Default$4 = {
        backdrop: true,
        keyboard: true,
        focus: true,
        show: true
      };
      var DefaultType$4 = {
        backdrop: "(boolean|string)",
        keyboard: "boolean",
        focus: "boolean",
        show: "boolean"
      };
      var Modal = function() {
        function Modal2(element, config2) {
          this._config = this._getConfig(config2);
          this._element = element;
          this._dialog = element.querySelector(SELECTOR_DIALOG);
          this._backdrop = null;
          this._isShown = false;
          this._isBodyOverflowing = false;
          this._ignoreBackdropClick = false;
          this._isTransitioning = false;
          this._scrollbarWidth = 0;
        }
        var _proto = Modal2.prototype;
        _proto.toggle = function toggle(relatedTarget) {
          return this._isShown ? this.hide() : this.show(relatedTarget);
        };
        _proto.show = function show(relatedTarget) {
          var _this = this;
          if (this._isShown || this._isTransitioning) {
            return;
          }
          var showEvent = $__default["default"].Event(EVENT_SHOW$2, {
            relatedTarget
          });
          $__default["default"](this._element).trigger(showEvent);
          if (showEvent.isDefaultPrevented()) {
            return;
          }
          this._isShown = true;
          if ($__default["default"](this._element).hasClass(CLASS_NAME_FADE$4)) {
            this._isTransitioning = true;
          }
          this._checkScrollbar();
          this._setScrollbar();
          this._adjustDialog();
          this._setEscapeEvent();
          this._setResizeEvent();
          $__default["default"](this._element).on(EVENT_CLICK_DISMISS$1, SELECTOR_DATA_DISMISS$1, function(event) {
            return _this.hide(event);
          });
          $__default["default"](this._dialog).on(EVENT_MOUSEDOWN_DISMISS, function() {
            $__default["default"](_this._element).one(EVENT_MOUSEUP_DISMISS, function(event) {
              if ($__default["default"](event.target).is(_this._element)) {
                _this._ignoreBackdropClick = true;
              }
            });
          });
          this._showBackdrop(function() {
            return _this._showElement(relatedTarget);
          });
        };
        _proto.hide = function hide2(event) {
          var _this2 = this;
          if (event) {
            event.preventDefault();
          }
          if (!this._isShown || this._isTransitioning) {
            return;
          }
          var hideEvent = $__default["default"].Event(EVENT_HIDE$2);
          $__default["default"](this._element).trigger(hideEvent);
          if (!this._isShown || hideEvent.isDefaultPrevented()) {
            return;
          }
          this._isShown = false;
          var transition = $__default["default"](this._element).hasClass(CLASS_NAME_FADE$4);
          if (transition) {
            this._isTransitioning = true;
          }
          this._setEscapeEvent();
          this._setResizeEvent();
          $__default["default"](document).off(EVENT_FOCUSIN);
          $__default["default"](this._element).removeClass(CLASS_NAME_SHOW$4);
          $__default["default"](this._element).off(EVENT_CLICK_DISMISS$1);
          $__default["default"](this._dialog).off(EVENT_MOUSEDOWN_DISMISS);
          if (transition) {
            var transitionDuration = Util.getTransitionDurationFromElement(this._element);
            $__default["default"](this._element).one(Util.TRANSITION_END, function(event2) {
              return _this2._hideModal(event2);
            }).emulateTransitionEnd(transitionDuration);
          } else {
            this._hideModal();
          }
        };
        _proto.dispose = function dispose() {
          [window, this._element, this._dialog].forEach(function(htmlElement) {
            return $__default["default"](htmlElement).off(EVENT_KEY$5);
          });
          $__default["default"](document).off(EVENT_FOCUSIN);
          $__default["default"].removeData(this._element, DATA_KEY$5);
          this._config = null;
          this._element = null;
          this._dialog = null;
          this._backdrop = null;
          this._isShown = null;
          this._isBodyOverflowing = null;
          this._ignoreBackdropClick = null;
          this._isTransitioning = null;
          this._scrollbarWidth = null;
        };
        _proto.handleUpdate = function handleUpdate() {
          this._adjustDialog();
        };
        _proto._getConfig = function _getConfig(config2) {
          config2 = _extends2({}, Default$4, config2);
          Util.typeCheckConfig(NAME$5, config2, DefaultType$4);
          return config2;
        };
        _proto._triggerBackdropTransition = function _triggerBackdropTransition() {
          var _this3 = this;
          var hideEventPrevented = $__default["default"].Event(EVENT_HIDE_PREVENTED);
          $__default["default"](this._element).trigger(hideEventPrevented);
          if (hideEventPrevented.isDefaultPrevented()) {
            return;
          }
          var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
          if (!isModalOverflowing) {
            this._element.style.overflowY = "hidden";
          }
          this._element.classList.add(CLASS_NAME_STATIC);
          var modalTransitionDuration = Util.getTransitionDurationFromElement(this._dialog);
          $__default["default"](this._element).off(Util.TRANSITION_END);
          $__default["default"](this._element).one(Util.TRANSITION_END, function() {
            _this3._element.classList.remove(CLASS_NAME_STATIC);
            if (!isModalOverflowing) {
              $__default["default"](_this3._element).one(Util.TRANSITION_END, function() {
                _this3._element.style.overflowY = "";
              }).emulateTransitionEnd(_this3._element, modalTransitionDuration);
            }
          }).emulateTransitionEnd(modalTransitionDuration);
          this._element.focus();
        };
        _proto._showElement = function _showElement(relatedTarget) {
          var _this4 = this;
          var transition = $__default["default"](this._element).hasClass(CLASS_NAME_FADE$4);
          var modalBody = this._dialog ? this._dialog.querySelector(SELECTOR_MODAL_BODY) : null;
          if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {
            document.body.appendChild(this._element);
          }
          this._element.style.display = "block";
          this._element.removeAttribute("aria-hidden");
          this._element.setAttribute("aria-modal", true);
          this._element.setAttribute("role", "dialog");
          if ($__default["default"](this._dialog).hasClass(CLASS_NAME_SCROLLABLE) && modalBody) {
            modalBody.scrollTop = 0;
          } else {
            this._element.scrollTop = 0;
          }
          if (transition) {
            Util.reflow(this._element);
          }
          $__default["default"](this._element).addClass(CLASS_NAME_SHOW$4);
          if (this._config.focus) {
            this._enforceFocus();
          }
          var shownEvent = $__default["default"].Event(EVENT_SHOWN$2, {
            relatedTarget
          });
          var transitionComplete = function transitionComplete2() {
            if (_this4._config.focus) {
              _this4._element.focus();
            }
            _this4._isTransitioning = false;
            $__default["default"](_this4._element).trigger(shownEvent);
          };
          if (transition) {
            var transitionDuration = Util.getTransitionDurationFromElement(this._dialog);
            $__default["default"](this._dialog).one(Util.TRANSITION_END, transitionComplete).emulateTransitionEnd(transitionDuration);
          } else {
            transitionComplete();
          }
        };
        _proto._enforceFocus = function _enforceFocus() {
          var _this5 = this;
          $__default["default"](document).off(EVENT_FOCUSIN).on(EVENT_FOCUSIN, function(event) {
            if (document !== event.target && _this5._element !== event.target && $__default["default"](_this5._element).has(event.target).length === 0) {
              _this5._element.focus();
            }
          });
        };
        _proto._setEscapeEvent = function _setEscapeEvent() {
          var _this6 = this;
          if (this._isShown) {
            $__default["default"](this._element).on(EVENT_KEYDOWN_DISMISS, function(event) {
              if (_this6._config.keyboard && event.which === ESCAPE_KEYCODE) {
                event.preventDefault();
                _this6.hide();
              } else if (!_this6._config.keyboard && event.which === ESCAPE_KEYCODE) {
                _this6._triggerBackdropTransition();
              }
            });
          } else if (!this._isShown) {
            $__default["default"](this._element).off(EVENT_KEYDOWN_DISMISS);
          }
        };
        _proto._setResizeEvent = function _setResizeEvent() {
          var _this7 = this;
          if (this._isShown) {
            $__default["default"](window).on(EVENT_RESIZE, function(event) {
              return _this7.handleUpdate(event);
            });
          } else {
            $__default["default"](window).off(EVENT_RESIZE);
          }
        };
        _proto._hideModal = function _hideModal() {
          var _this8 = this;
          this._element.style.display = "none";
          this._element.setAttribute("aria-hidden", true);
          this._element.removeAttribute("aria-modal");
          this._element.removeAttribute("role");
          this._isTransitioning = false;
          this._showBackdrop(function() {
            $__default["default"](document.body).removeClass(CLASS_NAME_OPEN);
            _this8._resetAdjustments();
            _this8._resetScrollbar();
            $__default["default"](_this8._element).trigger(EVENT_HIDDEN$2);
          });
        };
        _proto._removeBackdrop = function _removeBackdrop() {
          if (this._backdrop) {
            $__default["default"](this._backdrop).remove();
            this._backdrop = null;
          }
        };
        _proto._showBackdrop = function _showBackdrop(callback) {
          var _this9 = this;
          var animate = $__default["default"](this._element).hasClass(CLASS_NAME_FADE$4) ? CLASS_NAME_FADE$4 : "";
          if (this._isShown && this._config.backdrop) {
            this._backdrop = document.createElement("div");
            this._backdrop.className = CLASS_NAME_BACKDROP;
            if (animate) {
              this._backdrop.classList.add(animate);
            }
            $__default["default"](this._backdrop).appendTo(document.body);
            $__default["default"](this._element).on(EVENT_CLICK_DISMISS$1, function(event) {
              if (_this9._ignoreBackdropClick) {
                _this9._ignoreBackdropClick = false;
                return;
              }
              if (event.target !== event.currentTarget) {
                return;
              }
              if (_this9._config.backdrop === "static") {
                _this9._triggerBackdropTransition();
              } else {
                _this9.hide();
              }
            });
            if (animate) {
              Util.reflow(this._backdrop);
            }
            $__default["default"](this._backdrop).addClass(CLASS_NAME_SHOW$4);
            if (!callback) {
              return;
            }
            if (!animate) {
              callback();
              return;
            }
            var backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);
            $__default["default"](this._backdrop).one(Util.TRANSITION_END, callback).emulateTransitionEnd(backdropTransitionDuration);
          } else if (!this._isShown && this._backdrop) {
            $__default["default"](this._backdrop).removeClass(CLASS_NAME_SHOW$4);
            var callbackRemove = function callbackRemove2() {
              _this9._removeBackdrop();
              if (callback) {
                callback();
              }
            };
            if ($__default["default"](this._element).hasClass(CLASS_NAME_FADE$4)) {
              var _backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);
              $__default["default"](this._backdrop).one(Util.TRANSITION_END, callbackRemove).emulateTransitionEnd(_backdropTransitionDuration);
            } else {
              callbackRemove();
            }
          } else if (callback) {
            callback();
          }
        };
        _proto._adjustDialog = function _adjustDialog() {
          var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
          if (!this._isBodyOverflowing && isModalOverflowing) {
            this._element.style.paddingLeft = this._scrollbarWidth + "px";
          }
          if (this._isBodyOverflowing && !isModalOverflowing) {
            this._element.style.paddingRight = this._scrollbarWidth + "px";
          }
        };
        _proto._resetAdjustments = function _resetAdjustments() {
          this._element.style.paddingLeft = "";
          this._element.style.paddingRight = "";
        };
        _proto._checkScrollbar = function _checkScrollbar() {
          var rect = document.body.getBoundingClientRect();
          this._isBodyOverflowing = Math.round(rect.left + rect.right) < window.innerWidth;
          this._scrollbarWidth = this._getScrollbarWidth();
        };
        _proto._setScrollbar = function _setScrollbar() {
          var _this10 = this;
          if (this._isBodyOverflowing) {
            var fixedContent = [].slice.call(document.querySelectorAll(SELECTOR_FIXED_CONTENT));
            var stickyContent = [].slice.call(document.querySelectorAll(SELECTOR_STICKY_CONTENT));
            $__default["default"](fixedContent).each(function(index, element) {
              var actualPadding2 = element.style.paddingRight;
              var calculatedPadding2 = $__default["default"](element).css("padding-right");
              $__default["default"](element).data("padding-right", actualPadding2).css("padding-right", parseFloat(calculatedPadding2) + _this10._scrollbarWidth + "px");
            });
            $__default["default"](stickyContent).each(function(index, element) {
              var actualMargin = element.style.marginRight;
              var calculatedMargin = $__default["default"](element).css("margin-right");
              $__default["default"](element).data("margin-right", actualMargin).css("margin-right", parseFloat(calculatedMargin) - _this10._scrollbarWidth + "px");
            });
            var actualPadding = document.body.style.paddingRight;
            var calculatedPadding = $__default["default"](document.body).css("padding-right");
            $__default["default"](document.body).data("padding-right", actualPadding).css("padding-right", parseFloat(calculatedPadding) + this._scrollbarWidth + "px");
          }
          $__default["default"](document.body).addClass(CLASS_NAME_OPEN);
        };
        _proto._resetScrollbar = function _resetScrollbar() {
          var fixedContent = [].slice.call(document.querySelectorAll(SELECTOR_FIXED_CONTENT));
          $__default["default"](fixedContent).each(function(index, element) {
            var padding2 = $__default["default"](element).data("padding-right");
            $__default["default"](element).removeData("padding-right");
            element.style.paddingRight = padding2 ? padding2 : "";
          });
          var elements = [].slice.call(document.querySelectorAll("" + SELECTOR_STICKY_CONTENT));
          $__default["default"](elements).each(function(index, element) {
            var margin = $__default["default"](element).data("margin-right");
            if (typeof margin !== "undefined") {
              $__default["default"](element).css("margin-right", margin).removeData("margin-right");
            }
          });
          var padding = $__default["default"](document.body).data("padding-right");
          $__default["default"](document.body).removeData("padding-right");
          document.body.style.paddingRight = padding ? padding : "";
        };
        _proto._getScrollbarWidth = function _getScrollbarWidth() {
          var scrollDiv = document.createElement("div");
          scrollDiv.className = CLASS_NAME_SCROLLBAR_MEASURER;
          document.body.appendChild(scrollDiv);
          var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
          document.body.removeChild(scrollDiv);
          return scrollbarWidth;
        };
        Modal2._jQueryInterface = function _jQueryInterface(config2, relatedTarget) {
          return this.each(function() {
            var data = $__default["default"](this).data(DATA_KEY$5);
            var _config = _extends2({}, Default$4, $__default["default"](this).data(), typeof config2 === "object" && config2 ? config2 : {});
            if (!data) {
              data = new Modal2(this, _config);
              $__default["default"](this).data(DATA_KEY$5, data);
            }
            if (typeof config2 === "string") {
              if (typeof data[config2] === "undefined") {
                throw new TypeError('No method named "' + config2 + '"');
              }
              data[config2](relatedTarget);
            } else if (_config.show) {
              data.show(relatedTarget);
            }
          });
        };
        _createClass(Modal2, null, [{
          key: "VERSION",
          get: function get() {
            return VERSION$5;
          }
        }, {
          key: "Default",
          get: function get() {
            return Default$4;
          }
        }]);
        return Modal2;
      }();
      $__default["default"](document).on(EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function(event) {
        var _this11 = this;
        var target;
        var selector = Util.getSelectorFromElement(this);
        if (selector) {
          target = document.querySelector(selector);
        }
        var config2 = $__default["default"](target).data(DATA_KEY$5) ? "toggle" : _extends2({}, $__default["default"](target).data(), $__default["default"](this).data());
        if (this.tagName === "A" || this.tagName === "AREA") {
          event.preventDefault();
        }
        var $target = $__default["default"](target).one(EVENT_SHOW$2, function(showEvent) {
          if (showEvent.isDefaultPrevented()) {
            return;
          }
          $target.one(EVENT_HIDDEN$2, function() {
            if ($__default["default"](_this11).is(":visible")) {
              _this11.focus();
            }
          });
        });
        Modal._jQueryInterface.call($__default["default"](target), config2, this);
      });
      $__default["default"].fn[NAME$5] = Modal._jQueryInterface;
      $__default["default"].fn[NAME$5].Constructor = Modal;
      $__default["default"].fn[NAME$5].noConflict = function() {
        $__default["default"].fn[NAME$5] = JQUERY_NO_CONFLICT$5;
        return Modal._jQueryInterface;
      };
      var uriAttrs = ["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"];
      var ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
      var DefaultWhitelist = {
        // Global attributes allowed on any supplied element below.
        "*": ["class", "dir", "id", "lang", "role", ARIA_ATTRIBUTE_PATTERN],
        a: ["target", "href", "title", "rel"],
        area: [],
        b: [],
        br: [],
        col: [],
        code: [],
        div: [],
        em: [],
        hr: [],
        h1: [],
        h2: [],
        h3: [],
        h4: [],
        h5: [],
        h6: [],
        i: [],
        img: ["src", "srcset", "alt", "title", "width", "height"],
        li: [],
        ol: [],
        p: [],
        pre: [],
        s: [],
        small: [],
        span: [],
        sub: [],
        sup: [],
        strong: [],
        u: [],
        ul: []
      };
      var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i;
      var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;
      function allowedAttribute(attr, allowedAttributeList) {
        var attrName = attr.nodeName.toLowerCase();
        if (allowedAttributeList.indexOf(attrName) !== -1) {
          if (uriAttrs.indexOf(attrName) !== -1) {
            return Boolean(SAFE_URL_PATTERN.test(attr.nodeValue) || DATA_URL_PATTERN.test(attr.nodeValue));
          }
          return true;
        }
        var regExp = allowedAttributeList.filter(function(attrRegex) {
          return attrRegex instanceof RegExp;
        });
        for (var i2 = 0, len = regExp.length; i2 < len; i2++) {
          if (regExp[i2].test(attrName)) {
            return true;
          }
        }
        return false;
      }
      function sanitizeHtml(unsafeHtml, whiteList, sanitizeFn) {
        if (unsafeHtml.length === 0) {
          return unsafeHtml;
        }
        if (sanitizeFn && typeof sanitizeFn === "function") {
          return sanitizeFn(unsafeHtml);
        }
        var domParser = new window.DOMParser();
        var createdDocument = domParser.parseFromString(unsafeHtml, "text/html");
        var whitelistKeys = Object.keys(whiteList);
        var elements = [].slice.call(createdDocument.body.querySelectorAll("*"));
        var _loop = function _loop2(i3, len2) {
          var el = elements[i3];
          var elName = el.nodeName.toLowerCase();
          if (whitelistKeys.indexOf(el.nodeName.toLowerCase()) === -1) {
            el.parentNode.removeChild(el);
            return "continue";
          }
          var attributeList = [].slice.call(el.attributes);
          var whitelistedAttributes = [].concat(whiteList["*"] || [], whiteList[elName] || []);
          attributeList.forEach(function(attr) {
            if (!allowedAttribute(attr, whitelistedAttributes)) {
              el.removeAttribute(attr.nodeName);
            }
          });
        };
        for (var i2 = 0, len = elements.length; i2 < len; i2++) {
          var _ret = _loop(i2);
          if (_ret === "continue")
            continue;
        }
        return createdDocument.body.innerHTML;
      }
      var NAME$4 = "tooltip";
      var VERSION$4 = "4.6.2";
      var DATA_KEY$4 = "bs.tooltip";
      var EVENT_KEY$4 = "." + DATA_KEY$4;
      var JQUERY_NO_CONFLICT$4 = $__default["default"].fn[NAME$4];
      var CLASS_PREFIX$1 = "bs-tooltip";
      var BSCLS_PREFIX_REGEX$1 = new RegExp("(^|\\s)" + CLASS_PREFIX$1 + "\\S+", "g");
      var DISALLOWED_ATTRIBUTES = ["sanitize", "whiteList", "sanitizeFn"];
      var CLASS_NAME_FADE$3 = "fade";
      var CLASS_NAME_SHOW$3 = "show";
      var HOVER_STATE_SHOW = "show";
      var HOVER_STATE_OUT = "out";
      var SELECTOR_TOOLTIP_INNER = ".tooltip-inner";
      var SELECTOR_ARROW = ".arrow";
      var TRIGGER_HOVER = "hover";
      var TRIGGER_FOCUS = "focus";
      var TRIGGER_CLICK = "click";
      var TRIGGER_MANUAL = "manual";
      var AttachmentMap = {
        AUTO: "auto",
        TOP: "top",
        RIGHT: "right",
        BOTTOM: "bottom",
        LEFT: "left"
      };
      var Default$3 = {
        animation: true,
        template: '<div class="tooltip" role="tooltip"><div class="arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: "hover focus",
        title: "",
        delay: 0,
        html: false,
        selector: false,
        placement: "top",
        offset: 0,
        container: false,
        fallbackPlacement: "flip",
        boundary: "scrollParent",
        customClass: "",
        sanitize: true,
        sanitizeFn: null,
        whiteList: DefaultWhitelist,
        popperConfig: null
      };
      var DefaultType$3 = {
        animation: "boolean",
        template: "string",
        title: "(string|element|function)",
        trigger: "string",
        delay: "(number|object)",
        html: "boolean",
        selector: "(string|boolean)",
        placement: "(string|function)",
        offset: "(number|string|function)",
        container: "(string|element|boolean)",
        fallbackPlacement: "(string|array)",
        boundary: "(string|element)",
        customClass: "(string|function)",
        sanitize: "boolean",
        sanitizeFn: "(null|function)",
        whiteList: "object",
        popperConfig: "(null|object)"
      };
      var Event$1 = {
        HIDE: "hide" + EVENT_KEY$4,
        HIDDEN: "hidden" + EVENT_KEY$4,
        SHOW: "show" + EVENT_KEY$4,
        SHOWN: "shown" + EVENT_KEY$4,
        INSERTED: "inserted" + EVENT_KEY$4,
        CLICK: "click" + EVENT_KEY$4,
        FOCUSIN: "focusin" + EVENT_KEY$4,
        FOCUSOUT: "focusout" + EVENT_KEY$4,
        MOUSEENTER: "mouseenter" + EVENT_KEY$4,
        MOUSELEAVE: "mouseleave" + EVENT_KEY$4
      };
      var Tooltip = function() {
        function Tooltip2(element, config2) {
          if (typeof Popper__default["default"] === "undefined") {
            throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
          }
          this._isEnabled = true;
          this._timeout = 0;
          this._hoverState = "";
          this._activeTrigger = {};
          this._popper = null;
          this.element = element;
          this.config = this._getConfig(config2);
          this.tip = null;
          this._setListeners();
        }
        var _proto = Tooltip2.prototype;
        _proto.enable = function enable() {
          this._isEnabled = true;
        };
        _proto.disable = function disable() {
          this._isEnabled = false;
        };
        _proto.toggleEnabled = function toggleEnabled() {
          this._isEnabled = !this._isEnabled;
        };
        _proto.toggle = function toggle(event) {
          if (!this._isEnabled) {
            return;
          }
          if (event) {
            var dataKey = this.constructor.DATA_KEY;
            var context = $__default["default"](event.currentTarget).data(dataKey);
            if (!context) {
              context = new this.constructor(event.currentTarget, this._getDelegateConfig());
              $__default["default"](event.currentTarget).data(dataKey, context);
            }
            context._activeTrigger.click = !context._activeTrigger.click;
            if (context._isWithActiveTrigger()) {
              context._enter(null, context);
            } else {
              context._leave(null, context);
            }
          } else {
            if ($__default["default"](this.getTipElement()).hasClass(CLASS_NAME_SHOW$3)) {
              this._leave(null, this);
              return;
            }
            this._enter(null, this);
          }
        };
        _proto.dispose = function dispose() {
          clearTimeout(this._timeout);
          $__default["default"].removeData(this.element, this.constructor.DATA_KEY);
          $__default["default"](this.element).off(this.constructor.EVENT_KEY);
          $__default["default"](this.element).closest(".modal").off("hide.bs.modal", this._hideModalHandler);
          if (this.tip) {
            $__default["default"](this.tip).remove();
          }
          this._isEnabled = null;
          this._timeout = null;
          this._hoverState = null;
          this._activeTrigger = null;
          if (this._popper) {
            this._popper.destroy();
          }
          this._popper = null;
          this.element = null;
          this.config = null;
          this.tip = null;
        };
        _proto.show = function show() {
          var _this = this;
          if ($__default["default"](this.element).css("display") === "none") {
            throw new Error("Please use show on visible elements");
          }
          var showEvent = $__default["default"].Event(this.constructor.Event.SHOW);
          if (this.isWithContent() && this._isEnabled) {
            $__default["default"](this.element).trigger(showEvent);
            var shadowRoot = Util.findShadowRoot(this.element);
            var isInTheDom = $__default["default"].contains(shadowRoot !== null ? shadowRoot : this.element.ownerDocument.documentElement, this.element);
            if (showEvent.isDefaultPrevented() || !isInTheDom) {
              return;
            }
            var tip = this.getTipElement();
            var tipId = Util.getUID(this.constructor.NAME);
            tip.setAttribute("id", tipId);
            this.element.setAttribute("aria-describedby", tipId);
            this.setContent();
            if (this.config.animation) {
              $__default["default"](tip).addClass(CLASS_NAME_FADE$3);
            }
            var placement = typeof this.config.placement === "function" ? this.config.placement.call(this, tip, this.element) : this.config.placement;
            var attachment = this._getAttachment(placement);
            this.addAttachmentClass(attachment);
            var container = this._getContainer();
            $__default["default"](tip).data(this.constructor.DATA_KEY, this);
            if (!$__default["default"].contains(this.element.ownerDocument.documentElement, this.tip)) {
              $__default["default"](tip).appendTo(container);
            }
            $__default["default"](this.element).trigger(this.constructor.Event.INSERTED);
            this._popper = new Popper__default["default"](this.element, tip, this._getPopperConfig(attachment));
            $__default["default"](tip).addClass(CLASS_NAME_SHOW$3);
            $__default["default"](tip).addClass(this.config.customClass);
            if ("ontouchstart" in document.documentElement) {
              $__default["default"](document.body).children().on("mouseover", null, $__default["default"].noop);
            }
            var complete = function complete2() {
              if (_this.config.animation) {
                _this._fixTransition();
              }
              var prevHoverState = _this._hoverState;
              _this._hoverState = null;
              $__default["default"](_this.element).trigger(_this.constructor.Event.SHOWN);
              if (prevHoverState === HOVER_STATE_OUT) {
                _this._leave(null, _this);
              }
            };
            if ($__default["default"](this.tip).hasClass(CLASS_NAME_FADE$3)) {
              var transitionDuration = Util.getTransitionDurationFromElement(this.tip);
              $__default["default"](this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
            } else {
              complete();
            }
          }
        };
        _proto.hide = function hide2(callback) {
          var _this2 = this;
          var tip = this.getTipElement();
          var hideEvent = $__default["default"].Event(this.constructor.Event.HIDE);
          var complete = function complete2() {
            if (_this2._hoverState !== HOVER_STATE_SHOW && tip.parentNode) {
              tip.parentNode.removeChild(tip);
            }
            _this2._cleanTipClass();
            _this2.element.removeAttribute("aria-describedby");
            $__default["default"](_this2.element).trigger(_this2.constructor.Event.HIDDEN);
            if (_this2._popper !== null) {
              _this2._popper.destroy();
            }
            if (callback) {
              callback();
            }
          };
          $__default["default"](this.element).trigger(hideEvent);
          if (hideEvent.isDefaultPrevented()) {
            return;
          }
          $__default["default"](tip).removeClass(CLASS_NAME_SHOW$3);
          if ("ontouchstart" in document.documentElement) {
            $__default["default"](document.body).children().off("mouseover", null, $__default["default"].noop);
          }
          this._activeTrigger[TRIGGER_CLICK] = false;
          this._activeTrigger[TRIGGER_FOCUS] = false;
          this._activeTrigger[TRIGGER_HOVER] = false;
          if ($__default["default"](this.tip).hasClass(CLASS_NAME_FADE$3)) {
            var transitionDuration = Util.getTransitionDurationFromElement(tip);
            $__default["default"](tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
          } else {
            complete();
          }
          this._hoverState = "";
        };
        _proto.update = function update2() {
          if (this._popper !== null) {
            this._popper.scheduleUpdate();
          }
        };
        _proto.isWithContent = function isWithContent() {
          return Boolean(this.getTitle());
        };
        _proto.addAttachmentClass = function addAttachmentClass(attachment) {
          $__default["default"](this.getTipElement()).addClass(CLASS_PREFIX$1 + "-" + attachment);
        };
        _proto.getTipElement = function getTipElement() {
          this.tip = this.tip || $__default["default"](this.config.template)[0];
          return this.tip;
        };
        _proto.setContent = function setContent() {
          var tip = this.getTipElement();
          this.setElementContent($__default["default"](tip.querySelectorAll(SELECTOR_TOOLTIP_INNER)), this.getTitle());
          $__default["default"](tip).removeClass(CLASS_NAME_FADE$3 + " " + CLASS_NAME_SHOW$3);
        };
        _proto.setElementContent = function setElementContent($element, content) {
          if (typeof content === "object" && (content.nodeType || content.jquery)) {
            if (this.config.html) {
              if (!$__default["default"](content).parent().is($element)) {
                $element.empty().append(content);
              }
            } else {
              $element.text($__default["default"](content).text());
            }
            return;
          }
          if (this.config.html) {
            if (this.config.sanitize) {
              content = sanitizeHtml(content, this.config.whiteList, this.config.sanitizeFn);
            }
            $element.html(content);
          } else {
            $element.text(content);
          }
        };
        _proto.getTitle = function getTitle() {
          var title = this.element.getAttribute("data-original-title");
          if (!title) {
            title = typeof this.config.title === "function" ? this.config.title.call(this.element) : this.config.title;
          }
          return title;
        };
        _proto._getPopperConfig = function _getPopperConfig(attachment) {
          var _this3 = this;
          var defaultBsConfig = {
            placement: attachment,
            modifiers: {
              offset: this._getOffset(),
              flip: {
                behavior: this.config.fallbackPlacement
              },
              arrow: {
                element: SELECTOR_ARROW
              },
              preventOverflow: {
                boundariesElement: this.config.boundary
              }
            },
            onCreate: function onCreate2(data) {
              if (data.originalPlacement !== data.placement) {
                _this3._handlePopperPlacementChange(data);
              }
            },
            onUpdate: function onUpdate2(data) {
              return _this3._handlePopperPlacementChange(data);
            }
          };
          return _extends2({}, defaultBsConfig, this.config.popperConfig);
        };
        _proto._getOffset = function _getOffset() {
          var _this4 = this;
          var offset2 = {};
          if (typeof this.config.offset === "function") {
            offset2.fn = function(data) {
              data.offsets = _extends2({}, data.offsets, _this4.config.offset(data.offsets, _this4.element));
              return data;
            };
          } else {
            offset2.offset = this.config.offset;
          }
          return offset2;
        };
        _proto._getContainer = function _getContainer() {
          if (this.config.container === false) {
            return document.body;
          }
          if (Util.isElement(this.config.container)) {
            return $__default["default"](this.config.container);
          }
          return $__default["default"](document).find(this.config.container);
        };
        _proto._getAttachment = function _getAttachment(placement) {
          return AttachmentMap[placement.toUpperCase()];
        };
        _proto._setListeners = function _setListeners() {
          var _this5 = this;
          var triggers = this.config.trigger.split(" ");
          triggers.forEach(function(trigger) {
            if (trigger === "click") {
              $__default["default"](_this5.element).on(_this5.constructor.Event.CLICK, _this5.config.selector, function(event) {
                return _this5.toggle(event);
              });
            } else if (trigger !== TRIGGER_MANUAL) {
              var eventIn = trigger === TRIGGER_HOVER ? _this5.constructor.Event.MOUSEENTER : _this5.constructor.Event.FOCUSIN;
              var eventOut = trigger === TRIGGER_HOVER ? _this5.constructor.Event.MOUSELEAVE : _this5.constructor.Event.FOCUSOUT;
              $__default["default"](_this5.element).on(eventIn, _this5.config.selector, function(event) {
                return _this5._enter(event);
              }).on(eventOut, _this5.config.selector, function(event) {
                return _this5._leave(event);
              });
            }
          });
          this._hideModalHandler = function() {
            if (_this5.element) {
              _this5.hide();
            }
          };
          $__default["default"](this.element).closest(".modal").on("hide.bs.modal", this._hideModalHandler);
          if (this.config.selector) {
            this.config = _extends2({}, this.config, {
              trigger: "manual",
              selector: ""
            });
          } else {
            this._fixTitle();
          }
        };
        _proto._fixTitle = function _fixTitle() {
          var titleType = typeof this.element.getAttribute("data-original-title");
          if (this.element.getAttribute("title") || titleType !== "string") {
            this.element.setAttribute("data-original-title", this.element.getAttribute("title") || "");
            this.element.setAttribute("title", "");
          }
        };
        _proto._enter = function _enter(event, context) {
          var dataKey = this.constructor.DATA_KEY;
          context = context || $__default["default"](event.currentTarget).data(dataKey);
          if (!context) {
            context = new this.constructor(event.currentTarget, this._getDelegateConfig());
            $__default["default"](event.currentTarget).data(dataKey, context);
          }
          if (event) {
            context._activeTrigger[event.type === "focusin" ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
          }
          if ($__default["default"](context.getTipElement()).hasClass(CLASS_NAME_SHOW$3) || context._hoverState === HOVER_STATE_SHOW) {
            context._hoverState = HOVER_STATE_SHOW;
            return;
          }
          clearTimeout(context._timeout);
          context._hoverState = HOVER_STATE_SHOW;
          if (!context.config.delay || !context.config.delay.show) {
            context.show();
            return;
          }
          context._timeout = setTimeout(function() {
            if (context._hoverState === HOVER_STATE_SHOW) {
              context.show();
            }
          }, context.config.delay.show);
        };
        _proto._leave = function _leave(event, context) {
          var dataKey = this.constructor.DATA_KEY;
          context = context || $__default["default"](event.currentTarget).data(dataKey);
          if (!context) {
            context = new this.constructor(event.currentTarget, this._getDelegateConfig());
            $__default["default"](event.currentTarget).data(dataKey, context);
          }
          if (event) {
            context._activeTrigger[event.type === "focusout" ? TRIGGER_FOCUS : TRIGGER_HOVER] = false;
          }
          if (context._isWithActiveTrigger()) {
            return;
          }
          clearTimeout(context._timeout);
          context._hoverState = HOVER_STATE_OUT;
          if (!context.config.delay || !context.config.delay.hide) {
            context.hide();
            return;
          }
          context._timeout = setTimeout(function() {
            if (context._hoverState === HOVER_STATE_OUT) {
              context.hide();
            }
          }, context.config.delay.hide);
        };
        _proto._isWithActiveTrigger = function _isWithActiveTrigger() {
          for (var trigger in this._activeTrigger) {
            if (this._activeTrigger[trigger]) {
              return true;
            }
          }
          return false;
        };
        _proto._getConfig = function _getConfig(config2) {
          var dataAttributes = $__default["default"](this.element).data();
          Object.keys(dataAttributes).forEach(function(dataAttr) {
            if (DISALLOWED_ATTRIBUTES.indexOf(dataAttr) !== -1) {
              delete dataAttributes[dataAttr];
            }
          });
          config2 = _extends2({}, this.constructor.Default, dataAttributes, typeof config2 === "object" && config2 ? config2 : {});
          if (typeof config2.delay === "number") {
            config2.delay = {
              show: config2.delay,
              hide: config2.delay
            };
          }
          if (typeof config2.title === "number") {
            config2.title = config2.title.toString();
          }
          if (typeof config2.content === "number") {
            config2.content = config2.content.toString();
          }
          Util.typeCheckConfig(NAME$4, config2, this.constructor.DefaultType);
          if (config2.sanitize) {
            config2.template = sanitizeHtml(config2.template, config2.whiteList, config2.sanitizeFn);
          }
          return config2;
        };
        _proto._getDelegateConfig = function _getDelegateConfig() {
          var config2 = {};
          if (this.config) {
            for (var key in this.config) {
              if (this.constructor.Default[key] !== this.config[key]) {
                config2[key] = this.config[key];
              }
            }
          }
          return config2;
        };
        _proto._cleanTipClass = function _cleanTipClass() {
          var $tip = $__default["default"](this.getTipElement());
          var tabClass = $tip.attr("class").match(BSCLS_PREFIX_REGEX$1);
          if (tabClass !== null && tabClass.length) {
            $tip.removeClass(tabClass.join(""));
          }
        };
        _proto._handlePopperPlacementChange = function _handlePopperPlacementChange(popperData) {
          this.tip = popperData.instance.popper;
          this._cleanTipClass();
          this.addAttachmentClass(this._getAttachment(popperData.placement));
        };
        _proto._fixTransition = function _fixTransition() {
          var tip = this.getTipElement();
          var initConfigAnimation = this.config.animation;
          if (tip.getAttribute("x-placement") !== null) {
            return;
          }
          $__default["default"](tip).removeClass(CLASS_NAME_FADE$3);
          this.config.animation = false;
          this.hide();
          this.show();
          this.config.animation = initConfigAnimation;
        };
        Tooltip2._jQueryInterface = function _jQueryInterface(config2) {
          return this.each(function() {
            var $element = $__default["default"](this);
            var data = $element.data(DATA_KEY$4);
            var _config = typeof config2 === "object" && config2;
            if (!data && /dispose|hide/.test(config2)) {
              return;
            }
            if (!data) {
              data = new Tooltip2(this, _config);
              $element.data(DATA_KEY$4, data);
            }
            if (typeof config2 === "string") {
              if (typeof data[config2] === "undefined") {
                throw new TypeError('No method named "' + config2 + '"');
              }
              data[config2]();
            }
          });
        };
        _createClass(Tooltip2, null, [{
          key: "VERSION",
          get: function get() {
            return VERSION$4;
          }
        }, {
          key: "Default",
          get: function get() {
            return Default$3;
          }
        }, {
          key: "NAME",
          get: function get() {
            return NAME$4;
          }
        }, {
          key: "DATA_KEY",
          get: function get() {
            return DATA_KEY$4;
          }
        }, {
          key: "Event",
          get: function get() {
            return Event$1;
          }
        }, {
          key: "EVENT_KEY",
          get: function get() {
            return EVENT_KEY$4;
          }
        }, {
          key: "DefaultType",
          get: function get() {
            return DefaultType$3;
          }
        }]);
        return Tooltip2;
      }();
      $__default["default"].fn[NAME$4] = Tooltip._jQueryInterface;
      $__default["default"].fn[NAME$4].Constructor = Tooltip;
      $__default["default"].fn[NAME$4].noConflict = function() {
        $__default["default"].fn[NAME$4] = JQUERY_NO_CONFLICT$4;
        return Tooltip._jQueryInterface;
      };
      var NAME$3 = "popover";
      var VERSION$3 = "4.6.2";
      var DATA_KEY$3 = "bs.popover";
      var EVENT_KEY$3 = "." + DATA_KEY$3;
      var JQUERY_NO_CONFLICT$3 = $__default["default"].fn[NAME$3];
      var CLASS_PREFIX = "bs-popover";
      var BSCLS_PREFIX_REGEX = new RegExp("(^|\\s)" + CLASS_PREFIX + "\\S+", "g");
      var CLASS_NAME_FADE$2 = "fade";
      var CLASS_NAME_SHOW$2 = "show";
      var SELECTOR_TITLE = ".popover-header";
      var SELECTOR_CONTENT = ".popover-body";
      var Default$2 = _extends2({}, Tooltip.Default, {
        placement: "right",
        trigger: "click",
        content: "",
        template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>'
      });
      var DefaultType$2 = _extends2({}, Tooltip.DefaultType, {
        content: "(string|element|function)"
      });
      var Event = {
        HIDE: "hide" + EVENT_KEY$3,
        HIDDEN: "hidden" + EVENT_KEY$3,
        SHOW: "show" + EVENT_KEY$3,
        SHOWN: "shown" + EVENT_KEY$3,
        INSERTED: "inserted" + EVENT_KEY$3,
        CLICK: "click" + EVENT_KEY$3,
        FOCUSIN: "focusin" + EVENT_KEY$3,
        FOCUSOUT: "focusout" + EVENT_KEY$3,
        MOUSEENTER: "mouseenter" + EVENT_KEY$3,
        MOUSELEAVE: "mouseleave" + EVENT_KEY$3
      };
      var Popover = function(_Tooltip) {
        _inheritsLoose(Popover2, _Tooltip);
        function Popover2() {
          return _Tooltip.apply(this, arguments) || this;
        }
        var _proto = Popover2.prototype;
        _proto.isWithContent = function isWithContent() {
          return this.getTitle() || this._getContent();
        };
        _proto.addAttachmentClass = function addAttachmentClass(attachment) {
          $__default["default"](this.getTipElement()).addClass(CLASS_PREFIX + "-" + attachment);
        };
        _proto.getTipElement = function getTipElement() {
          this.tip = this.tip || $__default["default"](this.config.template)[0];
          return this.tip;
        };
        _proto.setContent = function setContent() {
          var $tip = $__default["default"](this.getTipElement());
          this.setElementContent($tip.find(SELECTOR_TITLE), this.getTitle());
          var content = this._getContent();
          if (typeof content === "function") {
            content = content.call(this.element);
          }
          this.setElementContent($tip.find(SELECTOR_CONTENT), content);
          $tip.removeClass(CLASS_NAME_FADE$2 + " " + CLASS_NAME_SHOW$2);
        };
        _proto._getContent = function _getContent() {
          return this.element.getAttribute("data-content") || this.config.content;
        };
        _proto._cleanTipClass = function _cleanTipClass() {
          var $tip = $__default["default"](this.getTipElement());
          var tabClass = $tip.attr("class").match(BSCLS_PREFIX_REGEX);
          if (tabClass !== null && tabClass.length > 0) {
            $tip.removeClass(tabClass.join(""));
          }
        };
        Popover2._jQueryInterface = function _jQueryInterface(config2) {
          return this.each(function() {
            var data = $__default["default"](this).data(DATA_KEY$3);
            var _config = typeof config2 === "object" ? config2 : null;
            if (!data && /dispose|hide/.test(config2)) {
              return;
            }
            if (!data) {
              data = new Popover2(this, _config);
              $__default["default"](this).data(DATA_KEY$3, data);
            }
            if (typeof config2 === "string") {
              if (typeof data[config2] === "undefined") {
                throw new TypeError('No method named "' + config2 + '"');
              }
              data[config2]();
            }
          });
        };
        _createClass(Popover2, null, [{
          key: "VERSION",
          get: (
            // Getters
            function get() {
              return VERSION$3;
            }
          )
        }, {
          key: "Default",
          get: function get() {
            return Default$2;
          }
        }, {
          key: "NAME",
          get: function get() {
            return NAME$3;
          }
        }, {
          key: "DATA_KEY",
          get: function get() {
            return DATA_KEY$3;
          }
        }, {
          key: "Event",
          get: function get() {
            return Event;
          }
        }, {
          key: "EVENT_KEY",
          get: function get() {
            return EVENT_KEY$3;
          }
        }, {
          key: "DefaultType",
          get: function get() {
            return DefaultType$2;
          }
        }]);
        return Popover2;
      }(Tooltip);
      $__default["default"].fn[NAME$3] = Popover._jQueryInterface;
      $__default["default"].fn[NAME$3].Constructor = Popover;
      $__default["default"].fn[NAME$3].noConflict = function() {
        $__default["default"].fn[NAME$3] = JQUERY_NO_CONFLICT$3;
        return Popover._jQueryInterface;
      };
      var NAME$2 = "scrollspy";
      var VERSION$2 = "4.6.2";
      var DATA_KEY$2 = "bs.scrollspy";
      var EVENT_KEY$2 = "." + DATA_KEY$2;
      var DATA_API_KEY$1 = ".data-api";
      var JQUERY_NO_CONFLICT$2 = $__default["default"].fn[NAME$2];
      var CLASS_NAME_DROPDOWN_ITEM = "dropdown-item";
      var CLASS_NAME_ACTIVE$1 = "active";
      var EVENT_ACTIVATE = "activate" + EVENT_KEY$2;
      var EVENT_SCROLL = "scroll" + EVENT_KEY$2;
      var EVENT_LOAD_DATA_API = "load" + EVENT_KEY$2 + DATA_API_KEY$1;
      var METHOD_OFFSET = "offset";
      var METHOD_POSITION = "position";
      var SELECTOR_DATA_SPY = '[data-spy="scroll"]';
      var SELECTOR_NAV_LIST_GROUP$1 = ".nav, .list-group";
      var SELECTOR_NAV_LINKS = ".nav-link";
      var SELECTOR_NAV_ITEMS = ".nav-item";
      var SELECTOR_LIST_ITEMS = ".list-group-item";
      var SELECTOR_DROPDOWN$1 = ".dropdown";
      var SELECTOR_DROPDOWN_ITEMS = ".dropdown-item";
      var SELECTOR_DROPDOWN_TOGGLE$1 = ".dropdown-toggle";
      var Default$1 = {
        offset: 10,
        method: "auto",
        target: ""
      };
      var DefaultType$1 = {
        offset: "number",
        method: "string",
        target: "(string|element)"
      };
      var ScrollSpy = function() {
        function ScrollSpy2(element, config2) {
          var _this = this;
          this._element = element;
          this._scrollElement = element.tagName === "BODY" ? window : element;
          this._config = this._getConfig(config2);
          this._selector = this._config.target + " " + SELECTOR_NAV_LINKS + "," + (this._config.target + " " + SELECTOR_LIST_ITEMS + ",") + (this._config.target + " " + SELECTOR_DROPDOWN_ITEMS);
          this._offsets = [];
          this._targets = [];
          this._activeTarget = null;
          this._scrollHeight = 0;
          $__default["default"](this._scrollElement).on(EVENT_SCROLL, function(event) {
            return _this._process(event);
          });
          this.refresh();
          this._process();
        }
        var _proto = ScrollSpy2.prototype;
        _proto.refresh = function refresh() {
          var _this2 = this;
          var autoMethod = this._scrollElement === this._scrollElement.window ? METHOD_OFFSET : METHOD_POSITION;
          var offsetMethod = this._config.method === "auto" ? autoMethod : this._config.method;
          var offsetBase = offsetMethod === METHOD_POSITION ? this._getScrollTop() : 0;
          this._offsets = [];
          this._targets = [];
          this._scrollHeight = this._getScrollHeight();
          var targets = [].slice.call(document.querySelectorAll(this._selector));
          targets.map(function(element) {
            var target;
            var targetSelector = Util.getSelectorFromElement(element);
            if (targetSelector) {
              target = document.querySelector(targetSelector);
            }
            if (target) {
              var targetBCR = target.getBoundingClientRect();
              if (targetBCR.width || targetBCR.height) {
                return [$__default["default"](target)[offsetMethod]().top + offsetBase, targetSelector];
              }
            }
            return null;
          }).filter(Boolean).sort(function(a, b2) {
            return a[0] - b2[0];
          }).forEach(function(item) {
            _this2._offsets.push(item[0]);
            _this2._targets.push(item[1]);
          });
        };
        _proto.dispose = function dispose() {
          $__default["default"].removeData(this._element, DATA_KEY$2);
          $__default["default"](this._scrollElement).off(EVENT_KEY$2);
          this._element = null;
          this._scrollElement = null;
          this._config = null;
          this._selector = null;
          this._offsets = null;
          this._targets = null;
          this._activeTarget = null;
          this._scrollHeight = null;
        };
        _proto._getConfig = function _getConfig(config2) {
          config2 = _extends2({}, Default$1, typeof config2 === "object" && config2 ? config2 : {});
          if (typeof config2.target !== "string" && Util.isElement(config2.target)) {
            var id2 = $__default["default"](config2.target).attr("id");
            if (!id2) {
              id2 = Util.getUID(NAME$2);
              $__default["default"](config2.target).attr("id", id2);
            }
            config2.target = "#" + id2;
          }
          Util.typeCheckConfig(NAME$2, config2, DefaultType$1);
          return config2;
        };
        _proto._getScrollTop = function _getScrollTop() {
          return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
        };
        _proto._getScrollHeight = function _getScrollHeight() {
          return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
        };
        _proto._getOffsetHeight = function _getOffsetHeight() {
          return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
        };
        _proto._process = function _process() {
          var scrollTop = this._getScrollTop() + this._config.offset;
          var scrollHeight = this._getScrollHeight();
          var maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();
          if (this._scrollHeight !== scrollHeight) {
            this.refresh();
          }
          if (scrollTop >= maxScroll) {
            var target = this._targets[this._targets.length - 1];
            if (this._activeTarget !== target) {
              this._activate(target);
            }
            return;
          }
          if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {
            this._activeTarget = null;
            this._clear();
            return;
          }
          for (var i2 = this._offsets.length; i2--; ) {
            var isActiveTarget = this._activeTarget !== this._targets[i2] && scrollTop >= this._offsets[i2] && (typeof this._offsets[i2 + 1] === "undefined" || scrollTop < this._offsets[i2 + 1]);
            if (isActiveTarget) {
              this._activate(this._targets[i2]);
            }
          }
        };
        _proto._activate = function _activate(target) {
          this._activeTarget = target;
          this._clear();
          var queries = this._selector.split(",").map(function(selector) {
            return selector + '[data-target="' + target + '"],' + selector + '[href="' + target + '"]';
          });
          var $link = $__default["default"]([].slice.call(document.querySelectorAll(queries.join(","))));
          if ($link.hasClass(CLASS_NAME_DROPDOWN_ITEM)) {
            $link.closest(SELECTOR_DROPDOWN$1).find(SELECTOR_DROPDOWN_TOGGLE$1).addClass(CLASS_NAME_ACTIVE$1);
            $link.addClass(CLASS_NAME_ACTIVE$1);
          } else {
            $link.addClass(CLASS_NAME_ACTIVE$1);
            $link.parents(SELECTOR_NAV_LIST_GROUP$1).prev(SELECTOR_NAV_LINKS + ", " + SELECTOR_LIST_ITEMS).addClass(CLASS_NAME_ACTIVE$1);
            $link.parents(SELECTOR_NAV_LIST_GROUP$1).prev(SELECTOR_NAV_ITEMS).children(SELECTOR_NAV_LINKS).addClass(CLASS_NAME_ACTIVE$1);
          }
          $__default["default"](this._scrollElement).trigger(EVENT_ACTIVATE, {
            relatedTarget: target
          });
        };
        _proto._clear = function _clear() {
          [].slice.call(document.querySelectorAll(this._selector)).filter(function(node) {
            return node.classList.contains(CLASS_NAME_ACTIVE$1);
          }).forEach(function(node) {
            return node.classList.remove(CLASS_NAME_ACTIVE$1);
          });
        };
        ScrollSpy2._jQueryInterface = function _jQueryInterface(config2) {
          return this.each(function() {
            var data = $__default["default"](this).data(DATA_KEY$2);
            var _config = typeof config2 === "object" && config2;
            if (!data) {
              data = new ScrollSpy2(this, _config);
              $__default["default"](this).data(DATA_KEY$2, data);
            }
            if (typeof config2 === "string") {
              if (typeof data[config2] === "undefined") {
                throw new TypeError('No method named "' + config2 + '"');
              }
              data[config2]();
            }
          });
        };
        _createClass(ScrollSpy2, null, [{
          key: "VERSION",
          get: function get() {
            return VERSION$2;
          }
        }, {
          key: "Default",
          get: function get() {
            return Default$1;
          }
        }]);
        return ScrollSpy2;
      }();
      $__default["default"](window).on(EVENT_LOAD_DATA_API, function() {
        var scrollSpys = [].slice.call(document.querySelectorAll(SELECTOR_DATA_SPY));
        var scrollSpysLength = scrollSpys.length;
        for (var i2 = scrollSpysLength; i2--; ) {
          var $spy = $__default["default"](scrollSpys[i2]);
          ScrollSpy._jQueryInterface.call($spy, $spy.data());
        }
      });
      $__default["default"].fn[NAME$2] = ScrollSpy._jQueryInterface;
      $__default["default"].fn[NAME$2].Constructor = ScrollSpy;
      $__default["default"].fn[NAME$2].noConflict = function() {
        $__default["default"].fn[NAME$2] = JQUERY_NO_CONFLICT$2;
        return ScrollSpy._jQueryInterface;
      };
      var NAME$1 = "tab";
      var VERSION$1 = "4.6.2";
      var DATA_KEY$1 = "bs.tab";
      var EVENT_KEY$1 = "." + DATA_KEY$1;
      var DATA_API_KEY = ".data-api";
      var JQUERY_NO_CONFLICT$1 = $__default["default"].fn[NAME$1];
      var CLASS_NAME_DROPDOWN_MENU = "dropdown-menu";
      var CLASS_NAME_ACTIVE = "active";
      var CLASS_NAME_DISABLED = "disabled";
      var CLASS_NAME_FADE$1 = "fade";
      var CLASS_NAME_SHOW$1 = "show";
      var EVENT_HIDE$1 = "hide" + EVENT_KEY$1;
      var EVENT_HIDDEN$1 = "hidden" + EVENT_KEY$1;
      var EVENT_SHOW$1 = "show" + EVENT_KEY$1;
      var EVENT_SHOWN$1 = "shown" + EVENT_KEY$1;
      var EVENT_CLICK_DATA_API = "click" + EVENT_KEY$1 + DATA_API_KEY;
      var SELECTOR_DROPDOWN = ".dropdown";
      var SELECTOR_NAV_LIST_GROUP = ".nav, .list-group";
      var SELECTOR_ACTIVE = ".active";
      var SELECTOR_ACTIVE_UL = "> li > .active";
      var SELECTOR_DATA_TOGGLE = '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]';
      var SELECTOR_DROPDOWN_TOGGLE = ".dropdown-toggle";
      var SELECTOR_DROPDOWN_ACTIVE_CHILD = "> .dropdown-menu .active";
      var Tab = function() {
        function Tab2(element) {
          this._element = element;
        }
        var _proto = Tab2.prototype;
        _proto.show = function show() {
          var _this = this;
          if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && $__default["default"](this._element).hasClass(CLASS_NAME_ACTIVE) || $__default["default"](this._element).hasClass(CLASS_NAME_DISABLED) || this._element.hasAttribute("disabled")) {
            return;
          }
          var target;
          var previous;
          var listElement = $__default["default"](this._element).closest(SELECTOR_NAV_LIST_GROUP)[0];
          var selector = Util.getSelectorFromElement(this._element);
          if (listElement) {
            var itemSelector = listElement.nodeName === "UL" || listElement.nodeName === "OL" ? SELECTOR_ACTIVE_UL : SELECTOR_ACTIVE;
            previous = $__default["default"].makeArray($__default["default"](listElement).find(itemSelector));
            previous = previous[previous.length - 1];
          }
          var hideEvent = $__default["default"].Event(EVENT_HIDE$1, {
            relatedTarget: this._element
          });
          var showEvent = $__default["default"].Event(EVENT_SHOW$1, {
            relatedTarget: previous
          });
          if (previous) {
            $__default["default"](previous).trigger(hideEvent);
          }
          $__default["default"](this._element).trigger(showEvent);
          if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {
            return;
          }
          if (selector) {
            target = document.querySelector(selector);
          }
          this._activate(this._element, listElement);
          var complete = function complete2() {
            var hiddenEvent = $__default["default"].Event(EVENT_HIDDEN$1, {
              relatedTarget: _this._element
            });
            var shownEvent = $__default["default"].Event(EVENT_SHOWN$1, {
              relatedTarget: previous
            });
            $__default["default"](previous).trigger(hiddenEvent);
            $__default["default"](_this._element).trigger(shownEvent);
          };
          if (target) {
            this._activate(target, target.parentNode, complete);
          } else {
            complete();
          }
        };
        _proto.dispose = function dispose() {
          $__default["default"].removeData(this._element, DATA_KEY$1);
          this._element = null;
        };
        _proto._activate = function _activate(element, container, callback) {
          var _this2 = this;
          var activeElements = container && (container.nodeName === "UL" || container.nodeName === "OL") ? $__default["default"](container).find(SELECTOR_ACTIVE_UL) : $__default["default"](container).children(SELECTOR_ACTIVE);
          var active = activeElements[0];
          var isTransitioning = callback && active && $__default["default"](active).hasClass(CLASS_NAME_FADE$1);
          var complete = function complete2() {
            return _this2._transitionComplete(element, active, callback);
          };
          if (active && isTransitioning) {
            var transitionDuration = Util.getTransitionDurationFromElement(active);
            $__default["default"](active).removeClass(CLASS_NAME_SHOW$1).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
          } else {
            complete();
          }
        };
        _proto._transitionComplete = function _transitionComplete(element, active, callback) {
          if (active) {
            $__default["default"](active).removeClass(CLASS_NAME_ACTIVE);
            var dropdownChild = $__default["default"](active.parentNode).find(SELECTOR_DROPDOWN_ACTIVE_CHILD)[0];
            if (dropdownChild) {
              $__default["default"](dropdownChild).removeClass(CLASS_NAME_ACTIVE);
            }
            if (active.getAttribute("role") === "tab") {
              active.setAttribute("aria-selected", false);
            }
          }
          $__default["default"](element).addClass(CLASS_NAME_ACTIVE);
          if (element.getAttribute("role") === "tab") {
            element.setAttribute("aria-selected", true);
          }
          Util.reflow(element);
          if (element.classList.contains(CLASS_NAME_FADE$1)) {
            element.classList.add(CLASS_NAME_SHOW$1);
          }
          var parent2 = element.parentNode;
          if (parent2 && parent2.nodeName === "LI") {
            parent2 = parent2.parentNode;
          }
          if (parent2 && $__default["default"](parent2).hasClass(CLASS_NAME_DROPDOWN_MENU)) {
            var dropdownElement = $__default["default"](element).closest(SELECTOR_DROPDOWN)[0];
            if (dropdownElement) {
              var dropdownToggleList = [].slice.call(dropdownElement.querySelectorAll(SELECTOR_DROPDOWN_TOGGLE));
              $__default["default"](dropdownToggleList).addClass(CLASS_NAME_ACTIVE);
            }
            element.setAttribute("aria-expanded", true);
          }
          if (callback) {
            callback();
          }
        };
        Tab2._jQueryInterface = function _jQueryInterface(config2) {
          return this.each(function() {
            var $this = $__default["default"](this);
            var data = $this.data(DATA_KEY$1);
            if (!data) {
              data = new Tab2(this);
              $this.data(DATA_KEY$1, data);
            }
            if (typeof config2 === "string") {
              if (typeof data[config2] === "undefined") {
                throw new TypeError('No method named "' + config2 + '"');
              }
              data[config2]();
            }
          });
        };
        _createClass(Tab2, null, [{
          key: "VERSION",
          get: function get() {
            return VERSION$1;
          }
        }]);
        return Tab2;
      }();
      $__default["default"](document).on(EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function(event) {
        event.preventDefault();
        Tab._jQueryInterface.call($__default["default"](this), "show");
      });
      $__default["default"].fn[NAME$1] = Tab._jQueryInterface;
      $__default["default"].fn[NAME$1].Constructor = Tab;
      $__default["default"].fn[NAME$1].noConflict = function() {
        $__default["default"].fn[NAME$1] = JQUERY_NO_CONFLICT$1;
        return Tab._jQueryInterface;
      };
      var NAME = "toast";
      var VERSION3 = "4.6.2";
      var DATA_KEY = "bs.toast";
      var EVENT_KEY = "." + DATA_KEY;
      var JQUERY_NO_CONFLICT = $__default["default"].fn[NAME];
      var CLASS_NAME_FADE = "fade";
      var CLASS_NAME_HIDE = "hide";
      var CLASS_NAME_SHOW = "show";
      var CLASS_NAME_SHOWING = "showing";
      var EVENT_CLICK_DISMISS = "click.dismiss" + EVENT_KEY;
      var EVENT_HIDE = "hide" + EVENT_KEY;
      var EVENT_HIDDEN = "hidden" + EVENT_KEY;
      var EVENT_SHOW = "show" + EVENT_KEY;
      var EVENT_SHOWN = "shown" + EVENT_KEY;
      var SELECTOR_DATA_DISMISS = '[data-dismiss="toast"]';
      var Default = {
        animation: true,
        autohide: true,
        delay: 500
      };
      var DefaultType = {
        animation: "boolean",
        autohide: "boolean",
        delay: "number"
      };
      var Toast = function() {
        function Toast2(element, config2) {
          this._element = element;
          this._config = this._getConfig(config2);
          this._timeout = null;
          this._setListeners();
        }
        var _proto = Toast2.prototype;
        _proto.show = function show() {
          var _this = this;
          var showEvent = $__default["default"].Event(EVENT_SHOW);
          $__default["default"](this._element).trigger(showEvent);
          if (showEvent.isDefaultPrevented()) {
            return;
          }
          this._clearTimeout();
          if (this._config.animation) {
            this._element.classList.add(CLASS_NAME_FADE);
          }
          var complete = function complete2() {
            _this._element.classList.remove(CLASS_NAME_SHOWING);
            _this._element.classList.add(CLASS_NAME_SHOW);
            $__default["default"](_this._element).trigger(EVENT_SHOWN);
            if (_this._config.autohide) {
              _this._timeout = setTimeout(function() {
                _this.hide();
              }, _this._config.delay);
            }
          };
          this._element.classList.remove(CLASS_NAME_HIDE);
          Util.reflow(this._element);
          this._element.classList.add(CLASS_NAME_SHOWING);
          if (this._config.animation) {
            var transitionDuration = Util.getTransitionDurationFromElement(this._element);
            $__default["default"](this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
          } else {
            complete();
          }
        };
        _proto.hide = function hide2() {
          if (!this._element.classList.contains(CLASS_NAME_SHOW)) {
            return;
          }
          var hideEvent = $__default["default"].Event(EVENT_HIDE);
          $__default["default"](this._element).trigger(hideEvent);
          if (hideEvent.isDefaultPrevented()) {
            return;
          }
          this._close();
        };
        _proto.dispose = function dispose() {
          this._clearTimeout();
          if (this._element.classList.contains(CLASS_NAME_SHOW)) {
            this._element.classList.remove(CLASS_NAME_SHOW);
          }
          $__default["default"](this._element).off(EVENT_CLICK_DISMISS);
          $__default["default"].removeData(this._element, DATA_KEY);
          this._element = null;
          this._config = null;
        };
        _proto._getConfig = function _getConfig(config2) {
          config2 = _extends2({}, Default, $__default["default"](this._element).data(), typeof config2 === "object" && config2 ? config2 : {});
          Util.typeCheckConfig(NAME, config2, this.constructor.DefaultType);
          return config2;
        };
        _proto._setListeners = function _setListeners() {
          var _this2 = this;
          $__default["default"](this._element).on(EVENT_CLICK_DISMISS, SELECTOR_DATA_DISMISS, function() {
            return _this2.hide();
          });
        };
        _proto._close = function _close() {
          var _this3 = this;
          var complete = function complete2() {
            _this3._element.classList.add(CLASS_NAME_HIDE);
            $__default["default"](_this3._element).trigger(EVENT_HIDDEN);
          };
          this._element.classList.remove(CLASS_NAME_SHOW);
          if (this._config.animation) {
            var transitionDuration = Util.getTransitionDurationFromElement(this._element);
            $__default["default"](this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
          } else {
            complete();
          }
        };
        _proto._clearTimeout = function _clearTimeout() {
          clearTimeout(this._timeout);
          this._timeout = null;
        };
        Toast2._jQueryInterface = function _jQueryInterface(config2) {
          return this.each(function() {
            var $element = $__default["default"](this);
            var data = $element.data(DATA_KEY);
            var _config = typeof config2 === "object" && config2;
            if (!data) {
              data = new Toast2(this, _config);
              $element.data(DATA_KEY, data);
            }
            if (typeof config2 === "string") {
              if (typeof data[config2] === "undefined") {
                throw new TypeError('No method named "' + config2 + '"');
              }
              data[config2](this);
            }
          });
        };
        _createClass(Toast2, null, [{
          key: "VERSION",
          get: function get() {
            return VERSION3;
          }
        }, {
          key: "DefaultType",
          get: function get() {
            return DefaultType;
          }
        }, {
          key: "Default",
          get: function get() {
            return Default;
          }
        }]);
        return Toast2;
      }();
      $__default["default"].fn[NAME] = Toast._jQueryInterface;
      $__default["default"].fn[NAME].Constructor = Toast;
      $__default["default"].fn[NAME].noConflict = function() {
        $__default["default"].fn[NAME] = JQUERY_NO_CONFLICT;
        return Toast._jQueryInterface;
      };
      exports2.Alert = Alert;
      exports2.Button = Button;
      exports2.Carousel = Carousel;
      exports2.Collapse = Collapse;
      exports2.Dropdown = Dropdown;
      exports2.Modal = Modal;
      exports2.Popover = Popover;
      exports2.Scrollspy = ScrollSpy;
      exports2.Tab = Tab;
      exports2.Toast = Toast;
      exports2.Tooltip = Tooltip;
      exports2.Util = Util;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/ng-fire-admin/node_modules/@angular/fire/angularfire2.js
var RealtimeDatabaseURL = new InjectionToken("angularfire2.realtimeDatabaseURL");
function noop() {
}
var ɵZoneScheduler = function() {
  function ɵZoneScheduler2(zone, delegate) {
    if (delegate === void 0) {
      delegate = queueScheduler;
    }
    this.zone = zone;
    this.delegate = delegate;
  }
  ɵZoneScheduler2.prototype.now = function() {
    return this.delegate.now();
  };
  ɵZoneScheduler2.prototype.schedule = function(work, delay, state) {
    var targetZone = this.zone;
    var workInZone = function(state2) {
      var _this = this;
      targetZone.runGuarded(function() {
        work.apply(_this, [state2]);
      });
    };
    return this.delegate.schedule(workInZone, delay, state);
  };
  return ɵZoneScheduler2;
}();
var ɵBlockUntilFirstOperator = function() {
  function ɵBlockUntilFirstOperator2(zone) {
    this.zone = zone;
    this.task = null;
  }
  ɵBlockUntilFirstOperator2.prototype.call = function(subscriber, source) {
    var unscheduleTask = this.unscheduleTask.bind(this);
    this.task = this.zone.run(function() {
      return Zone.current.scheduleMacroTask("firebaseZoneBlock", noop, {}, noop, noop);
    });
    return source.pipe(tap(unscheduleTask, unscheduleTask, unscheduleTask)).subscribe(subscriber).add(unscheduleTask);
  };
  ɵBlockUntilFirstOperator2.prototype.unscheduleTask = function() {
    if (this.task != null && this.task.state === "scheduled") {
      this.task.invoke();
      this.task = null;
    }
  };
  return ɵBlockUntilFirstOperator2;
}();
var ɵAngularFireSchedulers = /* @__PURE__ */ function() {
  function ɵAngularFireSchedulers2(ngZone) {
    this.ngZone = ngZone;
    this.outsideAngular = ngZone.runOutsideAngular(function() {
      return new ɵZoneScheduler(Zone.current);
    });
    this.insideAngular = ngZone.run(function() {
      return new ɵZoneScheduler(Zone.current, asyncScheduler);
    });
  }
  return ɵAngularFireSchedulers2;
}();
function ɵkeepUnstableUntilFirstFactory(schedulers, platformId) {
  return function keepUnstableUntilFirst(obs$) {
    if (isPlatformServer(platformId)) {
      obs$ = obs$.lift(new ɵBlockUntilFirstOperator(schedulers.ngZone));
    }
    return obs$.pipe(subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));
  };
}
var FirebaseZoneScheduler = function() {
  function FirebaseZoneScheduler2(zone, platformId) {
    this.zone = zone;
    this.platformId = platformId;
  }
  FirebaseZoneScheduler2.prototype.schedule = function() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    return this.zone.runGuarded(function() {
      return queueScheduler.schedule.apply(queueScheduler, args);
    });
  };
  FirebaseZoneScheduler2.prototype.keepUnstableUntilFirst = function(obs$) {
    if (isPlatformServer(this.platformId)) {
      return new Observable(function(subscriber) {
        var noop4 = function() {
        };
        var task = Zone.current.scheduleMacroTask("firebaseZoneBlock", noop4, {}, noop4, noop4);
        obs$.subscribe(function(next) {
          if (task.state === "scheduled") {
            task.invoke();
          }
          ;
          subscriber.next(next);
        }, function(error) {
          if (task.state === "scheduled") {
            task.invoke();
          }
          subscriber.error(error);
        }, function() {
          if (task.state === "scheduled") {
            task.invoke();
          }
          subscriber.complete();
        });
      });
    } else {
      return obs$;
    }
  };
  FirebaseZoneScheduler2.prototype.runOutsideAngular = function(obs$) {
    var _this = this;
    return new Observable(function(subscriber) {
      return _this.zone.runOutsideAngular(function() {
        return obs$.subscribe(function(value) {
          return _this.zone.run(function() {
            return subscriber.next(value);
          });
        }, function(error) {
          return _this.zone.run(function() {
            return subscriber.error(error);
          });
        }, function() {
          return _this.zone.run(function() {
            return subscriber.complete();
          });
        });
      });
    });
  };
  return FirebaseZoneScheduler2;
}();

// node_modules/ng-fire-admin/node_modules/firebase/app/dist/index.esm.js
var import_app = __toESM(require_index_cjs3());
var import_app2 = __toESM(require_index_cjs3());
var name2 = "firebase";
var version = "7.24.0";
import_app.default.registerVersion(name2, version, "app");

// node_modules/ng-fire-admin/node_modules/@angular/fire/firebase.app.module.js
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r2 = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d = decorators[i2])
        r2 = (c < 3 ? d(r2) : c > 3 ? d(target, key, r2) : d(target, key)) || r2;
  return c > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata2 = function(k3, v2) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k3, v2);
};
var __param2 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var FirebaseOptionsToken = new InjectionToken("angularfire2.app.options");
var FirebaseNameOrConfigToken = new InjectionToken("angularfire2.app.nameOrConfig");
var FIREBASE_OPTIONS = FirebaseOptionsToken;
var FIREBASE_APP_NAME = FirebaseNameOrConfigToken;
var FirebaseApp = /* @__PURE__ */ function() {
  function FirebaseApp2() {
  }
  return FirebaseApp2;
}();
var VERSION2 = new Version("5.4.2");
function _firebaseAppFactory(options, zone, nameOrConfig) {
  var name4 = typeof nameOrConfig === "string" && nameOrConfig || "[DEFAULT]";
  var config2 = typeof nameOrConfig === "object" && nameOrConfig || {};
  config2.name = config2.name || name4;
  var existingApp = import_app2.default.apps.filter(function(app) {
    return app && app.name === config2.name;
  })[0];
  return existingApp || zone.runOutsideAngular(function() {
    return import_app2.default.initializeApp(options, config2);
  });
}
var FirebaseAppProvider = {
  provide: FirebaseApp,
  useFactory: _firebaseAppFactory,
  deps: [
    FIREBASE_OPTIONS,
    NgZone,
    [new Optional(), FIREBASE_APP_NAME]
  ]
};
var AngularFireModule = function() {
  function AngularFireModule2(platformId) {
    if (import_app2.default.registerVersion) {
      import_app2.default.registerVersion("angularfire", VERSION2.full, platformId.toString());
      import_app2.default.registerVersion("angular", VERSION.full);
    }
  }
  AngularFireModule_1 = AngularFireModule2;
  AngularFireModule2.initializeApp = function(options, nameOrConfig) {
    return {
      ngModule: AngularFireModule_1,
      providers: [
        { provide: FIREBASE_OPTIONS, useValue: options },
        { provide: FIREBASE_APP_NAME, useValue: nameOrConfig }
      ]
    };
  };
  var AngularFireModule_1;
  AngularFireModule2 = AngularFireModule_1 = __decorate2([
    NgModule({
      providers: [FirebaseAppProvider]
    }),
    __param2(0, Inject(PLATFORM_ID)),
    __metadata2("design:paramtypes", [Object])
  ], AngularFireModule2);
  return AngularFireModule2;
}();

// node_modules/ng-fire-admin/fesm5/ng-fire-admin.js
init_tslib_es6();

// node_modules/ng-fire-admin/node_modules/@angular/fire/firestore/observable/fromRef.js
function _fromRef(ref, scheduler) {
  if (scheduler === void 0) {
    scheduler = asyncScheduler;
  }
  return new Observable(function(subscriber) {
    var unsubscribe;
    if (scheduler != null) {
      scheduler.schedule(function() {
        unsubscribe = ref.onSnapshot(subscriber);
      });
    } else {
      unsubscribe = ref.onSnapshot(subscriber);
    }
    return function() {
      if (unsubscribe != null) {
        unsubscribe();
      }
    };
  });
}
function fromRef(ref, scheduler) {
  return _fromRef(ref, scheduler);
}
function fromDocRef(ref, scheduler) {
  return fromRef(ref, scheduler).pipe(map(function(payload) {
    return { payload, type: "value" };
  }));
}
function fromCollectionRef(ref, scheduler) {
  return fromRef(ref, scheduler).pipe(map(function(payload) {
    return { payload, type: "query" };
  }));
}

// node_modules/ng-fire-admin/node_modules/@angular/fire/firestore/collection/changes.js
function docChanges(query, scheduler) {
  return fromCollectionRef(query, scheduler).pipe(map(function(action) {
    return action.payload.docChanges().map(function(change) {
      return { type: change.type, payload: change };
    });
  }));
}
function sortedChanges(query, events, scheduler) {
  return fromCollectionRef(query, scheduler).pipe(map(function(changes) {
    return changes.payload.docChanges();
  }), scan(function(current, changes) {
    return combineChanges(current, changes, events);
  }, []), map(function(changes) {
    return changes.map(function(c) {
      return { type: c.type, payload: c };
    });
  }));
}
function combineChanges(current, changes, events) {
  changes.forEach(function(change) {
    if (events.indexOf(change.type) > -1) {
      current = combineChange(current, change);
    }
  });
  return current;
}
function combineChange(combined, change) {
  switch (change.type) {
    case "added":
      if (combined[change.newIndex] && combined[change.newIndex].doc.ref.isEqual(change.doc.ref)) {
      } else {
        combined.splice(change.newIndex, 0, change);
      }
      break;
    case "modified":
      if (combined[change.oldIndex] == null || combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {
        if (change.oldIndex !== change.newIndex) {
          combined.splice(change.oldIndex, 1);
          combined.splice(change.newIndex, 0, change);
        } else {
          combined.splice(change.newIndex, 1, change);
        }
      }
      break;
    case "removed":
      if (combined[change.oldIndex] && combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {
        combined.splice(change.oldIndex, 1);
      }
      break;
  }
  return combined;
}

// node_modules/ng-fire-admin/node_modules/@angular/fire/firestore/collection/collection.js
var __assign2 = function() {
  __assign2 = Object.assign || function(t) {
    for (var s, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s = arguments[i2];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t[p2] = s[p2];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
function validateEventsArray(events) {
  if (!events || events.length === 0) {
    events = ["added", "removed", "modified"];
  }
  return events;
}
var AngularFirestoreCollection = function() {
  function AngularFirestoreCollection2(ref, query, afs) {
    this.ref = ref;
    this.query = query;
    this.afs = afs;
  }
  AngularFirestoreCollection2.prototype.stateChanges = function(events) {
    if (!events || events.length === 0) {
      return docChanges(this.query, this.afs.schedulers.outsideAngular).pipe(this.afs.keepUnstableUntilFirst);
    }
    return docChanges(this.query, this.afs.schedulers.outsideAngular).pipe(this.afs.keepUnstableUntilFirst, map(function(actions) {
      return actions.filter(function(change) {
        return events.indexOf(change.type) > -1;
      });
    }), filter(function(changes) {
      return changes.length > 0;
    }));
  };
  AngularFirestoreCollection2.prototype.auditTrail = function(events) {
    return this.stateChanges(events).pipe(scan(function(current, action) {
      return current.concat(action);
    }, []));
  };
  AngularFirestoreCollection2.prototype.snapshotChanges = function(events) {
    var validatedEvents = validateEventsArray(events);
    var scheduledSortedChanges$ = sortedChanges(this.query, validatedEvents, this.afs.schedulers.outsideAngular);
    return scheduledSortedChanges$.pipe(this.afs.keepUnstableUntilFirst);
  };
  AngularFirestoreCollection2.prototype.valueChanges = function(options) {
    if (options === void 0) {
      options = {};
    }
    return fromCollectionRef(this.query, this.afs.schedulers.outsideAngular).pipe(this.afs.keepUnstableUntilFirst, map(function(actions) {
      return actions.payload.docs.map(function(a) {
        var _a3;
        if (options.idField) {
          return __assign2({}, a.data(), (_a3 = {}, _a3[options.idField] = a.id, _a3));
        } else {
          return a.data();
        }
      });
    }));
  };
  AngularFirestoreCollection2.prototype.get = function(options) {
    return from(this.query.get(options)).pipe(observeOn(this.afs.schedulers.insideAngular));
  };
  AngularFirestoreCollection2.prototype.add = function(data) {
    return this.ref.add(data);
  };
  AngularFirestoreCollection2.prototype.doc = function(path) {
    return new AngularFirestoreDocument(this.ref.doc(path), this.afs);
  };
  return AngularFirestoreCollection2;
}();

// node_modules/ng-fire-admin/node_modules/@angular/fire/firestore/document/document.js
var AngularFirestoreDocument = function() {
  function AngularFirestoreDocument2(ref, afs) {
    this.ref = ref;
    this.afs = afs;
  }
  AngularFirestoreDocument2.prototype.set = function(data, options) {
    return this.ref.set(data, options);
  };
  AngularFirestoreDocument2.prototype.update = function(data) {
    return this.ref.update(data);
  };
  AngularFirestoreDocument2.prototype.delete = function() {
    return this.ref.delete();
  };
  AngularFirestoreDocument2.prototype.collection = function(path, queryFn) {
    var collectionRef = this.ref.collection(path);
    var _a3 = associateQuery(collectionRef, queryFn), ref = _a3.ref, query = _a3.query;
    return new AngularFirestoreCollection(ref, query, this.afs);
  };
  AngularFirestoreDocument2.prototype.snapshotChanges = function() {
    var scheduledFromDocRef$ = fromDocRef(this.ref, this.afs.schedulers.outsideAngular);
    return scheduledFromDocRef$.pipe(this.afs.keepUnstableUntilFirst);
  };
  AngularFirestoreDocument2.prototype.valueChanges = function() {
    return this.snapshotChanges().pipe(map(function(action) {
      return action.payload.data();
    }));
  };
  AngularFirestoreDocument2.prototype.get = function(options) {
    return from(this.ref.get(options)).pipe(observeOn(this.afs.schedulers.insideAngular));
  };
  return AngularFirestoreDocument2;
}();

// node_modules/ng-fire-admin/node_modules/@angular/fire/firestore/collection-group/collection-group.js
var AngularFirestoreCollectionGroup = function() {
  function AngularFirestoreCollectionGroup2(query, afs) {
    this.query = query;
    this.afs = afs;
  }
  AngularFirestoreCollectionGroup2.prototype.stateChanges = function(events) {
    if (!events || events.length === 0) {
      return docChanges(this.query, this.afs.schedulers.outsideAngular).pipe(this.afs.keepUnstableUntilFirst);
    }
    return docChanges(this.query, this.afs.schedulers.outsideAngular).pipe(this.afs.keepUnstableUntilFirst, map(function(actions) {
      return actions.filter(function(change) {
        return events.indexOf(change.type) > -1;
      });
    }), filter(function(changes) {
      return changes.length > 0;
    }));
  };
  AngularFirestoreCollectionGroup2.prototype.auditTrail = function(events) {
    return this.stateChanges(events).pipe(scan(function(current, action) {
      return current.concat(action);
    }, []));
  };
  AngularFirestoreCollectionGroup2.prototype.snapshotChanges = function(events) {
    var validatedEvents = validateEventsArray(events);
    var scheduledSortedChanges$ = sortedChanges(this.query, validatedEvents, this.afs.schedulers.outsideAngular);
    return scheduledSortedChanges$.pipe(this.afs.keepUnstableUntilFirst);
  };
  AngularFirestoreCollectionGroup2.prototype.valueChanges = function() {
    var fromCollectionRefScheduled$ = fromCollectionRef(this.query, this.afs.schedulers.outsideAngular);
    return fromCollectionRefScheduled$.pipe(this.afs.keepUnstableUntilFirst, map(function(actions) {
      return actions.payload.docs.map(function(a) {
        return a.data();
      });
    }));
  };
  AngularFirestoreCollectionGroup2.prototype.get = function(options) {
    return from(this.query.get(options)).pipe(observeOn(this.afs.schedulers.insideAngular));
  };
  return AngularFirestoreCollectionGroup2;
}();

// node_modules/ng-fire-admin/node_modules/@angular/fire/firestore/firestore.js
var __decorate3 = function(decorators, target, key, desc) {
  var c = arguments.length, r2 = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d = decorators[i2])
        r2 = (c < 3 ? d(r2) : c > 3 ? d(target, key, r2) : d(target, key)) || r2;
  return c > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata3 = function(k3, v2) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k3, v2);
};
var __param3 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var EnablePersistenceToken = new InjectionToken("angularfire2.enableFirestorePersistence");
var PersistenceSettingsToken = new InjectionToken("angularfire2.firestore.persistenceSettings");
var FirestoreSettingsToken = new InjectionToken("angularfire2.firestore.settings");
var ENABLE_PERSISTENCE = EnablePersistenceToken;
var PERSISTENCE_SETTINGS = PersistenceSettingsToken;
var SETTINGS = FirestoreSettingsToken;
var major = parseInt(import_app2.default.SDK_VERSION.split(".")[0]);
var minor = parseInt(import_app2.default.SDK_VERSION.split(".")[1]);
var DefaultFirestoreSettings = major < 5 || major == 5 && minor < 8 ? { timestampsInSnapshots: true } : {};
function associateQuery(collectionRef, queryFn) {
  if (queryFn === void 0) {
    queryFn = function(ref2) {
      return ref2;
    };
  }
  var query = queryFn(collectionRef);
  var ref = collectionRef;
  return { query, ref };
}
var AngularFirestore = function() {
  function AngularFirestore2(options, nameOrConfig, shouldEnablePersistence, settings, platformId, zone, persistenceSettings) {
    var _this = this;
    this.schedulers = new ɵAngularFireSchedulers(zone);
    this.keepUnstableUntilFirst = ɵkeepUnstableUntilFirstFactory(this.schedulers, platformId);
    this.firestore = zone.runOutsideAngular(function() {
      var app = _firebaseAppFactory(options, zone, nameOrConfig);
      var firestore = app.firestore();
      firestore.settings(settings || DefaultFirestoreSettings);
      return firestore;
    });
    if (shouldEnablePersistence && !isPlatformServer(platformId)) {
      var enablePersistence = function() {
        try {
          return from(_this.firestore.enablePersistence(persistenceSettings || void 0).then(function() {
            return true;
          }, function() {
            return false;
          }));
        } catch (e) {
          return of(false);
        }
      };
      this.persistenceEnabled$ = zone.runOutsideAngular(enablePersistence);
    } else {
      this.persistenceEnabled$ = of(false);
    }
  }
  AngularFirestore2.prototype.collection = function(pathOrRef, queryFn) {
    var collectionRef;
    if (typeof pathOrRef === "string") {
      collectionRef = this.firestore.collection(pathOrRef);
    } else {
      collectionRef = pathOrRef;
    }
    var _a3 = associateQuery(collectionRef, queryFn), ref = _a3.ref, query = _a3.query;
    return new AngularFirestoreCollection(ref, query, this);
  };
  AngularFirestore2.prototype.collectionGroup = function(collectionId, queryGroupFn) {
    if (major < 6) {
      throw "collection group queries require Firebase JS SDK >= 6.0";
    }
    var queryFn = queryGroupFn || function(ref) {
      return ref;
    };
    var firestore = this.firestore;
    var collectionGroup = firestore.collectionGroup(collectionId);
    return new AngularFirestoreCollectionGroup(queryFn(collectionGroup), this);
  };
  AngularFirestore2.prototype.doc = function(pathOrRef) {
    var ref;
    if (typeof pathOrRef === "string") {
      ref = this.firestore.doc(pathOrRef);
    } else {
      ref = pathOrRef;
    }
    return new AngularFirestoreDocument(ref, this);
  };
  AngularFirestore2.prototype.createId = function() {
    return this.firestore.collection("_").doc().id;
  };
  AngularFirestore2 = __decorate3([
    Injectable(),
    __param3(0, Inject(FIREBASE_OPTIONS)),
    __param3(1, Optional()),
    __param3(1, Inject(FIREBASE_APP_NAME)),
    __param3(2, Optional()),
    __param3(2, Inject(ENABLE_PERSISTENCE)),
    __param3(3, Optional()),
    __param3(3, Inject(SETTINGS)),
    __param3(4, Inject(PLATFORM_ID)),
    __param3(6, Optional()),
    __param3(6, Inject(PERSISTENCE_SETTINGS)),
    __metadata3("design:paramtypes", [
      Object,
      Object,
      Object,
      Object,
      Object,
      NgZone,
      Object
    ])
  ], AngularFirestore2);
  return AngularFirestore2;
}();

// node_modules/ng-fire-admin/node_modules/@firebase/firestore/dist/index.esm.js
init_tslib_es6();
var import_app5 = __toESM(require_index_cjs3());
init_index_esm();

// node_modules/ng-fire-admin/node_modules/@firebase/util/dist/index.esm.js
init_tslib_es6();
var Deferred = (
  /** @class */
  function() {
    function Deferred2() {
      var _this = this;
      this.reject = function() {
      };
      this.resolve = function() {
      };
      this.promise = new Promise(function(resolve2, reject) {
        _this.resolve = resolve2;
        _this.reject = reject;
      });
    }
    Deferred2.prototype.wrapCallback = function(callback) {
      var _this = this;
      return function(error, value) {
        if (error) {
          _this.reject(error);
        } else {
          _this.resolve(value);
        }
        if (typeof callback === "function") {
          _this.promise.catch(function() {
          });
          if (callback.length === 1) {
            callback(error);
          } else {
            callback(error, value);
          }
        }
      };
    };
    return Deferred2;
  }()
);
function getUA() {
  if (typeof navigator !== "undefined" && typeof navigator["userAgent"] === "string") {
    return navigator["userAgent"];
  } else {
    return "";
  }
}
function isMobileCordova() {
  return typeof window !== "undefined" && // @ts-ignore Setting up an broadly applicable index signature for Window
  // just to deal with this case would probably be a bad idea.
  !!(window["cordova"] || window["phonegap"] || window["PhoneGap"]) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA());
}
function isBrowserExtension() {
  var runtime = typeof chrome === "object" ? chrome.runtime : typeof browser === "object" ? browser.runtime : void 0;
  return typeof runtime === "object" && runtime.id !== void 0;
}
function isReactNative() {
  return typeof navigator === "object" && navigator["product"] === "ReactNative";
}
function isElectron() {
  return getUA().indexOf("Electron/") >= 0;
}
function isIE() {
  var ua3 = getUA();
  return ua3.indexOf("MSIE ") >= 0 || ua3.indexOf("Trident/") >= 0;
}
function isUWP() {
  return getUA().indexOf("MSAppHost/") >= 0;
}
var ERROR_NAME = "FirebaseError";
var FirebaseError = (
  /** @class */
  function(_super) {
    __extends(FirebaseError2, _super);
    function FirebaseError2(code, message) {
      var _this = _super.call(this, message) || this;
      _this.code = code;
      _this.name = ERROR_NAME;
      Object.setPrototypeOf(_this, FirebaseError2.prototype);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(_this, ErrorFactory.prototype.create);
      }
      return _this;
    }
    return FirebaseError2;
  }(Error)
);
var ErrorFactory = (
  /** @class */
  function() {
    function ErrorFactory2(service, serviceName, errors) {
      this.service = service;
      this.serviceName = serviceName;
      this.errors = errors;
    }
    ErrorFactory2.prototype.create = function(code) {
      var data = [];
      for (var _i2 = 1; _i2 < arguments.length; _i2++) {
        data[_i2 - 1] = arguments[_i2];
      }
      var customData = data[0] || {};
      var fullCode = this.service + "/" + code;
      var template = this.errors[code];
      var message = template ? replaceTemplate(template, customData) : "Error";
      var fullMessage = this.serviceName + ": " + message + " (" + fullCode + ").";
      var error = new FirebaseError(fullCode, fullMessage);
      for (var _a3 = 0, _b = Object.keys(customData); _a3 < _b.length; _a3++) {
        var key = _b[_a3];
        if (key.slice(-1) !== "_") {
          if (key in error) {
            console.warn('Overwriting FirebaseError base field "' + key + '" can cause unexpected behavior.');
          }
          error[key] = customData[key];
        }
      }
      return error;
    };
    return ErrorFactory2;
  }()
);
function replaceTemplate(template, data) {
  return template.replace(PATTERN, function(_2, key) {
    var value = data[key];
    return value != null ? String(value) : "<" + key + "?>";
  });
}
var PATTERN = /\{\$([^}]+)}/g;
var Sha1 = (
  /** @class */
  function() {
    function Sha12() {
      this.chain_ = [];
      this.buf_ = [];
      this.W_ = [];
      this.pad_ = [];
      this.inbuf_ = 0;
      this.total_ = 0;
      this.blockSize = 512 / 8;
      this.pad_[0] = 128;
      for (var i2 = 1; i2 < this.blockSize; ++i2) {
        this.pad_[i2] = 0;
      }
      this.reset();
    }
    Sha12.prototype.reset = function() {
      this.chain_[0] = 1732584193;
      this.chain_[1] = 4023233417;
      this.chain_[2] = 2562383102;
      this.chain_[3] = 271733878;
      this.chain_[4] = 3285377520;
      this.inbuf_ = 0;
      this.total_ = 0;
    };
    Sha12.prototype.compress_ = function(buf, offset2) {
      if (!offset2) {
        offset2 = 0;
      }
      var W3 = this.W_;
      if (typeof buf === "string") {
        for (var i2 = 0; i2 < 16; i2++) {
          W3[i2] = buf.charCodeAt(offset2) << 24 | buf.charCodeAt(offset2 + 1) << 16 | buf.charCodeAt(offset2 + 2) << 8 | buf.charCodeAt(offset2 + 3);
          offset2 += 4;
        }
      } else {
        for (var i2 = 0; i2 < 16; i2++) {
          W3[i2] = buf[offset2] << 24 | buf[offset2 + 1] << 16 | buf[offset2 + 2] << 8 | buf[offset2 + 3];
          offset2 += 4;
        }
      }
      for (var i2 = 16; i2 < 80; i2++) {
        var t = W3[i2 - 3] ^ W3[i2 - 8] ^ W3[i2 - 14] ^ W3[i2 - 16];
        W3[i2] = (t << 1 | t >>> 31) & 4294967295;
      }
      var a = this.chain_[0];
      var b2 = this.chain_[1];
      var c = this.chain_[2];
      var d = this.chain_[3];
      var e = this.chain_[4];
      var f, k3;
      for (var i2 = 0; i2 < 80; i2++) {
        if (i2 < 40) {
          if (i2 < 20) {
            f = d ^ b2 & (c ^ d);
            k3 = 1518500249;
          } else {
            f = b2 ^ c ^ d;
            k3 = 1859775393;
          }
        } else {
          if (i2 < 60) {
            f = b2 & c | d & (b2 | c);
            k3 = 2400959708;
          } else {
            f = b2 ^ c ^ d;
            k3 = 3395469782;
          }
        }
        var t = (a << 5 | a >>> 27) + f + e + k3 + W3[i2] & 4294967295;
        e = d;
        d = c;
        c = (b2 << 30 | b2 >>> 2) & 4294967295;
        b2 = a;
        a = t;
      }
      this.chain_[0] = this.chain_[0] + a & 4294967295;
      this.chain_[1] = this.chain_[1] + b2 & 4294967295;
      this.chain_[2] = this.chain_[2] + c & 4294967295;
      this.chain_[3] = this.chain_[3] + d & 4294967295;
      this.chain_[4] = this.chain_[4] + e & 4294967295;
    };
    Sha12.prototype.update = function(bytes, length) {
      if (bytes == null) {
        return;
      }
      if (length === void 0) {
        length = bytes.length;
      }
      var lengthMinusBlock = length - this.blockSize;
      var n2 = 0;
      var buf = this.buf_;
      var inbuf = this.inbuf_;
      while (n2 < length) {
        if (inbuf === 0) {
          while (n2 <= lengthMinusBlock) {
            this.compress_(bytes, n2);
            n2 += this.blockSize;
          }
        }
        if (typeof bytes === "string") {
          while (n2 < length) {
            buf[inbuf] = bytes.charCodeAt(n2);
            ++inbuf;
            ++n2;
            if (inbuf === this.blockSize) {
              this.compress_(buf);
              inbuf = 0;
              break;
            }
          }
        } else {
          while (n2 < length) {
            buf[inbuf] = bytes[n2];
            ++inbuf;
            ++n2;
            if (inbuf === this.blockSize) {
              this.compress_(buf);
              inbuf = 0;
              break;
            }
          }
        }
      }
      this.inbuf_ = inbuf;
      this.total_ += length;
    };
    Sha12.prototype.digest = function() {
      var digest = [];
      var totalBits = this.total_ * 8;
      if (this.inbuf_ < 56) {
        this.update(this.pad_, 56 - this.inbuf_);
      } else {
        this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));
      }
      for (var i2 = this.blockSize - 1; i2 >= 56; i2--) {
        this.buf_[i2] = totalBits & 255;
        totalBits /= 256;
      }
      this.compress_(this.buf_);
      var n2 = 0;
      for (var i2 = 0; i2 < 5; i2++) {
        for (var j2 = 24; j2 >= 0; j2 -= 8) {
          digest[n2] = this.chain_[i2] >> j2 & 255;
          ++n2;
        }
      }
      return digest;
    };
    return Sha12;
  }()
);
var ObserverProxy = (
  /** @class */
  function() {
    function ObserverProxy2(executor, onNoObservers) {
      var _this = this;
      this.observers = [];
      this.unsubscribes = [];
      this.observerCount = 0;
      this.task = Promise.resolve();
      this.finalized = false;
      this.onNoObservers = onNoObservers;
      this.task.then(function() {
        executor(_this);
      }).catch(function(e) {
        _this.error(e);
      });
    }
    ObserverProxy2.prototype.next = function(value) {
      this.forEachObserver(function(observer) {
        observer.next(value);
      });
    };
    ObserverProxy2.prototype.error = function(error) {
      this.forEachObserver(function(observer) {
        observer.error(error);
      });
      this.close(error);
    };
    ObserverProxy2.prototype.complete = function() {
      this.forEachObserver(function(observer) {
        observer.complete();
      });
      this.close();
    };
    ObserverProxy2.prototype.subscribe = function(nextOrObserver, error, complete) {
      var _this = this;
      var observer;
      if (nextOrObserver === void 0 && error === void 0 && complete === void 0) {
        throw new Error("Missing Observer.");
      }
      if (implementsAnyMethods(nextOrObserver, [
        "next",
        "error",
        "complete"
      ])) {
        observer = nextOrObserver;
      } else {
        observer = {
          next: nextOrObserver,
          error,
          complete
        };
      }
      if (observer.next === void 0) {
        observer.next = noop2;
      }
      if (observer.error === void 0) {
        observer.error = noop2;
      }
      if (observer.complete === void 0) {
        observer.complete = noop2;
      }
      var unsub = this.unsubscribeOne.bind(this, this.observers.length);
      if (this.finalized) {
        this.task.then(function() {
          try {
            if (_this.finalError) {
              observer.error(_this.finalError);
            } else {
              observer.complete();
            }
          } catch (e) {
          }
          return;
        });
      }
      this.observers.push(observer);
      return unsub;
    };
    ObserverProxy2.prototype.unsubscribeOne = function(i2) {
      if (this.observers === void 0 || this.observers[i2] === void 0) {
        return;
      }
      delete this.observers[i2];
      this.observerCount -= 1;
      if (this.observerCount === 0 && this.onNoObservers !== void 0) {
        this.onNoObservers(this);
      }
    };
    ObserverProxy2.prototype.forEachObserver = function(fn2) {
      if (this.finalized) {
        return;
      }
      for (var i2 = 0; i2 < this.observers.length; i2++) {
        this.sendOne(i2, fn2);
      }
    };
    ObserverProxy2.prototype.sendOne = function(i2, fn2) {
      var _this = this;
      this.task.then(function() {
        if (_this.observers !== void 0 && _this.observers[i2] !== void 0) {
          try {
            fn2(_this.observers[i2]);
          } catch (e) {
            if (typeof console !== "undefined" && console.error) {
              console.error(e);
            }
          }
        }
      });
    };
    ObserverProxy2.prototype.close = function(err) {
      var _this = this;
      if (this.finalized) {
        return;
      }
      this.finalized = true;
      if (err !== void 0) {
        this.finalError = err;
      }
      this.task.then(function() {
        _this.observers = void 0;
        _this.onNoObservers = void 0;
      });
    };
    return ObserverProxy2;
  }()
);
function implementsAnyMethods(obj, methods) {
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  for (var _i2 = 0, methods_1 = methods; _i2 < methods_1.length; _i2++) {
    var method = methods_1[_i2];
    if (method in obj && typeof obj[method] === "function") {
      return true;
    }
  }
  return false;
}
function noop2() {
}
var MAX_VALUE_MILLIS = 4 * 60 * 60 * 1e3;

// node_modules/ng-fire-admin/node_modules/@firebase/webchannel-wrapper/dist/index.esm.js
var extendStatics2 = function(d, b2) {
  extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
    d2.__proto__ = b3;
  } || function(d2, b3) {
    for (var p2 in b3)
      if (Object.prototype.hasOwnProperty.call(b3, p2))
        d2[p2] = b3[p2];
  };
  return extendStatics2(d, b2);
};
function __extends2(d, b2) {
  extendStatics2(d, b2);
  function __() {
    this.constructor = d;
  }
  d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
function __values2(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i2 >= o.length)
          o = void 0;
        return { value: o && o[i2++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var g;
var goog = goog || {};
var k = commonjsGlobal || self;
function aa() {
}
function ba(a) {
  var b2 = typeof a;
  return "object" != b2 ? b2 : a ? Array.isArray(a) ? "array" : b2 : "null";
}
function ca(a) {
  var b2 = ba(a);
  return "array" == b2 || "object" == b2 && "number" == typeof a.length;
}
function n(a) {
  var b2 = typeof a;
  return "object" == b2 && null != a || "function" == b2;
}
function da(a) {
  return Object.prototype.hasOwnProperty.call(a, ea) && a[ea] || (a[ea] = ++fa);
}
var ea = "closure_uid_" + (1e9 * Math.random() >>> 0);
var fa = 0;
function ha(a, b2, c) {
  return a.call.apply(a.bind, arguments);
}
function ja(a, b2, c) {
  if (!a)
    throw Error();
  if (2 < arguments.length) {
    var d = Array.prototype.slice.call(arguments, 2);
    return function() {
      var e = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(e, d);
      return a.apply(b2, e);
    };
  }
  return function() {
    return a.apply(b2, arguments);
  };
}
function p(a, b2, c) {
  Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? p = ha : p = ja;
  return p.apply(null, arguments);
}
function ka(a, b2) {
  var c = Array.prototype.slice.call(arguments, 1);
  return function() {
    var d = c.slice();
    d.push.apply(d, arguments);
    return a.apply(this, d);
  };
}
var q = Date.now;
function r(a, b2) {
  function c() {
  }
  c.prototype = b2.prototype;
  a.S = b2.prototype;
  a.prototype = new c();
  a.prototype.constructor = a;
}
function u() {
  this.j = this.j;
  this.i = this.i;
}
var la = 0;
u.prototype.j = false;
u.prototype.ja = function() {
  if (!this.j && (this.j = true, this.G(), 0 != la)) {
    var a = da(this);
  }
};
u.prototype.G = function() {
  if (this.i)
    for (; this.i.length; )
      this.i.shift()();
};
var na = Array.prototype.indexOf ? function(a, b2) {
  return Array.prototype.indexOf.call(a, b2, void 0);
} : function(a, b2) {
  if ("string" === typeof a)
    return "string" !== typeof b2 || 1 != b2.length ? -1 : a.indexOf(b2, 0);
  for (var c = 0; c < a.length; c++)
    if (c in a && a[c] === b2)
      return c;
  return -1;
};
var oa = Array.prototype.forEach ? function(a, b2, c) {
  Array.prototype.forEach.call(a, b2, c);
} : function(a, b2, c) {
  for (var d = a.length, e = "string" === typeof a ? a.split("") : a, f = 0; f < d; f++)
    f in e && b2.call(c, e[f], f, a);
};
function pa(a) {
  a: {
    var b2 = qa;
    for (var c = a.length, d = "string" === typeof a ? a.split("") : a, e = 0; e < c; e++)
      if (e in d && b2.call(void 0, d[e], e, a)) {
        b2 = e;
        break a;
      }
    b2 = -1;
  }
  return 0 > b2 ? null : "string" === typeof a ? a.charAt(b2) : a[b2];
}
function ra(a) {
  return Array.prototype.concat.apply([], arguments);
}
function sa(a) {
  var b2 = a.length;
  if (0 < b2) {
    for (var c = Array(b2), d = 0; d < b2; d++)
      c[d] = a[d];
    return c;
  }
  return [];
}
function ta(a) {
  return /^[\s\xa0]*$/.test(a);
}
var ua = String.prototype.trim ? function(a) {
  return a.trim();
} : function(a) {
  return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a)[1];
};
function v(a, b2) {
  return -1 != a.indexOf(b2);
}
function xa(a, b2) {
  return a < b2 ? -1 : a > b2 ? 1 : 0;
}
var w;
a: {
  ya2 = k.navigator;
  if (ya2) {
    za = ya2.userAgent;
    if (za) {
      w = za;
      break a;
    }
  }
  w = "";
}
var ya2;
var za;
function Aa(a, b2, c) {
  for (var d in a)
    b2.call(c, a[d], d, a);
}
function Ba(a) {
  var b2 = {};
  for (var c in a)
    b2[c] = a[c];
  return b2;
}
var Ca = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
function Da(a, b2) {
  var c, d;
  for (var e = 1; e < arguments.length; e++) {
    d = arguments[e];
    for (c in d)
      a[c] = d[c];
    for (var f = 0; f < Ca.length; f++)
      c = Ca[f], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
  }
}
function Ea(a) {
  Ea[" "](a);
  return a;
}
Ea[" "] = aa;
function Fa(a, b2) {
  var c = Ga;
  return Object.prototype.hasOwnProperty.call(c, a) ? c[a] : c[a] = b2(a);
}
var Ha = v(w, "Opera");
var x = v(w, "Trident") || v(w, "MSIE");
var Ia = v(w, "Edge");
var Ja = Ia || x;
var Ka = v(w, "Gecko") && !(v(w.toLowerCase(), "webkit") && !v(w, "Edge")) && !(v(w, "Trident") || v(w, "MSIE")) && !v(w, "Edge");
var La = v(w.toLowerCase(), "webkit") && !v(w, "Edge");
function Ma() {
  var a = k.document;
  return a ? a.documentMode : void 0;
}
var Na;
a: {
  Oa2 = "", Pa = function() {
    var a = w;
    if (Ka)
      return /rv:([^\);]+)(\)|;)/.exec(a);
    if (Ia)
      return /Edge\/([\d\.]+)/.exec(a);
    if (x)
      return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);
    if (La)
      return /WebKit\/(\S+)/.exec(a);
    if (Ha)
      return /(?:Version)[ \/]?(\S+)/.exec(a);
  }();
  Pa && (Oa2 = Pa ? Pa[1] : "");
  if (x) {
    Qa = Ma();
    if (null != Qa && Qa > parseFloat(Oa2)) {
      Na = String(Qa);
      break a;
    }
  }
  Na = Oa2;
}
var Oa2;
var Pa;
var Qa;
var Ga = {};
function Ra(a) {
  return Fa(a, function() {
    {
      var b2 = 0;
      var e = ua(String(Na)).split("."), f = ua(String(a)).split("."), h = Math.max(e.length, f.length);
      for (var m = 0; 0 == b2 && m < h; m++) {
        var c = e[m] || "", d = f[m] || "";
        do {
          c = /(\d*)(\D*)(.*)/.exec(c) || ["", "", "", ""];
          d = /(\d*)(\D*)(.*)/.exec(d) || ["", "", "", ""];
          if (0 == c[0].length && 0 == d[0].length)
            break;
          b2 = xa(0 == c[1].length ? 0 : parseInt(c[1], 10), 0 == d[1].length ? 0 : parseInt(d[1], 10)) || xa(0 == c[2].length, 0 == d[2].length) || xa(c[2], d[2]);
          c = c[3];
          d = d[3];
        } while (0 == b2);
      }
    }
    return 0 <= b2;
  });
}
var Sa;
if (k.document && x) {
  Ta2 = Ma();
  Sa = Ta2 ? Ta2 : parseInt(Na, 10) || void 0;
} else
  Sa = void 0;
var Ta2;
var Ua = Sa;
var Va = !x || 9 <= Number(Ua);
var Wa = x && !Ra("9");
var Xa = function() {
  if (!k.addEventListener || !Object.defineProperty)
    return false;
  var a = false, b2 = Object.defineProperty({}, "passive", { get: function() {
    a = true;
  } });
  try {
    k.addEventListener("test", aa, b2), k.removeEventListener("test", aa, b2);
  } catch (c) {
  }
  return a;
}();
function y(a, b2) {
  this.type = a;
  this.a = this.target = b2;
  this.defaultPrevented = false;
}
y.prototype.b = function() {
  this.defaultPrevented = true;
};
function A(a, b2) {
  y.call(this, a ? a.type : "");
  this.relatedTarget = this.a = this.target = null;
  this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0;
  this.key = "";
  this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = false;
  this.pointerId = 0;
  this.pointerType = "";
  this.c = null;
  if (a) {
    var c = this.type = a.type, d = a.changedTouches && a.changedTouches.length ? a.changedTouches[0] : null;
    this.target = a.target || a.srcElement;
    this.a = b2;
    if (b2 = a.relatedTarget) {
      if (Ka) {
        a: {
          try {
            Ea(b2.nodeName);
            var e = true;
            break a;
          } catch (f) {
          }
          e = false;
        }
        e || (b2 = null);
      }
    } else
      "mouseover" == c ? b2 = a.fromElement : "mouseout" == c && (b2 = a.toElement);
    this.relatedTarget = b2;
    d ? (this.clientX = void 0 !== d.clientX ? d.clientX : d.pageX, this.clientY = void 0 !== d.clientY ? d.clientY : d.pageY, this.screenX = d.screenX || 0, this.screenY = d.screenY || 0) : (this.clientX = void 0 !== a.clientX ? a.clientX : a.pageX, this.clientY = void 0 !== a.clientY ? a.clientY : a.pageY, this.screenX = a.screenX || 0, this.screenY = a.screenY || 0);
    this.button = a.button;
    this.key = a.key || "";
    this.ctrlKey = a.ctrlKey;
    this.altKey = a.altKey;
    this.shiftKey = a.shiftKey;
    this.metaKey = a.metaKey;
    this.pointerId = a.pointerId || 0;
    this.pointerType = "string" === typeof a.pointerType ? a.pointerType : Ya[a.pointerType] || "";
    this.c = a;
    a.defaultPrevented && this.b();
  }
}
r(A, y);
var Ya = { 2: "touch", 3: "pen", 4: "mouse" };
A.prototype.b = function() {
  A.S.b.call(this);
  var a = this.c;
  if (a.preventDefault)
    a.preventDefault();
  else if (a.returnValue = false, Wa)
    try {
      if (a.ctrlKey || 112 <= a.keyCode && 123 >= a.keyCode)
        a.keyCode = -1;
    } catch (b2) {
    }
};
var C = "closure_listenable_" + (1e6 * Math.random() | 0);
var Za = 0;
function $a(a, b2, c, d, e) {
  this.listener = a;
  this.proxy = null;
  this.src = b2;
  this.type = c;
  this.capture = !!d;
  this.ca = e;
  this.key = ++Za;
  this.Y = this.Z = false;
}
function ab(a) {
  a.Y = true;
  a.listener = null;
  a.proxy = null;
  a.src = null;
  a.ca = null;
}
function bb(a) {
  this.src = a;
  this.a = {};
  this.b = 0;
}
bb.prototype.add = function(a, b2, c, d, e) {
  var f = a.toString();
  a = this.a[f];
  a || (a = this.a[f] = [], this.b++);
  var h = cb(a, b2, d, e);
  -1 < h ? (b2 = a[h], c || (b2.Z = false)) : (b2 = new $a(b2, this.src, f, !!d, e), b2.Z = c, a.push(b2));
  return b2;
};
function db(a, b2) {
  var c = b2.type;
  if (c in a.a) {
    var d = a.a[c], e = na(d, b2), f;
    (f = 0 <= e) && Array.prototype.splice.call(d, e, 1);
    f && (ab(b2), 0 == a.a[c].length && (delete a.a[c], a.b--));
  }
}
function cb(a, b2, c, d) {
  for (var e = 0; e < a.length; ++e) {
    var f = a[e];
    if (!f.Y && f.listener == b2 && f.capture == !!c && f.ca == d)
      return e;
  }
  return -1;
}
var eb = "closure_lm_" + (1e6 * Math.random() | 0);
var fb = {};
function hb(a, b2, c, d, e) {
  if (d && d.once)
    return ib(a, b2, c, d, e);
  if (Array.isArray(b2)) {
    for (var f = 0; f < b2.length; f++)
      hb(a, b2[f], c, d, e);
    return null;
  }
  c = jb(c);
  return a && a[C] ? a.va(b2, c, n(d) ? !!d.capture : !!d, e) : kb(a, b2, c, false, d, e);
}
function kb(a, b2, c, d, e, f) {
  if (!b2)
    throw Error("Invalid event type");
  var h = n(e) ? !!e.capture : !!e;
  if (h && !Va)
    return null;
  var m = lb(a);
  m || (a[eb] = m = new bb(a));
  c = m.add(b2, c, d, h, f);
  if (c.proxy)
    return c;
  d = mb();
  c.proxy = d;
  d.src = a;
  d.listener = c;
  if (a.addEventListener)
    Xa || (e = h), void 0 === e && (e = false), a.addEventListener(b2.toString(), d, e);
  else if (a.attachEvent)
    a.attachEvent(nb(b2.toString()), d);
  else if (a.addListener && a.removeListener)
    a.addListener(d);
  else
    throw Error("addEventListener and attachEvent are unavailable.");
  return c;
}
function mb() {
  var a = ob, b2 = Va ? function(c) {
    return a.call(b2.src, b2.listener, c);
  } : function(c) {
    c = a.call(b2.src, b2.listener, c);
    if (!c)
      return c;
  };
  return b2;
}
function ib(a, b2, c, d, e) {
  if (Array.isArray(b2)) {
    for (var f = 0; f < b2.length; f++)
      ib(a, b2[f], c, d, e);
    return null;
  }
  c = jb(c);
  return a && a[C] ? a.wa(b2, c, n(d) ? !!d.capture : !!d, e) : kb(a, b2, c, true, d, e);
}
function pb(a, b2, c, d, e) {
  if (Array.isArray(b2))
    for (var f = 0; f < b2.length; f++)
      pb(a, b2[f], c, d, e);
  else
    (d = n(d) ? !!d.capture : !!d, c = jb(c), a && a[C]) ? (a = a.c, b2 = String(b2).toString(), b2 in a.a && (f = a.a[b2], c = cb(f, c, d, e), -1 < c && (ab(f[c]), Array.prototype.splice.call(f, c, 1), 0 == f.length && (delete a.a[b2], a.b--)))) : a && (a = lb(a)) && (b2 = a.a[b2.toString()], a = -1, b2 && (a = cb(b2, c, d, e)), (c = -1 < a ? b2[a] : null) && rb(c));
}
function rb(a) {
  if ("number" !== typeof a && a && !a.Y) {
    var b2 = a.src;
    if (b2 && b2[C])
      db(b2.c, a);
    else {
      var c = a.type, d = a.proxy;
      b2.removeEventListener ? b2.removeEventListener(c, d, a.capture) : b2.detachEvent ? b2.detachEvent(nb(c), d) : b2.addListener && b2.removeListener && b2.removeListener(d);
      (c = lb(b2)) ? (db(c, a), 0 == c.b && (c.src = null, b2[eb] = null)) : ab(a);
    }
  }
}
function nb(a) {
  return a in fb ? fb[a] : fb[a] = "on" + a;
}
function sb(a, b2) {
  var c = a.listener, d = a.ca || a.src;
  a.Z && rb(a);
  return c.call(d, b2);
}
function ob(a, b2) {
  if (a.Y)
    return true;
  if (!Va) {
    if (!b2)
      a: {
        b2 = ["window", "event"];
        for (var c = k, d = 0; d < b2.length; d++)
          if (c = c[b2[d]], null == c) {
            b2 = null;
            break a;
          }
        b2 = c;
      }
    b2 = new A(b2, this);
    return sb(a, b2);
  }
  return sb(a, new A(b2, this));
}
function lb(a) {
  a = a[eb];
  return a instanceof bb ? a : null;
}
var tb = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);
function jb(a) {
  if ("function" == ba(a))
    return a;
  a[tb] || (a[tb] = function(b2) {
    return a.handleEvent(b2);
  });
  return a[tb];
}
function D() {
  u.call(this);
  this.c = new bb(this);
  this.J = this;
  this.C = null;
}
r(D, u);
D.prototype[C] = true;
g = D.prototype;
g.addEventListener = function(a, b2, c, d) {
  hb(this, a, b2, c, d);
};
g.removeEventListener = function(a, b2, c, d) {
  pb(this, a, b2, c, d);
};
g.dispatchEvent = function(a) {
  var b2, c = this.C;
  if (c)
    for (b2 = []; c; c = c.C)
      b2.push(c);
  c = this.J;
  var d = a.type || a;
  if ("string" === typeof a)
    a = new y(a, c);
  else if (a instanceof y)
    a.target = a.target || c;
  else {
    var e = a;
    a = new y(d, c);
    Da(a, e);
  }
  e = true;
  if (b2)
    for (var f = b2.length - 1; 0 <= f; f--) {
      var h = a.a = b2[f];
      e = ub(h, d, true, a) && e;
    }
  h = a.a = c;
  e = ub(h, d, true, a) && e;
  e = ub(h, d, false, a) && e;
  if (b2)
    for (f = 0; f < b2.length; f++)
      h = a.a = b2[f], e = ub(h, d, false, a) && e;
  return e;
};
g.G = function() {
  D.S.G.call(this);
  if (this.c) {
    var a = this.c, c;
    for (c in a.a) {
      for (var d = a.a[c], e = 0; e < d.length; e++)
        ab(d[e]);
      delete a.a[c];
      a.b--;
    }
  }
  this.C = null;
};
g.va = function(a, b2, c, d) {
  return this.c.add(String(a), b2, false, c, d);
};
g.wa = function(a, b2, c, d) {
  return this.c.add(String(a), b2, true, c, d);
};
function ub(a, b2, c, d) {
  b2 = a.c.a[String(b2)];
  if (!b2)
    return true;
  b2 = b2.concat();
  for (var e = true, f = 0; f < b2.length; ++f) {
    var h = b2[f];
    if (h && !h.Y && h.capture == c) {
      var m = h.listener, l = h.ca || h.src;
      h.Z && db(a.c, h);
      e = false !== m.call(l, d) && e;
    }
  }
  return e && !d.defaultPrevented;
}
var vb = k.JSON.stringify;
function wb() {
  this.b = this.a = null;
}
var yb = new /** @class */
(function() {
  function class_1(a, b2, c) {
    this.f = c;
    this.c = a;
    this.g = b2;
    this.b = 0;
    this.a = null;
  }
  class_1.prototype.get = function() {
    var a;
    0 < this.b ? (this.b--, a = this.a, this.a = a.next, a.next = null) : a = this.c();
    return a;
  };
  return class_1;
}())(function() {
  return new xb();
}, function(a) {
  a.reset();
}, 100);
wb.prototype.add = function(a, b2) {
  var c = yb.get();
  c.set(a, b2);
  this.b ? this.b.next = c : this.a = c;
  this.b = c;
};
function zb() {
  var a = Ab, b2 = null;
  a.a && (b2 = a.a, a.a = a.a.next, a.a || (a.b = null), b2.next = null);
  return b2;
}
function xb() {
  this.next = this.b = this.a = null;
}
xb.prototype.set = function(a, b2) {
  this.a = a;
  this.b = b2;
  this.next = null;
};
xb.prototype.reset = function() {
  this.next = this.b = this.a = null;
};
function Bb(a) {
  k.setTimeout(function() {
    throw a;
  }, 0);
}
function Cb(a, b2) {
  Db || Eb();
  Fb || (Db(), Fb = true);
  Ab.add(a, b2);
}
var Db;
function Eb() {
  var a = k.Promise.resolve(void 0);
  Db = function() {
    a.then(Gb);
  };
}
var Fb = false;
var Ab = new wb();
function Gb() {
  for (var a; a = zb(); ) {
    try {
      a.a.call(a.b);
    } catch (c) {
      Bb(c);
    }
    var b2 = yb;
    b2.g(a);
    b2.b < b2.f && (b2.b++, a.next = b2.a, b2.a = a);
  }
  Fb = false;
}
function Hb(a, b2) {
  D.call(this);
  this.b = a || 1;
  this.a = b2 || k;
  this.f = p(this.Ya, this);
  this.g = q();
}
r(Hb, D);
g = Hb.prototype;
g.aa = false;
g.M = null;
g.Ya = function() {
  if (this.aa) {
    var a = q() - this.g;
    0 < a && a < 0.8 * this.b ? this.M = this.a.setTimeout(this.f, this.b - a) : (this.M && (this.a.clearTimeout(this.M), this.M = null), this.dispatchEvent("tick"), this.aa && (Ib(this), this.start()));
  }
};
g.start = function() {
  this.aa = true;
  this.M || (this.M = this.a.setTimeout(this.f, this.b), this.g = q());
};
function Ib(a) {
  a.aa = false;
  a.M && (a.a.clearTimeout(a.M), a.M = null);
}
g.G = function() {
  Hb.S.G.call(this);
  Ib(this);
  delete this.a;
};
function Jb(a, b2, c) {
  if ("function" == ba(a))
    c && (a = p(a, c));
  else if (a && "function" == typeof a.handleEvent)
    a = p(a.handleEvent, a);
  else
    throw Error("Invalid listener argument");
  return 2147483647 < Number(b2) ? -1 : k.setTimeout(a, b2 || 0);
}
function Kb(a) {
  a.a = Jb(function() {
    a.a = null;
    a.c && (a.c = false, Kb(a));
  }, a.h);
  var b2 = a.b;
  a.b = null;
  a.g.apply(null, b2);
}
var Lb = (
  /** @class */
  function(_super) {
    __extends2(Lb2, _super);
    function Lb2(a, b2, c) {
      var _this = _super.call(this) || this;
      _this.g = null != c ? a.bind(c) : a;
      _this.h = b2;
      _this.b = null;
      _this.c = false;
      _this.a = null;
      return _this;
    }
    Lb2.prototype.f = function(a) {
      this.b = arguments;
      this.a ? this.c = true : Kb(this);
    };
    Lb2.prototype.G = function() {
      _super.prototype.G.call(this);
      this.a && (k.clearTimeout(this.a), this.a = null, this.c = false, this.b = null);
    };
    return Lb2;
  }(u)
);
function E(a) {
  u.call(this);
  this.b = a;
  this.a = {};
}
r(E, u);
var Mb = [];
function Nb(a, b2, c, d) {
  Array.isArray(c) || (c && (Mb[0] = c.toString()), c = Mb);
  for (var e = 0; e < c.length; e++) {
    var f = hb(b2, c[e], d || a.handleEvent, false, a.b || a);
    if (!f)
      break;
    a.a[f.key] = f;
  }
}
function Ob(a) {
  Aa(a.a, function(b2, c) {
    this.a.hasOwnProperty(c) && rb(b2);
  }, a);
  a.a = {};
}
E.prototype.G = function() {
  E.S.G.call(this);
  Ob(this);
};
E.prototype.handleEvent = function() {
  throw Error("EventHandler.handleEvent not implemented");
};
function Pb() {
  this.a = true;
}
function Qb(a, b2, c, d, e, f) {
  a.info(function() {
    if (a.a)
      if (f) {
        var h = "";
        for (var m = f.split("&"), l = 0; l < m.length; l++) {
          var t = m[l].split("=");
          if (1 < t.length) {
            var B2 = t[0];
            t = t[1];
            var z2 = B2.split("_");
            h = 2 <= z2.length && "type" == z2[1] ? h + (B2 + "=" + t + "&") : h + (B2 + "=redacted&");
          }
        }
      } else
        h = null;
    else
      h = f;
    return "XMLHTTP REQ (" + d + ") [attempt " + e + "]: " + b2 + "\n" + c + "\n" + h;
  });
}
function Rb(a, b2, c, d, e, f, h) {
  a.info(function() {
    return "XMLHTTP RESP (" + d + ") [ attempt " + e + "]: " + b2 + "\n" + c + "\n" + f + " " + h;
  });
}
function F(a, b2, c, d) {
  a.info(function() {
    return "XMLHTTP TEXT (" + b2 + "): " + Sb(a, c) + (d ? " " + d : "");
  });
}
function Tb(a, b2) {
  a.info(function() {
    return "TIMEOUT: " + b2;
  });
}
Pb.prototype.info = function() {
};
function Sb(a, b2) {
  if (!a.a)
    return b2;
  if (!b2)
    return null;
  try {
    var c = JSON.parse(b2);
    if (c) {
      for (a = 0; a < c.length; a++)
        if (Array.isArray(c[a])) {
          var d = c[a];
          if (!(2 > d.length)) {
            var e = d[1];
            if (Array.isArray(e) && !(1 > e.length)) {
              var f = e[0];
              if ("noop" != f && "stop" != f && "close" != f)
                for (var h = 1; h < e.length; h++)
                  e[h] = "";
            }
          }
        }
    }
    return vb(c);
  } catch (m) {
    return b2;
  }
}
var Ub = null;
function Vb() {
  return Ub = Ub || new D();
}
function Wb(a) {
  y.call(this, "serverreachability", a);
}
r(Wb, y);
function G(a) {
  var b2 = Vb();
  b2.dispatchEvent(new Wb(b2, a));
}
function Xb(a) {
  y.call(this, "statevent", a);
}
r(Xb, y);
function H(a) {
  var b2 = Vb();
  b2.dispatchEvent(new Xb(b2, a));
}
function Yb(a) {
  y.call(this, "timingevent", a);
}
r(Yb, y);
function I(a, b2) {
  if ("function" != ba(a))
    throw Error("Fn must not be null and must be a function");
  return k.setTimeout(function() {
    a();
  }, b2);
}
var Zb = { NO_ERROR: 0, Za: 1, gb: 2, fb: 3, bb: 4, eb: 5, hb: 6, Da: 7, TIMEOUT: 8, kb: 9 };
var $b = { ab: "complete", ob: "success", Ea: "error", Da: "abort", mb: "ready", nb: "readystatechange", TIMEOUT: "timeout", ib: "incrementaldata", lb: "progress", cb: "downloadprogress", pb: "uploadprogress" };
function ac() {
}
ac.prototype.a = null;
function bc(a) {
  var b2;
  (b2 = a.a) || (b2 = a.a = {});
  return b2;
}
function cc() {
}
var J = { OPEN: "a", $a: "b", Ea: "c", jb: "d" };
function dc() {
  y.call(this, "d");
}
r(dc, y);
function ec() {
  y.call(this, "c");
}
r(ec, y);
var fc;
function gc() {
}
r(gc, ac);
fc = new gc();
function K(a, b2, c, d) {
  this.g = a;
  this.c = b2;
  this.f = c;
  this.T = d || 1;
  this.J = new E(this);
  this.P = hc;
  a = Ja ? 125 : void 0;
  this.R = new Hb(a);
  this.B = null;
  this.b = false;
  this.j = this.l = this.i = this.H = this.u = this.U = this.o = null;
  this.s = [];
  this.a = null;
  this.D = 0;
  this.h = this.m = null;
  this.N = -1;
  this.A = false;
  this.O = 0;
  this.F = null;
  this.W = this.C = this.V = this.I = false;
}
var hc = 45e3;
var ic = {};
var jc = {};
g = K.prototype;
g.setTimeout = function(a) {
  this.P = a;
};
function kc(a, b2, c) {
  a.H = 1;
  a.i = lc(L(b2));
  a.j = c;
  a.I = true;
  mc(a, null);
}
function mc(a, b2) {
  a.u = q();
  M(a);
  a.l = L(a.i);
  var c = a.l, d = a.T;
  Array.isArray(d) || (d = [String(d)]);
  nc(c.b, "t", d);
  a.D = 0;
  a.a = oc(a.g, a.g.C ? b2 : null);
  0 < a.O && (a.F = new Lb(p(a.Ca, a, a.a), a.O));
  Nb(a.J, a.a, "readystatechange", a.Wa);
  b2 = a.B ? Ba(a.B) : {};
  a.j ? (a.m || (a.m = "POST"), b2["Content-Type"] = "application/x-www-form-urlencoded", a.a.ba(a.l, a.m, a.j, b2)) : (a.m = "GET", a.a.ba(a.l, a.m, null, b2));
  G(1);
  Qb(a.c, a.m, a.l, a.f, a.T, a.j);
}
g.Wa = function(a) {
  a = a.target;
  var b2 = this.F;
  b2 && 3 == N(a) ? b2.f() : this.Ca(a);
};
g.Ca = function(a) {
  try {
    if (a == this.a)
      a: {
        var b2 = N(this.a), c = this.a.ua(), d = this.a.X();
        if (!(3 > b2 || 3 == b2 && !Ja && !this.a.$())) {
          this.A || 4 != b2 || 7 == c || (8 == c || 0 >= d ? G(3) : G(2));
          pc(this);
          var e = this.a.X();
          this.N = e;
          var f = this.a.$();
          this.b = 200 == e;
          Rb(this.c, this.m, this.l, this.f, this.T, b2, e);
          if (this.b) {
            if (this.V && !this.C) {
              b: {
                if (this.a) {
                  var h, m = this.a;
                  if ((h = m.a ? m.a.getResponseHeader("X-HTTP-Initial-Response") : null) && !ta(h)) {
                    var l = h;
                    break b;
                  }
                }
                l = null;
              }
              if (l)
                F(this.c, this.f, l, "Initial handshake response via X-HTTP-Initial-Response"), this.C = true, qc(this, l);
              else {
                this.b = false;
                this.h = 3;
                H(12);
                O(this);
                rc(this);
                break a;
              }
            }
            this.I ? (tc(this, b2, f), Ja && this.b && 3 == b2 && (Nb(this.J, this.R, "tick", this.Va), this.R.start())) : (F(this.c, this.f, f, null), qc(this, f));
            4 == b2 && O(this);
            this.b && !this.A && (4 == b2 ? uc(this.g, this) : (this.b = false, M(this)));
          } else
            400 == e && 0 < f.indexOf("Unknown SID") ? (this.h = 3, H(12)) : (this.h = 0, H(13)), O(this), rc(this);
        }
      }
  } catch (t) {
  } finally {
  }
};
function tc(a, b2, c) {
  for (var d = true; !a.A && a.D < c.length; ) {
    var e = vc(a, c);
    if (e == jc) {
      4 == b2 && (a.h = 4, H(14), d = false);
      F(a.c, a.f, null, "[Incomplete Response]");
      break;
    } else if (e == ic) {
      a.h = 4;
      H(15);
      F(a.c, a.f, c, "[Invalid Chunk]");
      d = false;
      break;
    } else
      F(a.c, a.f, e, null), qc(a, e);
  }
  4 == b2 && 0 == c.length && (a.h = 1, H(16), d = false);
  a.b = a.b && d;
  d ? 0 < c.length && !a.W && (a.W = true, b2 = a.g, b2.a == a && b2.V && !b2.F && (b2.c.info("Great, no buffering proxy detected. Bytes received: " + c.length), xc(b2), b2.F = true)) : (F(a.c, a.f, c, "[Invalid Chunked Response]"), O(a), rc(a));
}
g.Va = function() {
  if (this.a) {
    var a = N(this.a), b2 = this.a.$();
    this.D < b2.length && (pc(this), tc(this, a, b2), this.b && 4 != a && M(this));
  }
};
function vc(a, b2) {
  var c = a.D, d = b2.indexOf("\n", c);
  if (-1 == d)
    return jc;
  c = Number(b2.substring(c, d));
  if (isNaN(c))
    return ic;
  d += 1;
  if (d + c > b2.length)
    return jc;
  b2 = b2.substr(d, c);
  a.D = d + c;
  return b2;
}
g.cancel = function() {
  this.A = true;
  O(this);
};
function M(a) {
  a.U = q() + a.P;
  yc(a, a.P);
}
function yc(a, b2) {
  if (null != a.o)
    throw Error("WatchDog timer not null");
  a.o = I(p(a.Ua, a), b2);
}
function pc(a) {
  a.o && (k.clearTimeout(a.o), a.o = null);
}
g.Ua = function() {
  this.o = null;
  var a = q();
  0 <= a - this.U ? (Tb(this.c, this.l), 2 != this.H && (G(3), H(17)), O(this), this.h = 2, rc(this)) : yc(this, this.U - a);
};
function rc(a) {
  0 == a.g.v || a.A || uc(a.g, a);
}
function O(a) {
  pc(a);
  var b2 = a.F;
  b2 && "function" == typeof b2.ja && b2.ja();
  a.F = null;
  Ib(a.R);
  Ob(a.J);
  a.a && (b2 = a.a, a.a = null, b2.abort(), b2.ja());
}
function qc(a, b2) {
  try {
    var c = a.g;
    if (0 != c.v && (c.a == a || zc(c.b, a))) {
      if (c.I = a.N, !a.C && zc(c.b, a) && 3 == c.v) {
        try {
          var d = c.ka.a.parse(b2);
        } catch (sc) {
          d = null;
        }
        if (Array.isArray(d) && 3 == d.length) {
          var e = d;
          if (0 == e[0])
            a: {
              if (!c.j) {
                if (c.a)
                  if (c.a.u + 3e3 < a.u)
                    Ac(c), Bc(c);
                  else
                    break a;
                Cc(c);
                H(18);
              }
            }
          else
            c.oa = e[1], 0 < c.oa - c.P && 37500 > e[2] && c.H && 0 == c.o && !c.m && (c.m = I(p(c.Ra, c), 6e3));
          if (1 >= Dc(c.b) && c.ea) {
            try {
              c.ea();
            } catch (sc) {
            }
            c.ea = void 0;
          }
        } else
          P(c, 11);
      } else if ((a.C || c.a == a) && Ac(c), !ta(b2))
        for (b2 = d = c.ka.a.parse(b2), d = 0; d < b2.length; d++)
          if (e = b2[d], c.P = e[0], e = e[1], 2 == c.v)
            if ("c" == e[0]) {
              c.J = e[1];
              c.ga = e[2];
              var f = e[3];
              null != f && (c.ha = f, c.c.info("VER=" + c.ha));
              var h = e[4];
              null != h && (c.pa = h, c.c.info("SVER=" + c.pa));
              var m = e[5];
              if (null != m && "number" === typeof m && 0 < m) {
                var l = 1.5 * m;
                c.D = l;
                c.c.info("backChannelRequestTimeoutMs_=" + l);
              }
              l = c;
              var t = a.a;
              if (t) {
                var B2 = t.a ? t.a.getResponseHeader("X-Client-Wire-Protocol") : null;
                if (B2) {
                  var z2 = l.b;
                  !z2.a && (v(B2, "spdy") || v(B2, "quic") || v(B2, "h2")) && (z2.f = z2.g, z2.a = /* @__PURE__ */ new Set(), z2.b && (Ec(z2, z2.b), z2.b = null));
                }
                if (l.A) {
                  var qb = t.a ? t.a.getResponseHeader("X-HTTP-Session-Id") : null;
                  qb && (l.na = qb, Q(l.B, l.A, qb));
                }
              }
              c.v = 3;
              c.f && c.f.ta();
              c.V && (c.N = q() - a.u, c.c.info("Handshake RTT: " + c.N + "ms"));
              l = c;
              var va2 = a;
              l.la = Fc(l, l.C ? l.ga : null, l.fa);
              if (va2.C) {
                Gc(l.b, va2);
                var wa2 = va2, wc = l.D;
                wc && wa2.setTimeout(wc);
                wa2.o && (pc(wa2), M(wa2));
                l.a = va2;
              } else
                Hc(l);
              0 < c.g.length && Ic(c);
            } else
              "stop" != e[0] && "close" != e[0] || P(c, 7);
          else
            3 == c.v && ("stop" == e[0] || "close" == e[0] ? "stop" == e[0] ? P(c, 7) : Jc(c) : "noop" != e[0] && c.f && c.f.sa(e), c.o = 0);
    }
    G(4);
  } catch (sc) {
  }
}
function Kc(a) {
  if (a.K && "function" == typeof a.K)
    return a.K();
  if ("string" === typeof a)
    return a.split("");
  if (ca(a)) {
    for (var b2 = [], c = a.length, d = 0; d < c; d++)
      b2.push(a[d]);
    return b2;
  }
  b2 = [];
  c = 0;
  for (d in a)
    b2[c++] = a[d];
  return a = b2;
}
function Lc(a, b2) {
  if (a.forEach && "function" == typeof a.forEach)
    a.forEach(b2, void 0);
  else if (ca(a) || "string" === typeof a)
    oa(a, b2, void 0);
  else {
    if (a.L && "function" == typeof a.L)
      var c = a.L();
    else if (a.K && "function" == typeof a.K)
      c = void 0;
    else if (ca(a) || "string" === typeof a) {
      c = [];
      for (var d = a.length, e = 0; e < d; e++)
        c.push(e);
    } else
      for (e in c = [], d = 0, a)
        c[d++] = e;
    d = Kc(a);
    e = d.length;
    for (var f = 0; f < e; f++)
      b2.call(void 0, d[f], c && c[f], a);
  }
}
function R(a, b2) {
  this.b = {};
  this.a = [];
  this.c = 0;
  var c = arguments.length;
  if (1 < c) {
    if (c % 2)
      throw Error("Uneven number of arguments");
    for (var d = 0; d < c; d += 2)
      this.set(arguments[d], arguments[d + 1]);
  } else if (a)
    if (a instanceof R)
      for (c = a.L(), d = 0; d < c.length; d++)
        this.set(c[d], a.get(c[d]));
    else
      for (d in a)
        this.set(d, a[d]);
}
g = R.prototype;
g.K = function() {
  Mc(this);
  for (var a = [], b2 = 0; b2 < this.a.length; b2++)
    a.push(this.b[this.a[b2]]);
  return a;
};
g.L = function() {
  Mc(this);
  return this.a.concat();
};
function Mc(a) {
  if (a.c != a.a.length) {
    for (var b2 = 0, c = 0; b2 < a.a.length; ) {
      var d = a.a[b2];
      S(a.b, d) && (a.a[c++] = d);
      b2++;
    }
    a.a.length = c;
  }
  if (a.c != a.a.length) {
    var e = {};
    for (c = b2 = 0; b2 < a.a.length; )
      d = a.a[b2], S(e, d) || (a.a[c++] = d, e[d] = 1), b2++;
    a.a.length = c;
  }
}
g.get = function(a, b2) {
  return S(this.b, a) ? this.b[a] : b2;
};
g.set = function(a, b2) {
  S(this.b, a) || (this.c++, this.a.push(a));
  this.b[a] = b2;
};
g.forEach = function(a, b2) {
  for (var c = this.L(), d = 0; d < c.length; d++) {
    var e = c[d], f = this.get(e);
    a.call(b2, f, e, this);
  }
};
function S(a, b2) {
  return Object.prototype.hasOwnProperty.call(a, b2);
}
var Nc = /^(?:([^:/?#.]+):)?(?:\/\/(?:([^\\/?#]*)@)?([^\\/?#]*?)(?::([0-9]+))?(?=[\\/?#]|$))?([^?#]+)?(?:\?([^#]*))?(?:#([\s\S]*))?$/;
function Oc(a, b2) {
  if (a) {
    a = a.split("&");
    for (var c = 0; c < a.length; c++) {
      var d = a[c].indexOf("="), e = null;
      if (0 <= d) {
        var f = a[c].substring(0, d);
        e = a[c].substring(d + 1);
      } else
        f = a[c];
      b2(f, e ? decodeURIComponent(e.replace(/\+/g, " ")) : "");
    }
  }
}
function T(a, b2) {
  this.c = this.j = this.f = "";
  this.h = null;
  this.i = this.g = "";
  this.a = false;
  if (a instanceof T) {
    this.a = void 0 !== b2 ? b2 : a.a;
    Pc(this, a.f);
    this.j = a.j;
    Qc(this, a.c);
    Rc(this, a.h);
    this.g = a.g;
    b2 = a.b;
    var c = new U();
    c.c = b2.c;
    b2.a && (c.a = new R(b2.a), c.b = b2.b);
    Sc(this, c);
    this.i = a.i;
  } else
    a && (c = String(a).match(Nc)) ? (this.a = !!b2, Pc(this, c[1] || "", true), this.j = Tc(c[2] || ""), Qc(this, c[3] || "", true), Rc(this, c[4]), this.g = Tc(c[5] || "", true), Sc(this, c[6] || "", true), this.i = Tc(c[7] || "")) : (this.a = !!b2, this.b = new U(null, this.a));
}
T.prototype.toString = function() {
  var a = [], b2 = this.f;
  b2 && a.push(Uc(b2, Vc, true), ":");
  var c = this.c;
  if (c || "file" == b2)
    a.push("//"), (b2 = this.j) && a.push(Uc(b2, Vc, true), "@"), a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), c = this.h, null != c && a.push(":", String(c));
  if (c = this.g)
    this.c && "/" != c.charAt(0) && a.push("/"), a.push(Uc(c, "/" == c.charAt(0) ? Wc : Xc, true));
  (c = this.b.toString()) && a.push("?", c);
  (c = this.i) && a.push("#", Uc(c, Yc));
  return a.join("");
};
function L(a) {
  return new T(a);
}
function Pc(a, b2, c) {
  a.f = c ? Tc(b2, true) : b2;
  a.f && (a.f = a.f.replace(/:$/, ""));
}
function Qc(a, b2, c) {
  a.c = c ? Tc(b2, true) : b2;
}
function Rc(a, b2) {
  if (b2) {
    b2 = Number(b2);
    if (isNaN(b2) || 0 > b2)
      throw Error("Bad port number " + b2);
    a.h = b2;
  } else
    a.h = null;
}
function Sc(a, b2, c) {
  b2 instanceof U ? (a.b = b2, Zc(a.b, a.a)) : (c || (b2 = Uc(b2, $c)), a.b = new U(b2, a.a));
}
function Q(a, b2, c) {
  a.b.set(b2, c);
}
function lc(a) {
  Q(a, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ q()).toString(36));
  return a;
}
function ad(a) {
  return a instanceof T ? L(a) : new T(a, void 0);
}
function bd(a, b2, c, d) {
  var e = new T(null, void 0);
  a && Pc(e, a);
  b2 && Qc(e, b2);
  c && Rc(e, c);
  d && (e.g = d);
  return e;
}
function Tc(a, b2) {
  return a ? b2 ? decodeURI(a.replace(/%25/g, "%2525")) : decodeURIComponent(a) : "";
}
function Uc(a, b2, c) {
  return "string" === typeof a ? (a = encodeURI(a).replace(b2, cd), c && (a = a.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), a) : null;
}
function cd(a) {
  a = a.charCodeAt(0);
  return "%" + (a >> 4 & 15).toString(16) + (a & 15).toString(16);
}
var Vc = /[#\/\?@]/g;
var Xc = /[#\?:]/g;
var Wc = /[#\?]/g;
var $c = /[#\?@]/g;
var Yc = /#/g;
function U(a, b2) {
  this.b = this.a = null;
  this.c = a || null;
  this.f = !!b2;
}
function V(a) {
  a.a || (a.a = new R(), a.b = 0, a.c && Oc(a.c, function(b2, c) {
    a.add(decodeURIComponent(b2.replace(/\+/g, " ")), c);
  }));
}
g = U.prototype;
g.add = function(a, b2) {
  V(this);
  this.c = null;
  a = W(this, a);
  var c = this.a.get(a);
  c || this.a.set(a, c = []);
  c.push(b2);
  this.b += 1;
  return this;
};
function dd(a, b2) {
  V(a);
  b2 = W(a, b2);
  S(a.a.b, b2) && (a.c = null, a.b -= a.a.get(b2).length, a = a.a, S(a.b, b2) && (delete a.b[b2], a.c--, a.a.length > 2 * a.c && Mc(a)));
}
function ed(a, b2) {
  V(a);
  b2 = W(a, b2);
  return S(a.a.b, b2);
}
g.forEach = function(a, b2) {
  V(this);
  this.a.forEach(function(c, d) {
    oa(c, function(e) {
      a.call(b2, e, d, this);
    }, this);
  }, this);
};
g.L = function() {
  V(this);
  for (var a = this.a.K(), b2 = this.a.L(), c = [], d = 0; d < b2.length; d++)
    for (var e = a[d], f = 0; f < e.length; f++)
      c.push(b2[d]);
  return c;
};
g.K = function(a) {
  V(this);
  var b2 = [];
  if ("string" === typeof a)
    ed(this, a) && (b2 = ra(b2, this.a.get(W(this, a))));
  else {
    a = this.a.K();
    for (var c = 0; c < a.length; c++)
      b2 = ra(b2, a[c]);
  }
  return b2;
};
g.set = function(a, b2) {
  V(this);
  this.c = null;
  a = W(this, a);
  ed(this, a) && (this.b -= this.a.get(a).length);
  this.a.set(a, [b2]);
  this.b += 1;
  return this;
};
g.get = function(a, b2) {
  if (!a)
    return b2;
  a = this.K(a);
  return 0 < a.length ? String(a[0]) : b2;
};
function nc(a, b2, c) {
  dd(a, b2);
  0 < c.length && (a.c = null, a.a.set(W(a, b2), sa(c)), a.b += c.length);
}
g.toString = function() {
  if (this.c)
    return this.c;
  if (!this.a)
    return "";
  for (var a = [], b2 = this.a.L(), c = 0; c < b2.length; c++) {
    var d = b2[c], e = encodeURIComponent(String(d));
    d = this.K(d);
    for (var f = 0; f < d.length; f++) {
      var h = e;
      "" !== d[f] && (h += "=" + encodeURIComponent(String(d[f])));
      a.push(h);
    }
  }
  return this.c = a.join("&");
};
function W(a, b2) {
  b2 = String(b2);
  a.f && (b2 = b2.toLowerCase());
  return b2;
}
function Zc(a, b2) {
  b2 && !a.f && (V(a), a.c = null, a.a.forEach(function(c, d) {
    var e = d.toLowerCase();
    d != e && (dd(this, d), nc(this, e, c));
  }, a));
  a.f = b2;
}
function fd(a, b2) {
  this.b = a;
  this.a = b2;
}
function gd(a) {
  this.g = a || hd;
  k.PerformanceNavigationTiming ? (a = k.performance.getEntriesByType("navigation"), a = 0 < a.length && ("hq" == a[0].nextHopProtocol || "h2" == a[0].nextHopProtocol)) : a = !!(k.ia && k.ia.ya && k.ia.ya() && k.ia.ya().qb);
  this.f = a ? this.g : 1;
  this.a = null;
  1 < this.f && (this.a = /* @__PURE__ */ new Set());
  this.b = null;
  this.c = [];
}
var hd = 10;
function id(a) {
  return a.b ? true : a.a ? a.a.size >= a.f : false;
}
function Dc(a) {
  return a.b ? 1 : a.a ? a.a.size : 0;
}
function zc(a, b2) {
  return a.b ? a.b == b2 : a.a ? a.a.has(b2) : false;
}
function Ec(a, b2) {
  a.a ? a.a.add(b2) : a.b = b2;
}
function Gc(a, b2) {
  a.b && a.b == b2 ? a.b = null : a.a && a.a.has(b2) && a.a.delete(b2);
}
gd.prototype.cancel = function() {
  var e_1, _a3;
  this.c = jd(this);
  if (this.b)
    this.b.cancel(), this.b = null;
  else if (this.a && 0 !== this.a.size) {
    try {
      for (var _b = __values2(this.a.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
        var a = _c.value;
        a.cancel();
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a3 = _b.return))
          _a3.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    this.a.clear();
  }
};
function jd(a) {
  var e_2, _a3;
  if (null != a.b)
    return a.c.concat(a.b.s);
  if (null != a.a && 0 !== a.a.size) {
    var b2 = a.c;
    try {
      for (var _b = __values2(a.a.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
        var c = _c.value;
        b2 = b2.concat(c.s);
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a3 = _b.return))
          _a3.call(_b);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    return b2;
  }
  return sa(a.c);
}
function kd() {
}
kd.prototype.stringify = function(a) {
  return k.JSON.stringify(a, void 0);
};
kd.prototype.parse = function(a) {
  return k.JSON.parse(a, void 0);
};
function ld() {
  this.a = new kd();
}
function md(a, b2, c) {
  var d = c || "";
  try {
    Lc(a, function(e, f) {
      var h = e;
      n(e) && (h = vb(e));
      b2.push(d + f + "=" + encodeURIComponent(h));
    });
  } catch (e) {
    throw b2.push(d + "type=" + encodeURIComponent("_badmap")), e;
  }
}
function nd(a, b2) {
  var c = new Pb();
  if (k.Image) {
    var d = new Image();
    d.onload = ka(od, c, d, "TestLoadImage: loaded", true, b2);
    d.onerror = ka(od, c, d, "TestLoadImage: error", false, b2);
    d.onabort = ka(od, c, d, "TestLoadImage: abort", false, b2);
    d.ontimeout = ka(od, c, d, "TestLoadImage: timeout", false, b2);
    k.setTimeout(function() {
      if (d.ontimeout)
        d.ontimeout();
    }, 1e4);
    d.src = a;
  } else
    b2(false);
}
function od(a, b2, c, d, e) {
  try {
    b2.onload = null, b2.onerror = null, b2.onabort = null, b2.ontimeout = null, e(d);
  } catch (f) {
  }
}
var pd = k.JSON.parse;
function X(a) {
  D.call(this);
  this.headers = new R();
  this.H = a || null;
  this.b = false;
  this.s = this.a = null;
  this.B = "";
  this.h = 0;
  this.f = "";
  this.g = this.A = this.l = this.u = false;
  this.o = 0;
  this.m = null;
  this.I = qd;
  this.D = this.F = false;
}
r(X, D);
var qd = "";
var rd = /^https?$/i;
var sd = ["POST", "PUT"];
g = X.prototype;
g.ba = function(a, b2, c, d) {
  if (this.a)
    throw Error("[goog.net.XhrIo] Object is active with another request=" + this.B + "; newUri=" + a);
  b2 = b2 ? b2.toUpperCase() : "GET";
  this.B = a;
  this.f = "";
  this.h = 0;
  this.u = false;
  this.b = true;
  this.a = new XMLHttpRequest();
  this.s = this.H ? bc(this.H) : bc(fc);
  this.a.onreadystatechange = p(this.za, this);
  try {
    this.A = true, this.a.open(b2, String(a), true), this.A = false;
  } catch (f) {
    td(this, f);
    return;
  }
  a = c || "";
  var e = new R(this.headers);
  d && Lc(d, function(f, h) {
    e.set(h, f);
  });
  d = pa(e.L());
  c = k.FormData && a instanceof k.FormData;
  !(0 <= na(sd, b2)) || d || c || e.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
  e.forEach(function(f, h) {
    this.a.setRequestHeader(h, f);
  }, this);
  this.I && (this.a.responseType = this.I);
  "withCredentials" in this.a && this.a.withCredentials !== this.F && (this.a.withCredentials = this.F);
  try {
    ud(this), 0 < this.o && ((this.D = vd(this.a)) ? (this.a.timeout = this.o, this.a.ontimeout = p(this.xa, this)) : this.m = Jb(this.xa, this.o, this)), this.l = true, this.a.send(a), this.l = false;
  } catch (f) {
    td(this, f);
  }
};
function vd(a) {
  return x && Ra(9) && "number" === typeof a.timeout && void 0 !== a.ontimeout;
}
function qa(a) {
  return "content-type" == a.toLowerCase();
}
g.xa = function() {
  "undefined" != typeof goog && this.a && (this.f = "Timed out after " + this.o + "ms, aborting", this.h = 8, this.dispatchEvent("timeout"), this.abort(8));
};
function td(a, b2) {
  a.b = false;
  a.a && (a.g = true, a.a.abort(), a.g = false);
  a.f = b2;
  a.h = 5;
  wd(a);
  xd(a);
}
function wd(a) {
  a.u || (a.u = true, a.dispatchEvent("complete"), a.dispatchEvent("error"));
}
g.abort = function(a) {
  this.a && this.b && (this.b = false, this.g = true, this.a.abort(), this.g = false, this.h = a || 7, this.dispatchEvent("complete"), this.dispatchEvent("abort"), xd(this));
};
g.G = function() {
  this.a && (this.b && (this.b = false, this.g = true, this.a.abort(), this.g = false), xd(this, true));
  X.S.G.call(this);
};
g.za = function() {
  this.j || (this.A || this.l || this.g ? yd(this) : this.Ta());
};
g.Ta = function() {
  yd(this);
};
function yd(a) {
  if (a.b && "undefined" != typeof goog && (!a.s[1] || 4 != N(a) || 2 != a.X())) {
    if (a.l && 4 == N(a))
      Jb(a.za, 0, a);
    else if (a.dispatchEvent("readystatechange"), 4 == N(a)) {
      a.b = false;
      try {
        var b2 = a.X();
        a:
          switch (b2) {
            case 200:
            case 201:
            case 202:
            case 204:
            case 206:
            case 304:
            case 1223:
              var c = true;
              break a;
            default:
              c = false;
          }
        var d;
        if (!(d = c)) {
          var e;
          if (e = 0 === b2) {
            var f = String(a.B).match(Nc)[1] || null;
            if (!f && k.self && k.self.location) {
              var h = k.self.location.protocol;
              f = h.substr(0, h.length - 1);
            }
            e = !rd.test(f ? f.toLowerCase() : "");
          }
          d = e;
        }
        if (d)
          a.dispatchEvent("complete"), a.dispatchEvent("success");
        else {
          a.h = 6;
          try {
            var m = 2 < N(a) ? a.a.statusText : "";
          } catch (l) {
            m = "";
          }
          a.f = m + " [" + a.X() + "]";
          wd(a);
        }
      } finally {
        xd(a);
      }
    }
  }
}
function xd(a, b2) {
  if (a.a) {
    ud(a);
    var c = a.a, d = a.s[0] ? aa : null;
    a.a = null;
    a.s = null;
    b2 || a.dispatchEvent("ready");
    try {
      c.onreadystatechange = d;
    } catch (e) {
    }
  }
}
function ud(a) {
  a.a && a.D && (a.a.ontimeout = null);
  a.m && (k.clearTimeout(a.m), a.m = null);
}
function N(a) {
  return a.a ? a.a.readyState : 0;
}
g.X = function() {
  try {
    return 2 < N(this) ? this.a.status : -1;
  } catch (a) {
    return -1;
  }
};
g.$ = function() {
  try {
    return this.a ? this.a.responseText : "";
  } catch (a) {
    return "";
  }
};
g.Na = function(a) {
  if (this.a) {
    var b2 = this.a.responseText;
    a && 0 == b2.indexOf(a) && (b2 = b2.substring(a.length));
    return pd(b2);
  }
};
g.ua = function() {
  return this.h;
};
g.Qa = function() {
  return "string" === typeof this.f ? this.f : String(this.f);
};
function zd(a) {
  var b2 = "";
  Aa(a, function(c, d) {
    b2 += d;
    b2 += ":";
    b2 += c;
    b2 += "\r\n";
  });
  return b2;
}
function Ad(a, b2, c) {
  a: {
    for (d in c) {
      var d = false;
      break a;
    }
    d = true;
  }
  d || (c = zd(c), "string" === typeof a ? null != c && encodeURIComponent(String(c)) : Q(a, b2, c));
}
function Bd(a, b2, c) {
  return c && c.internalChannelParams ? c.internalChannelParams[a] || b2 : b2;
}
function Cd(a) {
  this.pa = 0;
  this.g = [];
  this.c = new Pb();
  this.ga = this.la = this.B = this.fa = this.a = this.na = this.A = this.W = this.i = this.O = this.l = null;
  this.La = this.R = 0;
  this.Ia = Bd("failFast", false, a);
  this.H = this.m = this.j = this.h = this.f = null;
  this.T = true;
  this.I = this.oa = this.P = -1;
  this.U = this.o = this.u = 0;
  this.Fa = Bd("baseRetryDelayMs", 5e3, a);
  this.Ma = Bd("retryDelaySeedMs", 1e4, a);
  this.Ja = Bd("forwardChannelMaxRetries", 2, a);
  this.ma = Bd("forwardChannelRequestTimeoutMs", 2e4, a);
  this.Ka = a && a.g || void 0;
  this.D = void 0;
  this.C = a && a.supportsCrossDomainXhr || false;
  this.J = "";
  this.b = new gd(a && a.concurrentRequestLimit);
  this.ka = new ld();
  this.da = a && a.fastHandshake || false;
  this.Ga = a && a.b || false;
  a && a.f && (this.c.a = false);
  a && a.forceLongPolling && (this.T = false);
  this.V = !this.da && this.T && a && a.c || false;
  this.ea = void 0;
  this.N = 0;
  this.F = false;
  this.s = null;
}
g = Cd.prototype;
g.ha = 8;
g.v = 1;
function Jc(a) {
  Dd(a);
  if (3 == a.v) {
    var b2 = a.R++, c = L(a.B);
    Q(c, "SID", a.J);
    Q(c, "RID", b2);
    Q(c, "TYPE", "terminate");
    Ed(a, c);
    b2 = new K(a, a.c, b2, void 0);
    b2.H = 2;
    b2.i = lc(L(c));
    c = false;
    k.navigator && k.navigator.sendBeacon && (c = k.navigator.sendBeacon(b2.i.toString(), ""));
    !c && k.Image && (new Image().src = b2.i, c = true);
    c || (b2.a = oc(b2.g, null), b2.a.ba(b2.i));
    b2.u = q();
    M(b2);
  }
  Fd(a);
}
function Bc(a) {
  a.a && (xc(a), a.a.cancel(), a.a = null);
}
function Dd(a) {
  Bc(a);
  a.j && (k.clearTimeout(a.j), a.j = null);
  Ac(a);
  a.b.cancel();
  a.h && ("number" === typeof a.h && k.clearTimeout(a.h), a.h = null);
}
function Gd(a, b2) {
  a.g.push(new fd(a.La++, b2));
  3 == a.v && Ic(a);
}
function Ic(a) {
  id(a.b) || a.h || (a.h = true, Cb(a.Ba, a), a.u = 0);
}
function Hd(a, b2) {
  if (Dc(a.b) >= a.b.f - (a.h ? 1 : 0))
    return false;
  if (a.h)
    return a.g = b2.s.concat(a.g), true;
  if (1 == a.v || 2 == a.v || a.u >= (a.Ia ? 0 : a.Ja))
    return false;
  a.h = I(p(a.Ba, a, b2), Id(a, a.u));
  a.u++;
  return true;
}
g.Ba = function(a) {
  if (this.h)
    if (this.h = null, 1 == this.v) {
      if (!a) {
        this.R = Math.floor(1e5 * Math.random());
        a = this.R++;
        var b2 = new K(this, this.c, a, void 0), c = this.l;
        this.O && (c ? (c = Ba(c), Da(c, this.O)) : c = this.O);
        null === this.i && (b2.B = c);
        var d;
        if (this.da)
          a: {
            for (var e = d = 0; e < this.g.length; e++) {
              b: {
                var f = this.g[e];
                if ("__data__" in f.a && (f = f.a.__data__, "string" === typeof f)) {
                  f = f.length;
                  break b;
                }
                f = void 0;
              }
              if (void 0 === f)
                break;
              d += f;
              if (4096 < d) {
                d = e;
                break a;
              }
              if (4096 === d || e === this.g.length - 1) {
                d = e + 1;
                break a;
              }
            }
            d = 1e3;
          }
        else
          d = 1e3;
        d = Jd(this, b2, d);
        e = L(this.B);
        Q(e, "RID", a);
        Q(e, "CVER", 22);
        this.A && Q(e, "X-HTTP-Session-Id", this.A);
        Ed(this, e);
        this.i && c && Ad(e, this.i, c);
        Ec(this.b, b2);
        this.Ga && Q(e, "TYPE", "init");
        this.da ? (Q(e, "$req", d), Q(e, "SID", "null"), b2.V = true, kc(b2, e, null)) : kc(b2, e, d);
        this.v = 2;
      }
    } else
      3 == this.v && (a ? Kd(this, a) : 0 == this.g.length || id(this.b) || Kd(this));
};
function Kd(a, b2) {
  var c;
  b2 ? c = b2.f : c = a.R++;
  var d = L(a.B);
  Q(d, "SID", a.J);
  Q(d, "RID", c);
  Q(d, "AID", a.P);
  Ed(a, d);
  a.i && a.l && Ad(d, a.i, a.l);
  c = new K(a, a.c, c, a.u + 1);
  null === a.i && (c.B = a.l);
  b2 && (a.g = b2.s.concat(a.g));
  b2 = Jd(a, c, 1e3);
  c.setTimeout(Math.round(0.5 * a.ma) + Math.round(0.5 * a.ma * Math.random()));
  Ec(a.b, c);
  kc(c, d, b2);
}
function Ed(a, b2) {
  a.f && Lc({}, function(c, d) {
    Q(b2, d, c);
  });
}
function Jd(a, b2, c) {
  c = Math.min(a.g.length, c);
  var d = a.f ? p(a.f.Ha, a.f, a) : null;
  a:
    for (var e = a.g, f = -1; ; ) {
      var h = ["count=" + c];
      -1 == f ? 0 < c ? (f = e[0].b, h.push("ofs=" + f)) : f = 0 : h.push("ofs=" + f);
      for (var m = true, l = 0; l < c; l++) {
        var t = e[l].b, B2 = e[l].a;
        t -= f;
        if (0 > t)
          f = Math.max(0, e[l].b - 100), m = false;
        else
          try {
            md(B2, h, "req" + t + "_");
          } catch (z2) {
            d && d(B2);
          }
      }
      if (m) {
        d = h.join("&");
        break a;
      }
    }
  a = a.g.splice(0, c);
  b2.s = a;
  return d;
}
function Hc(a) {
  a.a || a.j || (a.U = 1, Cb(a.Aa, a), a.o = 0);
}
function Cc(a) {
  if (a.a || a.j || 3 <= a.o)
    return false;
  a.U++;
  a.j = I(p(a.Aa, a), Id(a, a.o));
  a.o++;
  return true;
}
g.Aa = function() {
  this.j = null;
  Ld(this);
  if (this.V && !(this.F || null == this.a || 0 >= this.N)) {
    var a = 2 * this.N;
    this.c.info("BP detection timer enabled: " + a);
    this.s = I(p(this.Sa, this), a);
  }
};
g.Sa = function() {
  this.s && (this.s = null, this.c.info("BP detection timeout reached."), this.c.info("Buffering proxy detected and switch to long-polling!"), this.H = false, this.F = true, Bc(this), Ld(this));
};
function xc(a) {
  null != a.s && (k.clearTimeout(a.s), a.s = null);
}
function Ld(a) {
  a.a = new K(a, a.c, "rpc", a.U);
  null === a.i && (a.a.B = a.l);
  a.a.O = 0;
  var b2 = L(a.la);
  Q(b2, "RID", "rpc");
  Q(b2, "SID", a.J);
  Q(b2, "CI", a.H ? "0" : "1");
  Q(b2, "AID", a.P);
  Ed(a, b2);
  Q(b2, "TYPE", "xmlhttp");
  a.i && a.l && Ad(b2, a.i, a.l);
  a.D && a.a.setTimeout(a.D);
  var c = a.a;
  a = a.ga;
  c.H = 1;
  c.i = lc(L(b2));
  c.j = null;
  c.I = true;
  mc(c, a);
}
g.Ra = function() {
  null != this.m && (this.m = null, Bc(this), Cc(this), H(19));
};
function Ac(a) {
  null != a.m && (k.clearTimeout(a.m), a.m = null);
}
function uc(a, b2) {
  var c = null;
  if (a.a == b2) {
    Ac(a);
    xc(a);
    a.a = null;
    var d = 2;
  } else if (zc(a.b, b2))
    c = b2.s, Gc(a.b, b2), d = 1;
  else
    return;
  a.I = b2.N;
  if (0 != a.v) {
    if (b2.b)
      if (1 == d) {
        c = b2.j ? b2.j.length : 0;
        b2 = q() - b2.u;
        var e = a.u;
        d = Vb();
        d.dispatchEvent(new Yb(d, c, b2, e));
        Ic(a);
      } else
        Hc(a);
    else if (e = b2.h, 3 == e || 0 == e && 0 < a.I || !(1 == d && Hd(a, b2) || 2 == d && Cc(a)))
      switch (c && 0 < c.length && (b2 = a.b, b2.c = b2.c.concat(c)), e) {
        case 1:
          P(a, 5);
          break;
        case 4:
          P(a, 10);
          break;
        case 3:
          P(a, 6);
          break;
        default:
          P(a, 2);
      }
  }
}
function Id(a, b2) {
  var c = a.Fa + Math.floor(Math.random() * a.Ma);
  a.f || (c *= 2);
  return c * b2;
}
function P(a, b2) {
  a.c.info("Error code " + b2);
  if (2 == b2) {
    var c = null;
    a.f && (c = null);
    var d = p(a.Xa, a);
    c || (c = new T("//www.google.com/images/cleardot.gif"), k.location && "http" == k.location.protocol || Pc(c, "https"), lc(c));
    nd(c.toString(), d);
  } else
    H(2);
  a.v = 0;
  a.f && a.f.ra(b2);
  Fd(a);
  Dd(a);
}
g.Xa = function(a) {
  a ? (this.c.info("Successfully pinged google.com"), H(2)) : (this.c.info("Failed to ping google.com"), H(1));
};
function Fd(a) {
  a.v = 0;
  a.I = -1;
  if (a.f) {
    if (0 != jd(a.b).length || 0 != a.g.length)
      a.b.c.length = 0, sa(a.g), a.g.length = 0;
    a.f.qa();
  }
}
function Fc(a, b2, c) {
  var d = ad(c);
  if ("" != d.c)
    b2 && Qc(d, b2 + "." + d.c), Rc(d, d.h);
  else {
    var e = k.location;
    d = bd(e.protocol, b2 ? b2 + "." + e.hostname : e.hostname, +e.port, c);
  }
  a.W && Aa(a.W, function(f, h) {
    Q(d, h, f);
  });
  b2 = a.A;
  c = a.na;
  b2 && c && Q(d, b2, c);
  Q(d, "VER", a.ha);
  Ed(a, d);
  return d;
}
function oc(a, b2) {
  if (b2 && !a.C)
    throw Error("Can't create secondary domain capable XhrIo object.");
  b2 = new X(a.Ka);
  b2.F = a.C;
  return b2;
}
function Md() {
}
g = Md.prototype;
g.ta = function() {
};
g.sa = function() {
};
g.ra = function() {
};
g.qa = function() {
};
g.Ha = function() {
};
function Nd() {
  if (x && !(10 <= Number(Ua)))
    throw Error("Environmental error: no available transport.");
}
Nd.prototype.a = function(a, b2) {
  return new Y(a, b2);
};
function Y(a, b2) {
  D.call(this);
  this.a = new Cd(b2);
  this.l = a;
  this.b = b2 && b2.messageUrlParams || null;
  a = b2 && b2.messageHeaders || null;
  b2 && b2.clientProtocolHeaderRequired && (a ? a["X-Client-Protocol"] = "webchannel" : a = { "X-Client-Protocol": "webchannel" });
  this.a.l = a;
  a = b2 && b2.initMessageHeaders || null;
  b2 && b2.messageContentType && (a ? a["X-WebChannel-Content-Type"] = b2.messageContentType : a = { "X-WebChannel-Content-Type": b2.messageContentType });
  b2 && b2.a && (a ? a["X-WebChannel-Client-Profile"] = b2.a : a = { "X-WebChannel-Client-Profile": b2.a });
  this.a.O = a;
  (a = b2 && b2.httpHeadersOverwriteParam) && !ta(a) && (this.a.i = a);
  this.h = b2 && b2.supportsCrossDomainXhr || false;
  this.g = b2 && b2.sendRawJson || false;
  (b2 = b2 && b2.httpSessionIdParam) && !ta(b2) && (this.a.A = b2, a = this.b, null !== a && b2 in a && (a = this.b, b2 in a && delete a[b2]));
  this.f = new Z(this);
}
r(Y, D);
g = Y.prototype;
g.addEventListener = function(a, b2, c, d) {
  Y.S.addEventListener.call(this, a, b2, c, d);
};
g.removeEventListener = function(a, b2, c, d) {
  Y.S.removeEventListener.call(this, a, b2, c, d);
};
g.Oa = function() {
  this.a.f = this.f;
  this.h && (this.a.C = true);
  var a = this.a, b2 = this.l, c = this.b || void 0;
  H(0);
  a.fa = b2;
  a.W = c || {};
  a.H = a.T;
  a.B = Fc(a, null, a.fa);
  Ic(a);
};
g.close = function() {
  Jc(this.a);
};
g.Pa = function(a) {
  if ("string" === typeof a) {
    var b2 = {};
    b2.__data__ = a;
    Gd(this.a, b2);
  } else
    this.g ? (b2 = {}, b2.__data__ = vb(a), Gd(this.a, b2)) : Gd(this.a, a);
};
g.G = function() {
  this.a.f = null;
  delete this.f;
  Jc(this.a);
  delete this.a;
  Y.S.G.call(this);
};
function Od(a) {
  dc.call(this);
  var b2 = a.__sm__;
  if (b2) {
    a: {
      for (var c in b2) {
        a = c;
        break a;
      }
      a = void 0;
    }
    (this.c = a) ? (a = this.c, this.data = null !== b2 && a in b2 ? b2[a] : void 0) : this.data = b2;
  } else
    this.data = a;
}
r(Od, dc);
function Pd() {
  ec.call(this);
  this.status = 1;
}
r(Pd, ec);
function Z(a) {
  this.a = a;
}
r(Z, Md);
Z.prototype.ta = function() {
  this.a.dispatchEvent("a");
};
Z.prototype.sa = function(a) {
  this.a.dispatchEvent(new Od(a));
};
Z.prototype.ra = function(a) {
  this.a.dispatchEvent(new Pd(a));
};
Z.prototype.qa = function() {
  this.a.dispatchEvent("b");
};
Nd.prototype.createWebChannel = Nd.prototype.a;
Y.prototype.send = Y.prototype.Pa;
Y.prototype.open = Y.prototype.Oa;
Y.prototype.close = Y.prototype.close;
Zb.NO_ERROR = 0;
Zb.TIMEOUT = 8;
Zb.HTTP_ERROR = 6;
$b.COMPLETE = "complete";
cc.EventType = J;
J.OPEN = "a";
J.CLOSE = "b";
J.ERROR = "c";
J.MESSAGE = "d";
D.prototype.listen = D.prototype.va;
X.prototype.listenOnce = X.prototype.wa;
X.prototype.getLastError = X.prototype.Qa;
X.prototype.getLastErrorCode = X.prototype.ua;
X.prototype.getStatus = X.prototype.X;
X.prototype.getResponseJson = X.prototype.Na;
X.prototype.getResponseText = X.prototype.$;
X.prototype.send = X.prototype.ba;
var createWebChannelTransport = function() {
  return new Nd();
};
var ErrorCode = Zb;
var EventType = $b;
var WebChannel = cc;
var XhrIo = X;

// node_modules/ng-fire-admin/node_modules/@firebase/component/dist/index.esm.js
init_tslib_es6();
var Component2 = (
  /** @class */
  function() {
    function Component3(name4, instanceFactory, type) {
      this.name = name4;
      this.instanceFactory = instanceFactory;
      this.type = type;
      this.multipleInstances = false;
      this.serviceProps = {};
      this.instantiationMode = "LAZY";
    }
    Component3.prototype.setInstantiationMode = function(mode) {
      this.instantiationMode = mode;
      return this;
    };
    Component3.prototype.setMultipleInstances = function(multipleInstances) {
      this.multipleInstances = multipleInstances;
      return this;
    };
    Component3.prototype.setServiceProps = function(props) {
      this.serviceProps = props;
      return this;
    };
    return Component3;
  }()
);
var DEFAULT_ENTRY_NAME = "[DEFAULT]";
var Provider = (
  /** @class */
  function() {
    function Provider2(name4, container) {
      this.name = name4;
      this.container = container;
      this.component = null;
      this.instances = /* @__PURE__ */ new Map();
      this.instancesDeferred = /* @__PURE__ */ new Map();
    }
    Provider2.prototype.get = function(identifier) {
      if (identifier === void 0) {
        identifier = DEFAULT_ENTRY_NAME;
      }
      var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
      if (!this.instancesDeferred.has(normalizedIdentifier)) {
        var deferred = new Deferred();
        this.instancesDeferred.set(normalizedIdentifier, deferred);
        try {
          var instance = this.getOrInitializeService(normalizedIdentifier);
          if (instance) {
            deferred.resolve(instance);
          }
        } catch (e) {
        }
      }
      return this.instancesDeferred.get(normalizedIdentifier).promise;
    };
    Provider2.prototype.getImmediate = function(options) {
      var _a3 = __assign({ identifier: DEFAULT_ENTRY_NAME, optional: false }, options), identifier = _a3.identifier, optional = _a3.optional;
      var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
      try {
        var instance = this.getOrInitializeService(normalizedIdentifier);
        if (!instance) {
          if (optional) {
            return null;
          }
          throw Error("Service " + this.name + " is not available");
        }
        return instance;
      } catch (e) {
        if (optional) {
          return null;
        } else {
          throw e;
        }
      }
    };
    Provider2.prototype.getComponent = function() {
      return this.component;
    };
    Provider2.prototype.setComponent = function(component) {
      var e_1, _a3;
      if (component.name !== this.name) {
        throw Error("Mismatching Component " + component.name + " for Provider " + this.name + ".");
      }
      if (this.component) {
        throw Error("Component for " + this.name + " has already been provided");
      }
      this.component = component;
      if (isComponentEager(component)) {
        try {
          this.getOrInitializeService(DEFAULT_ENTRY_NAME);
        } catch (e) {
        }
      }
      try {
        for (var _b = __values(this.instancesDeferred.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
          var _d = __read(_c.value, 2), instanceIdentifier = _d[0], instanceDeferred = _d[1];
          var normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
          try {
            var instance = this.getOrInitializeService(normalizedIdentifier);
            instanceDeferred.resolve(instance);
          } catch (e) {
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a3 = _b.return))
            _a3.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    };
    Provider2.prototype.clearInstance = function(identifier) {
      if (identifier === void 0) {
        identifier = DEFAULT_ENTRY_NAME;
      }
      this.instancesDeferred.delete(identifier);
      this.instances.delete(identifier);
    };
    Provider2.prototype.delete = function() {
      return __awaiter(this, void 0, void 0, function() {
        var services;
        return __generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              services = Array.from(this.instances.values());
              return [4, Promise.all(__spread(services.filter(function(service) {
                return "INTERNAL" in service;
              }).map(function(service) {
                return service.INTERNAL.delete();
              }), services.filter(function(service) {
                return "_delete" in service;
              }).map(function(service) {
                return service._delete();
              })))];
            case 1:
              _a3.sent();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Provider2.prototype.isComponentSet = function() {
      return this.component != null;
    };
    Provider2.prototype.getOrInitializeService = function(identifier) {
      var instance = this.instances.get(identifier);
      if (!instance && this.component) {
        instance = this.component.instanceFactory(this.container, normalizeIdentifierForFactory(identifier));
        this.instances.set(identifier, instance);
      }
      return instance || null;
    };
    Provider2.prototype.normalizeInstanceIdentifier = function(identifier) {
      if (this.component) {
        return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;
      } else {
        return identifier;
      }
    };
    return Provider2;
  }()
);
function normalizeIdentifierForFactory(identifier) {
  return identifier === DEFAULT_ENTRY_NAME ? void 0 : identifier;
}
function isComponentEager(component) {
  return component.instantiationMode === "EAGER";
}
var ComponentContainer = (
  /** @class */
  function() {
    function ComponentContainer2(name4) {
      this.name = name4;
      this.providers = /* @__PURE__ */ new Map();
    }
    ComponentContainer2.prototype.addComponent = function(component) {
      var provider = this.getProvider(component.name);
      if (provider.isComponentSet()) {
        throw new Error("Component " + component.name + " has already been registered with " + this.name);
      }
      provider.setComponent(component);
    };
    ComponentContainer2.prototype.addOrOverwriteComponent = function(component) {
      var provider = this.getProvider(component.name);
      if (provider.isComponentSet()) {
        this.providers.delete(component.name);
      }
      this.addComponent(component);
    };
    ComponentContainer2.prototype.getProvider = function(name4) {
      if (this.providers.has(name4)) {
        return this.providers.get(name4);
      }
      var provider = new Provider(name4, this);
      this.providers.set(name4, provider);
      return provider;
    };
    ComponentContainer2.prototype.getProviders = function() {
      return Array.from(this.providers.values());
    };
    return ComponentContainer2;
  }()
);

// node_modules/ng-fire-admin/node_modules/@firebase/firestore/dist/index.esm.js
var b = {
  // Causes are copied from:
  // https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h
  /** Not an error; returned on success. */
  OK: "ok",
  /** The operation was cancelled (typically by the caller). */
  CANCELLED: "cancelled",
  /** Unknown error or an error from a different error domain. */
  UNKNOWN: "unknown",
  /**
   * Client specified an invalid argument. Note that this differs from
   * FAILED_PRECONDITION. INVALID_ARGUMENT indicates arguments that are
   * problematic regardless of the state of the system (e.g., a malformed file
   * name).
   */
  INVALID_ARGUMENT: "invalid-argument",
  /**
   * Deadline expired before operation could complete. For operations that
   * change the state of the system, this error may be returned even if the
   * operation has completed successfully. For example, a successful response
   * from a server could have been delayed long enough for the deadline to
   * expire.
   */
  DEADLINE_EXCEEDED: "deadline-exceeded",
  /** Some requested entity (e.g., file or directory) was not found. */
  NOT_FOUND: "not-found",
  /**
   * Some entity that we attempted to create (e.g., file or directory) already
   * exists.
   */
  ALREADY_EXISTS: "already-exists",
  /**
   * The caller does not have permission to execute the specified operation.
   * PERMISSION_DENIED must not be used for rejections caused by exhausting
   * some resource (use RESOURCE_EXHAUSTED instead for those errors).
   * PERMISSION_DENIED must not be used if the caller can not be identified
   * (use UNAUTHENTICATED instead for those errors).
   */
  PERMISSION_DENIED: "permission-denied",
  /**
   * The request does not have valid authentication credentials for the
   * operation.
   */
  UNAUTHENTICATED: "unauthenticated",
  /**
   * Some resource has been exhausted, perhaps a per-user quota, or perhaps the
   * entire file system is out of space.
   */
  RESOURCE_EXHAUSTED: "resource-exhausted",
  /**
   * Operation was rejected because the system is not in a state required for
   * the operation's execution. For example, directory to be deleted may be
   * non-empty, an rmdir operation is applied to a non-directory, etc.
   *
   * A litmus test that may help a service implementor in deciding
   * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:
   *  (a) Use UNAVAILABLE if the client can retry just the failing call.
   *  (b) Use ABORTED if the client should retry at a higher-level
   *      (e.g., restarting a read-modify-write sequence).
   *  (c) Use FAILED_PRECONDITION if the client should not retry until
   *      the system state has been explicitly fixed. E.g., if an "rmdir"
   *      fails because the directory is non-empty, FAILED_PRECONDITION
   *      should be returned since the client should not retry unless
   *      they have first fixed up the directory by deleting files from it.
   *  (d) Use FAILED_PRECONDITION if the client performs conditional
   *      REST Get/Update/Delete on a resource and the resource on the
   *      server does not match the condition. E.g., conflicting
   *      read-modify-write on the same resource.
   */
  FAILED_PRECONDITION: "failed-precondition",
  /**
   * The operation was aborted, typically due to a concurrency issue like
   * sequencer check failures, transaction aborts, etc.
   *
   * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,
   * and UNAVAILABLE.
   */
  ABORTED: "aborted",
  /**
   * Operation was attempted past the valid range. E.g., seeking or reading
   * past end of file.
   *
   * Unlike INVALID_ARGUMENT, this error indicates a problem that may be fixed
   * if the system state changes. For example, a 32-bit file system will
   * generate INVALID_ARGUMENT if asked to read at an offset that is not in the
   * range [0,2^32-1], but it will generate OUT_OF_RANGE if asked to read from
   * an offset past the current file size.
   *
   * There is a fair bit of overlap between FAILED_PRECONDITION and
   * OUT_OF_RANGE. We recommend using OUT_OF_RANGE (the more specific error)
   * when it applies so that callers who are iterating through a space can
   * easily look for an OUT_OF_RANGE error to detect when they are done.
   */
  OUT_OF_RANGE: "out-of-range",
  /** Operation is not implemented or not supported/enabled in this service. */
  UNIMPLEMENTED: "unimplemented",
  /**
   * Internal errors. Means some invariants expected by underlying System has
   * been broken. If you see one of these errors, Something is very broken.
   */
  INTERNAL: "internal",
  /**
   * The service is currently unavailable. This is a most likely a transient
   * condition and may be corrected by retrying with a backoff.
   *
   * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,
   * and UNAVAILABLE.
   */
  UNAVAILABLE: "unavailable",
  /** Unrecoverable data loss or corruption. */
  DATA_LOSS: "data-loss"
};
var I2 = (
  /** @class */
  function(e) {
    function n2(t, n3) {
      var r2 = this;
      return (r2 = e.call(this, n3) || this).code = t, r2.message = n3, r2.name = "FirebaseError", // HACK: We write a toString property directly because Error is not a real
      // class and so inheritance does not work correctly. We could alternatively
      // do the same "back-door inheritance" trick that FirebaseError does.
      r2.toString = function() {
        return r2.name + ": [code=" + r2.code + "]: " + r2.message;
      }, r2;
    }
    return __extends(n2, e), n2;
  }(Error)
);
var E2 = new Logger("@firebase/firestore");
function _() {
  return E2.logLevel;
}
function T2(t) {
  for (var e = [], n2 = 1; n2 < arguments.length; n2++)
    e[n2 - 1] = arguments[n2];
  if (E2.logLevel <= LogLevel.DEBUG) {
    var i2 = e.map(S2);
    E2.debug.apply(E2, __spreadArrays(["Firestore (7.24.0): " + t], i2));
  }
}
function N2(t) {
  for (var e = [], n2 = 1; n2 < arguments.length; n2++)
    e[n2 - 1] = arguments[n2];
  if (E2.logLevel <= LogLevel.ERROR) {
    var i2 = e.map(S2);
    E2.error.apply(E2, __spreadArrays(["Firestore (7.24.0): " + t], i2));
  }
}
function A2(t) {
  for (var e = [], n2 = 1; n2 < arguments.length; n2++)
    e[n2 - 1] = arguments[n2];
  if (E2.logLevel <= LogLevel.WARN) {
    var i2 = e.map(S2);
    E2.warn.apply(E2, __spreadArrays(["Firestore (7.24.0): " + t], i2));
  }
}
function S2(t) {
  if ("string" == typeof t)
    return t;
  try {
    return e = t, JSON.stringify(e);
  } catch (e2) {
    return t;
  }
  var e;
}
function D2(t) {
  void 0 === t && (t = "Unexpected state");
  var e = "FIRESTORE (7.24.0) INTERNAL ASSERTION FAILED: " + t;
  throw N2(e), new Error(e);
}
function k2(t, e) {
  t || D2();
}
function x2(t, e) {
  return t;
}
function L2(t) {
  var e = 0;
  for (var n2 in t)
    Object.prototype.hasOwnProperty.call(t, n2) && e++;
  return e;
}
function R2(t, e) {
  for (var n2 in t)
    Object.prototype.hasOwnProperty.call(t, n2) && e(n2, t[n2]);
}
function O2(t) {
  for (var e in t)
    if (Object.prototype.hasOwnProperty.call(t, e))
      return false;
  return true;
}
var P2 = (
  /** @class */
  function() {
    function t(t2, e, n2) {
      void 0 === e ? e = 0 : e > t2.length && D2(), void 0 === n2 ? n2 = t2.length - e : n2 > t2.length - e && D2(), this.segments = t2, this.offset = e, this.t = n2;
    }
    return Object.defineProperty(t.prototype, "length", {
      get: function() {
        return this.t;
      },
      enumerable: false,
      configurable: true
    }), t.prototype.isEqual = function(e) {
      return 0 === t.i(this, e);
    }, t.prototype.child = function(e) {
      var n2 = this.segments.slice(this.offset, this.limit());
      return e instanceof t ? e.forEach(function(t2) {
        n2.push(t2);
      }) : n2.push(e), this.o(n2);
    }, /** The index of one past the last segment of the path. */
    t.prototype.limit = function() {
      return this.offset + this.length;
    }, t.prototype.u = function(t2) {
      return t2 = void 0 === t2 ? 1 : t2, this.o(this.segments, this.offset + t2, this.length - t2);
    }, t.prototype.h = function() {
      return this.o(this.segments, this.offset, this.length - 1);
    }, t.prototype.l = function() {
      return this.segments[this.offset];
    }, t.prototype._ = function() {
      return this.get(this.length - 1);
    }, t.prototype.get = function(t2) {
      return this.segments[this.offset + t2];
    }, t.prototype.m = function() {
      return 0 === this.length;
    }, t.prototype.T = function(t2) {
      if (t2.length < this.length)
        return false;
      for (var e = 0; e < this.length; e++)
        if (this.get(e) !== t2.get(e))
          return false;
      return true;
    }, t.prototype.I = function(t2) {
      if (this.length + 1 !== t2.length)
        return false;
      for (var e = 0; e < this.length; e++)
        if (this.get(e) !== t2.get(e))
          return false;
      return true;
    }, t.prototype.forEach = function(t2) {
      for (var e = this.offset, n2 = this.limit(); e < n2; e++)
        t2(this.segments[e]);
    }, t.prototype.A = function() {
      return this.segments.slice(this.offset, this.limit());
    }, t.i = function(t2, e) {
      for (var n2 = Math.min(t2.length, e.length), r2 = 0; r2 < n2; r2++) {
        var i2 = t2.get(r2), o = e.get(r2);
        if (i2 < o)
          return -1;
        if (i2 > o)
          return 1;
      }
      return t2.length < e.length ? -1 : t2.length > e.length ? 1 : 0;
    }, t;
  }()
);
var V2 = (
  /** @class */
  function(e) {
    function n2() {
      return null !== e && e.apply(this, arguments) || this;
    }
    return __extends(n2, e), n2.prototype.o = function(t, e2, r2) {
      return new n2(t, e2, r2);
    }, n2.prototype.R = function() {
      return this.A().join("/");
    }, n2.prototype.toString = function() {
      return this.R();
    }, /**
     * Creates a resource path from the given slash-delimited string. If multiple
     * arguments are provided, all components are combined. Leading and trailing
     * slashes from all components are ignored.
     */
    n2.g = function() {
      for (var t = [], e2 = 0; e2 < arguments.length; e2++)
        t[e2] = arguments[e2];
      for (var r2 = [], i2 = 0, o = t; i2 < o.length; i2++) {
        var s = o[i2];
        if (s.indexOf("//") >= 0)
          throw new I2(b.INVALID_ARGUMENT, "Invalid segment (" + s + "). Paths must not contain // in them.");
        r2.push.apply(r2, s.split("/").filter(function(t2) {
          return t2.length > 0;
        }));
      }
      return new n2(r2);
    }, n2.P = function() {
      return new n2([]);
    }, n2;
  }(P2)
);
var U2 = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
var C2 = (
  /** @class */
  function(e) {
    function n2() {
      return null !== e && e.apply(this, arguments) || this;
    }
    return __extends(n2, e), n2.prototype.o = function(t, e2, r2) {
      return new n2(t, e2, r2);
    }, /**
     * Returns true if the string could be used as a segment in a field path
     * without escaping.
     */
    n2.V = function(t) {
      return U2.test(t);
    }, n2.prototype.R = function() {
      return this.A().map(function(t) {
        return t = t.replace("\\", "\\\\").replace("`", "\\`"), n2.V(t) || (t = "`" + t + "`"), t;
      }).join(".");
    }, n2.prototype.toString = function() {
      return this.R();
    }, /**
     * Returns true if this field references the key of a document.
     */
    n2.prototype.p = function() {
      return 1 === this.length && "__name__" === this.get(0);
    }, /**
     * The field designating the key of a document.
     */
    n2.v = function() {
      return new n2(["__name__"]);
    }, /**
     * Parses a field string from the given server-formatted string.
     *
     * - Splitting the empty string is not allowed (for now at least).
     * - Empty segments within the string (e.g. if there are two consecutive
     *   separators) are not allowed.
     *
     * TODO(b/37244157): we should make this more strict. Right now, it allows
     * non-identifier path components, even if they aren't escaped.
     */
    n2.S = function(t) {
      for (var e2 = [], r2 = "", i2 = 0, o = function() {
        if (0 === r2.length)
          throw new I2(b.INVALID_ARGUMENT, "Invalid field path (" + t + "). Paths must not be empty, begin with '.', end with '.', or contain '..'");
        e2.push(r2), r2 = "";
      }, s = false; i2 < t.length; ) {
        var u4 = t[i2];
        if ("\\" === u4) {
          if (i2 + 1 === t.length)
            throw new I2(b.INVALID_ARGUMENT, "Path has trailing escape character: " + t);
          var a = t[i2 + 1];
          if ("\\" !== a && "." !== a && "`" !== a)
            throw new I2(b.INVALID_ARGUMENT, "Path has invalid escape sequence: " + t);
          r2 += a, i2 += 2;
        } else
          "`" === u4 ? (s = !s, i2++) : "." !== u4 || s ? (r2 += u4, i2++) : (o(), i2++);
      }
      if (o(), s)
        throw new I2(b.INVALID_ARGUMENT, "Unterminated ` in path: " + t);
      return new n2(e2);
    }, n2.P = function() {
      return new n2([]);
    }, n2;
  }(P2)
);
var F2 = (
  /** @class */
  function() {
    function t(t2) {
      this.path = t2;
    }
    return t.D = function(e) {
      return new t(V2.g(e));
    }, t.C = function(e) {
      return new t(V2.g(e).u(5));
    }, /** Returns true if the document is in the specified collectionId. */
    t.prototype.N = function(t2) {
      return this.path.length >= 2 && this.path.get(this.path.length - 2) === t2;
    }, t.prototype.isEqual = function(t2) {
      return null !== t2 && 0 === V2.i(this.path, t2.path);
    }, t.prototype.toString = function() {
      return this.path.toString();
    }, t.i = function(t2, e) {
      return V2.i(t2.path, e.path);
    }, t.F = function(t2) {
      return t2.length % 2 == 0;
    }, /**
     * Creates and returns a new document key with the given segments.
     *
     * @param segments The segments of the path to the document
     * @return A new instance of DocumentKey
     */
    t.$ = function(e) {
      return new t(new V2(e.slice()));
    }, t;
  }()
);
function M2(t, e) {
  if (0 !== e.length)
    throw new I2(b.INVALID_ARGUMENT, "Function " + t + "() does not support arguments, but was called with " + rt(e.length, "argument") + ".");
}
function q2(t, e, n2) {
  if (e.length !== n2)
    throw new I2(b.INVALID_ARGUMENT, "Function " + t + "() requires " + rt(n2, "argument") + ", but was called with " + rt(e.length, "argument") + ".");
}
function j(t, e, n2) {
  if (e.length < n2)
    throw new I2(b.INVALID_ARGUMENT, "Function " + t + "() requires at least " + rt(n2, "argument") + ", but was called with " + rt(e.length, "argument") + ".");
}
function G2(t, e, n2, r2) {
  if (e.length < n2 || e.length > r2)
    throw new I2(b.INVALID_ARGUMENT, "Function " + t + "() requires between " + n2 + " and " + r2 + " arguments, but was called with " + rt(e.length, "argument") + ".");
}
function z(t, e, n2, r2) {
  Y2(t, e, nt(n2) + " argument", r2);
}
function B(t, e, n2, r2) {
  void 0 !== r2 && z(t, e, n2, r2);
}
function K2(t, e, n2, r2) {
  Y2(t, e, n2 + " option", r2);
}
function W2(t, e, n2, r2) {
  void 0 !== r2 && K2(t, e, n2, r2);
}
function Q2(t, e, n2, r2, i2) {
  void 0 !== r2 && function(t2, e2, n3, r3, i3) {
    for (var o = [], s = 0, u4 = i3; s < u4.length; s++) {
      var a = u4[s];
      if (a === r3)
        return;
      o.push(X2(a));
    }
    var c = X2(r3);
    throw new I2(b.INVALID_ARGUMENT, "Invalid value " + c + " provided to function " + t2 + '() for option "' + n3 + '". Acceptable values: ' + o.join(", "));
  }(t, 0, n2, r2, i2);
}
function H2(t, e, n2, r2) {
  if (!e.some(function(t2) {
    return t2 === r2;
  }))
    throw new I2(b.INVALID_ARGUMENT, "Invalid value " + X2(r2) + " provided to function " + t + "() for its " + nt(n2) + " argument. Acceptable values: " + e.join(", "));
  return r2;
}
function Y2(t, e, n2, r2) {
  if (!("object" === e ? $2(r2) : "non-empty string" === e ? "string" == typeof r2 && "" !== r2 : typeof r2 === e)) {
    var i2 = X2(r2);
    throw new I2(b.INVALID_ARGUMENT, "Function " + t + "() requires its " + n2 + " to be of type " + e + ", but it was: " + i2);
  }
}
function $2(t) {
  return "object" == typeof t && null !== t && (Object.getPrototypeOf(t) === Object.prototype || null === Object.getPrototypeOf(t));
}
function X2(t) {
  if (void 0 === t)
    return "undefined";
  if (null === t)
    return "null";
  if ("string" == typeof t)
    return t.length > 20 && (t = t.substring(0, 20) + "..."), JSON.stringify(t);
  if ("number" == typeof t || "boolean" == typeof t)
    return "" + t;
  if ("object" == typeof t) {
    if (t instanceof Array)
      return "an array";
    var e = (
      /** Hacky method to try to get the constructor name for an object. */
      function(t2) {
        if (t2.constructor) {
          var e2 = /function\s+([^\s(]+)\s*\(/.exec(t2.constructor.toString());
          if (e2 && e2.length > 1)
            return e2[1];
        }
        return null;
      }(t)
    );
    return e ? "a custom " + e + " object" : "an object";
  }
  return "function" == typeof t ? "a function" : D2();
}
function J2(t, e, n2) {
  if (void 0 === n2)
    throw new I2(b.INVALID_ARGUMENT, "Function " + t + "() requires a valid " + nt(e) + " argument, but it was undefined.");
}
function Z2(t, e, n2) {
  R2(e, function(e2, r2) {
    if (n2.indexOf(e2) < 0)
      throw new I2(b.INVALID_ARGUMENT, "Unknown option '" + e2 + "' passed to function " + t + "(). Available options: " + n2.join(", "));
  });
}
function tt(t, e, n2, r2) {
  var i2 = X2(r2);
  return new I2(b.INVALID_ARGUMENT, "Function " + t + "() requires its " + nt(n2) + " argument to be a " + e + ", but it was: " + i2);
}
function et(t, e, n2) {
  if (n2 <= 0)
    throw new I2(b.INVALID_ARGUMENT, "Function " + t + "() requires its " + nt(e) + " argument to be a positive number, but it was: " + n2 + ".");
}
function nt(t) {
  switch (t) {
    case 1:
      return "first";
    case 2:
      return "second";
    case 3:
      return "third";
    default:
      return t + "th";
  }
}
function rt(t, e) {
  return t + " " + e + (1 === t ? "" : "s");
}
function it(t) {
  var e = (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    "undefined" != typeof self && (self.crypto || self.msCrypto)
  ), n2 = new Uint8Array(t);
  if (e && "function" == typeof e.getRandomValues)
    e.getRandomValues(n2);
  else
    for (var r2 = 0; r2 < t; r2++)
      n2[r2] = Math.floor(256 * Math.random());
  return n2;
}
var ot = (
  /** @class */
  function() {
    function t() {
    }
    return t.k = function() {
      for (var t2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", e = Math.floor(256 / t2.length) * t2.length, n2 = ""; n2.length < 20; )
        for (var r2 = it(40), i2 = 0; i2 < r2.length; ++i2)
          n2.length < 20 && r2[i2] < e && (n2 += t2.charAt(r2[i2] % t2.length));
      return n2;
    }, t;
  }()
);
function st(t, e) {
  return t < e ? -1 : t > e ? 1 : 0;
}
function ut(t, e, n2) {
  return t.length === e.length && t.every(function(t2, r2) {
    return n2(t2, e[r2]);
  });
}
function at(t) {
  return t + "\0";
}
var ct = (
  /** @class */
  function() {
    function t(t2) {
      this.M = t2;
    }
    return t.fromBase64String = function(e) {
      return new t(atob(e));
    }, t.fromUint8Array = function(e) {
      return new t(
        /**
        * Helper function to convert an Uint8array to a binary string.
        */
        function(t2) {
          for (var e2 = "", n2 = 0; n2 < t2.length; ++n2)
            e2 += String.fromCharCode(t2[n2]);
          return e2;
        }(e)
      );
    }, t.prototype.toBase64 = function() {
      return t2 = this.M, btoa(t2);
      var t2;
    }, t.prototype.toUint8Array = function() {
      return function(t2) {
        for (var e = new Uint8Array(t2.length), n2 = 0; n2 < t2.length; n2++)
          e[n2] = t2.charCodeAt(n2);
        return e;
      }(this.M);
    }, t.prototype.O = function() {
      return 2 * this.M.length;
    }, t.prototype.L = function(t2) {
      return st(this.M, t2.M);
    }, t.prototype.isEqual = function(t2) {
      return this.M === t2.M;
    }, t;
  }()
);
ct.B = new ct("");
var ht = (
  /** @class */
  function() {
    function t(t2) {
      this.q = t2;
    }
    return t.fromBase64String = function(e) {
      try {
        return new t(ct.fromBase64String(e));
      } catch (e2) {
        throw new I2(b.INVALID_ARGUMENT, "Failed to construct Bytes from Base64 string: " + e2);
      }
    }, /**
     * Creates a new `Bytes` object from the given Uint8Array.
     *
     * @param array The Uint8Array used to create the `Bytes` object.
     */
    t.fromUint8Array = function(e) {
      return new t(ct.fromUint8Array(e));
    }, /**
     * Returns the underlying bytes as a Base64-encoded string.
     *
     * @return The Base64-encoded string created from the `Bytes` object.
     */
    t.prototype.toBase64 = function() {
      return this.q.toBase64();
    }, /**
     * Returns the underlying bytes in a new `Uint8Array`.
     *
     * @return The Uint8Array created from the `Bytes` object.
     */
    t.prototype.toUint8Array = function() {
      return this.q.toUint8Array();
    }, /**
     * Returns a string representation of the `Bytes` object.
     *
     * @return A string representation of the `Bytes` object.
     */
    t.prototype.toString = function() {
      return "Bytes(base64: " + this.toBase64() + ")";
    }, /**
     * Returns true if this `Bytes` object is equal to the provided one.
     *
     * @param other The `Bytes` object to compare against.
     * @return true if this `Bytes` object is equal to the provided one.
     */
    t.prototype.isEqual = function(t2) {
      return this.q.isEqual(t2.q);
    }, t;
  }()
);
function ft() {
  if ("undefined" == typeof Uint8Array)
    throw new I2(b.UNIMPLEMENTED, "Uint8Arrays are not available in this environment.");
}
function lt() {
  if ("undefined" == typeof atob)
    throw new I2(b.UNIMPLEMENTED, "Blobs are unavailable in Firestore in this environment.");
}
var pt = (
  /** @class */
  function(e) {
    function n2() {
      return null !== e && e.apply(this, arguments) || this;
    }
    return __extends(n2, e), n2.fromBase64String = function(t) {
      q2("Blob.fromBase64String", arguments, 1), z("Blob.fromBase64String", "string", 1, t), lt();
      try {
        return new n2(ct.fromBase64String(t));
      } catch (t2) {
        throw new I2(b.INVALID_ARGUMENT, "Failed to construct Blob from Base64 string: " + t2);
      }
    }, n2.fromUint8Array = function(t) {
      if (q2("Blob.fromUint8Array", arguments, 1), ft(), !(t instanceof Uint8Array))
        throw tt("Blob.fromUint8Array", "Uint8Array", 1, t);
      return new n2(ct.fromUint8Array(t));
    }, n2.prototype.toBase64 = function() {
      return q2("Blob.toBase64", arguments, 0), lt(), e.prototype.toBase64.call(this);
    }, n2.prototype.toUint8Array = function() {
      return q2("Blob.toUint8Array", arguments, 0), ft(), e.prototype.toUint8Array.call(this);
    }, n2.prototype.toString = function() {
      return "Blob(base64: " + this.toBase64() + ")";
    }, n2;
  }(ht)
);
var dt = (
  /**
       * Constructs a DatabaseInfo using the provided host, databaseId and
       * persistenceKey.
       *
       * @param databaseId The database to use.
       * @param persistenceKey A unique identifier for this Firestore's local
       * storage (used in conjunction with the databaseId).
       * @param host The Firestore backend host to connect to.
       * @param ssl Whether to use SSL when connecting.
       * @param forceLongPolling Whether to use the forceLongPolling option
       * when using WebChannel as the network transport.
       * @param autoDetectLongPolling Whether to use the detectBufferingProxy
       * option when using WebChannel as the network transport.
       */
  function(t, e, n2, r2, i2, o) {
    this.U = t, this.persistenceKey = e, this.host = n2, this.ssl = r2, this.forceLongPolling = i2, this.W = o;
  }
);
var vt = (
  /** @class */
  function() {
    function t(t2, e) {
      this.projectId = t2, this.database = e || "(default)";
    }
    return Object.defineProperty(t.prototype, "j", {
      get: function() {
        return "(default)" === this.database;
      },
      enumerable: false,
      configurable: true
    }), t.prototype.isEqual = function(e) {
      return e instanceof t && e.projectId === this.projectId && e.database === this.database;
    }, t.prototype.L = function(t2) {
      return st(this.projectId, t2.projectId) || st(this.database, t2.database);
    }, t;
  }()
);
var yt = (
  /** @class */
  function() {
    function t(t2, e) {
      this.K = t2, this.G = e, /**
           * The inner map for a key -> value pair. Due to the possibility of
           * collisions we keep a list of entries that we do a linear search through
           * to find an actual match. Note that collisions should be rare, so we still
           * expect near constant time lookups in practice.
           */
      this.H = {};
    }
    return t.prototype.get = function(t2) {
      var e = this.K(t2), n2 = this.H[e];
      if (void 0 !== n2)
        for (var r2 = 0, i2 = n2; r2 < i2.length; r2++) {
          var o = i2[r2], s = o[0], u4 = o[1];
          if (this.G(s, t2))
            return u4;
        }
    }, t.prototype.has = function(t2) {
      return void 0 !== this.get(t2);
    }, /** Put this key and value in the map. */
    t.prototype.set = function(t2, e) {
      var n2 = this.K(t2), r2 = this.H[n2];
      if (void 0 !== r2) {
        for (var i2 = 0; i2 < r2.length; i2++)
          if (this.G(r2[i2][0], t2))
            return void (r2[i2] = [t2, e]);
        r2.push([t2, e]);
      } else
        this.H[n2] = [[t2, e]];
    }, /**
     * Remove this key from the map. Returns a boolean if anything was deleted.
     */
    t.prototype.delete = function(t2) {
      var e = this.K(t2), n2 = this.H[e];
      if (void 0 === n2)
        return false;
      for (var r2 = 0; r2 < n2.length; r2++)
        if (this.G(n2[r2][0], t2))
          return 1 === n2.length ? delete this.H[e] : n2.splice(r2, 1), true;
      return false;
    }, t.prototype.forEach = function(t2) {
      R2(this.H, function(e, n2) {
        for (var r2 = 0, i2 = n2; r2 < i2.length; r2++) {
          var o = i2[r2], s = o[0], u4 = o[1];
          t2(s, u4);
        }
      });
    }, t.prototype.m = function() {
      return O2(this.H);
    }, t;
  }()
);
var mt = (
  /** @class */
  function() {
    function t(t2, e) {
      if (this.seconds = t2, this.nanoseconds = e, e < 0)
        throw new I2(b.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
      if (e >= 1e9)
        throw new I2(b.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
      if (t2 < -62135596800)
        throw new I2(b.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t2);
      if (t2 >= 253402300800)
        throw new I2(b.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t2);
    }
    return t.now = function() {
      return t.fromMillis(Date.now());
    }, /**
     * Creates a new timestamp from the given date.
     *
     * @param date The date to initialize the `Timestamp` from.
     * @return A new `Timestamp` representing the same point in time as the given
     *     date.
     */
    t.fromDate = function(e) {
      return t.fromMillis(e.getTime());
    }, /**
     * Creates a new timestamp from the given number of milliseconds.
     *
     * @param milliseconds Number of milliseconds since Unix epoch
     *     1970-01-01T00:00:00Z.
     * @return A new `Timestamp` representing the same point in time as the given
     *     number of milliseconds.
     */
    t.fromMillis = function(e) {
      var n2 = Math.floor(e / 1e3);
      return new t(n2, 1e6 * (e - 1e3 * n2));
    }, /**
     * Converts a `Timestamp` to a JavaScript `Date` object. This conversion causes
     * a loss of precision since `Date` objects only support millisecond precision.
     *
     * @return JavaScript `Date` object representing the same point in time as
     *     this `Timestamp`, with millisecond precision.
     */
    t.prototype.toDate = function() {
      return new Date(this.toMillis());
    }, /**
     * Converts a `Timestamp` to a numeric timestamp (in milliseconds since
     * epoch). This operation causes a loss of precision.
     *
     * @return The point in time corresponding to this timestamp, represented as
     *     the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.
     */
    t.prototype.toMillis = function() {
      return 1e3 * this.seconds + this.nanoseconds / 1e6;
    }, t.prototype.Y = function(t2) {
      return this.seconds === t2.seconds ? st(this.nanoseconds, t2.nanoseconds) : st(this.seconds, t2.seconds);
    }, /**
     * Returns true if this `Timestamp` is equal to the provided one.
     *
     * @param other The `Timestamp` to compare against.
     * @return true if this `Timestamp` is equal to the provided one.
     */
    t.prototype.isEqual = function(t2) {
      return t2.seconds === this.seconds && t2.nanoseconds === this.nanoseconds;
    }, t.prototype.toString = function() {
      return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
    }, t.prototype.toJSON = function() {
      return {
        seconds: this.seconds,
        nanoseconds: this.nanoseconds
      };
    }, /**
     * Converts this object to a primitive string, which allows Timestamp objects to be compared
     * using the `>`, `<=`, `>=` and `>` operators.
     */
    t.prototype.valueOf = function() {
      var t2 = this.seconds - -62135596800;
      return String(t2).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0");
    }, t;
  }()
);
var gt = (
  /** @class */
  function() {
    function t(t2) {
      this.timestamp = t2;
    }
    return t.J = function(e) {
      return new t(e);
    }, t.min = function() {
      return new t(new mt(0, 0));
    }, t.prototype.L = function(t2) {
      return this.timestamp.Y(t2.timestamp);
    }, t.prototype.isEqual = function(t2) {
      return this.timestamp.isEqual(t2.timestamp);
    }, /** Returns a number representation of the version for use in spec tests. */
    t.prototype.X = function() {
      return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
    }, t.prototype.toString = function() {
      return "SnapshotVersion(" + this.timestamp.toString() + ")";
    }, t.prototype.Z = function() {
      return this.timestamp;
    }, t;
  }()
);
function wt(t) {
  return null == t;
}
function bt(t) {
  return 0 === t && 1 / t == -1 / 0;
}
function It(t) {
  return "number" == typeof t && Number.isInteger(t) && !bt(t) && t <= Number.MAX_SAFE_INTEGER && t >= Number.MIN_SAFE_INTEGER;
}
var Et = function(t, e, n2, r2, i2, o, s) {
  void 0 === e && (e = null), void 0 === n2 && (n2 = []), void 0 === r2 && (r2 = []), void 0 === i2 && (i2 = null), void 0 === o && (o = null), void 0 === s && (s = null), this.path = t, this.collectionGroup = e, this.orderBy = n2, this.filters = r2, this.limit = i2, this.startAt = o, this.endAt = s, this.tt = null;
};
function _t(t, e, n2, r2, i2, o, s) {
  return void 0 === e && (e = null), void 0 === n2 && (n2 = []), void 0 === r2 && (r2 = []), void 0 === i2 && (i2 = null), void 0 === o && (o = null), void 0 === s && (s = null), new Et(t, e, n2, r2, i2, o, s);
}
function Tt(t) {
  var e = x2(t);
  if (null === e.tt) {
    var n2 = e.path.R();
    null !== e.collectionGroup && (n2 += "|cg:" + e.collectionGroup), n2 += "|f:", n2 += e.filters.map(function(t2) {
      return function(t3) {
        return t3.field.R() + t3.op.toString() + ve(t3.value);
      }(t2);
    }).join(","), n2 += "|ob:", n2 += e.orderBy.map(function(t2) {
      return (e2 = t2).field.R() + e2.dir;
      var e2;
    }).join(","), wt(e.limit) || (n2 += "|l:", n2 += e.limit), e.startAt && (n2 += "|lb:", n2 += br(e.startAt)), e.endAt && (n2 += "|ub:", n2 += br(e.endAt)), e.tt = n2;
  }
  return e.tt;
}
function Nt(t, e) {
  if (t.limit !== e.limit)
    return false;
  if (t.orderBy.length !== e.orderBy.length)
    return false;
  for (var n2 = 0; n2 < t.orderBy.length; n2++)
    if (!Nr(t.orderBy[n2], e.orderBy[n2]))
      return false;
  if (t.filters.length !== e.filters.length)
    return false;
  for (var r2 = 0; r2 < t.filters.length; r2++)
    if (i2 = t.filters[r2], o = e.filters[r2], i2.op !== o.op || !i2.field.isEqual(o.field) || !fe(i2.value, o.value))
      return false;
  var i2, o;
  return t.collectionGroup === e.collectionGroup && !!t.path.isEqual(e.path) && !!Er(t.startAt, e.startAt) && Er(t.endAt, e.endAt);
}
function At(t) {
  return F2.F(t.path) && null === t.collectionGroup && 0 === t.filters.length;
}
var St;
var Dt;
var kt = (
  /** @class */
  function() {
    function t(t2, e, n2, r2, i2, o, s) {
      void 0 === i2 && (i2 = gt.min()), void 0 === o && (o = gt.min()), void 0 === s && (s = ct.B), this.target = t2, this.targetId = e, this.et = n2, this.sequenceNumber = r2, this.nt = i2, this.lastLimboFreeSnapshotVersion = o, this.resumeToken = s;
    }
    return t.prototype.st = function(e) {
      return new t(this.target, this.targetId, this.et, e, this.nt, this.lastLimboFreeSnapshotVersion, this.resumeToken);
    }, /**
     * Creates a new target data instance with an updated resume token and
     * snapshot version.
     */
    t.prototype.it = function(e, n2) {
      return new t(this.target, this.targetId, this.et, this.sequenceNumber, n2, this.lastLimboFreeSnapshotVersion, e);
    }, /**
     * Creates a new target data instance with an updated last limbo free
     * snapshot version number.
     */
    t.prototype.rt = function(e) {
      return new t(this.target, this.targetId, this.et, this.sequenceNumber, this.nt, e, this.resumeToken);
    }, t;
  }()
);
var xt = (
  // TODO(b/33078163): just use simplest form of existence filter for now
  function(t) {
    this.count = t;
  }
);
function Lt(t) {
  switch (t) {
    case b.OK:
      return D2();
    case b.CANCELLED:
    case b.UNKNOWN:
    case b.DEADLINE_EXCEEDED:
    case b.RESOURCE_EXHAUSTED:
    case b.INTERNAL:
    case b.UNAVAILABLE:
    case b.UNAUTHENTICATED:
      return false;
    case b.INVALID_ARGUMENT:
    case b.NOT_FOUND:
    case b.ALREADY_EXISTS:
    case b.PERMISSION_DENIED:
    case b.FAILED_PRECONDITION:
    case b.ABORTED:
    case b.OUT_OF_RANGE:
    case b.UNIMPLEMENTED:
    case b.DATA_LOSS:
      return true;
    default:
      return D2();
  }
}
function Rt(t) {
  if (void 0 === t)
    return N2("GRPC error has no .code"), b.UNKNOWN;
  switch (t) {
    case St.OK:
      return b.OK;
    case St.CANCELLED:
      return b.CANCELLED;
    case St.UNKNOWN:
      return b.UNKNOWN;
    case St.DEADLINE_EXCEEDED:
      return b.DEADLINE_EXCEEDED;
    case St.RESOURCE_EXHAUSTED:
      return b.RESOURCE_EXHAUSTED;
    case St.INTERNAL:
      return b.INTERNAL;
    case St.UNAVAILABLE:
      return b.UNAVAILABLE;
    case St.UNAUTHENTICATED:
      return b.UNAUTHENTICATED;
    case St.INVALID_ARGUMENT:
      return b.INVALID_ARGUMENT;
    case St.NOT_FOUND:
      return b.NOT_FOUND;
    case St.ALREADY_EXISTS:
      return b.ALREADY_EXISTS;
    case St.PERMISSION_DENIED:
      return b.PERMISSION_DENIED;
    case St.FAILED_PRECONDITION:
      return b.FAILED_PRECONDITION;
    case St.ABORTED:
      return b.ABORTED;
    case St.OUT_OF_RANGE:
      return b.OUT_OF_RANGE;
    case St.UNIMPLEMENTED:
      return b.UNIMPLEMENTED;
    case St.DATA_LOSS:
      return b.DATA_LOSS;
    default:
      return D2();
  }
}
(Dt = St || (St = {}))[Dt.OK = 0] = "OK", Dt[Dt.CANCELLED = 1] = "CANCELLED", Dt[Dt.UNKNOWN = 2] = "UNKNOWN", Dt[Dt.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", Dt[Dt.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", Dt[Dt.NOT_FOUND = 5] = "NOT_FOUND", Dt[Dt.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", Dt[Dt.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", Dt[Dt.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", Dt[Dt.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", Dt[Dt.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", Dt[Dt.ABORTED = 10] = "ABORTED", Dt[Dt.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", Dt[Dt.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", Dt[Dt.INTERNAL = 13] = "INTERNAL", Dt[Dt.UNAVAILABLE = 14] = "UNAVAILABLE", Dt[Dt.DATA_LOSS = 15] = "DATA_LOSS";
var Ot = (
  /** @class */
  function() {
    function t(t2, e) {
      this.i = t2, this.root = e || Vt.EMPTY;
    }
    return t.prototype.ot = function(e, n2) {
      return new t(this.i, this.root.ot(e, n2, this.i).copy(null, null, Vt.at, null, null));
    }, // Returns a copy of the map, with the specified key removed.
    t.prototype.remove = function(e) {
      return new t(this.i, this.root.remove(e, this.i).copy(null, null, Vt.at, null, null));
    }, // Returns the value of the node with the given key, or null.
    t.prototype.get = function(t2) {
      for (var e = this.root; !e.m(); ) {
        var n2 = this.i(t2, e.key);
        if (0 === n2)
          return e.value;
        n2 < 0 ? e = e.left : n2 > 0 && (e = e.right);
      }
      return null;
    }, // Returns the index of the element in this sorted map, or -1 if it doesn't
    // exist.
    t.prototype.indexOf = function(t2) {
      for (var e = 0, n2 = this.root; !n2.m(); ) {
        var r2 = this.i(t2, n2.key);
        if (0 === r2)
          return e + n2.left.size;
        r2 < 0 ? n2 = n2.left : (
          // Count all nodes left of the node plus the node itself
          (e += n2.left.size + 1, n2 = n2.right)
        );
      }
      return -1;
    }, t.prototype.m = function() {
      return this.root.m();
    }, Object.defineProperty(t.prototype, "size", {
      // Returns the total number of nodes in the map.
      get: function() {
        return this.root.size;
      },
      enumerable: false,
      configurable: true
    }), // Returns the minimum key in the map.
    t.prototype.ct = function() {
      return this.root.ct();
    }, // Returns the maximum key in the map.
    t.prototype.ut = function() {
      return this.root.ut();
    }, // Traverses the map in key order and calls the specified action function
    // for each key/value pair. If action returns true, traversal is aborted.
    // Returns the first truthy value returned by action, or the last falsey
    // value returned by action.
    t.prototype.ht = function(t2) {
      return this.root.ht(t2);
    }, t.prototype.forEach = function(t2) {
      this.ht(function(e, n2) {
        return t2(e, n2), false;
      });
    }, t.prototype.toString = function() {
      var t2 = [];
      return this.ht(function(e, n2) {
        return t2.push(e + ":" + n2), false;
      }), "{" + t2.join(", ") + "}";
    }, // Traverses the map in reverse key order and calls the specified action
    // function for each key/value pair. If action returns true, traversal is
    // aborted.
    // Returns the first truthy value returned by action, or the last falsey
    // value returned by action.
    t.prototype.lt = function(t2) {
      return this.root.lt(t2);
    }, // Returns an iterator over the SortedMap.
    t.prototype._t = function() {
      return new Pt(this.root, null, this.i, false);
    }, t.prototype.ft = function(t2) {
      return new Pt(this.root, t2, this.i, false);
    }, t.prototype.dt = function() {
      return new Pt(this.root, null, this.i, true);
    }, t.prototype.wt = function(t2) {
      return new Pt(this.root, t2, this.i, true);
    }, t;
  }()
);
var Pt = (
  /** @class */
  function() {
    function t(t2, e, n2, r2) {
      this.Tt = r2, this.Et = [];
      for (var i2 = 1; !t2.m(); )
        if (i2 = e ? n2(t2.key, e) : 1, // flip the comparison if we're going in reverse
        r2 && (i2 *= -1), i2 < 0)
          t2 = this.Tt ? t2.left : t2.right;
        else {
          if (0 === i2) {
            this.Et.push(t2);
            break;
          }
          this.Et.push(t2), t2 = this.Tt ? t2.right : t2.left;
        }
    }
    return t.prototype.It = function() {
      var t2 = this.Et.pop(), e = {
        key: t2.key,
        value: t2.value
      };
      if (this.Tt)
        for (t2 = t2.left; !t2.m(); )
          this.Et.push(t2), t2 = t2.right;
      else
        for (t2 = t2.right; !t2.m(); )
          this.Et.push(t2), t2 = t2.left;
      return e;
    }, t.prototype.At = function() {
      return this.Et.length > 0;
    }, t.prototype.Rt = function() {
      if (0 === this.Et.length)
        return null;
      var t2 = this.Et[this.Et.length - 1];
      return {
        key: t2.key,
        value: t2.value
      };
    }, t;
  }()
);
var Vt = (
  /** @class */
  function() {
    function t(e, n2, r2, i2, o) {
      this.key = e, this.value = n2, this.color = null != r2 ? r2 : t.RED, this.left = null != i2 ? i2 : t.EMPTY, this.right = null != o ? o : t.EMPTY, this.size = this.left.size + 1 + this.right.size;
    }
    return t.prototype.copy = function(e, n2, r2, i2, o) {
      return new t(null != e ? e : this.key, null != n2 ? n2 : this.value, null != r2 ? r2 : this.color, null != i2 ? i2 : this.left, null != o ? o : this.right);
    }, t.prototype.m = function() {
      return false;
    }, // Traverses the tree in key order and calls the specified action function
    // for each node. If action returns true, traversal is aborted.
    // Returns the first truthy value returned by action, or the last falsey
    // value returned by action.
    t.prototype.ht = function(t2) {
      return this.left.ht(t2) || t2(this.key, this.value) || this.right.ht(t2);
    }, // Traverses the tree in reverse key order and calls the specified action
    // function for each node. If action returns true, traversal is aborted.
    // Returns the first truthy value returned by action, or the last falsey
    // value returned by action.
    t.prototype.lt = function(t2) {
      return this.right.lt(t2) || t2(this.key, this.value) || this.left.lt(t2);
    }, // Returns the minimum node in the tree.
    t.prototype.min = function() {
      return this.left.m() ? this : this.left.min();
    }, // Returns the maximum key in the tree.
    t.prototype.ct = function() {
      return this.min().key;
    }, // Returns the maximum key in the tree.
    t.prototype.ut = function() {
      return this.right.m() ? this.key : this.right.ut();
    }, // Returns new tree, with the key/value added.
    t.prototype.ot = function(t2, e, n2) {
      var r2 = this, i2 = n2(t2, r2.key);
      return (r2 = i2 < 0 ? r2.copy(null, null, null, r2.left.ot(t2, e, n2), null) : 0 === i2 ? r2.copy(null, e, null, null, null) : r2.copy(null, null, null, null, r2.right.ot(t2, e, n2))).gt();
    }, t.prototype.Pt = function() {
      if (this.left.m())
        return t.EMPTY;
      var e = this;
      return e.left.yt() || e.left.left.yt() || (e = e.Vt()), (e = e.copy(null, null, null, e.left.Pt(), null)).gt();
    }, // Returns new tree, with the specified item removed.
    t.prototype.remove = function(e, n2) {
      var r2, i2 = this;
      if (n2(e, i2.key) < 0)
        i2.left.m() || i2.left.yt() || i2.left.left.yt() || (i2 = i2.Vt()), i2 = i2.copy(null, null, null, i2.left.remove(e, n2), null);
      else {
        if (i2.left.yt() && (i2 = i2.bt()), i2.right.m() || i2.right.yt() || i2.right.left.yt() || (i2 = i2.vt()), 0 === n2(e, i2.key)) {
          if (i2.right.m())
            return t.EMPTY;
          r2 = i2.right.min(), i2 = i2.copy(r2.key, r2.value, null, null, i2.right.Pt());
        }
        i2 = i2.copy(null, null, null, null, i2.right.remove(e, n2));
      }
      return i2.gt();
    }, t.prototype.yt = function() {
      return this.color;
    }, // Returns new tree after performing any needed rotations.
    t.prototype.gt = function() {
      var t2 = this;
      return t2.right.yt() && !t2.left.yt() && (t2 = t2.St()), t2.left.yt() && t2.left.left.yt() && (t2 = t2.bt()), t2.left.yt() && t2.right.yt() && (t2 = t2.Dt()), t2;
    }, t.prototype.Vt = function() {
      var t2 = this.Dt();
      return t2.right.left.yt() && (t2 = (t2 = (t2 = t2.copy(null, null, null, null, t2.right.bt())).St()).Dt()), t2;
    }, t.prototype.vt = function() {
      var t2 = this.Dt();
      return t2.left.left.yt() && (t2 = (t2 = t2.bt()).Dt()), t2;
    }, t.prototype.St = function() {
      var e = this.copy(null, null, t.RED, null, this.right.left);
      return this.right.copy(null, null, this.color, e, null);
    }, t.prototype.bt = function() {
      var e = this.copy(null, null, t.RED, this.left.right, null);
      return this.left.copy(null, null, this.color, null, e);
    }, t.prototype.Dt = function() {
      var t2 = this.left.copy(null, null, !this.left.color, null, null), e = this.right.copy(null, null, !this.right.color, null, null);
      return this.copy(null, null, !this.color, t2, e);
    }, // For testing.
    t.prototype.Ct = function() {
      var t2 = this.Nt();
      return Math.pow(2, t2) <= this.size + 1;
    }, // In a balanced RB tree, the black-depth (number of black nodes) from root to
    // leaves is equal on both sides.  This function verifies that or asserts.
    t.prototype.Nt = function() {
      if (this.yt() && this.left.yt())
        throw D2();
      if (this.right.yt())
        throw D2();
      var t2 = this.left.Nt();
      if (t2 !== this.right.Nt())
        throw D2();
      return t2 + (this.yt() ? 0 : 1);
    }, t;
  }()
);
Vt.EMPTY = null, Vt.RED = true, Vt.at = false, // end LLRBEmptyNode
Vt.EMPTY = new /** @class */
(function() {
  function t() {
    this.size = 0;
  }
  return Object.defineProperty(t.prototype, "key", {
    get: function() {
      throw D2();
    },
    enumerable: false,
    configurable: true
  }), Object.defineProperty(t.prototype, "value", {
    get: function() {
      throw D2();
    },
    enumerable: false,
    configurable: true
  }), Object.defineProperty(t.prototype, "color", {
    get: function() {
      throw D2();
    },
    enumerable: false,
    configurable: true
  }), Object.defineProperty(t.prototype, "left", {
    get: function() {
      throw D2();
    },
    enumerable: false,
    configurable: true
  }), Object.defineProperty(t.prototype, "right", {
    get: function() {
      throw D2();
    },
    enumerable: false,
    configurable: true
  }), // Returns a copy of the current node.
  t.prototype.copy = function(t2, e, n2, r2, i2) {
    return this;
  }, // Returns a copy of the tree, with the specified key/value added.
  t.prototype.ot = function(t2, e, n2) {
    return new Vt(t2, e);
  }, // Returns a copy of the tree, with the specified key removed.
  t.prototype.remove = function(t2, e) {
    return this;
  }, t.prototype.m = function() {
    return true;
  }, t.prototype.ht = function(t2) {
    return false;
  }, t.prototype.lt = function(t2) {
    return false;
  }, t.prototype.ct = function() {
    return null;
  }, t.prototype.ut = function() {
    return null;
  }, t.prototype.yt = function() {
    return false;
  }, // For testing.
  t.prototype.Ct = function() {
    return true;
  }, t.prototype.Nt = function() {
    return 0;
  }, t;
}())();
var Ut = (
  /** @class */
  function() {
    function t(t2) {
      this.i = t2, this.data = new Ot(this.i);
    }
    return t.prototype.has = function(t2) {
      return null !== this.data.get(t2);
    }, t.prototype.first = function() {
      return this.data.ct();
    }, t.prototype.last = function() {
      return this.data.ut();
    }, Object.defineProperty(t.prototype, "size", {
      get: function() {
        return this.data.size;
      },
      enumerable: false,
      configurable: true
    }), t.prototype.indexOf = function(t2) {
      return this.data.indexOf(t2);
    }, /** Iterates elements in order defined by "comparator" */
    t.prototype.forEach = function(t2) {
      this.data.ht(function(e, n2) {
        return t2(e), false;
      });
    }, /** Iterates over `elem`s such that: range[0] <= elem < range[1]. */
    t.prototype.Ft = function(t2, e) {
      for (var n2 = this.data.ft(t2[0]); n2.At(); ) {
        var r2 = n2.It();
        if (this.i(r2.key, t2[1]) >= 0)
          return;
        e(r2.key);
      }
    }, /**
     * Iterates over `elem`s such that: start <= elem until false is returned.
     */
    t.prototype.xt = function(t2, e) {
      var n2;
      for (n2 = void 0 !== e ? this.data.ft(e) : this.data._t(); n2.At(); )
        if (!t2(n2.It().key))
          return;
    }, /** Finds the least element greater than or equal to `elem`. */
    t.prototype.$t = function(t2) {
      var e = this.data.ft(t2);
      return e.At() ? e.It().key : null;
    }, t.prototype._t = function() {
      return new Ct(this.data._t());
    }, t.prototype.ft = function(t2) {
      return new Ct(this.data.ft(t2));
    }, /** Inserts or updates an element */
    t.prototype.add = function(t2) {
      return this.copy(this.data.remove(t2).ot(t2, true));
    }, /** Deletes an element */
    t.prototype.delete = function(t2) {
      return this.has(t2) ? this.copy(this.data.remove(t2)) : this;
    }, t.prototype.m = function() {
      return this.data.m();
    }, t.prototype.kt = function(t2) {
      var e = this;
      return e.size < t2.size && (e = t2, t2 = this), t2.forEach(function(t3) {
        e = e.add(t3);
      }), e;
    }, t.prototype.isEqual = function(e) {
      if (!(e instanceof t))
        return false;
      if (this.size !== e.size)
        return false;
      for (var n2 = this.data._t(), r2 = e.data._t(); n2.At(); ) {
        var i2 = n2.It().key, o = r2.It().key;
        if (0 !== this.i(i2, o))
          return false;
      }
      return true;
    }, t.prototype.A = function() {
      var t2 = [];
      return this.forEach(function(e) {
        t2.push(e);
      }), t2;
    }, t.prototype.toString = function() {
      var t2 = [];
      return this.forEach(function(e) {
        return t2.push(e);
      }), "SortedSet(" + t2.toString() + ")";
    }, t.prototype.copy = function(e) {
      var n2 = new t(this.i);
      return n2.data = e, n2;
    }, t;
  }()
);
var Ct = (
  /** @class */
  function() {
    function t(t2) {
      this.Mt = t2;
    }
    return t.prototype.It = function() {
      return this.Mt.It().key;
    }, t.prototype.At = function() {
      return this.Mt.At();
    }, t;
  }()
);
var Ft = new Ot(F2.i);
function Mt() {
  return Ft;
}
function qt() {
  return Mt();
}
var jt = new Ot(F2.i);
function Gt() {
  return jt;
}
var zt = new Ot(F2.i);
var Bt = new Ut(F2.i);
function Kt() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  for (var n2 = Bt, r2 = 0, i2 = t; r2 < i2.length; r2++) {
    var o = i2[r2];
    n2 = n2.add(o);
  }
  return n2;
}
var Wt = new Ut(st);
function Qt() {
  return Wt;
}
var Ht = (
  /** @class */
  function() {
    function t(t2) {
      this.i = t2 ? function(e, n2) {
        return t2(e, n2) || F2.i(e.key, n2.key);
      } : function(t3, e) {
        return F2.i(t3.key, e.key);
      }, this.Ot = Gt(), this.Lt = new Ot(this.i);
    }
    return t.Bt = function(e) {
      return new t(e.i);
    }, t.prototype.has = function(t2) {
      return null != this.Ot.get(t2);
    }, t.prototype.get = function(t2) {
      return this.Ot.get(t2);
    }, t.prototype.first = function() {
      return this.Lt.ct();
    }, t.prototype.last = function() {
      return this.Lt.ut();
    }, t.prototype.m = function() {
      return this.Lt.m();
    }, /**
     * Returns the index of the provided key in the document set, or -1 if the
     * document key is not present in the set;
     */
    t.prototype.indexOf = function(t2) {
      var e = this.Ot.get(t2);
      return e ? this.Lt.indexOf(e) : -1;
    }, Object.defineProperty(t.prototype, "size", {
      get: function() {
        return this.Lt.size;
      },
      enumerable: false,
      configurable: true
    }), /** Iterates documents in order defined by "comparator" */
    t.prototype.forEach = function(t2) {
      this.Lt.ht(function(e, n2) {
        return t2(e), false;
      });
    }, /** Inserts or updates a document with the same key */
    t.prototype.add = function(t2) {
      var e = this.delete(t2.key);
      return e.copy(e.Ot.ot(t2.key, t2), e.Lt.ot(t2, null));
    }, /** Deletes a document with a given key */
    t.prototype.delete = function(t2) {
      var e = this.get(t2);
      return e ? this.copy(this.Ot.remove(t2), this.Lt.remove(e)) : this;
    }, t.prototype.isEqual = function(e) {
      if (!(e instanceof t))
        return false;
      if (this.size !== e.size)
        return false;
      for (var n2 = this.Lt._t(), r2 = e.Lt._t(); n2.At(); ) {
        var i2 = n2.It().key, o = r2.It().key;
        if (!i2.isEqual(o))
          return false;
      }
      return true;
    }, t.prototype.toString = function() {
      var t2 = [];
      return this.forEach(function(e) {
        t2.push(e.toString());
      }), 0 === t2.length ? "DocumentSet ()" : "DocumentSet (\n  " + t2.join("  \n") + "\n)";
    }, t.prototype.copy = function(e, n2) {
      var r2 = new t();
      return r2.i = this.i, r2.Ot = e, r2.Lt = n2, r2;
    }, t;
  }()
);
var Yt = (
  /** @class */
  function() {
    function t() {
      this.qt = new Ot(F2.i);
    }
    return t.prototype.track = function(t2) {
      var e = t2.doc.key, n2 = this.qt.get(e);
      n2 ? (
        // Merge the new change with the existing change.
        0 !== t2.type && 3 === n2.type ? this.qt = this.qt.ot(e, t2) : 3 === t2.type && 1 !== n2.type ? this.qt = this.qt.ot(e, {
          type: n2.type,
          doc: t2.doc
        }) : 2 === t2.type && 2 === n2.type ? this.qt = this.qt.ot(e, {
          type: 2,
          doc: t2.doc
        }) : 2 === t2.type && 0 === n2.type ? this.qt = this.qt.ot(e, {
          type: 0,
          doc: t2.doc
        }) : 1 === t2.type && 0 === n2.type ? this.qt = this.qt.remove(e) : 1 === t2.type && 2 === n2.type ? this.qt = this.qt.ot(e, {
          type: 1,
          doc: n2.doc
        }) : 0 === t2.type && 1 === n2.type ? this.qt = this.qt.ot(e, {
          type: 2,
          doc: t2.doc
        }) : (
          // This includes these cases, which don't make sense:
          // Added->Added
          // Removed->Removed
          // Modified->Added
          // Removed->Modified
          // Metadata->Added
          // Removed->Metadata
          D2()
        )
      ) : this.qt = this.qt.ot(e, t2);
    }, t.prototype.Ut = function() {
      var t2 = [];
      return this.qt.ht(function(e, n2) {
        t2.push(n2);
      }), t2;
    }, t;
  }()
);
var $t = (
  /** @class */
  function() {
    function t(t2, e, n2, r2, i2, o, s, u4) {
      this.query = t2, this.docs = e, this.Qt = n2, this.docChanges = r2, this.Wt = i2, this.fromCache = o, this.jt = s, this.Kt = u4;
    }
    return t.Gt = function(e, n2, r2, i2) {
      var o = [];
      return n2.forEach(function(t2) {
        o.push({
          type: 0,
          doc: t2
        });
      }), new t(
        e,
        n2,
        Ht.Bt(n2),
        o,
        r2,
        i2,
        /* syncStateChanged= */
        true,
        /* excludesMetadataChanges= */
        false
      );
    }, Object.defineProperty(t.prototype, "hasPendingWrites", {
      get: function() {
        return !this.Wt.m();
      },
      enumerable: false,
      configurable: true
    }), t.prototype.isEqual = function(t2) {
      if (!(this.fromCache === t2.fromCache && this.jt === t2.jt && this.Wt.isEqual(t2.Wt) && or(this.query, t2.query) && this.docs.isEqual(t2.docs) && this.Qt.isEqual(t2.Qt)))
        return false;
      var e = this.docChanges, n2 = t2.docChanges;
      if (e.length !== n2.length)
        return false;
      for (var r2 = 0; r2 < e.length; r2++)
        if (e[r2].type !== n2[r2].type || !e[r2].doc.isEqual(n2[r2].doc))
          return false;
      return true;
    }, t;
  }()
);
var Xt = (
  /** @class */
  function() {
    function t(t2, e, n2, r2, i2) {
      this.nt = t2, this.zt = e, this.Ht = n2, this.Yt = r2, this.Jt = i2;
    }
    return t.Xt = function(e, n2) {
      var r2 = /* @__PURE__ */ new Map();
      return r2.set(e, Jt.Zt(e, n2)), new t(gt.min(), r2, Qt(), Mt(), Kt());
    }, t;
  }()
);
var Jt = (
  /** @class */
  function() {
    function t(t2, e, n2, r2, i2) {
      this.resumeToken = t2, this.te = e, this.ee = n2, this.ne = r2, this.se = i2;
    }
    return t.Zt = function(e, n2) {
      return new t(ct.B, n2, Kt(), Kt(), Kt());
    }, t;
  }()
);
var Zt = function(t, e, n2, r2) {
  this.ie = t, this.removedTargetIds = e, this.key = n2, this.re = r2;
};
var te = function(t, e) {
  this.targetId = t, this.oe = e;
};
var ee = function(t, e, n2, r2) {
  void 0 === n2 && (n2 = ct.B), void 0 === r2 && (r2 = null), this.state = t, this.targetIds = e, this.resumeToken = n2, this.cause = r2;
};
var ne = (
  /** @class */
  function() {
    function t() {
      this.ae = 0, /**
           * Keeps track of the document changes since the last raised snapshot.
           *
           * These changes are continuously updated as we receive document updates and
           * always reflect the current set of changes against the last issued snapshot.
           */
      this.ce = oe(), /** See public getters for explanations of these fields. */
      this.ue = ct.B, this.he = false, /**
           * Whether this target state should be included in the next snapshot. We
           * initialize to true so that newly-added targets are included in the next
           * RemoteEvent.
           */
      this.le = true;
    }
    return Object.defineProperty(t.prototype, "te", {
      /**
       * Whether this target has been marked 'current'.
       *
       * 'Current' has special meaning in the RPC protocol: It implies that the
       * Watch backend has sent us all changes up to the point at which the target
       * was added and that the target is consistent with the rest of the watch
       * stream.
       */
      get: function() {
        return this.he;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "resumeToken", {
      /** The last resume token sent to us for this target. */
      get: function() {
        return this.ue;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "_e", {
      /** Whether this target has pending target adds or target removes. */
      get: function() {
        return 0 !== this.ae;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "fe", {
      /** Whether we have modified any state that should trigger a snapshot. */
      get: function() {
        return this.le;
      },
      enumerable: false,
      configurable: true
    }), /**
     * Applies the resume token to the TargetChange, but only when it has a new
     * value. Empty resumeTokens are discarded.
     */
    t.prototype.de = function(t2) {
      t2.O() > 0 && (this.le = true, this.ue = t2);
    }, /**
     * Creates a target change from the current set of changes.
     *
     * To reset the document changes after raising this snapshot, call
     * `clearPendingChanges()`.
     */
    t.prototype.we = function() {
      var t2 = Kt(), e = Kt(), n2 = Kt();
      return this.ce.forEach(function(r2, i2) {
        switch (i2) {
          case 0:
            t2 = t2.add(r2);
            break;
          case 2:
            e = e.add(r2);
            break;
          case 1:
            n2 = n2.add(r2);
            break;
          default:
            D2();
        }
      }), new Jt(this.ue, this.he, t2, e, n2);
    }, /**
     * Resets the document changes and sets `hasPendingChanges` to false.
     */
    t.prototype.me = function() {
      this.le = false, this.ce = oe();
    }, t.prototype.Te = function(t2, e) {
      this.le = true, this.ce = this.ce.ot(t2, e);
    }, t.prototype.Ee = function(t2) {
      this.le = true, this.ce = this.ce.remove(t2);
    }, t.prototype.Ie = function() {
      this.ae += 1;
    }, t.prototype.Ae = function() {
      this.ae -= 1;
    }, t.prototype.Re = function() {
      this.le = true, this.he = true;
    }, t;
  }()
);
var re = (
  /** @class */
  function() {
    function t(t2) {
      this.ge = t2, /** The internal state of all tracked targets. */
      this.Pe = /* @__PURE__ */ new Map(), /** Keeps track of the documents to update since the last raised snapshot. */
      this.ye = Mt(), /** A mapping of document keys to their set of target IDs. */
      this.Ve = ie(), /**
           * A list of targets with existence filter mismatches. These targets are
           * known to be inconsistent and their listens needs to be re-established by
           * RemoteStore.
           */
      this.pe = new Ut(st);
    }
    return t.prototype.be = function(t2) {
      for (var e = 0, n2 = t2.ie; e < n2.length; e++) {
        var r2 = n2[e];
        t2.re instanceof zn ? this.ve(r2, t2.re) : t2.re instanceof Bn && this.Se(r2, t2.key, t2.re);
      }
      for (var i2 = 0, o = t2.removedTargetIds; i2 < o.length; i2++) {
        var s = o[i2];
        this.Se(s, t2.key, t2.re);
      }
    }, /** Processes and adds the WatchTargetChange to the current set of changes. */
    t.prototype.De = function(t2) {
      var e = this;
      this.Ce(t2, function(n2) {
        var r2 = e.Ne(n2);
        switch (t2.state) {
          case 0:
            e.Fe(n2) && r2.de(t2.resumeToken);
            break;
          case 1:
            r2.Ae(), r2._e || // We have a freshly added target, so we need to reset any state
            // that we had previously. This can happen e.g. when remove and add
            // back a target for existence filter mismatches.
            r2.me(), r2.de(t2.resumeToken);
            break;
          case 2:
            r2.Ae(), r2._e || e.removeTarget(n2);
            break;
          case 3:
            e.Fe(n2) && (r2.Re(), r2.de(t2.resumeToken));
            break;
          case 4:
            e.Fe(n2) && // Reset the target and synthesizes removes for all existing
            // documents. The backend will re-add any documents that still
            // match the target before it sends the next global snapshot.
            (e.xe(n2), r2.de(t2.resumeToken));
            break;
          default:
            D2();
        }
      });
    }, /**
     * Iterates over all targetIds that the watch change applies to: either the
     * targetIds explicitly listed in the change or the targetIds of all currently
     * active targets.
     */
    t.prototype.Ce = function(t2, e) {
      var n2 = this;
      t2.targetIds.length > 0 ? t2.targetIds.forEach(e) : this.Pe.forEach(function(t3, r2) {
        n2.Fe(r2) && e(r2);
      });
    }, /**
     * Handles existence filters and synthesizes deletes for filter mismatches.
     * Targets that are invalidated by filter mismatches are added to
     * `pendingTargetResets`.
     */
    t.prototype.$e = function(t2) {
      var e = t2.targetId, n2 = t2.oe.count, r2 = this.ke(e);
      if (r2) {
        var i2 = r2.target;
        if (At(i2))
          if (0 === n2) {
            var o = new F2(i2.path);
            this.Se(e, o, new Bn(o, gt.min()));
          } else
            k2(1 === n2);
        else
          this.Me(e) !== n2 && // Existence filter mismatch: We reset the mapping and raise a new
          // snapshot with `isFromCache:true`.
          (this.xe(e), this.pe = this.pe.add(e));
      }
    }, /**
     * Converts the currently accumulated state into a remote event at the
     * provided snapshot version. Resets the accumulated changes before returning.
     */
    t.prototype.Oe = function(t2) {
      var e = this, n2 = /* @__PURE__ */ new Map();
      this.Pe.forEach(function(r3, i3) {
        var o = e.ke(i3);
        if (o) {
          if (r3.te && At(o.target)) {
            var s = new F2(o.target.path);
            null !== e.ye.get(s) || e.Le(i3, s) || e.Se(i3, s, new Bn(s, t2));
          }
          r3.fe && (n2.set(i3, r3.we()), r3.me());
        }
      });
      var r2 = Kt();
      this.Ve.forEach(function(t3, n3) {
        var i3 = true;
        n3.xt(function(t4) {
          var n4 = e.ke(t4);
          return !n4 || 2 === n4.et || (i3 = false, false);
        }), i3 && (r2 = r2.add(t3));
      });
      var i2 = new Xt(t2, n2, this.pe, this.ye, r2);
      return this.ye = Mt(), this.Ve = ie(), this.pe = new Ut(st), i2;
    }, /**
     * Adds the provided document to the internal list of document updates and
     * its document key to the given target's mapping.
     */
    // Visible for testing.
    t.prototype.ve = function(t2, e) {
      if (this.Fe(t2)) {
        var n2 = this.Le(t2, e.key) ? 2 : 0;
        this.Ne(t2).Te(e.key, n2), this.ye = this.ye.ot(e.key, e), this.Ve = this.Ve.ot(e.key, this.Be(e.key).add(t2));
      }
    }, /**
     * Removes the provided document from the target mapping. If the
     * document no longer matches the target, but the document's state is still
     * known (e.g. we know that the document was deleted or we received the change
     * that caused the filter mismatch), the new document can be provided
     * to update the remote document cache.
     */
    // Visible for testing.
    t.prototype.Se = function(t2, e, n2) {
      if (this.Fe(t2)) {
        var r2 = this.Ne(t2);
        this.Le(t2, e) ? r2.Te(
          e,
          1
          /* Removed */
        ) : (
          // The document may have entered and left the target before we raised a
          // snapshot, so we can just ignore the change.
          r2.Ee(e)
        ), this.Ve = this.Ve.ot(e, this.Be(e).delete(t2)), n2 && (this.ye = this.ye.ot(e, n2));
      }
    }, t.prototype.removeTarget = function(t2) {
      this.Pe.delete(t2);
    }, /**
     * Returns the current count of documents in the target. This includes both
     * the number of documents that the LocalStore considers to be part of the
     * target as well as any accumulated changes.
     */
    t.prototype.Me = function(t2) {
      var e = this.Ne(t2).we();
      return this.ge.qe(t2).size + e.ee.size - e.se.size;
    }, /**
     * Increment the number of acks needed from watch before we can consider the
     * server to be 'in-sync' with the client's active targets.
     */
    t.prototype.Ie = function(t2) {
      this.Ne(t2).Ie();
    }, t.prototype.Ne = function(t2) {
      var e = this.Pe.get(t2);
      return e || (e = new ne(), this.Pe.set(t2, e)), e;
    }, t.prototype.Be = function(t2) {
      var e = this.Ve.get(t2);
      return e || (e = new Ut(st), this.Ve = this.Ve.ot(t2, e)), e;
    }, /**
     * Verifies that the user is still interested in this target (by calling
     * `getTargetDataForTarget()`) and that we are not waiting for pending ADDs
     * from watch.
     */
    t.prototype.Fe = function(t2) {
      var e = null !== this.ke(t2);
      return e || T2("WatchChangeAggregator", "Detected inactive target", t2), e;
    }, /**
     * Returns the TargetData for an active target (i.e. a target that the user
     * is still interested in that has no outstanding target change requests).
     */
    t.prototype.ke = function(t2) {
      var e = this.Pe.get(t2);
      return e && e._e ? null : this.ge.Ue(t2);
    }, /**
     * Resets the state of a Watch target to its initial state (e.g. sets
     * 'current' to false, clears the resume token and removes its target mapping
     * from all documents).
     */
    t.prototype.xe = function(t2) {
      var e = this;
      this.Pe.set(t2, new ne()), this.ge.qe(t2).forEach(function(n2) {
        e.Se(
          t2,
          n2,
          /*updatedDocument=*/
          null
        );
      });
    }, /**
     * Returns whether the LocalStore considers the document to be part of the
     * specified target.
     */
    t.prototype.Le = function(t2, e) {
      return this.ge.qe(t2).has(e);
    }, t;
  }()
);
function ie() {
  return new Ot(F2.i);
}
function oe() {
  return new Ot(F2.i);
}
function se(t) {
  var e, n2;
  return "server_timestamp" === (null === (n2 = ((null === (e = null == t ? void 0 : t.mapValue) || void 0 === e ? void 0 : e.fields) || {}).__type__) || void 0 === n2 ? void 0 : n2.stringValue);
}
function ue(t) {
  var e = t.mapValue.fields.__previous_value__;
  return se(e) ? ue(e) : e;
}
function ae(t) {
  var e = me(t.mapValue.fields.__local_write_time__.timestampValue);
  return new mt(e.seconds, e.nanos);
}
var ce = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
function he(t) {
  return "nullValue" in t ? 0 : "booleanValue" in t ? 1 : "integerValue" in t || "doubleValue" in t ? 2 : "timestampValue" in t ? 3 : "stringValue" in t ? 5 : "bytesValue" in t ? 6 : "referenceValue" in t ? 7 : "geoPointValue" in t ? 8 : "arrayValue" in t ? 9 : "mapValue" in t ? se(t) ? 4 : 10 : D2();
}
function fe(t, e) {
  var n2 = he(t);
  if (n2 !== he(e))
    return false;
  switch (n2) {
    case 0:
      return true;
    case 1:
      return t.booleanValue === e.booleanValue;
    case 4:
      return ae(t).isEqual(ae(e));
    case 3:
      return function(t2, e2) {
        if ("string" == typeof t2.timestampValue && "string" == typeof e2.timestampValue && t2.timestampValue.length === e2.timestampValue.length)
          return t2.timestampValue === e2.timestampValue;
        var n3 = me(t2.timestampValue), r2 = me(e2.timestampValue);
        return n3.seconds === r2.seconds && n3.nanos === r2.nanos;
      }(t, e);
    case 5:
      return t.stringValue === e.stringValue;
    case 6:
      return function(t2, e2) {
        return we(t2.bytesValue).isEqual(we(e2.bytesValue));
      }(t, e);
    case 7:
      return t.referenceValue === e.referenceValue;
    case 8:
      return function(t2, e2) {
        return ge(t2.geoPointValue.latitude) === ge(e2.geoPointValue.latitude) && ge(t2.geoPointValue.longitude) === ge(e2.geoPointValue.longitude);
      }(t, e);
    case 2:
      return function(t2, e2) {
        if ("integerValue" in t2 && "integerValue" in e2)
          return ge(t2.integerValue) === ge(e2.integerValue);
        if ("doubleValue" in t2 && "doubleValue" in e2) {
          var n3 = ge(t2.doubleValue), r2 = ge(e2.doubleValue);
          return n3 === r2 ? bt(n3) === bt(r2) : isNaN(n3) && isNaN(r2);
        }
        return false;
      }(t, e);
    case 9:
      return ut(t.arrayValue.values || [], e.arrayValue.values || [], fe);
    case 10:
      return function(t2, e2) {
        var n3 = t2.mapValue.fields || {}, r2 = e2.mapValue.fields || {};
        if (L2(n3) !== L2(r2))
          return false;
        for (var i2 in n3)
          if (n3.hasOwnProperty(i2) && (void 0 === r2[i2] || !fe(n3[i2], r2[i2])))
            return false;
        return true;
      }(t, e);
    default:
      return D2();
  }
}
function le(t, e) {
  return void 0 !== (t.values || []).find(function(t2) {
    return fe(t2, e);
  });
}
function pe(t, e) {
  var n2 = he(t), r2 = he(e);
  if (n2 !== r2)
    return st(n2, r2);
  switch (n2) {
    case 0:
      return 0;
    case 1:
      return st(t.booleanValue, e.booleanValue);
    case 2:
      return function(t2, e2) {
        var n3 = ge(t2.integerValue || t2.doubleValue), r3 = ge(e2.integerValue || e2.doubleValue);
        return n3 < r3 ? -1 : n3 > r3 ? 1 : n3 === r3 ? 0 : (
          // one or both are NaN.
          isNaN(n3) ? isNaN(r3) ? 0 : -1 : 1
        );
      }(t, e);
    case 3:
      return de(t.timestampValue, e.timestampValue);
    case 4:
      return de(ae(t), ae(e));
    case 5:
      return st(t.stringValue, e.stringValue);
    case 6:
      return function(t2, e2) {
        var n3 = we(t2), r3 = we(e2);
        return n3.L(r3);
      }(t.bytesValue, e.bytesValue);
    case 7:
      return function(t2, e2) {
        for (var n3 = t2.split("/"), r3 = e2.split("/"), i2 = 0; i2 < n3.length && i2 < r3.length; i2++) {
          var o = st(n3[i2], r3[i2]);
          if (0 !== o)
            return o;
        }
        return st(n3.length, r3.length);
      }(t.referenceValue, e.referenceValue);
    case 8:
      return function(t2, e2) {
        var n3 = st(ge(t2.latitude), ge(e2.latitude));
        return 0 !== n3 ? n3 : st(ge(t2.longitude), ge(e2.longitude));
      }(t.geoPointValue, e.geoPointValue);
    case 9:
      return function(t2, e2) {
        for (var n3 = t2.values || [], r3 = e2.values || [], i2 = 0; i2 < n3.length && i2 < r3.length; ++i2) {
          var o = pe(n3[i2], r3[i2]);
          if (o)
            return o;
        }
        return st(n3.length, r3.length);
      }(t.arrayValue, e.arrayValue);
    case 10:
      return function(t2, e2) {
        var n3 = t2.fields || {}, r3 = Object.keys(n3), i2 = e2.fields || {}, o = Object.keys(i2);
        r3.sort(), o.sort();
        for (var s = 0; s < r3.length && s < o.length; ++s) {
          var u4 = st(r3[s], o[s]);
          if (0 !== u4)
            return u4;
          var a = pe(n3[r3[s]], i2[o[s]]);
          if (0 !== a)
            return a;
        }
        return st(r3.length, o.length);
      }(t.mapValue, e.mapValue);
    default:
      throw D2();
  }
}
function de(t, e) {
  if ("string" == typeof t && "string" == typeof e && t.length === e.length)
    return st(t, e);
  var n2 = me(t), r2 = me(e), i2 = st(n2.seconds, r2.seconds);
  return 0 !== i2 ? i2 : st(n2.nanos, r2.nanos);
}
function ve(t) {
  return ye(t);
}
function ye(t) {
  return "nullValue" in t ? "null" : "booleanValue" in t ? "" + t.booleanValue : "integerValue" in t ? "" + t.integerValue : "doubleValue" in t ? "" + t.doubleValue : "timestampValue" in t ? function(t2) {
    var e2 = me(t2);
    return "time(" + e2.seconds + "," + e2.nanos + ")";
  }(t.timestampValue) : "stringValue" in t ? t.stringValue : "bytesValue" in t ? we(t.bytesValue).toBase64() : "referenceValue" in t ? (n2 = t.referenceValue, F2.C(n2).toString()) : "geoPointValue" in t ? "geo(" + (e = t.geoPointValue).latitude + "," + e.longitude + ")" : "arrayValue" in t ? function(t2) {
    for (var e2 = "[", n3 = true, r2 = 0, i2 = t2.values || []; r2 < i2.length; r2++) {
      n3 ? n3 = false : e2 += ",", e2 += ye(i2[r2]);
    }
    return e2 + "]";
  }(t.arrayValue) : "mapValue" in t ? function(t2) {
    for (var e2 = "{", n3 = true, r2 = 0, i2 = Object.keys(t2.fields || {}).sort(); r2 < i2.length; r2++) {
      var o = i2[r2];
      n3 ? n3 = false : e2 += ",", e2 += o + ":" + ye(t2.fields[o]);
    }
    return e2 + "}";
  }(t.mapValue) : D2();
  var e, n2;
}
function me(t) {
  if (k2(!!t), "string" == typeof t) {
    var e = 0, n2 = ce.exec(t);
    if (k2(!!n2), n2[1]) {
      var r2 = n2[1];
      r2 = (r2 + "000000000").substr(0, 9), e = Number(r2);
    }
    var i2 = new Date(t);
    return {
      seconds: Math.floor(i2.getTime() / 1e3),
      nanos: e
    };
  }
  return {
    seconds: ge(t.seconds),
    nanos: ge(t.nanos)
  };
}
function ge(t) {
  return "number" == typeof t ? t : "string" == typeof t ? Number(t) : 0;
}
function we(t) {
  return "string" == typeof t ? ct.fromBase64String(t) : ct.fromUint8Array(t);
}
function be(t, e) {
  return {
    referenceValue: "projects/" + t.projectId + "/databases/" + t.database + "/documents/" + e.path.R()
  };
}
function Ie(t) {
  return !!t && "integerValue" in t;
}
function Ee(t) {
  return !!t && "arrayValue" in t;
}
function _e(t) {
  return !!t && "nullValue" in t;
}
function Te(t) {
  return !!t && "doubleValue" in t && isNaN(Number(t.doubleValue));
}
function Ne(t) {
  return !!t && "mapValue" in t;
}
var Ae = {
  asc: "ASCENDING",
  desc: "DESCENDING"
};
var Se = {
  "<": "LESS_THAN",
  "<=": "LESS_THAN_OR_EQUAL",
  ">": "GREATER_THAN",
  ">=": "GREATER_THAN_OR_EQUAL",
  "==": "EQUAL",
  "!=": "NOT_EQUAL",
  "array-contains": "ARRAY_CONTAINS",
  in: "IN",
  "not-in": "NOT_IN",
  "array-contains-any": "ARRAY_CONTAINS_ANY"
};
var De = function(t, e) {
  this.U = t, this.Qe = e;
};
function ke(t) {
  return {
    integerValue: "" + t
  };
}
function xe(t, e) {
  if (t.Qe) {
    if (isNaN(e))
      return {
        doubleValue: "NaN"
      };
    if (e === 1 / 0)
      return {
        doubleValue: "Infinity"
      };
    if (e === -1 / 0)
      return {
        doubleValue: "-Infinity"
      };
  }
  return {
    doubleValue: bt(e) ? "-0" : e
  };
}
function Le(t, e) {
  return It(e) ? ke(e) : xe(t, e);
}
function Re(t, e) {
  return t.Qe ? new Date(1e3 * e.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "") + "." + ("000000000" + e.nanoseconds).slice(-9) + "Z" : {
    seconds: "" + e.seconds,
    nanos: e.nanoseconds
  };
}
function Oe(t, e) {
  return t.Qe ? e.toBase64() : e.toUint8Array();
}
function Pe(t, e) {
  return Re(t, e.Z());
}
function Ve(t) {
  return k2(!!t), gt.J(function(t2) {
    var e = me(t2);
    return new mt(e.seconds, e.nanos);
  }(t));
}
function Ue(t, e) {
  return function(t2) {
    return new V2(["projects", t2.projectId, "databases", t2.database]);
  }(t).child("documents").child(e).R();
}
function Ce(t) {
  var e = V2.g(t);
  return k2(un(e)), e;
}
function Fe(t, e) {
  return Ue(t.U, e.path);
}
function Me(t, e) {
  var n2 = Ce(e);
  return k2(n2.get(1) === t.U.projectId), k2(!n2.get(3) && !t.U.database || n2.get(3) === t.U.database), new F2(ze(n2));
}
function qe(t, e) {
  return Ue(t.U, e);
}
function je(t) {
  var e = Ce(t);
  return 4 === e.length ? V2.P() : ze(e);
}
function Ge(t) {
  return new V2(["projects", t.U.projectId, "databases", t.U.database]).R();
}
function ze(t) {
  return k2(t.length > 4 && "documents" === t.get(4)), t.u(5);
}
function Be(t, e, n2) {
  return {
    name: Fe(t, e),
    fields: n2.proto.mapValue.fields
  };
}
function Ke(t, e) {
  var n2;
  if (e instanceof Ln)
    n2 = {
      update: Be(t, e.key, e.value)
    };
  else if (e instanceof Cn)
    n2 = {
      delete: Fe(t, e.key)
    };
  else if (e instanceof Rn)
    n2 = {
      update: Be(t, e.key, e.data),
      updateMask: sn(e.We)
    };
  else if (e instanceof Pn)
    n2 = {
      transform: {
        document: Fe(t, e.key),
        fieldTransforms: e.fieldTransforms.map(function(t2) {
          return function(t3, e2) {
            var n3 = e2.transform;
            if (n3 instanceof ln)
              return {
                fieldPath: e2.field.R(),
                setToServerValue: "REQUEST_TIME"
              };
            if (n3 instanceof pn)
              return {
                fieldPath: e2.field.R(),
                appendMissingElements: {
                  values: n3.elements
                }
              };
            if (n3 instanceof vn)
              return {
                fieldPath: e2.field.R(),
                removeAllFromArray: {
                  values: n3.elements
                }
              };
            if (n3 instanceof mn)
              return {
                fieldPath: e2.field.R(),
                increment: n3.je
              };
            throw D2();
          }(0, t2);
        })
      }
    };
  else {
    if (!(e instanceof Fn))
      return D2();
    n2 = {
      verify: Fe(t, e.key)
    };
  }
  return e.Ge.Ke || (n2.currentDocument = function(t2, e2) {
    return void 0 !== e2.updateTime ? {
      updateTime: Pe(t2, e2.updateTime)
    } : void 0 !== e2.exists ? {
      exists: e2.exists
    } : D2();
  }(t, e.Ge)), n2;
}
function We(t, e) {
  var n2 = e.currentDocument ? function(t2) {
    return void 0 !== t2.updateTime ? _n.updateTime(Ve(t2.updateTime)) : void 0 !== t2.exists ? _n.exists(t2.exists) : _n.ze();
  }(e.currentDocument) : _n.ze();
  if (e.update) {
    e.update.name;
    var r2 = Me(t, e.update.name), i2 = new Mn({
      mapValue: {
        fields: e.update.fields
      }
    });
    if (e.updateMask) {
      var o = function(t2) {
        var e2 = t2.fieldPaths || [];
        return new bn(e2.map(function(t3) {
          return C2.S(t3);
        }));
      }(e.updateMask);
      return new Rn(r2, i2, o, n2);
    }
    return new Ln(r2, i2, n2);
  }
  if (e.delete) {
    var s = Me(t, e.delete);
    return new Cn(s, n2);
  }
  if (e.transform) {
    var u4 = Me(t, e.transform.document), a = e.transform.fieldTransforms.map(function(e2) {
      return function(t2, e3) {
        var n3 = null;
        if ("setToServerValue" in e3)
          k2("REQUEST_TIME" === e3.setToServerValue), n3 = new ln();
        else if ("appendMissingElements" in e3) {
          var r3 = e3.appendMissingElements.values || [];
          n3 = new pn(r3);
        } else if ("removeAllFromArray" in e3) {
          var i3 = e3.removeAllFromArray.values || [];
          n3 = new vn(i3);
        } else
          "increment" in e3 ? n3 = new mn(t2, e3.increment) : D2();
        var o2 = C2.S(e3.fieldPath);
        return new In(o2, n3);
      }(t, e2);
    });
    return k2(true === n2.exists), new Pn(u4, a);
  }
  if (e.verify) {
    var c = Me(t, e.verify);
    return new Fn(c, n2);
  }
  return D2();
}
function Qe(t, e) {
  return {
    documents: [qe(t, e.path)]
  };
}
function He(t, e) {
  var n2 = {
    structuredQuery: {}
  }, r2 = e.path;
  null !== e.collectionGroup ? (n2.parent = qe(t, r2), n2.structuredQuery.from = [{
    collectionId: e.collectionGroup,
    allDescendants: true
  }]) : (n2.parent = qe(t, r2.h()), n2.structuredQuery.from = [{
    collectionId: r2._()
  }]);
  var i2 = function(t2) {
    if (0 !== t2.length) {
      var e2 = t2.map(function(t3) {
        return function(t4) {
          if ("==" === t4.op) {
            if (Te(t4.value))
              return {
                unaryFilter: {
                  field: en(t4.field),
                  op: "IS_NAN"
                }
              };
            if (_e(t4.value))
              return {
                unaryFilter: {
                  field: en(t4.field),
                  op: "IS_NULL"
                }
              };
          } else if ("!=" === t4.op) {
            if (Te(t4.value))
              return {
                unaryFilter: {
                  field: en(t4.field),
                  op: "IS_NOT_NAN"
                }
              };
            if (_e(t4.value))
              return {
                unaryFilter: {
                  field: en(t4.field),
                  op: "IS_NOT_NULL"
                }
              };
          }
          return {
            fieldFilter: {
              field: en(t4.field),
              op: tn(t4.op),
              value: t4.value
            }
          };
        }(t3);
      });
      return 1 === e2.length ? e2[0] : {
        compositeFilter: {
          op: "AND",
          filters: e2
        }
      };
    }
  }(e.filters);
  i2 && (n2.structuredQuery.where = i2);
  var o = function(t2) {
    if (0 !== t2.length)
      return t2.map(function(t3) {
        return function(t4) {
          return {
            field: en(t4.field),
            direction: Ze(t4.dir)
          };
        }(t3);
      });
  }(e.orderBy);
  o && (n2.structuredQuery.orderBy = o);
  var s = function(t2, e2) {
    return t2.Qe || wt(e2) ? e2 : {
      value: e2
    };
  }(t, e.limit);
  return null !== s && (n2.structuredQuery.limit = s), e.startAt && (n2.structuredQuery.startAt = Xe(e.startAt)), e.endAt && (n2.structuredQuery.endAt = Xe(e.endAt)), n2;
}
function Ye(t) {
  var e = je(t.parent), n2 = t.structuredQuery, r2 = n2.from ? n2.from.length : 0, i2 = null;
  if (r2 > 0) {
    k2(1 === r2);
    var o = n2.from[0];
    o.allDescendants ? i2 = o.collectionId : e = e.child(o.collectionId);
  }
  var s = [];
  n2.where && (s = $e(n2.where));
  var u4 = [];
  n2.orderBy && (u4 = n2.orderBy.map(function(t2) {
    return function(t3) {
      return new _r(
        nn(t3.field),
        // visible for testing
        function(t4) {
          switch (t4) {
            case "ASCENDING":
              return "asc";
            case "DESCENDING":
              return "desc";
            default:
              return;
          }
        }(t3.direction)
      );
    }(t2);
  }));
  var a = null;
  n2.limit && (a = function(t2) {
    var e2;
    return wt(e2 = "object" == typeof t2 ? t2.value : t2) ? null : e2;
  }(n2.limit));
  var c = null;
  n2.startAt && (c = Je(n2.startAt));
  var h = null;
  return n2.endAt && (h = Je(n2.endAt)), er(Qn(e, i2, u4, s, a, "F", c, h));
}
function $e(t) {
  return t ? void 0 !== t.unaryFilter ? [on(t)] : void 0 !== t.fieldFilter ? [rn(t)] : void 0 !== t.compositeFilter ? t.compositeFilter.filters.map(function(t2) {
    return $e(t2);
  }).reduce(function(t2, e) {
    return t2.concat(e);
  }) : D2() : [];
}
function Xe(t) {
  return {
    before: t.before,
    values: t.position
  };
}
function Je(t) {
  var e = !!t.before, n2 = t.values || [];
  return new wr(n2, e);
}
function Ze(t) {
  return Ae[t];
}
function tn(t) {
  return Se[t];
}
function en(t) {
  return {
    fieldPath: t.R()
  };
}
function nn(t) {
  return C2.S(t.fieldPath);
}
function rn(t) {
  return hr.create(nn(t.fieldFilter.field), function(t2) {
    switch (t2) {
      case "EQUAL":
        return "==";
      case "NOT_EQUAL":
        return "!=";
      case "GREATER_THAN":
        return ">";
      case "GREATER_THAN_OR_EQUAL":
        return ">=";
      case "LESS_THAN":
        return "<";
      case "LESS_THAN_OR_EQUAL":
        return "<=";
      case "ARRAY_CONTAINS":
        return "array-contains";
      case "IN":
        return "in";
      case "NOT_IN":
        return "not-in";
      case "ARRAY_CONTAINS_ANY":
        return "array-contains-any";
      case "OPERATOR_UNSPECIFIED":
      default:
        return D2();
    }
  }(t.fieldFilter.op), t.fieldFilter.value);
}
function on(t) {
  switch (t.unaryFilter.op) {
    case "IS_NAN":
      var e = nn(t.unaryFilter.field);
      return hr.create(e, "==", {
        doubleValue: NaN
      });
    case "IS_NULL":
      var n2 = nn(t.unaryFilter.field);
      return hr.create(n2, "==", {
        nullValue: "NULL_VALUE"
      });
    case "IS_NOT_NAN":
      var r2 = nn(t.unaryFilter.field);
      return hr.create(r2, "!=", {
        doubleValue: NaN
      });
    case "IS_NOT_NULL":
      var i2 = nn(t.unaryFilter.field);
      return hr.create(i2, "!=", {
        nullValue: "NULL_VALUE"
      });
    case "OPERATOR_UNSPECIFIED":
    default:
      return D2();
  }
}
function sn(t) {
  var e = [];
  return t.fields.forEach(function(t2) {
    return e.push(t2.R());
  }), {
    fieldPaths: e
  };
}
function un(t) {
  return t.length >= 4 && "projects" === t.get(0) && "databases" === t.get(2);
}
var an = function() {
  this.He = void 0;
};
function cn(t, e, n2) {
  return t instanceof ln ? function(t2, e2) {
    var n3 = {
      fields: {
        __type__: {
          stringValue: "server_timestamp"
        },
        __local_write_time__: {
          timestampValue: {
            seconds: t2.seconds,
            nanos: t2.nanoseconds
          }
        }
      }
    };
    return e2 && (n3.fields.__previous_value__ = e2), {
      mapValue: n3
    };
  }(n2, e) : t instanceof pn ? dn(t, e) : t instanceof vn ? yn(t, e) : function(t2, e2) {
    var n3 = fn(t2, e2), r2 = gn(n3) + gn(t2.je);
    return Ie(n3) && Ie(t2.je) ? ke(r2) : xe(t2.serializer, r2);
  }(t, e);
}
function hn(t, e, n2) {
  return t instanceof pn ? dn(t, e) : t instanceof vn ? yn(t, e) : n2;
}
function fn(t, e) {
  return t instanceof mn ? Ie(n2 = e) || function(t2) {
    return !!t2 && "doubleValue" in t2;
  }(n2) ? e : {
    integerValue: 0
  } : null;
  var n2;
}
var ln = (
  /** @class */
  function(e) {
    function n2() {
      return null !== e && e.apply(this, arguments) || this;
    }
    return __extends(n2, e), n2;
  }(an)
);
var pn = (
  /** @class */
  function(e) {
    function n2(t) {
      var n3 = this;
      return (n3 = e.call(this) || this).elements = t, n3;
    }
    return __extends(n2, e), n2;
  }(an)
);
function dn(t, e) {
  for (var n2 = wn(e), r2 = function(t2) {
    n2.some(function(e2) {
      return fe(e2, t2);
    }) || n2.push(t2);
  }, i2 = 0, o = t.elements; i2 < o.length; i2++) {
    r2(o[i2]);
  }
  return {
    arrayValue: {
      values: n2
    }
  };
}
var vn = (
  /** @class */
  function(e) {
    function n2(t) {
      var n3 = this;
      return (n3 = e.call(this) || this).elements = t, n3;
    }
    return __extends(n2, e), n2;
  }(an)
);
function yn(t, e) {
  for (var n2 = wn(e), r2 = function(t2) {
    n2 = n2.filter(function(e2) {
      return !fe(e2, t2);
    });
  }, i2 = 0, o = t.elements; i2 < o.length; i2++) {
    r2(o[i2]);
  }
  return {
    arrayValue: {
      values: n2
    }
  };
}
var mn = (
  /** @class */
  function(e) {
    function n2(t, n3) {
      var r2 = this;
      return (r2 = e.call(this) || this).serializer = t, r2.je = n3, r2;
    }
    return __extends(n2, e), n2;
  }(an)
);
function gn(t) {
  return ge(t.integerValue || t.doubleValue);
}
function wn(t) {
  return Ee(t) && t.arrayValue.values ? t.arrayValue.values.slice() : [];
}
var bn = (
  /** @class */
  function() {
    function t(t2) {
      this.fields = t2, // TODO(dimond): validation of FieldMask
      // Sort the field mask to support `FieldMask.isEqual()` and assert below.
      t2.sort(C2.i);
    }
    return t.prototype.Ye = function(t2) {
      for (var e = 0, n2 = this.fields; e < n2.length; e++) {
        if (n2[e].T(t2))
          return true;
      }
      return false;
    }, t.prototype.isEqual = function(t2) {
      return ut(this.fields, t2.fields, function(t3, e) {
        return t3.isEqual(e);
      });
    }, t;
  }()
);
var In = function(t, e) {
  this.field = t, this.transform = e;
};
var En = function(t, e) {
  this.version = t, this.transformResults = e;
};
var _n = (
  /** @class */
  function() {
    function t(t2, e) {
      this.updateTime = t2, this.exists = e;
    }
    return t.ze = function() {
      return new t();
    }, /** Creates a new Precondition with an exists flag. */
    t.exists = function(e) {
      return new t(void 0, e);
    }, /** Creates a new Precondition based on a version a document exists at. */
    t.updateTime = function(e) {
      return new t(e);
    }, Object.defineProperty(t.prototype, "Ke", {
      /** Returns whether this Precondition is empty. */
      get: function() {
        return void 0 === this.updateTime && void 0 === this.exists;
      },
      enumerable: false,
      configurable: true
    }), t.prototype.isEqual = function(t2) {
      return this.exists === t2.exists && (this.updateTime ? !!t2.updateTime && this.updateTime.isEqual(t2.updateTime) : !t2.updateTime);
    }, t;
  }()
);
function Tn(t, e) {
  return void 0 !== t.updateTime ? e instanceof zn && e.version.isEqual(t.updateTime) : void 0 === t.exists || t.exists === e instanceof zn;
}
var Nn = function() {
};
function An(t, e, n2) {
  return t instanceof Ln ? function(t2, e2, n3) {
    return new zn(t2.key, n3.version, t2.value, {
      hasCommittedMutations: true
    });
  }(t, 0, n2) : t instanceof Rn ? function(t2, e2, n3) {
    if (!Tn(t2.Ge, e2))
      return new Kn(t2.key, n3.version);
    var r2 = On(t2, e2);
    return new zn(t2.key, n3.version, r2, {
      hasCommittedMutations: true
    });
  }(t, e, n2) : t instanceof Pn ? function(t2, e2, n3) {
    if (k2(null != n3.transformResults), !Tn(t2.Ge, e2))
      return new Kn(t2.key, n3.version);
    var r2 = Vn(t2, e2), i2 = (
      /**
      * Creates a list of "transform results" (a transform result is a field value
      * representing the result of applying a transform) for use after a
      * TransformMutation has been acknowledged by the server.
      *
      * @param fieldTransforms The field transforms to apply the result to.
      * @param baseDoc The document prior to applying this mutation batch.
      * @param serverTransformResults The transform results received by the server.
      * @return The transform results list.
      */
      function(t3, e3, n4) {
        var r3 = [];
        k2(t3.length === n4.length);
        for (var i3 = 0; i3 < n4.length; i3++) {
          var o2 = t3[i3], s2 = o2.transform, u4 = null;
          e3 instanceof zn && (u4 = e3.field(o2.field)), r3.push(hn(s2, u4, n4[i3]));
        }
        return r3;
      }(t2.fieldTransforms, e2, n3.transformResults)
    ), o = n3.version, s = Un(t2, r2.data(), i2);
    return new zn(t2.key, o, s, {
      hasCommittedMutations: true
    });
  }(t, e, n2) : function(t2, e2, n3) {
    return new Bn(t2.key, n3.version, {
      hasCommittedMutations: true
    });
  }(t, 0, n2);
}
function Sn(t, e, n2, r2) {
  return t instanceof Ln ? function(t2, e2) {
    if (!Tn(t2.Ge, e2))
      return e2;
    var n3 = xn(e2);
    return new zn(t2.key, n3, t2.value, {
      Je: true
    });
  }(t, e) : t instanceof Rn ? function(t2, e2) {
    if (!Tn(t2.Ge, e2))
      return e2;
    var n3 = xn(e2), r3 = On(t2, e2);
    return new zn(t2.key, n3, r3, {
      Je: true
    });
  }(t, e) : t instanceof Pn ? function(t2, e2, n3, r3) {
    if (!Tn(t2.Ge, e2))
      return e2;
    var i2 = Vn(t2, e2), o = function(t3, e3, n4, r4) {
      for (var i3 = [], o2 = 0, s2 = t3; o2 < s2.length; o2++) {
        var u4 = s2[o2], a = u4.transform, c = null;
        n4 instanceof zn && (c = n4.field(u4.field)), null === c && r4 instanceof zn && // If the current document does not contain a value for the mutated
        // field, use the value that existed before applying this mutation
        // batch. This solves an edge case where a PatchMutation clears the
        // values in a nested map before the TransformMutation is applied.
        (c = r4.field(u4.field)), i3.push(cn(a, c, e3));
      }
      return i3;
    }(t2.fieldTransforms, n3, e2, r3), s = Un(t2, i2.data(), o);
    return new zn(t2.key, i2.version, s, {
      Je: true
    });
  }(t, e, r2, n2) : function(t2, e2) {
    return Tn(t2.Ge, e2) ? new Bn(t2.key, gt.min()) : e2;
  }(t, e);
}
function Dn(t, e) {
  return t instanceof Pn ? function(t2, e2) {
    for (var n2 = null, r2 = 0, i2 = t2.fieldTransforms; r2 < i2.length; r2++) {
      var o = i2[r2], s = e2 instanceof zn ? e2.field(o.field) : void 0, u4 = fn(o.transform, s || null);
      null != u4 && (n2 = null == n2 ? new qn().set(o.field, u4) : n2.set(o.field, u4));
    }
    return n2 ? n2.Xe() : null;
  }(t, e) : null;
}
function kn(t, e) {
  return t.type === e.type && !!t.key.isEqual(e.key) && !!t.Ge.isEqual(e.Ge) && (0 === t.type ? t.value.isEqual(e.value) : 1 === t.type ? t.data.isEqual(e.data) && t.We.isEqual(e.We) : 2 !== t.type || ut(t.fieldTransforms, t.fieldTransforms, function(t2, e2) {
    return function(t3, e3) {
      return t3.field.isEqual(e3.field) && function(t4, e4) {
        return t4 instanceof pn && e4 instanceof pn || t4 instanceof vn && e4 instanceof vn ? ut(t4.elements, e4.elements, fe) : t4 instanceof mn && e4 instanceof mn ? fe(t4.je, e4.je) : t4 instanceof ln && e4 instanceof ln;
      }(t3.transform, e3.transform);
    }(t2, e2);
  }));
}
function xn(t) {
  return t instanceof zn ? t.version : gt.min();
}
var Ln = (
  /** @class */
  function(e) {
    function n2(t, n3, r2) {
      var i2 = this;
      return (i2 = e.call(this) || this).key = t, i2.value = n3, i2.Ge = r2, i2.type = 0, i2;
    }
    return __extends(n2, e), n2;
  }(Nn)
);
var Rn = (
  /** @class */
  function(e) {
    function n2(t, n3, r2, i2) {
      var o = this;
      return (o = e.call(this) || this).key = t, o.data = n3, o.We = r2, o.Ge = i2, o.type = 1, o;
    }
    return __extends(n2, e), n2;
  }(Nn)
);
function On(t, e) {
  return function(t2, e2) {
    var n2 = new qn(e2);
    return t2.We.fields.forEach(function(e3) {
      if (!e3.m()) {
        var r2 = t2.data.field(e3);
        null !== r2 ? n2.set(e3, r2) : n2.delete(e3);
      }
    }), n2.Xe();
  }(t, e instanceof zn ? e.data() : Mn.empty());
}
var Pn = (
  /** @class */
  function(e) {
    function n2(t, n3) {
      var r2 = this;
      return (r2 = e.call(this) || this).key = t, r2.fieldTransforms = n3, r2.type = 2, // NOTE: We set a precondition of exists: true as a safety-check, since we
      // always combine TransformMutations with a SetMutation or PatchMutation which
      // (if successful) should end up with an existing document.
      r2.Ge = _n.exists(true), r2;
    }
    return __extends(n2, e), n2;
  }(Nn)
);
function Vn(t, e) {
  return e;
}
function Un(t, e, n2) {
  for (var r2 = new qn(e), i2 = 0; i2 < t.fieldTransforms.length; i2++) {
    var o = t.fieldTransforms[i2];
    r2.set(o.field, n2[i2]);
  }
  return r2.Xe();
}
var Cn = (
  /** @class */
  function(e) {
    function n2(t, n3) {
      var r2 = this;
      return (r2 = e.call(this) || this).key = t, r2.Ge = n3, r2.type = 3, r2;
    }
    return __extends(n2, e), n2;
  }(Nn)
);
var Fn = (
  /** @class */
  function(e) {
    function n2(t, n3) {
      var r2 = this;
      return (r2 = e.call(this) || this).key = t, r2.Ge = n3, r2.type = 4, r2;
    }
    return __extends(n2, e), n2;
  }(Nn)
);
var Mn = (
  /** @class */
  function() {
    function t(t2) {
      this.proto = t2;
    }
    return t.empty = function() {
      return new t({
        mapValue: {}
      });
    }, /**
     * Returns the value at the given path or null.
     *
     * @param path the path to search
     * @return The value at the path or if there it doesn't exist.
     */
    t.prototype.field = function(t2) {
      if (t2.m())
        return this.proto;
      for (var e = this.proto, n2 = 0; n2 < t2.length - 1; ++n2) {
        if (!e.mapValue.fields)
          return null;
        if (!Ne(e = e.mapValue.fields[t2.get(n2)]))
          return null;
      }
      return (e = (e.mapValue.fields || {})[t2._()]) || null;
    }, t.prototype.isEqual = function(t2) {
      return fe(this.proto, t2.proto);
    }, t;
  }()
);
var qn = (
  /** @class */
  function() {
    function t(t2) {
      void 0 === t2 && (t2 = Mn.empty()), this.Ze = t2, /** A map that contains the accumulated changes in this builder. */
      this.tn = /* @__PURE__ */ new Map();
    }
    return t.prototype.set = function(t2, e) {
      return this.en(t2, e), this;
    }, /**
     * Removes the field at the specified path. If there is no field at the
     * specified path, nothing is changed.
     *
     * @param path The field path to remove.
     * @return The current Builder instance.
     */
    t.prototype.delete = function(t2) {
      return this.en(t2, null), this;
    }, /**
     * Adds `value` to the overlay map at `path`. Creates nested map entries if
     * needed.
     */
    t.prototype.en = function(t2, e) {
      for (var n2 = this.tn, r2 = 0; r2 < t2.length - 1; ++r2) {
        var i2 = t2.get(r2), o = n2.get(i2);
        o instanceof Map ? (
          // Re-use a previously created map
          n2 = o
        ) : o && 10 === he(o) ? (
          // Convert the existing Protobuf MapValue into a map
          (o = new Map(Object.entries(o.mapValue.fields || {})), n2.set(i2, o), n2 = o)
        ) : (
          // Create an empty map to represent the current nesting level
          (o = /* @__PURE__ */ new Map(), n2.set(i2, o), n2 = o)
        );
      }
      n2.set(t2._(), e);
    }, /** Returns an ObjectValue with all mutations applied. */
    t.prototype.Xe = function() {
      var t2 = this.nn(C2.P(), this.tn);
      return null != t2 ? new Mn(t2) : this.Ze;
    }, /**
     * Applies any overlays from `currentOverlays` that exist at `currentPath`
     * and returns the merged data at `currentPath` (or null if there were no
     * changes).
     *
     * @param currentPath The path at the current nesting level. Can be set to
     * FieldValue.emptyPath() to represent the root.
     * @param currentOverlays The overlays at the current nesting level in the
     * same format as `overlayMap`.
     * @return The merged data at `currentPath` or null if no modifications
     * were applied.
     */
    t.prototype.nn = function(t2, e) {
      var n2 = this, r2 = false, i2 = this.Ze.field(t2), o = Ne(i2) ? (
        // If there is already data at the current path, base our
        Object.assign({}, i2.mapValue.fields)
      ) : {};
      return e.forEach(function(e2, i3) {
        if (e2 instanceof Map) {
          var s = n2.nn(t2.child(i3), e2);
          null != s && (o[i3] = s, r2 = true);
        } else
          null !== e2 ? (o[i3] = e2, r2 = true) : o.hasOwnProperty(i3) && (delete o[i3], r2 = true);
      }), r2 ? {
        mapValue: {
          fields: o
        }
      } : null;
    }, t;
  }()
);
function jn(t) {
  var e = [];
  return R2(t.fields || {}, function(t2, n2) {
    var r2 = new C2([t2]);
    if (Ne(n2)) {
      var i2 = jn(n2.mapValue).fields;
      if (0 === i2.length)
        e.push(r2);
      else
        for (var o = 0, s = i2; o < s.length; o++) {
          var u4 = s[o];
          e.push(r2.child(u4));
        }
    } else
      e.push(r2);
  }), new bn(e);
}
var Gn = function(t, e) {
  this.key = t, this.version = e;
};
var zn = (
  /** @class */
  function(e) {
    function n2(t, n3, r2, i2) {
      var o = this;
      return (o = e.call(this, t, n3) || this).sn = r2, o.Je = !!i2.Je, o.hasCommittedMutations = !!i2.hasCommittedMutations, o;
    }
    return __extends(n2, e), n2.prototype.field = function(t) {
      return this.sn.field(t);
    }, n2.prototype.data = function() {
      return this.sn;
    }, n2.prototype.rn = function() {
      return this.sn.proto;
    }, n2.prototype.isEqual = function(t) {
      return t instanceof n2 && this.key.isEqual(t.key) && this.version.isEqual(t.version) && this.Je === t.Je && this.hasCommittedMutations === t.hasCommittedMutations && this.sn.isEqual(t.sn);
    }, n2.prototype.toString = function() {
      return "Document(" + this.key + ", " + this.version + ", " + this.sn.toString() + ", {hasLocalMutations: " + this.Je + "}), {hasCommittedMutations: " + this.hasCommittedMutations + "})";
    }, Object.defineProperty(n2.prototype, "hasPendingWrites", {
      get: function() {
        return this.Je || this.hasCommittedMutations;
      },
      enumerable: false,
      configurable: true
    }), n2;
  }(Gn)
);
var Bn = (
  /** @class */
  function(e) {
    function n2(t, n3, r2) {
      var i2 = this;
      return (i2 = e.call(this, t, n3) || this).hasCommittedMutations = !(!r2 || !r2.hasCommittedMutations), i2;
    }
    return __extends(n2, e), n2.prototype.toString = function() {
      return "NoDocument(" + this.key + ", " + this.version + ")";
    }, Object.defineProperty(n2.prototype, "hasPendingWrites", {
      get: function() {
        return this.hasCommittedMutations;
      },
      enumerable: false,
      configurable: true
    }), n2.prototype.isEqual = function(t) {
      return t instanceof n2 && t.hasCommittedMutations === this.hasCommittedMutations && t.version.isEqual(this.version) && t.key.isEqual(this.key);
    }, n2;
  }(Gn)
);
var Kn = (
  /** @class */
  function(e) {
    function n2() {
      return null !== e && e.apply(this, arguments) || this;
    }
    return __extends(n2, e), n2.prototype.toString = function() {
      return "UnknownDocument(" + this.key + ", " + this.version + ")";
    }, Object.defineProperty(n2.prototype, "hasPendingWrites", {
      get: function() {
        return true;
      },
      enumerable: false,
      configurable: true
    }), n2.prototype.isEqual = function(t) {
      return t instanceof n2 && t.version.isEqual(this.version) && t.key.isEqual(this.key);
    }, n2;
  }(Gn)
);
var Wn = (
  /**
       * Initializes a Query with a path and optional additional query constraints.
       * Path must currently be empty if this is a collection group query.
       */
  function(t, e, n2, r2, i2, o, s, u4) {
    void 0 === e && (e = null), void 0 === n2 && (n2 = []), void 0 === r2 && (r2 = []), void 0 === i2 && (i2 = null), void 0 === o && (o = "F"), void 0 === s && (s = null), void 0 === u4 && (u4 = null), this.path = t, this.collectionGroup = e, this.on = n2, this.filters = r2, this.limit = i2, this.an = o, this.startAt = s, this.endAt = u4, this.cn = null, // The corresponding `Target` of this `Query` instance.
    this.un = null, this.startAt, this.endAt;
  }
);
function Qn(t, e, n2, r2, i2, o, s, u4) {
  return new Wn(t, e, n2, r2, i2, o, s, u4);
}
function Hn(t) {
  return new Wn(t);
}
function Yn(t) {
  return !wt(t.limit) && "F" === t.an;
}
function $n(t) {
  return !wt(t.limit) && "L" === t.an;
}
function Xn(t) {
  return t.on.length > 0 ? t.on[0].field : null;
}
function Jn(t) {
  for (var e = 0, n2 = t.filters; e < n2.length; e++) {
    var r2 = n2[e];
    if (r2.hn())
      return r2.field;
  }
  return null;
}
function Zn(t) {
  return null !== t.collectionGroup;
}
function tr(t) {
  var e = x2(t);
  if (null === e.cn) {
    e.cn = [];
    var n2 = Jn(e), r2 = Xn(e);
    if (null !== n2 && null === r2)
      n2.p() || e.cn.push(new _r(n2)), e.cn.push(new _r(
        C2.v(),
        "asc"
        /* ASCENDING */
      ));
    else {
      for (var i2 = false, o = 0, s = e.on; o < s.length; o++) {
        var u4 = s[o];
        e.cn.push(u4), u4.field.p() && (i2 = true);
      }
      if (!i2) {
        var a = e.on.length > 0 ? e.on[e.on.length - 1].dir : "asc";
        e.cn.push(new _r(C2.v(), a));
      }
    }
  }
  return e.cn;
}
function er(t) {
  var e = x2(t);
  if (!e.un)
    if ("F" === e.an)
      e.un = _t(e.path, e.collectionGroup, tr(e), e.filters, e.limit, e.startAt, e.endAt);
    else {
      for (var n2 = [], r2 = 0, i2 = tr(e); r2 < i2.length; r2++) {
        var o = i2[r2], s = "desc" === o.dir ? "asc" : "desc";
        n2.push(new _r(o.field, s));
      }
      var u4 = e.endAt ? new wr(e.endAt.position, !e.endAt.before) : null, a = e.startAt ? new wr(e.startAt.position, !e.startAt.before) : null;
      e.un = _t(e.path, e.collectionGroup, n2, e.filters, e.limit, u4, a);
    }
  return e.un;
}
function nr(t, e, n2) {
  return new Wn(t.path, t.collectionGroup, t.on.slice(), t.filters.slice(), e, n2, t.startAt, t.endAt);
}
function rr(t, e) {
  return new Wn(t.path, t.collectionGroup, t.on.slice(), t.filters.slice(), t.limit, t.an, e, t.endAt);
}
function ir(t, e) {
  return new Wn(t.path, t.collectionGroup, t.on.slice(), t.filters.slice(), t.limit, t.an, t.startAt, e);
}
function or(t, e) {
  return Nt(er(t), er(e)) && t.an === e.an;
}
function sr(t) {
  return Tt(er(t)) + "|lt:" + t.an;
}
function ur(t) {
  return "Query(target=" + function(t2) {
    var e = t2.path.R();
    return null !== t2.collectionGroup && (e += " collectionGroup=" + t2.collectionGroup), t2.filters.length > 0 && (e += ", filters: [" + t2.filters.map(function(t3) {
      return (e2 = t3).field.R() + " " + e2.op + " " + ve(e2.value);
      var e2;
    }).join(", ") + "]"), wt(t2.limit) || (e += ", limit: " + t2.limit), t2.orderBy.length > 0 && (e += ", orderBy: [" + t2.orderBy.map(function(t3) {
      return (e2 = t3).field.R() + " (" + e2.dir + ")";
      var e2;
    }).join(", ") + "]"), t2.startAt && (e += ", startAt: " + br(t2.startAt)), t2.endAt && (e += ", endAt: " + br(t2.endAt)), "Target(" + e + ")";
  }(er(t)) + "; limitType=" + t.an + ")";
}
function ar(t, e) {
  return function(t2, e2) {
    var n2 = e2.key.path;
    return null !== t2.collectionGroup ? e2.key.N(t2.collectionGroup) && t2.path.T(n2) : F2.F(t2.path) ? t2.path.isEqual(n2) : t2.path.I(n2);
  }(t, e) && function(t2, e2) {
    for (var n2 = 0, r2 = t2.on; n2 < r2.length; n2++) {
      var i2 = r2[n2];
      if (!i2.field.p() && null === e2.field(i2.field))
        return false;
    }
    return true;
  }(t, e) && function(t2, e2) {
    for (var n2 = 0, r2 = t2.filters; n2 < r2.length; n2++) {
      if (!r2[n2].matches(e2))
        return false;
    }
    return true;
  }(t, e) && function(t2, e2) {
    return !(t2.startAt && !Ir(t2.startAt, tr(t2), e2)) && (!t2.endAt || !Ir(t2.endAt, tr(t2), e2));
  }(t, e);
}
function cr(t) {
  return function(e, n2) {
    for (var r2 = false, i2 = 0, o = tr(t); i2 < o.length; i2++) {
      var s = o[i2], u4 = Tr(s, e, n2);
      if (0 !== u4)
        return u4;
      r2 = r2 || s.field.p();
    }
    return 0;
  };
}
var hr = (
  /** @class */
  function(e) {
    function n2(t, n3, r2) {
      var i2 = this;
      return (i2 = e.call(this) || this).field = t, i2.op = n3, i2.value = r2, i2;
    }
    return __extends(n2, e), n2.create = function(t, e2, r2) {
      if (t.p())
        return "in" === e2 || "not-in" === e2 ? this.ln(t, e2, r2) : new fr(t, e2, r2);
      if (_e(r2)) {
        if ("==" !== e2 && "!=" !== e2)
          throw new I2(b.INVALID_ARGUMENT, "Invalid query. Null only supports '==' and '!=' comparisons.");
        return new n2(t, e2, r2);
      }
      if (Te(r2)) {
        if ("==" !== e2 && "!=" !== e2)
          throw new I2(b.INVALID_ARGUMENT, "Invalid query. NaN only supports '==' and '!=' comparisons.");
        return new n2(t, e2, r2);
      }
      return "array-contains" === e2 ? new vr(t, r2) : "in" === e2 ? new yr(t, r2) : "not-in" === e2 ? new mr(t, r2) : "array-contains-any" === e2 ? new gr(t, r2) : new n2(t, e2, r2);
    }, n2.ln = function(t, e2, n3) {
      return "in" === e2 ? new lr(t, n3) : new pr(t, n3);
    }, n2.prototype.matches = function(t) {
      var e2 = t.field(this.field);
      return "!=" === this.op ? null !== e2 && this._n(pe(e2, this.value)) : null !== e2 && he(this.value) === he(e2) && this._n(pe(e2, this.value));
    }, n2.prototype._n = function(t) {
      switch (this.op) {
        case "<":
          return t < 0;
        case "<=":
          return t <= 0;
        case "==":
          return 0 === t;
        case "!=":
          return 0 !== t;
        case ">":
          return t > 0;
        case ">=":
          return t >= 0;
        default:
          return D2();
      }
    }, n2.prototype.hn = function() {
      return [
        "<",
        "<=",
        ">",
        ">=",
        "!=",
        "not-in"
        /* NOT_IN */
      ].indexOf(this.op) >= 0;
    }, n2;
  }(function() {
  })
);
var fr = (
  /** @class */
  function(e) {
    function n2(t, n3, r2) {
      var i2 = this;
      return (i2 = e.call(this, t, n3, r2) || this).key = F2.C(r2.referenceValue), i2;
    }
    return __extends(n2, e), n2.prototype.matches = function(t) {
      var e2 = F2.i(t.key, this.key);
      return this._n(e2);
    }, n2;
  }(hr)
);
var lr = (
  /** @class */
  function(e) {
    function n2(t, n3) {
      var r2 = this;
      return (r2 = e.call(this, t, "in", n3) || this).keys = dr("in", n3), r2;
    }
    return __extends(n2, e), n2.prototype.matches = function(t) {
      return this.keys.some(function(e2) {
        return e2.isEqual(t.key);
      });
    }, n2;
  }(hr)
);
var pr = (
  /** @class */
  function(e) {
    function n2(t, n3) {
      var r2 = this;
      return (r2 = e.call(this, t, "not-in", n3) || this).keys = dr("not-in", n3), r2;
    }
    return __extends(n2, e), n2.prototype.matches = function(t) {
      return !this.keys.some(function(e2) {
        return e2.isEqual(t.key);
      });
    }, n2;
  }(hr)
);
function dr(t, e) {
  var n2;
  return ((null === (n2 = e.arrayValue) || void 0 === n2 ? void 0 : n2.values) || []).map(function(t2) {
    return F2.C(t2.referenceValue);
  });
}
var vr = (
  /** @class */
  function(e) {
    function n2(t, n3) {
      return e.call(this, t, "array-contains", n3) || this;
    }
    return __extends(n2, e), n2.prototype.matches = function(t) {
      var e2 = t.field(this.field);
      return Ee(e2) && le(e2.arrayValue, this.value);
    }, n2;
  }(hr)
);
var yr = (
  /** @class */
  function(e) {
    function n2(t, n3) {
      return e.call(this, t, "in", n3) || this;
    }
    return __extends(n2, e), n2.prototype.matches = function(t) {
      var e2 = t.field(this.field);
      return null !== e2 && le(this.value.arrayValue, e2);
    }, n2;
  }(hr)
);
var mr = (
  /** @class */
  function(e) {
    function n2(t, n3) {
      return e.call(this, t, "not-in", n3) || this;
    }
    return __extends(n2, e), n2.prototype.matches = function(t) {
      if (le(this.value.arrayValue, {
        nullValue: "NULL_VALUE"
      }))
        return false;
      var e2 = t.field(this.field);
      return null !== e2 && !le(this.value.arrayValue, e2);
    }, n2;
  }(hr)
);
var gr = (
  /** @class */
  function(e) {
    function n2(t, n3) {
      return e.call(this, t, "array-contains-any", n3) || this;
    }
    return __extends(n2, e), n2.prototype.matches = function(t) {
      var e2 = this, n3 = t.field(this.field);
      return !(!Ee(n3) || !n3.arrayValue.values) && n3.arrayValue.values.some(function(t2) {
        return le(e2.value.arrayValue, t2);
      });
    }, n2;
  }(hr)
);
var wr = function(t, e) {
  this.position = t, this.before = e;
};
function br(t) {
  return (t.before ? "b" : "a") + ":" + t.position.map(function(t2) {
    return ve(t2);
  }).join(",");
}
function Ir(t, e, n2) {
  for (var r2 = 0, i2 = 0; i2 < t.position.length; i2++) {
    var o = e[i2], s = t.position[i2];
    if (r2 = o.field.p() ? F2.i(F2.C(s.referenceValue), n2.key) : pe(s, n2.field(o.field)), "desc" === o.dir && (r2 *= -1), 0 !== r2)
      break;
  }
  return t.before ? r2 <= 0 : r2 < 0;
}
function Er(t, e) {
  if (null === t)
    return null === e;
  if (null === e)
    return false;
  if (t.before !== e.before || t.position.length !== e.position.length)
    return false;
  for (var n2 = 0; n2 < t.position.length; n2++)
    if (!fe(t.position[n2], e.position[n2]))
      return false;
  return true;
}
var _r = function(t, e) {
  void 0 === e && (e = "asc"), this.field = t, this.dir = e;
};
function Tr(t, e, n2) {
  var r2 = t.field.p() ? F2.i(e.key, n2.key) : function(t2, e2, n3) {
    var r3 = e2.field(t2), i2 = n3.field(t2);
    return null !== r3 && null !== i2 ? pe(r3, i2) : D2();
  }(t.field, e, n2);
  switch (t.dir) {
    case "asc":
      return r2;
    case "desc":
      return -1 * r2;
    default:
      return D2();
  }
}
function Nr(t, e) {
  return t.dir === e.dir && t.field.isEqual(e.field);
}
var Ar = function() {
  var t = this;
  this.promise = new Promise(function(e, n2) {
    t.resolve = e, t.reject = n2;
  });
};
var Sr = (
  /** @class */
  function() {
    function t(t2, e, n2, r2, i2) {
      void 0 === n2 && (n2 = 1e3), void 0 === r2 && (r2 = 1.5), void 0 === i2 && (i2 = 6e4), this.fn = t2, this.dn = e, this.wn = n2, this.mn = r2, this.Tn = i2, this.En = 0, this.In = null, /** The last backoff attempt, as epoch milliseconds. */
      this.An = Date.now(), this.reset();
    }
    return t.prototype.reset = function() {
      this.En = 0;
    }, /**
     * Resets the backoff delay to the maximum delay (e.g. for use after a
     * RESOURCE_EXHAUSTED error).
     */
    t.prototype.Rn = function() {
      this.En = this.Tn;
    }, /**
     * Returns a promise that resolves after currentDelayMs, and increases the
     * delay for any subsequent attempts. If there was a pending backoff operation
     * already, it will be canceled.
     */
    t.prototype.gn = function(t2) {
      var e = this;
      this.cancel();
      var n2 = Math.floor(this.En + this.Pn()), r2 = Math.max(0, Date.now() - this.An), i2 = Math.max(0, n2 - r2);
      i2 > 0 && T2("ExponentialBackoff", "Backing off for " + i2 + " ms (base delay: " + this.En + " ms, delay with jitter: " + n2 + " ms, last attempt: " + r2 + " ms ago)"), this.In = this.fn.yn(this.dn, i2, function() {
        return e.An = Date.now(), t2();
      }), // Apply backoff factor to determine next delay and ensure it is within
      // bounds.
      this.En *= this.mn, this.En < this.wn && (this.En = this.wn), this.En > this.Tn && (this.En = this.Tn);
    }, t.prototype.Vn = function() {
      null !== this.In && (this.In.pn(), this.In = null);
    }, t.prototype.cancel = function() {
      null !== this.In && (this.In.cancel(), this.In = null);
    }, /** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */
    t.prototype.Pn = function() {
      return (Math.random() - 0.5) * this.En;
    }, t;
  }()
);
var Dr = (
  /** @class */
  function() {
    function t(t2) {
      var e = this;
      this.bn = null, this.vn = null, // When the operation resolves, we'll set result or error and mark isDone.
      this.result = void 0, this.error = void 0, this.Sn = false, // Set to true when .then() or .catch() are called and prevents additional
      // chaining.
      this.Dn = false, t2(function(t3) {
        e.Sn = true, e.result = t3, e.bn && // value should be defined unless T is Void, but we can't express
        // that in the type system.
        e.bn(t3);
      }, function(t3) {
        e.Sn = true, e.error = t3, e.vn && e.vn(t3);
      });
    }
    return t.prototype.catch = function(t2) {
      return this.next(void 0, t2);
    }, t.prototype.next = function(e, n2) {
      var r2 = this;
      return this.Dn && D2(), this.Dn = true, this.Sn ? this.error ? this.Cn(n2, this.error) : this.Nn(e, this.result) : new t(function(t2, i2) {
        r2.bn = function(n3) {
          r2.Nn(e, n3).next(t2, i2);
        }, r2.vn = function(e2) {
          r2.Cn(n2, e2).next(t2, i2);
        };
      });
    }, t.prototype.Fn = function() {
      var t2 = this;
      return new Promise(function(e, n2) {
        t2.next(e, n2);
      });
    }, t.prototype.xn = function(e) {
      try {
        var n2 = e();
        return n2 instanceof t ? n2 : t.resolve(n2);
      } catch (e2) {
        return t.reject(e2);
      }
    }, t.prototype.Nn = function(e, n2) {
      return e ? this.xn(function() {
        return e(n2);
      }) : t.resolve(n2);
    }, t.prototype.Cn = function(e, n2) {
      return e ? this.xn(function() {
        return e(n2);
      }) : t.reject(n2);
    }, t.resolve = function(e) {
      return new t(function(t2, n2) {
        t2(e);
      });
    }, t.reject = function(e) {
      return new t(function(t2, n2) {
        n2(e);
      });
    }, t.$n = function(e) {
      return new t(function(t2, n2) {
        var r2 = 0, i2 = 0, o = false;
        e.forEach(function(e2) {
          ++r2, e2.next(function() {
            ++i2, o && i2 === r2 && t2();
          }, function(t3) {
            return n2(t3);
          });
        }), o = true, i2 === r2 && t2();
      });
    }, /**
     * Given an array of predicate functions that asynchronously evaluate to a
     * boolean, implements a short-circuiting `or` between the results. Predicates
     * will be evaluated until one of them returns `true`, then stop. The final
     * result will be whether any of them returned `true`.
     */
    t.kn = function(e) {
      for (var n2 = t.resolve(false), r2 = function(e2) {
        n2 = n2.next(function(n3) {
          return n3 ? t.resolve(n3) : e2();
        });
      }, i2 = 0, o = e; i2 < o.length; i2++) {
        r2(o[i2]);
      }
      return n2;
    }, t.forEach = function(t2, e) {
      var n2 = this, r2 = [];
      return t2.forEach(function(t3, i2) {
        r2.push(e.call(n2, t3, i2));
      }), this.$n(r2);
    }, t;
  }()
);
var kr = (
  /** @class */
  function() {
    function t(e, n2, r2) {
      this.name = e, this.version = n2, this.Mn = r2, // NOTE: According to https://bugs.webkit.org/show_bug.cgi?id=197050, the
      // bug we're checking for should exist in iOS >= 12.2 and < 13, but for
      // whatever reason it's much harder to hit after 12.2 so we only proactively
      // log on 12.2.
      12.2 === t.On(getUA()) && N2("Firestore persistence suffers from a bug in iOS 12.2 Safari that may cause your app to stop working. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.");
    }
    return t.delete = function(t2) {
      return T2("SimpleDb", "Removing database:", t2), Vr(window.indexedDB.deleteDatabase(t2)).Fn();
    }, /** Returns true if IndexedDB is available in the current environment. */
    t.Ln = function() {
      if ("undefined" == typeof indexedDB)
        return false;
      if (t.Bn())
        return true;
      var e = getUA(), n2 = t.On(e), r2 = 0 < n2 && n2 < 10, i2 = t.qn(e), o = 0 < i2 && i2 < 4.5;
      return !(e.indexOf("MSIE ") > 0 || e.indexOf("Trident/") > 0 || e.indexOf("Edge/") > 0 || r2 || o);
    }, /**
     * Returns true if the backing IndexedDB store is the Node IndexedDBShim
     * (see https://github.com/axemclion/IndexedDBShim).
     */
    t.Bn = function() {
      var t2;
      return "undefined" != typeof process && "YES" === (null === (t2 = process.env) || void 0 === t2 ? void 0 : t2.Un);
    }, /** Helper to get a typed SimpleDbStore from a transaction. */
    t.Qn = function(t2, e) {
      return t2.store(e);
    }, // visible for testing
    /** Parse User Agent to determine iOS version. Returns -1 if not found. */
    t.On = function(t2) {
      var e = t2.match(/i(?:phone|pad|pod) os ([\d_]+)/i), n2 = e ? e[1].split("_").slice(0, 2).join(".") : "-1";
      return Number(n2);
    }, // visible for testing
    /** Parse User Agent to determine Android version. Returns -1 if not found. */
    t.qn = function(t2) {
      var e = t2.match(/Android ([\d.]+)/i), n2 = e ? e[1].split(".").slice(0, 2).join(".") : "-1";
      return Number(n2);
    }, /**
     * Opens the specified database, creating or upgrading it if necessary.
     */
    t.prototype.Wn = function(t2) {
      return __awaiter(this, void 0, void 0, function() {
        var e, r2 = this;
        return __generator(this, function(n2) {
          switch (n2.label) {
            case 0:
              return this.db ? [3, 2] : (T2("SimpleDb", "Opening database:", this.name), e = this, [4, new Promise(function(e2, n3) {
                var i2 = indexedDB.open(r2.name, r2.version);
                i2.onsuccess = function(t3) {
                  var n4 = t3.target.result;
                  e2(n4);
                }, i2.onblocked = function() {
                  n3(new Lr(t2, "Cannot upgrade IndexedDB schema while another tab is open. Close all tabs that access Firestore and reload this page to proceed."));
                }, i2.onerror = function(e3) {
                  var r3 = e3.target.error;
                  "VersionError" === r3.name ? n3(new I2(b.FAILED_PRECONDITION, "A newer version of the Firestore SDK was previously used and so the persisted data is not compatible with the version of the SDK you are now using. The SDK will operate with persistence disabled. If you need persistence, please re-upgrade to a newer version of the SDK or else clear the persisted IndexedDB data for your app to start fresh.")) : n3(new Lr(t2, r3));
                }, i2.onupgradeneeded = function(t3) {
                  T2("SimpleDb", 'Database "' + r2.name + '" requires upgrade from version:', t3.oldVersion);
                  var e3 = t3.target.result;
                  r2.Mn.createOrUpgrade(e3, i2.transaction, t3.oldVersion, r2.version).next(function() {
                    T2("SimpleDb", "Database upgrade to version " + r2.version + " complete");
                  });
                };
              })]);
            case 1:
              e.db = n2.sent(), n2.label = 2;
            case 2:
              return [2, (this.jn && (this.db.onversionchange = function(t3) {
                return r2.jn(t3);
              }), this.db)];
          }
        });
      });
    }, t.prototype.Kn = function(t2) {
      this.jn = t2, this.db && (this.db.onversionchange = function(e) {
        return t2(e);
      });
    }, t.prototype.runTransaction = function(t2, r2, i2, o) {
      return __awaiter(this, void 0, void 0, function() {
        var e, s, u4, a, c;
        return __generator(this, function(h) {
          switch (h.label) {
            case 0:
              e = "readonly" === r2, s = 0, u4 = function() {
                var r3, u5, c2, h2, f;
                return __generator(this, function(n2) {
                  switch (n2.label) {
                    case 0:
                      ++s, n2.label = 1;
                    case 1:
                      return n2.trys.push([1, 4, , 5]), [4, a.Wn(t2)];
                    case 2:
                      return a.db = n2.sent(), r3 = Or.open(a.db, t2, e ? "readonly" : "readwrite", i2), u5 = o(r3).catch(function(t3) {
                        return r3.abort(t3), Dr.reject(t3);
                      }).Fn(), c2 = {}, u5.catch(function() {
                      }), [4, r3.Gn];
                    case 3:
                      return [2, (c2.value = // Wait for the transaction to complete (i.e. IndexedDb's onsuccess event to
                      // fire), but still return the original transactionFnResult back to the
                      // caller.
                      (n2.sent(), u5), c2)];
                    case 4:
                      return h2 = n2.sent(), f = "FirebaseError" !== h2.name && s < 3, T2("SimpleDb", "Transaction failed with error:", h2.message, "Retrying:", f), a.close(), f ? [3, 5] : [2, {
                        value: Promise.reject(h2)
                      }];
                    case 5:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              }, a = this, h.label = 1;
            case 1:
              return [5, u4()];
            case 2:
              if ("object" == typeof (c = h.sent()))
                return [2, c.value];
              h.label = 3;
            case 3:
              return [3, 1];
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, t.prototype.close = function() {
      this.db && this.db.close(), this.db = void 0;
    }, t;
  }()
);
var xr = (
  /** @class */
  function() {
    function t(t2) {
      this.zn = t2, this.Hn = false, this.Yn = null;
    }
    return Object.defineProperty(t.prototype, "Sn", {
      get: function() {
        return this.Hn;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "Jn", {
      get: function() {
        return this.Yn;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "cursor", {
      set: function(t2) {
        this.zn = t2;
      },
      enumerable: false,
      configurable: true
    }), /**
     * This function can be called to stop iteration at any point.
     */
    t.prototype.done = function() {
      this.Hn = true;
    }, /**
     * This function can be called to skip to that next key, which could be
     * an index or a primary key.
     */
    t.prototype.Xn = function(t2) {
      this.Yn = t2;
    }, /**
     * Delete the current cursor value from the object store.
     *
     * NOTE: You CANNOT do this with a keysOnly query.
     */
    t.prototype.delete = function() {
      return Vr(this.zn.delete());
    }, t;
  }()
);
var Lr = (
  /** @class */
  function(e) {
    function n2(t, n3) {
      var r2 = this;
      return (r2 = e.call(this, b.UNAVAILABLE, "IndexedDB transaction '" + t + "' failed: " + n3) || this).name = "IndexedDbTransactionError", r2;
    }
    return __extends(n2, e), n2;
  }(I2)
);
function Rr(t) {
  return "IndexedDbTransactionError" === t.name;
}
var Or = (
  /** @class */
  function() {
    function t(t2, e) {
      var n2 = this;
      this.action = t2, this.transaction = e, this.aborted = false, /**
           * A promise that resolves with the result of the IndexedDb transaction.
           */
      this.Zn = new Ar(), this.transaction.oncomplete = function() {
        n2.Zn.resolve();
      }, this.transaction.onabort = function() {
        e.error ? n2.Zn.reject(new Lr(t2, e.error)) : n2.Zn.resolve();
      }, this.transaction.onerror = function(e2) {
        var r2 = Cr(e2.target.error);
        n2.Zn.reject(new Lr(t2, r2));
      };
    }
    return t.open = function(e, n2, r2, i2) {
      try {
        return new t(n2, e.transaction(i2, r2));
      } catch (e2) {
        throw new Lr(n2, e2);
      }
    }, Object.defineProperty(t.prototype, "Gn", {
      get: function() {
        return this.Zn.promise;
      },
      enumerable: false,
      configurable: true
    }), t.prototype.abort = function(t2) {
      t2 && this.Zn.reject(t2), this.aborted || (T2("SimpleDb", "Aborting transaction:", t2 ? t2.message : "Client-initiated abort"), this.aborted = true, this.transaction.abort());
    }, /**
     * Returns a SimpleDbStore<KeyType, ValueType> for the specified store. All
     * operations performed on the SimpleDbStore happen within the context of this
     * transaction and it cannot be used anymore once the transaction is
     * completed.
     *
     * Note that we can't actually enforce that the KeyType and ValueType are
     * correct, but they allow type safety through the rest of the consuming code.
     */
    t.prototype.store = function(t2) {
      var e = this.transaction.objectStore(t2);
      return new Pr(e);
    }, t;
  }()
);
var Pr = (
  /** @class */
  function() {
    function t(t2) {
      this.store = t2;
    }
    return t.prototype.put = function(t2, e) {
      var n2;
      return void 0 !== e ? (T2("SimpleDb", "PUT", this.store.name, t2, e), n2 = this.store.put(e, t2)) : (T2("SimpleDb", "PUT", this.store.name, "<auto-key>", t2), n2 = this.store.put(t2)), Vr(n2);
    }, /**
     * Adds a new value into an Object Store and returns the new key. Similar to
     * IndexedDb's `add()`, this method will fail on primary key collisions.
     *
     * @param value The object to write.
     * @return The key of the value to add.
     */
    t.prototype.add = function(t2) {
      return T2("SimpleDb", "ADD", this.store.name, t2, t2), Vr(this.store.add(t2));
    }, /**
     * Gets the object with the specified key from the specified store, or null
     * if no object exists with the specified key.
     *
     * @key The key of the object to get.
     * @return The object with the specified key or null if no object exists.
     */
    t.prototype.get = function(t2) {
      var e = this;
      return Vr(this.store.get(t2)).next(function(n2) {
        return void 0 === n2 && (n2 = null), T2("SimpleDb", "GET", e.store.name, t2, n2), n2;
      });
    }, t.prototype.delete = function(t2) {
      return T2("SimpleDb", "DELETE", this.store.name, t2), Vr(this.store.delete(t2));
    }, /**
     * If we ever need more of the count variants, we can add overloads. For now,
     * all we need is to count everything in a store.
     *
     * Returns the number of rows in the store.
     */
    t.prototype.count = function() {
      return T2("SimpleDb", "COUNT", this.store.name), Vr(this.store.count());
    }, t.prototype.ts = function(t2, e) {
      var n2 = this.cursor(this.options(t2, e)), r2 = [];
      return this.es(n2, function(t3, e2) {
        r2.push(e2);
      }).next(function() {
        return r2;
      });
    }, t.prototype.ns = function(t2, e) {
      T2("SimpleDb", "DELETE ALL", this.store.name);
      var n2 = this.options(t2, e);
      n2.ss = false;
      var r2 = this.cursor(n2);
      return this.es(r2, function(t3, e2, n3) {
        return n3.delete();
      });
    }, t.prototype.rs = function(t2, e) {
      var n2;
      e ? n2 = t2 : (n2 = {}, e = t2);
      var r2 = this.cursor(n2);
      return this.es(r2, e);
    }, /**
     * Iterates over a store, but waits for the given callback to complete for
     * each entry before iterating the next entry. This allows the callback to do
     * asynchronous work to determine if this iteration should continue.
     *
     * The provided callback should return `true` to continue iteration, and
     * `false` otherwise.
     */
    t.prototype.os = function(t2) {
      var e = this.cursor({});
      return new Dr(function(n2, r2) {
        e.onerror = function(t3) {
          var e2 = Cr(t3.target.error);
          r2(e2);
        }, e.onsuccess = function(e2) {
          var r3 = e2.target.result;
          r3 ? t2(r3.primaryKey, r3.value).next(function(t3) {
            t3 ? r3.continue() : n2();
          }) : n2();
        };
      });
    }, t.prototype.es = function(t2, e) {
      var n2 = [];
      return new Dr(function(r2, i2) {
        t2.onerror = function(t3) {
          i2(t3.target.error);
        }, t2.onsuccess = function(t3) {
          var i3 = t3.target.result;
          if (i3) {
            var o = new xr(i3), s = e(i3.primaryKey, i3.value, o);
            if (s instanceof Dr) {
              var u4 = s.catch(function(t4) {
                return o.done(), Dr.reject(t4);
              });
              n2.push(u4);
            }
            o.Sn ? r2() : null === o.Jn ? i3.continue() : i3.continue(o.Jn);
          } else
            r2();
        };
      }).next(function() {
        return Dr.$n(n2);
      });
    }, t.prototype.options = function(t2, e) {
      var n2 = void 0;
      return void 0 !== t2 && ("string" == typeof t2 ? n2 = t2 : e = t2), {
        index: n2,
        range: e
      };
    }, t.prototype.cursor = function(t2) {
      var e = "next";
      if (t2.reverse && (e = "prev"), t2.index) {
        var n2 = this.store.index(t2.index);
        return t2.ss ? n2.openKeyCursor(t2.range, e) : n2.openCursor(t2.range, e);
      }
      return this.store.openCursor(t2.range, e);
    }, t;
  }()
);
function Vr(t) {
  return new Dr(function(e, n2) {
    t.onsuccess = function(t2) {
      var n3 = t2.target.result;
      e(n3);
    }, t.onerror = function(t2) {
      var e2 = Cr(t2.target.error);
      n2(e2);
    };
  });
}
var Ur = false;
function Cr(t) {
  var e = kr.On(getUA());
  if (e >= 12.2 && e < 13) {
    var n2 = "An internal error was encountered in the Indexed Database server";
    if (t.message.indexOf(n2) >= 0) {
      var r2 = new I2("internal", "IOS_INDEXEDDB_BUG1: IndexedDb has thrown '" + n2 + "'. This is likely due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.");
      return Ur || (Ur = true, // Throw a global exception outside of this promise chain, for the user to
      // potentially catch.
      setTimeout(function() {
        throw r2;
      }, 0)), r2;
    }
  }
  return t;
}
function Fr() {
  return "undefined" != typeof window ? window : null;
}
function Mr() {
  return "undefined" != typeof document ? document : null;
}
var qr = (
  /** @class */
  function() {
    function t(t2, e, n2, r2, i2) {
      this.cs = t2, this.dn = e, this.us = n2, this.op = r2, this.hs = i2, this.ls = new Ar(), this.then = this.ls.promise.then.bind(this.ls.promise), // It's normal for the deferred promise to be canceled (due to cancellation)
      // and so we attach a dummy catch callback to avoid
      // 'UnhandledPromiseRejectionWarning' log spam.
      this.ls.promise.catch(function(t3) {
      });
    }
    return t._s = function(e, n2, r2, i2, o) {
      var s = new t(e, n2, Date.now() + r2, i2, o);
      return s.start(r2), s;
    }, /**
     * Starts the timer. This is called immediately after construction by
     * createAndSchedule().
     */
    t.prototype.start = function(t2) {
      var e = this;
      this.fs = setTimeout(function() {
        return e.ds();
      }, t2);
    }, /**
     * Queues the operation to run immediately (if it hasn't already been run or
     * canceled).
     */
    t.prototype.pn = function() {
      return this.ds();
    }, /**
     * Cancels the operation if it hasn't already been executed or canceled. The
     * promise will be rejected.
     *
     * As long as the operation has not yet been run, calling cancel() provides a
     * guarantee that the operation will not be run.
     */
    t.prototype.cancel = function(t2) {
      null !== this.fs && (this.clearTimeout(), this.ls.reject(new I2(b.CANCELLED, "Operation cancelled" + (t2 ? ": " + t2 : ""))));
    }, t.prototype.ds = function() {
      var t2 = this;
      this.cs.ws(function() {
        return null !== t2.fs ? (t2.clearTimeout(), t2.op().then(function(e) {
          return t2.ls.resolve(e);
        })) : Promise.resolve();
      });
    }, t.prototype.clearTimeout = function() {
      null !== this.fs && (this.hs(this), clearTimeout(this.fs), this.fs = null);
    }, t;
  }()
);
var jr = (
  /** @class */
  function() {
    function t() {
      var t2 = this;
      this.Ts = Promise.resolve(), // A list of retryable operations. Retryable operations are run in order and
      // retried with backoff.
      this.Es = [], // Is this AsyncQueue being shut down? Once it is set to true, it will not
      // be changed again.
      this.Is = false, // Operations scheduled to be queued in the future. Operations are
      // automatically removed after they are run or canceled.
      this.As = [], // visible for testing
      this.Rs = null, // Flag set while there's an outstanding AsyncQueue operation, used for
      // assertion sanity-checks.
      this.gs = false, // List of TimerIds to fast-forward delays for.
      this.Ps = [], // Backoff timer used to schedule retries for retryable operations
      this.ys = new Sr(
        this,
        "async_queue_retry"
        /* AsyncQueueRetry */
      ), // Visibility handler that triggers an immediate retry of all retryable
      // operations. Meant to speed up recovery when we regain file system access
      // after page comes into foreground.
      this.Vs = function() {
        var e2 = Mr();
        e2 && T2("AsyncQueue", "Visibility state changed to  ", e2.visibilityState), t2.ys.Vn();
      };
      var e = Mr();
      e && "function" == typeof e.addEventListener && e.addEventListener("visibilitychange", this.Vs);
    }
    return Object.defineProperty(t.prototype, "ps", {
      // Is this AsyncQueue being shut down? If true, this instance will not enqueue
      // any new operations, Promises from enqueue requests will not resolve.
      get: function() {
        return this.Is;
      },
      enumerable: false,
      configurable: true
    }), /**
     * Adds a new operation to the queue without waiting for it to complete (i.e.
     * we ignore the Promise result).
     */
    t.prototype.ws = function(t2) {
      this.enqueue(t2);
    }, /**
     * Regardless if the queue has initialized shutdown, adds a new operation to the
     * queue without waiting for it to complete (i.e. we ignore the Promise result).
     */
    t.prototype.bs = function(t2) {
      this.vs(), // eslint-disable-next-line @typescript-eslint/no-floating-promises
      this.Ss(t2);
    }, /**
     * Initialize the shutdown of this queue. Once this method is called, the
     * only possible way to request running an operation is through
     * `enqueueEvenWhileRestricted()`.
     */
    t.prototype.Ds = function() {
      if (!this.Is) {
        this.Is = true;
        var t2 = Mr();
        t2 && "function" == typeof t2.removeEventListener && t2.removeEventListener("visibilitychange", this.Vs);
      }
    }, /**
     * Adds a new operation to the queue. Returns a promise that will be resolved
     * when the promise returned by the new operation is (with its value).
     */
    t.prototype.enqueue = function(t2) {
      return this.vs(), this.Is ? new Promise(function(t3) {
      }) : this.Ss(t2);
    }, /**
     * Enqueue a retryable operation.
     *
     * A retryable operation is rescheduled with backoff if it fails with a
     * IndexedDbTransactionError (the error type used by SimpleDb). All
     * retryable operations are executed in order and only run if all prior
     * operations were retried successfully.
     */
    t.prototype.Cs = function(t2) {
      var e = this;
      this.ws(function() {
        return e.Es.push(t2), e.Ns();
      });
    }, /**
     * Runs the next operation from the retryable queue. If the operation fails,
     * reschedules with backoff.
     */
    t.prototype.Ns = function() {
      return __awaiter(this, void 0, void 0, function() {
        var t2, e = this;
        return __generator(this, function(n2) {
          switch (n2.label) {
            case 0:
              if (0 === this.Es.length)
                return [3, 5];
              n2.label = 1;
            case 1:
              return n2.trys.push([1, 3, , 4]), [4, this.Es[0]()];
            case 2:
              return n2.sent(), this.Es.shift(), this.ys.reset(), [3, 4];
            case 3:
              if (!Rr(t2 = n2.sent()))
                throw t2;
              return T2("AsyncQueue", "Operation failed with retryable error: " + t2), [3, 4];
            case 4:
              this.Es.length > 0 && // If there are additional operations, we re-schedule `retryNextOp()`.
              // This is necessary to run retryable operations that failed during
              // their initial attempt since we don't know whether they are already
              // enqueued. If, for example, `op1`, `op2`, `op3` are enqueued and `op1`
              // needs to  be re-run, we will run `op1`, `op1`, `op2` using the
              // already enqueued calls to `retryNextOp()`. `op3()` will then run in the
              // call scheduled here.
              // Since `backoffAndRun()` cancels an existing backoff and schedules a
              // new backoff on every call, there is only ever a single additional
              // operation in the queue.
              this.ys.gn(function() {
                return e.Ns();
              }), n2.label = 5;
            case 5:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, t.prototype.Ss = function(t2) {
      var e = this, n2 = this.Ts.then(function() {
        return e.gs = true, t2().catch(function(t3) {
          throw e.Rs = t3, e.gs = false, N2(
            "INTERNAL UNHANDLED ERROR: ",
            /**
            * Chrome includes Error.message in Error.stack. Other browsers do not.
            * This returns expected output of message + stack when available.
            * @param error Error or FirestoreError
            */
            function(t4) {
              var e2 = t4.message || "";
              return t4.stack && (e2 = t4.stack.includes(t4.message) ? t4.stack : t4.message + "\n" + t4.stack), e2;
            }(t3)
          ), t3;
        }).then(function(t3) {
          return e.gs = false, t3;
        });
      });
      return this.Ts = n2, n2;
    }, /**
     * Schedules an operation to be queued on the AsyncQueue once the specified
     * `delayMs` has elapsed. The returned DelayedOperation can be used to cancel
     * or fast-forward the operation prior to its running.
     */
    t.prototype.yn = function(t2, e, n2) {
      var r2 = this;
      this.vs(), // Fast-forward delays for timerIds that have been overriden.
      this.Ps.indexOf(t2) > -1 && (e = 0);
      var i2 = qr._s(this, t2, e, n2, function(t3) {
        return r2.Fs(t3);
      });
      return this.As.push(i2), i2;
    }, t.prototype.vs = function() {
      this.Rs && D2();
    }, /**
     * Verifies there's an operation currently in-progress on the AsyncQueue.
     * Unfortunately we can't verify that the running code is in the promise chain
     * of that operation, so this isn't a foolproof check, but it should be enough
     * to catch some bugs.
     */
    t.prototype.xs = function() {
    }, /**
     * Waits until all currently queued tasks are finished executing. Delayed
     * operations are not run.
     */
    t.prototype.$s = function() {
      return __awaiter(this, void 0, void 0, function() {
        var t2;
        return __generator(this, function(e) {
          switch (e.label) {
            case 0:
              return [4, t2 = this.Ts];
            case 1:
              e.sent(), e.label = 2;
            case 2:
              if (t2 !== this.Ts)
                return [3, 0];
              e.label = 3;
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, /**
     * For Tests: Determine if a delayed operation with a particular TimerId
     * exists.
     */
    t.prototype.ks = function(t2) {
      for (var e = 0, n2 = this.As; e < n2.length; e++) {
        if (n2[e].dn === t2)
          return true;
      }
      return false;
    }, /**
     * For Tests: Runs some or all delayed operations early.
     *
     * @param lastTimerId Delayed operations up to and including this TimerId will
     *  be drained. Pass TimerId.All to run all delayed operations.
     * @returns a Promise that resolves once all operations have been run.
     */
    t.prototype.Ms = function(t2) {
      var e = this;
      return this.$s().then(function() {
        e.As.sort(function(t3, e2) {
          return t3.us - e2.us;
        });
        for (var n2 = 0, r2 = e.As; n2 < r2.length; n2++) {
          var i2 = r2[n2];
          if (i2.pn(), "all" !== t2 && i2.dn === t2)
            break;
        }
        return e.$s();
      });
    }, /**
     * For Tests: Skip all subsequent delays for a timer id.
     */
    t.prototype.Os = function(t2) {
      this.Ps.push(t2);
    }, /** Called once a DelayedOperation is run or canceled. */
    t.prototype.Fs = function(t2) {
      var e = this.As.indexOf(t2);
      this.As.splice(e, 1);
    }, t;
  }()
);
function Gr(t, e) {
  if (N2("AsyncQueue", e + ": " + t), Rr(t))
    return new I2(b.UNAVAILABLE, e + ": " + t);
  throw t;
}
var zr = function() {
  this.Ls = void 0, this.listeners = [];
};
var Br = function() {
  this.Bs = new yt(function(t) {
    return sr(t);
  }, or), this.onlineState = "Unknown", this.qs = /* @__PURE__ */ new Set();
};
function Kr(t, r2) {
  return __awaiter(this, void 0, void 0, function() {
    var e, i2, o, s, u4, a, c;
    return __generator(this, function(n2) {
      switch (n2.label) {
        case 0:
          if (e = x2(t), i2 = r2.query, o = false, (s = e.Bs.get(i2)) || (o = true, s = new zr()), !o)
            return [3, 4];
          n2.label = 1;
        case 1:
          return n2.trys.push([1, 3, , 4]), u4 = s, [4, e.Us(i2)];
        case 2:
          return u4.Ls = n2.sent(), [3, 4];
        case 3:
          return a = n2.sent(), c = Gr(a, "Initialization of query '" + ur(r2.query) + "' failed"), [2, void r2.onError(c)];
        case 4:
          return e.Bs.set(i2, s), s.listeners.push(r2), // Run global snapshot listeners if a consistent snapshot has been emitted.
          r2.Qs(e.onlineState), s.Ls && r2.Ws(s.Ls) && Yr(e), [
            2
            /*return*/
          ];
      }
    });
  });
}
function Wr(t, r2) {
  return __awaiter(this, void 0, void 0, function() {
    var e, i2, o, s, u4;
    return __generator(this, function(n2) {
      return e = x2(t), i2 = r2.query, o = false, (s = e.Bs.get(i2)) && (u4 = s.listeners.indexOf(r2)) >= 0 && (s.listeners.splice(u4, 1), o = 0 === s.listeners.length), o ? [2, (e.Bs.delete(i2), e.js(i2))] : [
        2
        /*return*/
      ];
    });
  });
}
function Qr(t, e) {
  for (var n2 = x2(t), r2 = false, i2 = 0, o = e; i2 < o.length; i2++) {
    var s = o[i2], u4 = s.query, a = n2.Bs.get(u4);
    if (a) {
      for (var c = 0, h = a.listeners; c < h.length; c++) {
        h[c].Ws(s) && (r2 = true);
      }
      a.Ls = s;
    }
  }
  r2 && Yr(n2);
}
function Hr(t, e, n2) {
  var r2 = x2(t), i2 = r2.Bs.get(e);
  if (i2)
    for (var o = 0, s = i2.listeners; o < s.length; o++) {
      s[o].onError(n2);
    }
  r2.Bs.delete(e);
}
function Yr(t) {
  t.qs.forEach(function(t2) {
    t2.next();
  });
}
var $r = (
  /** @class */
  function() {
    function t(t2, e, n2) {
      this.query = t2, this.Ks = e, /**
           * Initial snapshots (e.g. from cache) may not be propagated to the wrapped
           * observer. This flag is set to true once we've actually raised an event.
           */
      this.Gs = false, this.zs = null, this.onlineState = "Unknown", this.options = n2 || {};
    }
    return t.prototype.Ws = function(t2) {
      if (!this.options.includeMetadataChanges) {
        for (var e = [], n2 = 0, r2 = t2.docChanges; n2 < r2.length; n2++) {
          var i2 = r2[n2];
          3 !== i2.type && e.push(i2);
        }
        t2 = new $t(
          t2.query,
          t2.docs,
          t2.Qt,
          e,
          t2.Wt,
          t2.fromCache,
          t2.jt,
          /* excludesMetadataChanges= */
          true
        );
      }
      var o = false;
      return this.Gs ? this.Hs(t2) && (this.Ks.next(t2), o = true) : this.Ys(t2, this.onlineState) && (this.Js(t2), o = true), this.zs = t2, o;
    }, t.prototype.onError = function(t2) {
      this.Ks.error(t2);
    }, /** Returns whether a snapshot was raised. */
    t.prototype.Qs = function(t2) {
      this.onlineState = t2;
      var e = false;
      return this.zs && !this.Gs && this.Ys(this.zs, t2) && (this.Js(this.zs), e = true), e;
    }, t.prototype.Ys = function(t2, e) {
      if (!t2.fromCache)
        return true;
      var n2 = "Offline" !== e;
      return !(this.options.Xs && n2 || t2.docs.m() && "Offline" !== e);
    }, t.prototype.Hs = function(t2) {
      if (t2.docChanges.length > 0)
        return true;
      var e = this.zs && this.zs.hasPendingWrites !== t2.hasPendingWrites;
      return !(!t2.jt && !e) && true === this.options.includeMetadataChanges;
    }, t.prototype.Js = function(t2) {
      t2 = $t.Gt(t2.query, t2.docs, t2.Wt, t2.fromCache), this.Gs = true, this.Ks.next(t2);
    }, t;
  }()
);
var Xr = (
  /** @class */
  function() {
    function t(t2) {
      this.uid = t2;
    }
    return t.prototype.Zs = function() {
      return null != this.uid;
    }, /**
     * Returns a key representing this user, suitable for inclusion in a
     * dictionary.
     */
    t.prototype.ti = function() {
      return this.Zs() ? "uid:" + this.uid : "anonymous-user";
    }, t.prototype.isEqual = function(t2) {
      return t2.uid === this.uid;
    }, t;
  }()
);
Xr.UNAUTHENTICATED = new Xr(null), // TODO(mikelehen): Look into getting a proper uid-equivalent for
// non-FirebaseAuth providers.
Xr.ei = new Xr("google-credentials-uid"), Xr.ni = new Xr("first-party-uid");
var Jr = (
  /** @class */
  function() {
    function t(t2, e) {
      var n2 = this;
      this.previousValue = t2, e && (e.si = function(t3) {
        return n2.ii(t3);
      }, this.ri = function(t3) {
        return e.oi(t3);
      });
    }
    return t.prototype.ii = function(t2) {
      return this.previousValue = Math.max(t2, this.previousValue), this.previousValue;
    }, t.prototype.next = function() {
      var t2 = ++this.previousValue;
      return this.ri && this.ri(t2), t2;
    }, t;
  }()
);
function Zr(t, e) {
  return "firestore_clients_" + t + "_" + e;
}
function ti(t, e, n2) {
  var r2 = "firestore_mutations_" + t + "_" + n2;
  return e.Zs() && (r2 += "_" + e.uid), r2;
}
function ei(t, e) {
  return "firestore_targets_" + t + "_" + e;
}
Jr.ai = -1;
var ni = (
  /** @class */
  function() {
    function t(t2, e, n2, r2) {
      this.user = t2, this.batchId = e, this.state = n2, this.error = r2;
    }
    return t.ci = function(e, n2, r2) {
      var i2 = JSON.parse(r2), o = "object" == typeof i2 && -1 !== ["pending", "acknowledged", "rejected"].indexOf(i2.state) && (void 0 === i2.error || "object" == typeof i2.error), s = void 0;
      return o && i2.error && ((o = "string" == typeof i2.error.message && "string" == typeof i2.error.code) && (s = new I2(i2.error.code, i2.error.message))), o ? new t(e, n2, i2.state, s) : (N2("SharedClientState", "Failed to parse mutation state for ID '" + n2 + "': " + r2), null);
    }, t.prototype.ui = function() {
      var t2 = {
        state: this.state,
        updateTimeMs: Date.now()
      };
      return this.error && (t2.error = {
        code: this.error.code,
        message: this.error.message
      }), JSON.stringify(t2);
    }, t;
  }()
);
var ri = (
  /** @class */
  function() {
    function t(t2, e, n2) {
      this.targetId = t2, this.state = e, this.error = n2;
    }
    return t.ci = function(e, n2) {
      var r2 = JSON.parse(n2), i2 = "object" == typeof r2 && -1 !== ["not-current", "current", "rejected"].indexOf(r2.state) && (void 0 === r2.error || "object" == typeof r2.error), o = void 0;
      return i2 && r2.error && ((i2 = "string" == typeof r2.error.message && "string" == typeof r2.error.code) && (o = new I2(r2.error.code, r2.error.message))), i2 ? new t(e, r2.state, o) : (N2("SharedClientState", "Failed to parse target state for ID '" + e + "': " + n2), null);
    }, t.prototype.ui = function() {
      var t2 = {
        state: this.state,
        updateTimeMs: Date.now()
      };
      return this.error && (t2.error = {
        code: this.error.code,
        message: this.error.message
      }), JSON.stringify(t2);
    }, t;
  }()
);
var ii = (
  /** @class */
  function() {
    function t(t2, e) {
      this.clientId = t2, this.activeTargetIds = e;
    }
    return t.ci = function(e, n2) {
      for (var r2 = JSON.parse(n2), i2 = "object" == typeof r2 && r2.activeTargetIds instanceof Array, o = Qt(), s = 0; i2 && s < r2.activeTargetIds.length; ++s)
        i2 = It(r2.activeTargetIds[s]), o = o.add(r2.activeTargetIds[s]);
      return i2 ? new t(e, o) : (N2("SharedClientState", "Failed to parse client data for instance '" + e + "': " + n2), null);
    }, t;
  }()
);
var oi = (
  /** @class */
  function() {
    function t(t2, e) {
      this.clientId = t2, this.onlineState = e;
    }
    return t.ci = function(e) {
      var n2 = JSON.parse(e);
      return "object" == typeof n2 && -1 !== ["Unknown", "Online", "Offline"].indexOf(n2.onlineState) && "string" == typeof n2.clientId ? new t(n2.clientId, n2.onlineState) : (N2("SharedClientState", "Failed to parse online state: " + e), null);
    }, t;
  }()
);
var si = (
  /** @class */
  function() {
    function t() {
      this.activeTargetIds = Qt();
    }
    return t.prototype.hi = function(t2) {
      this.activeTargetIds = this.activeTargetIds.add(t2);
    }, t.prototype.li = function(t2) {
      this.activeTargetIds = this.activeTargetIds.delete(t2);
    }, /**
     * Converts this entry into a JSON-encoded format we can use for WebStorage.
     * Does not encode `clientId` as it is part of the key in WebStorage.
     */
    t.prototype.ui = function() {
      var t2 = {
        activeTargetIds: this.activeTargetIds.A(),
        updateTimeMs: Date.now()
      };
      return JSON.stringify(t2);
    }, t;
  }()
);
var ui = (
  /** @class */
  function() {
    function t(t2, e, n2, r2, i2) {
      this.window = t2, this.fn = e, this.persistenceKey = n2, this._i = r2, this.fi = null, this.di = null, this.si = null, this.wi = this.mi.bind(this), this.Ti = new Ot(st), this.Ei = false, /**
           * Captures WebStorage events that occur before `start()` is called. These
           * events are replayed once `WebStorageSharedClientState` is started.
           */
      this.Ii = [];
      var o = n2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      this.storage = this.window.localStorage, this.currentUser = i2, this.Ai = Zr(this.persistenceKey, this._i), this.Ri = /** Assembles the key for the current sequence number. */
      function(t3) {
        return "firestore_sequence_number_" + t3;
      }(this.persistenceKey), this.Ti = this.Ti.ot(this._i, new si()), this.gi = new RegExp("^firestore_clients_" + o + "_([^_]*)$"), this.Pi = new RegExp("^firestore_mutations_" + o + "_(\\d+)(?:_(.*))?$"), this.yi = new RegExp("^firestore_targets_" + o + "_(\\d+)$"), this.Vi = /** Assembles the key for the online state of the primary tab. */
      function(t3) {
        return "firestore_online_state_" + t3;
      }(this.persistenceKey), // Rather than adding the storage observer during start(), we add the
      // storage observer during initialization. This ensures that we collect
      // events before other components populate their initial state (during their
      // respective start() calls). Otherwise, we might for example miss a
      // mutation that is added after LocalStore's start() processed the existing
      // mutations but before we observe WebStorage events.
      this.window.addEventListener("storage", this.wi);
    }
    return t.Ln = function(t2) {
      return !(!t2 || !t2.localStorage);
    }, t.prototype.start = function() {
      return __awaiter(this, void 0, void 0, function() {
        var t2, e, r2, i2, o, s, u4, a, c, h, f, l = this;
        return __generator(this, function(n2) {
          switch (n2.label) {
            case 0:
              return [4, this.fi.pi()];
            case 1:
              for (t2 = n2.sent(), e = 0, r2 = t2; e < r2.length; e++)
                (i2 = r2[e]) !== this._i && (o = this.getItem(Zr(this.persistenceKey, i2))) && (s = ii.ci(i2, o)) && (this.Ti = this.Ti.ot(s.clientId, s));
              for (this.bi(), (u4 = this.storage.getItem(this.Vi)) && (a = this.vi(u4)) && this.Si(a), c = 0, h = this.Ii; c < h.length; c++)
                f = h[c], this.mi(f);
              return this.Ii = [], // Register a window unload hook to remove the client metadata entry from
              // WebStorage even if `shutdown()` was not called.
              this.window.addEventListener("unload", function() {
                return l.Di();
              }), this.Ei = true, [
                2
                /*return*/
              ];
          }
        });
      });
    }, t.prototype.oi = function(t2) {
      this.setItem(this.Ri, JSON.stringify(t2));
    }, t.prototype.Ci = function() {
      return this.Ni(this.Ti);
    }, t.prototype.Fi = function(t2) {
      var e = false;
      return this.Ti.forEach(function(n2, r2) {
        r2.activeTargetIds.has(t2) && (e = true);
      }), e;
    }, t.prototype.xi = function(t2) {
      this.$i(t2, "pending");
    }, t.prototype.ki = function(t2, e, n2) {
      this.$i(t2, e, n2), // Once a final mutation result is observed by other clients, they no longer
      // access the mutation's metadata entry. Since WebStorage replays events
      // in order, it is safe to delete the entry right after updating it.
      this.Mi(t2);
    }, t.prototype.Oi = function(t2) {
      var e = "not-current";
      if (this.Fi(t2)) {
        var n2 = this.storage.getItem(ei(this.persistenceKey, t2));
        if (n2) {
          var r2 = ri.ci(t2, n2);
          r2 && (e = r2.state);
        }
      }
      return this.Li.hi(t2), this.bi(), e;
    }, t.prototype.Bi = function(t2) {
      this.Li.li(t2), this.bi();
    }, t.prototype.qi = function(t2) {
      return this.Li.activeTargetIds.has(t2);
    }, t.prototype.Ui = function(t2) {
      this.removeItem(ei(this.persistenceKey, t2));
    }, t.prototype.Qi = function(t2, e, n2) {
      this.Wi(t2, e, n2);
    }, t.prototype.ji = function(t2, e, n2) {
      var r2 = this;
      e.forEach(function(t3) {
        r2.Mi(t3);
      }), this.currentUser = t2, n2.forEach(function(t3) {
        r2.xi(t3);
      });
    }, t.prototype.Ki = function(t2) {
      this.Gi(t2);
    }, t.prototype.Di = function() {
      this.Ei && (this.window.removeEventListener("storage", this.wi), this.removeItem(this.Ai), this.Ei = false);
    }, t.prototype.getItem = function(t2) {
      var e = this.storage.getItem(t2);
      return T2("SharedClientState", "READ", t2, e), e;
    }, t.prototype.setItem = function(t2, e) {
      T2("SharedClientState", "SET", t2, e), this.storage.setItem(t2, e);
    }, t.prototype.removeItem = function(t2) {
      T2("SharedClientState", "REMOVE", t2), this.storage.removeItem(t2);
    }, t.prototype.mi = function(t2) {
      var r2 = this, i2 = t2;
      if (i2.storageArea === this.storage) {
        if (T2("SharedClientState", "EVENT", i2.key, i2.newValue), i2.key === this.Ai)
          return void N2("Received WebStorage notification for local change. Another client might have garbage-collected our state");
        this.fn.Cs(function() {
          return __awaiter(r2, void 0, void 0, function() {
            var t3, e, r3, o, s, u4;
            return __generator(this, function(n2) {
              if (this.Ei) {
                if (null !== i2.key)
                  if (this.gi.test(i2.key)) {
                    if (null == i2.newValue)
                      return t3 = this.zi(i2.key), [2, this.Hi(t3, null)];
                    if (e = this.Yi(i2.key, i2.newValue))
                      return [2, this.Hi(e.clientId, e)];
                  } else if (this.Pi.test(i2.key)) {
                    if (null !== i2.newValue && (r3 = this.Ji(i2.key, i2.newValue)))
                      return [2, this.Xi(r3)];
                  } else if (this.yi.test(i2.key)) {
                    if (null !== i2.newValue && (o = this.Zi(i2.key, i2.newValue)))
                      return [2, this.tr(o)];
                  } else if (i2.key === this.Vi) {
                    if (null !== i2.newValue && (s = this.vi(i2.newValue)))
                      return [2, this.Si(s)];
                  } else
                    i2.key === this.Ri && (u4 = function(t4) {
                      var e2 = Jr.ai;
                      if (null != t4)
                        try {
                          var n3 = JSON.parse(t4);
                          k2("number" == typeof n3), e2 = n3;
                        } catch (t5) {
                          N2("SharedClientState", "Failed to read sequence number from WebStorage", t5);
                        }
                      return e2;
                    }(i2.newValue)) !== Jr.ai && this.si(u4);
              } else
                this.Ii.push(i2);
              return [
                2
                /*return*/
              ];
            });
          });
        });
      }
    }, Object.defineProperty(t.prototype, "Li", {
      get: function() {
        return this.Ti.get(this._i);
      },
      enumerable: false,
      configurable: true
    }), t.prototype.bi = function() {
      this.setItem(this.Ai, this.Li.ui());
    }, t.prototype.$i = function(t2, e, n2) {
      var r2 = new ni(this.currentUser, t2, e, n2), i2 = ti(this.persistenceKey, this.currentUser, t2);
      this.setItem(i2, r2.ui());
    }, t.prototype.Mi = function(t2) {
      var e = ti(this.persistenceKey, this.currentUser, t2);
      this.removeItem(e);
    }, t.prototype.Gi = function(t2) {
      var e = {
        clientId: this._i,
        onlineState: t2
      };
      this.storage.setItem(this.Vi, JSON.stringify(e));
    }, t.prototype.Wi = function(t2, e, n2) {
      var r2 = ei(this.persistenceKey, t2), i2 = new ri(t2, e, n2);
      this.setItem(r2, i2.ui());
    }, /**
     * Parses a client state key in WebStorage. Returns null if the key does not
     * match the expected key format.
     */
    t.prototype.zi = function(t2) {
      var e = this.gi.exec(t2);
      return e ? e[1] : null;
    }, /**
     * Parses a client state in WebStorage. Returns 'null' if the value could not
     * be parsed.
     */
    t.prototype.Yi = function(t2, e) {
      var n2 = this.zi(t2);
      return ii.ci(n2, e);
    }, /**
     * Parses a mutation batch state in WebStorage. Returns 'null' if the value
     * could not be parsed.
     */
    t.prototype.Ji = function(t2, e) {
      var n2 = this.Pi.exec(t2), r2 = Number(n2[1]), i2 = void 0 !== n2[2] ? n2[2] : null;
      return ni.ci(new Xr(i2), r2, e);
    }, /**
     * Parses a query target state from WebStorage. Returns 'null' if the value
     * could not be parsed.
     */
    t.prototype.Zi = function(t2, e) {
      var n2 = this.yi.exec(t2), r2 = Number(n2[1]);
      return ri.ci(r2, e);
    }, /**
     * Parses an online state from WebStorage. Returns 'null' if the value
     * could not be parsed.
     */
    t.prototype.vi = function(t2) {
      return oi.ci(t2);
    }, t.prototype.Xi = function(t2) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(e) {
          return t2.user.uid === this.currentUser.uid ? [2, this.fi.er(t2.batchId, t2.state, t2.error)] : (T2("SharedClientState", "Ignoring mutation for non-active user " + t2.user.uid), [
            2
            /*return*/
          ]);
        });
      });
    }, t.prototype.tr = function(t2) {
      return this.fi.nr(t2.targetId, t2.state, t2.error);
    }, t.prototype.Hi = function(t2, e) {
      var n2 = this, r2 = e ? this.Ti.ot(t2, e) : this.Ti.remove(t2), i2 = this.Ni(this.Ti), o = this.Ni(r2), s = [], u4 = [];
      return o.forEach(function(t3) {
        i2.has(t3) || s.push(t3);
      }), i2.forEach(function(t3) {
        o.has(t3) || u4.push(t3);
      }), this.fi.sr(s, u4).then(function() {
        n2.Ti = r2;
      });
    }, t.prototype.Si = function(t2) {
      this.Ti.get(t2.clientId) && this.di(t2.onlineState);
    }, t.prototype.Ni = function(t2) {
      var e = Qt();
      return t2.forEach(function(t3, n2) {
        e = e.kt(n2.activeTargetIds);
      }), e;
    }, t;
  }()
);
var ai = (
  /** @class */
  function() {
    function t() {
      this.ir = new si(), this.rr = {}, this.di = null, this.si = null;
    }
    return t.prototype.xi = function(t2) {
    }, t.prototype.ki = function(t2, e, n2) {
    }, t.prototype.Oi = function(t2) {
      return this.ir.hi(t2), this.rr[t2] || "not-current";
    }, t.prototype.Qi = function(t2, e, n2) {
      this.rr[t2] = e;
    }, t.prototype.Bi = function(t2) {
      this.ir.li(t2);
    }, t.prototype.qi = function(t2) {
      return this.ir.activeTargetIds.has(t2);
    }, t.prototype.Ui = function(t2) {
      delete this.rr[t2];
    }, t.prototype.Ci = function() {
      return this.ir.activeTargetIds;
    }, t.prototype.Fi = function(t2) {
      return this.ir.activeTargetIds.has(t2);
    }, t.prototype.start = function() {
      return this.ir = new si(), Promise.resolve();
    }, t.prototype.ji = function(t2, e, n2) {
    }, t.prototype.Ki = function(t2) {
    }, t.prototype.Di = function() {
    }, t.prototype.oi = function(t2) {
    }, t;
  }()
);
var ci = (
  /** @class */
  function() {
    function t(t2, e, n2, r2) {
      this.batchId = t2, this.ar = e, this.baseMutations = n2, this.mutations = r2;
    }
    return t.prototype.cr = function(t2, e, n2) {
      for (var r2 = n2.ur, i2 = 0; i2 < this.mutations.length; i2++) {
        var o = this.mutations[i2];
        o.key.isEqual(t2) && (e = An(o, e, r2[i2]));
      }
      return e;
    }, /**
     * Computes the local view of a document given all the mutations in this
     * batch.
     *
     * @param docKey The key of the document to apply mutations to.
     * @param maybeDoc The document to apply mutations to.
     */
    t.prototype.hr = function(t2, e) {
      for (var n2 = 0, r2 = this.baseMutations; n2 < r2.length; n2++) {
        var i2 = r2[n2];
        i2.key.isEqual(t2) && (e = Sn(i2, e, e, this.ar));
      }
      for (var o = e, s = 0, u4 = this.mutations; s < u4.length; s++) {
        var a = u4[s];
        a.key.isEqual(t2) && (e = Sn(a, e, o, this.ar));
      }
      return e;
    }, /**
     * Computes the local view for all provided documents given the mutations in
     * this batch.
     */
    t.prototype.lr = function(t2) {
      var e = this, n2 = t2;
      return this.mutations.forEach(function(r2) {
        var i2 = e.hr(r2.key, t2.get(r2.key));
        i2 && (n2 = n2.ot(r2.key, i2));
      }), n2;
    }, t.prototype.keys = function() {
      return this.mutations.reduce(function(t2, e) {
        return t2.add(e.key);
      }, Kt());
    }, t.prototype.isEqual = function(t2) {
      return this.batchId === t2.batchId && ut(this.mutations, t2.mutations, function(t3, e) {
        return kn(t3, e);
      }) && ut(this.baseMutations, t2.baseMutations, function(t3, e) {
        return kn(t3, e);
      });
    }, t;
  }()
);
var hi = (
  /** @class */
  function() {
    function t(t2, e, n2, r2) {
      this.batch = t2, this._r = e, this.ur = n2, this.dr = r2;
    }
    return t.from = function(e, n2, r2) {
      k2(e.mutations.length === r2.length);
      for (var i2 = zt, o = e.mutations, s = 0; s < o.length; s++)
        i2 = i2.ot(o[s].key, r2[s].version);
      return new t(e, n2, r2, i2);
    }, t;
  }()
);
var fi = (
  /** @class */
  function() {
    function t() {
      this.wr = new yt(function(t2) {
        return t2.toString();
      }, function(t2, e) {
        return t2.isEqual(e);
      }), this.mr = false;
    }
    return Object.defineProperty(t.prototype, "readTime", {
      get: function() {
        return this.Tr;
      },
      set: function(t2) {
        this.Tr = t2;
      },
      enumerable: false,
      configurable: true
    }), /**
     * Buffers a `RemoteDocumentCache.addEntry()` call.
     *
     * You can only modify documents that have already been retrieved via
     * `getEntry()/getEntries()` (enforced via IndexedDbs `apply()`).
     */
    t.prototype.Er = function(t2, e) {
      this.Ir(), this.readTime = e, this.wr.set(t2.key, t2);
    }, /**
     * Buffers a `RemoteDocumentCache.removeEntry()` call.
     *
     * You can only remove documents that have already been retrieved via
     * `getEntry()/getEntries()` (enforced via IndexedDbs `apply()`).
     */
    t.prototype.Ar = function(t2, e) {
      this.Ir(), e && (this.readTime = e), this.wr.set(t2, null);
    }, /**
     * Looks up an entry in the cache. The buffered changes will first be checked,
     * and if no buffered change applies, this will forward to
     * `RemoteDocumentCache.getEntry()`.
     *
     * @param transaction The transaction in which to perform any persistence
     *     operations.
     * @param documentKey The key of the entry to look up.
     * @return The cached Document or NoDocument entry, or null if we have nothing
     * cached.
     */
    t.prototype.Rr = function(t2, e) {
      this.Ir();
      var n2 = this.wr.get(e);
      return void 0 !== n2 ? Dr.resolve(n2) : this.gr(t2, e);
    }, /**
     * Looks up several entries in the cache, forwarding to
     * `RemoteDocumentCache.getEntry()`.
     *
     * @param transaction The transaction in which to perform any persistence
     *     operations.
     * @param documentKeys The keys of the entries to look up.
     * @return A map of cached `Document`s or `NoDocument`s, indexed by key. If an
     *     entry cannot be found, the corresponding key will be mapped to a null
     *     value.
     */
    t.prototype.getEntries = function(t2, e) {
      return this.Pr(t2, e);
    }, /**
     * Applies buffered changes to the underlying RemoteDocumentCache, using
     * the provided transaction.
     */
    t.prototype.apply = function(t2) {
      return this.Ir(), this.mr = true, this.yr(t2);
    }, /** Helper to assert this.changes is not null  */
    t.prototype.Ir = function() {
    }, t;
  }()
);
var li = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";
var pi = (
  /** @class */
  function() {
    function t() {
      this.Vr = [];
    }
    return t.prototype.pr = function(t2) {
      this.Vr.push(t2);
    }, t.prototype.br = function() {
      this.Vr.forEach(function(t2) {
        return t2();
      });
    }, t;
  }()
);
var di = (
  /** @class */
  function() {
    function t(t2, e, n2) {
      this.vr = t2, this.Sr = e, this.Dr = n2;
    }
    return t.prototype.Cr = function(t2, e) {
      var n2 = this;
      return this.Sr.Nr(t2, e).next(function(r2) {
        return n2.Fr(t2, e, r2);
      });
    }, /** Internal version of `getDocument` that allows reusing batches. */
    t.prototype.Fr = function(t2, e, n2) {
      return this.vr.Rr(t2, e).next(function(t3) {
        for (var r2 = 0, i2 = n2; r2 < i2.length; r2++) {
          t3 = i2[r2].hr(e, t3);
        }
        return t3;
      });
    }, // Returns the view of the given `docs` as they would appear after applying
    // all mutations in the given `batches`.
    t.prototype.$r = function(t2, e, n2) {
      var r2 = qt();
      return e.forEach(function(t3, e2) {
        for (var i2 = 0, o = n2; i2 < o.length; i2++) {
          e2 = o[i2].hr(t3, e2);
        }
        r2 = r2.ot(t3, e2);
      }), r2;
    }, /**
     * Gets the local view of the documents identified by `keys`.
     *
     * If we don't have cached state for a document in `keys`, a NoDocument will
     * be stored for that key in the resulting set.
     */
    t.prototype.kr = function(t2, e) {
      var n2 = this;
      return this.vr.getEntries(t2, e).next(function(e2) {
        return n2.Mr(t2, e2);
      });
    }, /**
     * Similar to `getDocuments`, but creates the local view from the given
     * `baseDocs` without retrieving documents from the local store.
     */
    t.prototype.Mr = function(t2, e) {
      var n2 = this;
      return this.Sr.Or(t2, e).next(function(r2) {
        var i2 = n2.$r(t2, e, r2), o = Mt();
        return i2.forEach(function(t3, e2) {
          e2 || (e2 = new Bn(t3, gt.min())), o = o.ot(t3, e2);
        }), o;
      });
    }, /**
     * Performs a query against the local view of all documents.
     *
     * @param transaction The persistence transaction.
     * @param query The query to match documents against.
     * @param sinceReadTime If not set to SnapshotVersion.min(), return only
     *     documents that have been read since this snapshot version (exclusive).
     */
    t.prototype.Lr = function(t2, e, n2) {
      return function(t3) {
        return F2.F(t3.path) && null === t3.collectionGroup && 0 === t3.filters.length;
      }(e) ? this.Br(t2, e.path) : Zn(e) ? this.qr(t2, e, n2) : this.Ur(t2, e, n2);
    }, t.prototype.Br = function(t2, e) {
      return this.Cr(t2, new F2(e)).next(function(t3) {
        var e2 = Gt();
        return t3 instanceof zn && (e2 = e2.ot(t3.key, t3)), e2;
      });
    }, t.prototype.qr = function(t2, e, n2) {
      var r2 = this, i2 = e.collectionGroup, o = Gt();
      return this.Dr.Qr(t2, i2).next(function(s) {
        return Dr.forEach(s, function(s2) {
          var u4 = function(t3, e2) {
            return new Wn(
              e2,
              /*collectionGroup=*/
              null,
              t3.on.slice(),
              t3.filters.slice(),
              t3.limit,
              t3.an,
              t3.startAt,
              t3.endAt
            );
          }(e, s2.child(i2));
          return r2.Ur(t2, u4, n2).next(function(t3) {
            t3.forEach(function(t4, e2) {
              o = o.ot(t4, e2);
            });
          });
        }).next(function() {
          return o;
        });
      });
    }, t.prototype.Ur = function(t2, e, n2) {
      var r2, i2, o = this;
      return this.vr.Lr(t2, e, n2).next(function(n3) {
        return r2 = n3, o.Sr.Wr(t2, e);
      }).next(function(e2) {
        return i2 = e2, o.jr(t2, i2, r2).next(function(t3) {
          r2 = t3;
          for (var e3 = 0, n3 = i2; e3 < n3.length; e3++)
            for (var o2 = n3[e3], s = 0, u4 = o2.mutations; s < u4.length; s++) {
              var a = u4[s], c = a.key, h = r2.get(c), f = Sn(a, h, h, o2.ar);
              r2 = f instanceof zn ? r2.ot(c, f) : r2.remove(c);
            }
        });
      }).next(function() {
        return r2.forEach(function(t3, n3) {
          ar(e, n3) || (r2 = r2.remove(t3));
        }), r2;
      });
    }, t.prototype.jr = function(t2, e, n2) {
      for (var r2 = Kt(), i2 = 0, o = e; i2 < o.length; i2++)
        for (var s = 0, u4 = o[i2].mutations; s < u4.length; s++) {
          var a = u4[s];
          a instanceof Rn && null === n2.get(a.key) && (r2 = r2.add(a.key));
        }
      var c = n2;
      return this.vr.getEntries(t2, r2).next(function(t3) {
        return t3.forEach(function(t4, e2) {
          null !== e2 && e2 instanceof zn && (c = c.ot(t4, e2));
        }), c;
      });
    }, t;
  }()
);
var vi = (
  /** @class */
  function() {
    function t(t2, e, n2, r2) {
      this.targetId = t2, this.fromCache = e, this.Kr = n2, this.Gr = r2;
    }
    return t.zr = function(e, n2) {
      for (var r2 = Kt(), i2 = Kt(), o = 0, s = n2.docChanges; o < s.length; o++) {
        var u4 = s[o];
        switch (u4.type) {
          case 0:
            r2 = r2.add(u4.doc.key);
            break;
          case 1:
            i2 = i2.add(u4.doc.key);
        }
      }
      return new t(e, n2.fromCache, r2, i2);
    }, t;
  }()
);
function yi(t, e) {
  var n2 = t[0], r2 = t[1], i2 = e[0], o = e[1], s = st(n2, i2);
  return 0 === s ? st(r2, o) : s;
}
var mi = (
  /** @class */
  function() {
    function t(t2) {
      this.Hr = t2, this.buffer = new Ut(yi), this.Yr = 0;
    }
    return t.prototype.Jr = function() {
      return ++this.Yr;
    }, t.prototype.Xr = function(t2) {
      var e = [t2, this.Jr()];
      if (this.buffer.size < this.Hr)
        this.buffer = this.buffer.add(e);
      else {
        var n2 = this.buffer.last();
        yi(e, n2) < 0 && (this.buffer = this.buffer.delete(n2).add(e));
      }
    }, Object.defineProperty(t.prototype, "maxValue", {
      get: function() {
        return this.buffer.last()[0];
      },
      enumerable: false,
      configurable: true
    }), t;
  }()
);
var gi = {
  Zr: false,
  eo: 0,
  no: 0,
  so: 0
};
var wi = (
  /** @class */
  function() {
    function t(t2, e, n2) {
      this.io = t2, this.ro = e, this.oo = n2;
    }
    return t.ao = function(e) {
      return new t(e, t.co, t.uo);
    }, t;
  }()
);
wi.ho = -1, wi.lo = 1048576, wi._o = 41943040, wi.co = 10, wi.uo = 1e3, wi.fo = new wi(wi._o, wi.co, wi.uo), wi.do = new wi(wi.ho, 0, 0);
var bi = (
  /** @class */
  function() {
    function t(t2, e) {
      this.wo = t2, this.cs = e, this.mo = false, this.To = null;
    }
    return t.prototype.start = function(t2) {
      this.wo.params.io !== wi.ho && this.Eo(t2);
    }, t.prototype.stop = function() {
      this.To && (this.To.cancel(), this.To = null);
    }, Object.defineProperty(t.prototype, "Ei", {
      get: function() {
        return null !== this.To;
      },
      enumerable: false,
      configurable: true
    }), t.prototype.Eo = function(t2) {
      var r2 = this, i2 = this.mo ? 3e5 : 6e4;
      T2("LruGarbageCollector", "Garbage collection scheduled in " + i2 + "ms"), this.To = this.cs.yn("lru_garbage_collection", i2, function() {
        return __awaiter(r2, void 0, void 0, function() {
          var e;
          return __generator(this, function(n2) {
            switch (n2.label) {
              case 0:
                this.To = null, this.mo = true, n2.label = 1;
              case 1:
                return n2.trys.push([1, 3, , 7]), [4, t2.Io(this.wo)];
              case 2:
                return n2.sent(), [3, 7];
              case 3:
                return Rr(e = n2.sent()) ? (T2("LruGarbageCollector", "Ignoring IndexedDB error during garbage collection: ", e), [3, 6]) : [3, 4];
              case 4:
                return [4, qo(e)];
              case 5:
                n2.sent(), n2.label = 6;
              case 6:
                return [3, 7];
              case 7:
                return [4, this.Eo(t2)];
              case 8:
                return n2.sent(), [
                  2
                  /*return*/
                ];
            }
          });
        });
      });
    }, t;
  }()
);
var Ii = (
  /** @class */
  function() {
    function t(t2, e) {
      this.Ao = t2, this.params = e;
    }
    return t.prototype.Ro = function(t2, e) {
      return this.Ao.Po(t2).next(function(t3) {
        return Math.floor(e / 100 * t3);
      });
    }, /** Returns the nth sequence number, counting in order from the smallest. */
    t.prototype.yo = function(t2, e) {
      var n2 = this;
      if (0 === e)
        return Dr.resolve(Jr.ai);
      var r2 = new mi(e);
      return this.Ao.Ce(t2, function(t3) {
        return r2.Xr(t3.sequenceNumber);
      }).next(function() {
        return n2.Ao.Vo(t2, function(t3) {
          return r2.Xr(t3);
        });
      }).next(function() {
        return r2.maxValue;
      });
    }, /**
     * Removes targets with a sequence number equal to or less than the given upper bound, and removes
     * document associations with those targets.
     */
    t.prototype.po = function(t2, e, n2) {
      return this.Ao.po(t2, e, n2);
    }, /**
     * Removes documents that have a sequence number equal to or less than the upper bound and are not
     * otherwise pinned.
     */
    t.prototype.bo = function(t2, e) {
      return this.Ao.bo(t2, e);
    }, t.prototype.vo = function(t2, e) {
      var n2 = this;
      return this.params.io === wi.ho ? (T2("LruGarbageCollector", "Garbage collection skipped; disabled"), Dr.resolve(gi)) : this.So(t2).next(function(r2) {
        return r2 < n2.params.io ? (T2("LruGarbageCollector", "Garbage collection skipped; Cache size " + r2 + " is lower than threshold " + n2.params.io), gi) : n2.Do(t2, e);
      });
    }, t.prototype.So = function(t2) {
      return this.Ao.So(t2);
    }, t.prototype.Do = function(t2, e) {
      var n2, r2, i2, o, u4, a, c, h = this, f = Date.now();
      return this.Ro(t2, this.params.ro).next(function(e2) {
        return e2 > h.params.oo ? (T2("LruGarbageCollector", "Capping sequence numbers to collect down to the maximum of " + h.params.oo + " from " + e2), r2 = h.params.oo) : r2 = e2, o = Date.now(), h.yo(t2, r2);
      }).next(function(r3) {
        return n2 = r3, u4 = Date.now(), h.po(t2, n2, e);
      }).next(function(e2) {
        return i2 = e2, a = Date.now(), h.bo(t2, n2);
      }).next(function(t3) {
        return c = Date.now(), _() <= LogLevel.DEBUG && T2("LruGarbageCollector", "LRU Garbage Collection\n	Counted targets in " + (o - f) + "ms\n	Determined least recently used " + r2 + " in " + (u4 - o) + "ms\n	Removed " + i2 + " targets in " + (a - u4) + "ms\n	Removed " + t3 + " documents in " + (c - a) + "ms\nTotal Duration: " + (c - f) + "ms"), Dr.resolve({
          Zr: true,
          eo: r2,
          no: i2,
          so: t3
        });
      });
    }, t;
  }()
);
function Ei(t) {
  for (var e = "", n2 = 0; n2 < t.length; n2++)
    e.length > 0 && (e = Ti(e)), e = _i(t.get(n2), e);
  return Ti(e);
}
function _i(t, e) {
  for (var n2 = e, r2 = t.length, i2 = 0; i2 < r2; i2++) {
    var o = t.charAt(i2);
    switch (o) {
      case "\0":
        n2 += "";
        break;
      case "":
        n2 += "";
        break;
      default:
        n2 += o;
    }
  }
  return n2;
}
function Ti(t) {
  return t + "";
}
function Ni(t) {
  var e = t.length;
  if (k2(e >= 2), 2 === e)
    return k2("" === t.charAt(0) && "" === t.charAt(1)), V2.P();
  for (var n2 = e - 2, r2 = [], i2 = "", o = 0; o < e; ) {
    var s = t.indexOf("", o);
    switch ((s < 0 || s > n2) && D2(), t.charAt(s + 1)) {
      case "":
        var u4 = t.substring(o, s), a = void 0;
        0 === i2.length ? (
          // Avoid copying for the common case of a segment that excludes \0
          // and \001
          a = u4
        ) : (a = i2 += u4, i2 = ""), r2.push(a);
        break;
      case "":
        i2 += t.substring(o, s), i2 += "\0";
        break;
      case "":
        i2 += t.substring(o, s + 1);
        break;
      default:
        D2();
    }
    o = s + 2;
  }
  return new V2(r2);
}
var Ai = function(t) {
  this.Co = t;
};
function Si(t, e) {
  if (e.document)
    return function(t2, e2, n3) {
      var r3 = Me(t2, e2.name), i3 = Ve(e2.updateTime), o2 = new Mn({
        mapValue: {
          fields: e2.fields
        }
      });
      return new zn(r3, i3, o2, {
        hasCommittedMutations: !!n3
      });
    }(t.Co, e.document, !!e.hasCommittedMutations);
  if (e.noDocument) {
    var n2 = F2.$(e.noDocument.path), r2 = Ri(e.noDocument.readTime);
    return new Bn(n2, r2, {
      hasCommittedMutations: !!e.hasCommittedMutations
    });
  }
  if (e.unknownDocument) {
    var i2 = F2.$(e.unknownDocument.path), o = Ri(e.unknownDocument.version);
    return new Kn(i2, o);
  }
  return D2();
}
function Di(t, e, n2) {
  var r2 = ki(n2), i2 = e.key.path.h().A();
  if (e instanceof zn) {
    var o = function(t2, e2) {
      return {
        name: Fe(t2, e2.key),
        fields: e2.rn().mapValue.fields,
        updateTime: Re(t2, e2.version.Z())
      };
    }(t.Co, e), s = e.hasCommittedMutations;
    return new io(
      /* unknownDocument= */
      null,
      /* noDocument= */
      null,
      o,
      s,
      r2,
      i2
    );
  }
  if (e instanceof Bn) {
    var u4 = e.key.path.A(), a = Li(e.version), c = e.hasCommittedMutations;
    return new io(
      /* unknownDocument= */
      null,
      new no(u4, a),
      /* document= */
      null,
      c,
      r2,
      i2
    );
  }
  if (e instanceof Kn) {
    var h = e.key.path.A(), f = Li(e.version);
    return new io(
      new ro(h, f),
      /* noDocument= */
      null,
      /* document= */
      null,
      /* hasCommittedMutations= */
      true,
      r2,
      i2
    );
  }
  return D2();
}
function ki(t) {
  var e = t.Z();
  return [e.seconds, e.nanoseconds];
}
function xi(t) {
  var e = new mt(t[0], t[1]);
  return gt.J(e);
}
function Li(t) {
  var e = t.Z();
  return new Xi(e.seconds, e.nanoseconds);
}
function Ri(t) {
  var e = new mt(t.seconds, t.nanoseconds);
  return gt.J(e);
}
function Oi(t, e) {
  var n2 = (e.baseMutations || []).map(function(e2) {
    return We(t.Co, e2);
  }), r2 = e.mutations.map(function(e2) {
    return We(t.Co, e2);
  }), i2 = mt.fromMillis(e.localWriteTimeMs);
  return new ci(e.batchId, i2, n2, r2);
}
function Pi(t) {
  var e, n2, r2 = Ri(t.readTime), i2 = void 0 !== t.lastLimboFreeSnapshotVersion ? Ri(t.lastLimboFreeSnapshotVersion) : gt.min();
  return void 0 !== t.query.documents ? (k2(1 === (n2 = t.query).documents.length), e = er(Hn(je(n2.documents[0])))) : e = Ye(t.query), new kt(e, t.targetId, 0, t.lastListenSequenceNumber, r2, i2, ct.fromBase64String(t.resumeToken));
}
function Vi(t, e) {
  var n2, r2 = Li(e.nt), i2 = Li(e.lastLimboFreeSnapshotVersion);
  n2 = At(e.target) ? Qe(t.Co, e.target) : He(t.Co, e.target);
  var o = e.resumeToken.toBase64();
  return new so(e.targetId, Tt(e.target), r2, o, e.sequenceNumber, i2, n2);
}
var Ui = (
  /** @class */
  function() {
    function t(t2, e, n2, r2) {
      this.userId = t2, this.serializer = e, this.Dr = n2, this.No = r2, /**
           * Caches the document keys for pending mutation batches. If the mutation
           * has been removed from IndexedDb, the cached value may continue to
           * be used to retrieve the batch's document keys. To remove a cached value
           * locally, `removeCachedMutationKeys()` should be invoked either directly
           * or through `removeMutationBatches()`.
           *
           * With multi-tab, when the primary client acknowledges or rejects a mutation,
           * this cache is used by secondary clients to invalidate the local
           * view of the documents that were previously affected by the mutation.
           */
      // PORTING NOTE: Multi-tab only.
      this.Fo = {};
    }
    return t.xo = function(e, n2, r2, i2) {
      return k2("" !== e.uid), new t(e.Zs() ? e.uid : "", n2, r2, i2);
    }, t.prototype.$o = function(t2) {
      var e = true, n2 = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);
      return Mi(t2).rs({
        index: to.userMutationsIndex,
        range: n2
      }, function(t3, n3, r2) {
        e = false, r2.done();
      }).next(function() {
        return e;
      });
    }, t.prototype.ko = function(t2, e, n2, r2) {
      var i2 = this, o = qi(t2), s = Mi(t2);
      return s.add({}).next(function(u4) {
        k2("number" == typeof u4);
        for (var a = new ci(u4, e, n2, r2), c = function(t3, e2, n3) {
          var r3 = n3.baseMutations.map(function(e3) {
            return Ke(t3.Co, e3);
          }), i3 = n3.mutations.map(function(e3) {
            return Ke(t3.Co, e3);
          });
          return new to(e2, n3.batchId, n3.ar.toMillis(), r3, i3);
        }(i2.serializer, i2.userId, a), h = [], f = new Ut(function(t3, e2) {
          return st(t3.R(), e2.R());
        }), l = 0, p2 = r2; l < p2.length; l++) {
          var d = p2[l], v2 = eo.key(i2.userId, d.key.path, u4);
          f = f.add(d.key.path.h()), h.push(s.put(c)), h.push(o.put(v2, eo.PLACEHOLDER));
        }
        return f.forEach(function(e2) {
          h.push(i2.Dr.Mo(t2, e2));
        }), t2.pr(function() {
          i2.Fo[u4] = a.keys();
        }), Dr.$n(h).next(function() {
          return a;
        });
      });
    }, t.prototype.Oo = function(t2, e) {
      var n2 = this;
      return Mi(t2).get(e).next(function(t3) {
        return t3 ? (k2(t3.userId === n2.userId), Oi(n2.serializer, t3)) : null;
      });
    }, /**
     * Returns the document keys for the mutation batch with the given batchId.
     * For primary clients, this method returns `null` after
     * `removeMutationBatches()` has been called. Secondary clients return a
     * cached result until `removeCachedMutationKeys()` is invoked.
     */
    // PORTING NOTE: Multi-tab only.
    t.prototype.Lo = function(t2, e) {
      var n2 = this;
      return this.Fo[e] ? Dr.resolve(this.Fo[e]) : this.Oo(t2, e).next(function(t3) {
        if (t3) {
          var r2 = t3.keys();
          return n2.Fo[e] = r2, r2;
        }
        return null;
      });
    }, t.prototype.Bo = function(t2, e) {
      var n2 = this, r2 = e + 1, i2 = IDBKeyRange.lowerBound([this.userId, r2]), o = null;
      return Mi(t2).rs({
        index: to.userMutationsIndex,
        range: i2
      }, function(t3, e2, i3) {
        e2.userId === n2.userId && (k2(e2.batchId >= r2), o = Oi(n2.serializer, e2)), i3.done();
      }).next(function() {
        return o;
      });
    }, t.prototype.qo = function(t2) {
      var e = IDBKeyRange.upperBound([this.userId, Number.POSITIVE_INFINITY]), n2 = -1;
      return Mi(t2).rs({
        index: to.userMutationsIndex,
        range: e,
        reverse: true
      }, function(t3, e2, r2) {
        n2 = e2.batchId, r2.done();
      }).next(function() {
        return n2;
      });
    }, t.prototype.Uo = function(t2) {
      var e = this, n2 = IDBKeyRange.bound([this.userId, -1], [this.userId, Number.POSITIVE_INFINITY]);
      return Mi(t2).ts(to.userMutationsIndex, n2).next(function(t3) {
        return t3.map(function(t4) {
          return Oi(e.serializer, t4);
        });
      });
    }, t.prototype.Nr = function(t2, e) {
      var n2 = this, r2 = eo.prefixForPath(this.userId, e.path), i2 = IDBKeyRange.lowerBound(r2), o = [];
      return qi(t2).rs({
        range: i2
      }, function(r3, i3, s) {
        var u4 = r3[0], a = r3[1], c = r3[2], h = Ni(a);
        if (u4 === n2.userId && e.path.isEqual(h))
          return Mi(t2).get(c).next(function(t3) {
            if (!t3)
              throw D2();
            k2(t3.userId === n2.userId), o.push(Oi(n2.serializer, t3));
          });
        s.done();
      }).next(function() {
        return o;
      });
    }, t.prototype.Or = function(t2, e) {
      var n2 = this, r2 = new Ut(st), i2 = [];
      return e.forEach(function(e2) {
        var o = eo.prefixForPath(n2.userId, e2.path), s = IDBKeyRange.lowerBound(o), u4 = qi(t2).rs({
          range: s
        }, function(t3, i3, o2) {
          var s2 = t3[0], u5 = t3[1], a = t3[2], c = Ni(u5);
          s2 === n2.userId && e2.path.isEqual(c) ? r2 = r2.add(a) : o2.done();
        });
        i2.push(u4);
      }), Dr.$n(i2).next(function() {
        return n2.Qo(t2, r2);
      });
    }, t.prototype.Wr = function(t2, e) {
      var n2 = this, r2 = e.path, i2 = r2.length + 1, o = eo.prefixForPath(this.userId, r2), s = IDBKeyRange.lowerBound(o), u4 = new Ut(st);
      return qi(t2).rs({
        range: s
      }, function(t3, e2, o2) {
        var s2 = t3[0], a = t3[1], c = t3[2], h = Ni(a);
        s2 === n2.userId && r2.T(h) ? (
          // Rows with document keys more than one segment longer than the
          // query path can't be matches. For example, a query on 'rooms'
          // can't match the document /rooms/abc/messages/xyx.
          // TODO(mcg): we'll need a different scanner when we implement
          // ancestor queries.
          h.length === i2 && (u4 = u4.add(c))
        ) : o2.done();
      }).next(function() {
        return n2.Qo(t2, u4);
      });
    }, t.prototype.Qo = function(t2, e) {
      var n2 = this, r2 = [], i2 = [];
      return e.forEach(function(e2) {
        i2.push(Mi(t2).get(e2).next(function(t3) {
          if (null === t3)
            throw D2();
          k2(t3.userId === n2.userId), r2.push(Oi(n2.serializer, t3));
        }));
      }), Dr.$n(i2).next(function() {
        return r2;
      });
    }, t.prototype.Wo = function(t2, e) {
      var n2 = this;
      return Fi(t2.jo, this.userId, e).next(function(r2) {
        return t2.pr(function() {
          n2.Ko(e.batchId);
        }), Dr.forEach(r2, function(e2) {
          return n2.No.Go(t2, e2);
        });
      });
    }, /**
     * Clears the cached keys for a mutation batch. This method should be
     * called by secondary clients after they process mutation updates.
     *
     * Note that this method does not have to be called from primary clients as
     * the corresponding cache entries are cleared when an acknowledged or
     * rejected batch is removed from the mutation queue.
     */
    // PORTING NOTE: Multi-tab only
    t.prototype.Ko = function(t2) {
      delete this.Fo[t2];
    }, t.prototype.zo = function(t2) {
      var e = this;
      return this.$o(t2).next(function(n2) {
        if (!n2)
          return Dr.resolve();
        var r2 = IDBKeyRange.lowerBound(eo.prefixForUser(e.userId)), i2 = [];
        return qi(t2).rs({
          range: r2
        }, function(t3, n3, r3) {
          if (t3[0] === e.userId) {
            var o = Ni(t3[1]);
            i2.push(o);
          } else
            r3.done();
        }).next(function() {
          k2(0 === i2.length);
        });
      });
    }, t.prototype.Ho = function(t2, e) {
      return Ci(t2, this.userId, e);
    }, // PORTING NOTE: Multi-tab only (state is held in memory in other clients).
    /** Returns the mutation queue's metadata from IndexedDb. */
    t.prototype.Yo = function(t2) {
      var e = this;
      return ji(t2).get(this.userId).next(function(t3) {
        return t3 || new Zi(
          e.userId,
          -1,
          /*lastStreamToken=*/
          ""
        );
      });
    }, t;
  }()
);
function Ci(t, e, n2) {
  var r2 = eo.prefixForPath(e, n2.path), i2 = r2[1], o = IDBKeyRange.lowerBound(r2), s = false;
  return qi(t).rs({
    range: o,
    ss: true
  }, function(t2, n3, r3) {
    var o2 = t2[0], u4 = t2[1];
    t2[2];
    o2 === e && u4 === i2 && (s = true), r3.done();
  }).next(function() {
    return s;
  });
}
function Fi(t, e, n2) {
  var r2 = t.store(to.store), i2 = t.store(eo.store), o = [], s = IDBKeyRange.only(n2.batchId), u4 = 0, a = r2.rs({
    range: s
  }, function(t2, e2, n3) {
    return u4++, n3.delete();
  });
  o.push(a.next(function() {
    k2(1 === u4);
  }));
  for (var c = [], h = 0, f = n2.mutations; h < f.length; h++) {
    var l = f[h], p2 = eo.key(e, l.key.path, n2.batchId);
    o.push(i2.delete(p2)), c.push(l.key);
  }
  return Dr.$n(o).next(function() {
    return c;
  });
}
function Mi(t) {
  return _o.Qn(t, to.store);
}
function qi(t) {
  return _o.Qn(t, eo.store);
}
function ji(t) {
  return _o.Qn(t, Zi.store);
}
var Gi = (
  /** @class */
  function() {
    function t(t2, e) {
      this.serializer = t2, this.Dr = e;
    }
    return t.prototype.Er = function(t2, e, n2) {
      return Ki(t2).put(Wi(e), n2);
    }, /**
     * Removes a document from the cache.
     *
     * All calls of `removeEntry`  are required to go through the RemoteDocumentChangeBuffer
     * returned by `newChangeBuffer()` to ensure proper accounting of metadata.
     */
    t.prototype.Ar = function(t2, e) {
      var n2 = Ki(t2), r2 = Wi(e);
      return n2.delete(r2);
    }, /**
     * Updates the current cache size.
     *
     * Callers to `addEntry()` and `removeEntry()` *must* call this afterwards to update the
     * cache's metadata.
     */
    t.prototype.updateMetadata = function(t2, e) {
      var n2 = this;
      return this.getMetadata(t2).next(function(r2) {
        return r2.byteSize += e, n2.Jo(t2, r2);
      });
    }, t.prototype.Rr = function(t2, e) {
      var n2 = this;
      return Ki(t2).get(Wi(e)).next(function(t3) {
        return n2.Xo(t3);
      });
    }, /**
     * Looks up an entry in the cache.
     *
     * @param documentKey The key of the entry to look up.
     * @return The cached MaybeDocument entry and its size, or null if we have nothing cached.
     */
    t.prototype.Zo = function(t2, e) {
      var n2 = this;
      return Ki(t2).get(Wi(e)).next(function(t3) {
        var e2 = n2.Xo(t3);
        return e2 ? {
          ta: e2,
          size: Qi(t3)
        } : null;
      });
    }, t.prototype.getEntries = function(t2, e) {
      var n2 = this, r2 = qt();
      return this.ea(t2, e, function(t3, e2) {
        var i2 = n2.Xo(e2);
        r2 = r2.ot(t3, i2);
      }).next(function() {
        return r2;
      });
    }, /**
     * Looks up several entries in the cache.
     *
     * @param documentKeys The set of keys entries to look up.
     * @return A map of MaybeDocuments indexed by key (if a document cannot be
     *     found, the key will be mapped to null) and a map of sizes indexed by
     *     key (zero if the key cannot be found).
     */
    t.prototype.na = function(t2, e) {
      var n2 = this, r2 = qt(), i2 = new Ot(F2.i);
      return this.ea(t2, e, function(t3, e2) {
        var o = n2.Xo(e2);
        o ? (r2 = r2.ot(t3, o), i2 = i2.ot(t3, Qi(e2))) : (r2 = r2.ot(t3, null), i2 = i2.ot(t3, 0));
      }).next(function() {
        return {
          sa: r2,
          ia: i2
        };
      });
    }, t.prototype.ea = function(t2, e, n2) {
      if (e.m())
        return Dr.resolve();
      var r2 = IDBKeyRange.bound(e.first().path.A(), e.last().path.A()), i2 = e._t(), o = i2.It();
      return Ki(t2).rs({
        range: r2
      }, function(t3, e2, r3) {
        for (var s = F2.$(t3); o && F2.i(o, s) < 0; )
          n2(o, null), o = i2.It();
        o && o.isEqual(s) && // Key found in cache.
        (n2(o, e2), o = i2.At() ? i2.It() : null), // Skip to the next key (if there is one).
        o ? r3.Xn(o.path.A()) : r3.done();
      }).next(function() {
        for (; o; )
          n2(o, null), o = i2.At() ? i2.It() : null;
      });
    }, t.prototype.Lr = function(t2, e, n2) {
      var r2 = this, i2 = Gt(), o = e.path.length + 1, s = {};
      if (n2.isEqual(gt.min())) {
        var u4 = e.path.A();
        s.range = IDBKeyRange.lowerBound(u4);
      } else {
        var a = e.path.A(), c = ki(n2);
        s.range = IDBKeyRange.lowerBound(
          [a, c],
          /* open= */
          true
        ), s.index = io.collectionReadTimeIndex;
      }
      return Ki(t2).rs(s, function(t3, n3, s2) {
        if (t3.length === o) {
          var u5 = Si(r2.serializer, n3);
          e.path.T(u5.key.path) ? u5 instanceof zn && ar(e, u5) && (i2 = i2.ot(u5.key, u5)) : s2.done();
        }
      }).next(function() {
        return i2;
      });
    }, t.prototype.ra = function(t2) {
      return new zi(this, !!t2 && t2.oa);
    }, t.prototype.aa = function(t2) {
      return this.getMetadata(t2).next(function(t3) {
        return t3.byteSize;
      });
    }, t.prototype.getMetadata = function(t2) {
      return Bi(t2).get(oo.key).next(function(t3) {
        return k2(!!t3), t3;
      });
    }, t.prototype.Jo = function(t2, e) {
      return Bi(t2).put(oo.key, e);
    }, /**
     * Decodes `remoteDoc` and returns the document (or null, if the document
     * corresponds to the format used for sentinel deletes).
     */
    t.prototype.Xo = function(t2) {
      if (t2) {
        var e = Si(this.serializer, t2);
        return e instanceof Bn && e.version.isEqual(gt.min()) ? null : e;
      }
      return null;
    }, t;
  }()
);
var zi = (
  /** @class */
  function(e) {
    function n2(t, n3) {
      var r2 = this;
      return (r2 = e.call(this) || this).ca = t, r2.oa = n3, // A map of document sizes prior to applying the changes in this buffer.
      r2.ua = new yt(function(t2) {
        return t2.toString();
      }, function(t2, e2) {
        return t2.isEqual(e2);
      }), r2;
    }
    return __extends(n2, e), n2.prototype.yr = function(t) {
      var e2 = this, n3 = [], r2 = 0, i2 = new Ut(function(t2, e3) {
        return st(t2.R(), e3.R());
      });
      return this.wr.forEach(function(o, s) {
        var u4 = e2.ua.get(o);
        if (s) {
          var a = Di(e2.ca.serializer, s, e2.readTime);
          i2 = i2.add(o.path.h());
          var c = Qi(a);
          r2 += c - u4, n3.push(e2.ca.Er(t, o, a));
        } else if (r2 -= u4, e2.oa) {
          var h = Di(e2.ca.serializer, new Bn(o, gt.min()), e2.readTime);
          n3.push(e2.ca.Er(t, o, h));
        } else
          n3.push(e2.ca.Ar(t, o));
      }), i2.forEach(function(r3) {
        n3.push(e2.ca.Dr.Mo(t, r3));
      }), n3.push(this.ca.updateMetadata(t, r2)), Dr.$n(n3);
    }, n2.prototype.gr = function(t, e2) {
      var n3 = this;
      return this.ca.Zo(t, e2).next(function(t2) {
        return null === t2 ? (n3.ua.set(e2, 0), null) : (n3.ua.set(e2, t2.size), t2.ta);
      });
    }, n2.prototype.Pr = function(t, e2) {
      var n3 = this;
      return this.ca.na(t, e2).next(function(t2) {
        var e3 = t2.sa;
        return t2.ia.forEach(function(t3, e4) {
          n3.ua.set(t3, e4);
        }), e3;
      });
    }, n2;
  }(fi)
);
function Bi(t) {
  return _o.Qn(t, oo.store);
}
function Ki(t) {
  return _o.Qn(t, io.store);
}
function Wi(t) {
  return t.path.A();
}
function Qi(t) {
  var e;
  if (t.document)
    e = t.document;
  else if (t.unknownDocument)
    e = t.unknownDocument;
  else {
    if (!t.noDocument)
      throw D2();
    e = t.noDocument;
  }
  return JSON.stringify(e).length;
}
var Hi = (
  /** @class */
  function() {
    function t() {
      this.ha = new Yi();
    }
    return t.prototype.Mo = function(t2, e) {
      return this.ha.add(e), Dr.resolve();
    }, t.prototype.Qr = function(t2, e) {
      return Dr.resolve(this.ha.getEntries(e));
    }, t;
  }()
);
var Yi = (
  /** @class */
  function() {
    function t() {
      this.index = {};
    }
    return t.prototype.add = function(t2) {
      var e = t2._(), n2 = t2.h(), r2 = this.index[e] || new Ut(V2.i), i2 = !r2.has(n2);
      return this.index[e] = r2.add(n2), i2;
    }, t.prototype.has = function(t2) {
      var e = t2._(), n2 = t2.h(), r2 = this.index[e];
      return r2 && r2.has(n2);
    }, t.prototype.getEntries = function(t2) {
      return (this.index[t2] || new Ut(V2.i)).A();
    }, t;
  }()
);
var $i = (
  /** @class */
  function() {
    function t(t2) {
      this.serializer = t2;
    }
    return t.prototype.createOrUpgrade = function(t2, e, n2, r2) {
      var i2 = this;
      k2(n2 < r2 && n2 >= 0 && r2 <= 10);
      var o = new Or("createOrUpgrade", e);
      n2 < 1 && r2 >= 1 && (function(t3) {
        t3.createObjectStore(Ji.store);
      }(t2), function(t3) {
        t3.createObjectStore(Zi.store, {
          keyPath: Zi.keyPath
        }), t3.createObjectStore(to.store, {
          keyPath: to.keyPath,
          autoIncrement: true
        }).createIndex(to.userMutationsIndex, to.userMutationsKeyPath, {
          unique: true
        }), t3.createObjectStore(eo.store);
      }(t2), ho(t2), function(t3) {
        t3.createObjectStore(io.store);
      }(t2));
      var s = Dr.resolve();
      return n2 < 3 && r2 >= 3 && // Brand new clients don't need to drop and recreate--only clients that
      // potentially have corrupt data.
      (0 !== n2 && (function(t3) {
        t3.deleteObjectStore(uo.store), t3.deleteObjectStore(so.store), t3.deleteObjectStore(ao.store);
      }(t2), ho(t2)), s = s.next(function() {
        return function(t3) {
          var e2 = t3.store(ao.store), n3 = new ao(
            /*highestTargetId=*/
            0,
            /*lastListenSequenceNumber=*/
            0,
            gt.min().Z(),
            /*targetCount=*/
            0
          );
          return e2.put(ao.key, n3);
        }(o);
      })), n2 < 4 && r2 >= 4 && (0 !== n2 && // Schema version 3 uses auto-generated keys to generate globally unique
      // mutation batch IDs (this was previously ensured internally by the
      // client). To migrate to the new schema, we have to read all mutations
      // and write them back out. We preserve the existing batch IDs to guarantee
      // consistency with other object stores. Any further mutation batch IDs will
      // be auto-generated.
      (s = s.next(function() {
        return function(t3, e2) {
          return e2.store(to.store).ts().next(function(n3) {
            t3.deleteObjectStore(to.store), t3.createObjectStore(to.store, {
              keyPath: to.keyPath,
              autoIncrement: true
            }).createIndex(to.userMutationsIndex, to.userMutationsKeyPath, {
              unique: true
            });
            var r3 = e2.store(to.store), i3 = n3.map(function(t4) {
              return r3.put(t4);
            });
            return Dr.$n(i3);
          });
        }(t2, o);
      })), s = s.next(function() {
        !function(t3) {
          t3.createObjectStore(fo.store, {
            keyPath: fo.keyPath
          });
        }(t2);
      })), n2 < 5 && r2 >= 5 && (s = s.next(function() {
        return i2.removeAcknowledgedMutations(o);
      })), n2 < 6 && r2 >= 6 && (s = s.next(function() {
        return function(t3) {
          t3.createObjectStore(oo.store);
        }(t2), i2.addDocumentGlobal(o);
      })), n2 < 7 && r2 >= 7 && (s = s.next(function() {
        return i2.ensureSequenceNumbers(o);
      })), n2 < 8 && r2 >= 8 && (s = s.next(function() {
        return i2.createCollectionParentIndex(t2, o);
      })), n2 < 9 && r2 >= 9 && (s = s.next(function() {
        !function(t3) {
          t3.objectStoreNames.contains("remoteDocumentChanges") && t3.deleteObjectStore("remoteDocumentChanges");
        }(t2), function(t3) {
          var e2 = t3.objectStore(io.store);
          e2.createIndex(io.readTimeIndex, io.readTimeIndexPath, {
            unique: false
          }), e2.createIndex(io.collectionReadTimeIndex, io.collectionReadTimeIndexPath, {
            unique: false
          });
        }(e);
      })), n2 < 10 && r2 >= 10 && (s = s.next(function() {
        return i2.rewriteCanonicalIds(o);
      })), s;
    }, t.prototype.addDocumentGlobal = function(t2) {
      var e = 0;
      return t2.store(io.store).rs(function(t3, n2) {
        e += Qi(n2);
      }).next(function() {
        var n2 = new oo(e);
        return t2.store(oo.store).put(oo.key, n2);
      });
    }, t.prototype.removeAcknowledgedMutations = function(t2) {
      var e = this, n2 = t2.store(Zi.store), r2 = t2.store(to.store);
      return n2.ts().next(function(n3) {
        return Dr.forEach(n3, function(n4) {
          var i2 = IDBKeyRange.bound([n4.userId, -1], [n4.userId, n4.lastAcknowledgedBatchId]);
          return r2.ts(to.userMutationsIndex, i2).next(function(r3) {
            return Dr.forEach(r3, function(r4) {
              k2(r4.userId === n4.userId);
              var i3 = Oi(e.serializer, r4);
              return Fi(t2, n4.userId, i3).next(function() {
              });
            });
          });
        });
      });
    }, /**
     * Ensures that every document in the remote document cache has a corresponding sentinel row
     * with a sequence number. Missing rows are given the most recently used sequence number.
     */
    t.prototype.ensureSequenceNumbers = function(t2) {
      var e = t2.store(uo.store), n2 = t2.store(io.store);
      return t2.store(ao.store).get(ao.key).next(function(t3) {
        var r2 = [];
        return n2.rs(function(n3, i2) {
          var o = new V2(n3), s = function(t4) {
            return [0, Ei(t4)];
          }(o);
          r2.push(e.get(s).next(function(n4) {
            return n4 ? Dr.resolve() : function(n5) {
              return e.put(new uo(0, Ei(n5), t3.highestListenSequenceNumber));
            }(o);
          }));
        }).next(function() {
          return Dr.$n(r2);
        });
      });
    }, t.prototype.createCollectionParentIndex = function(t2, e) {
      t2.createObjectStore(co.store, {
        keyPath: co.keyPath
      });
      var n2 = e.store(co.store), r2 = new Yi(), i2 = function(t3) {
        if (r2.add(t3)) {
          var e2 = t3._(), i3 = t3.h();
          return n2.put({
            collectionId: e2,
            parent: Ei(i3)
          });
        }
      };
      return e.store(io.store).rs({
        ss: true
      }, function(t3, e2) {
        var n3 = new V2(t3);
        return i2(n3.h());
      }).next(function() {
        return e.store(eo.store).rs({
          ss: true
        }, function(t3, e2) {
          t3[0];
          var n3 = t3[1], r3 = (t3[2], Ni(n3));
          return i2(r3.h());
        });
      });
    }, t.prototype.rewriteCanonicalIds = function(t2) {
      var e = this, n2 = t2.store(so.store);
      return n2.rs(function(t3, r2) {
        var i2 = Pi(r2), o = Vi(e.serializer, i2);
        return n2.put(o);
      });
    }, t;
  }()
);
var Xi = function(t, e) {
  this.seconds = t, this.nanoseconds = e;
};
var Ji = function(t, e, n2) {
  this.ownerId = t, this.allowTabSynchronization = e, this.leaseTimestampMs = n2;
};
Ji.store = "owner", /**
     * The key string used for the single object that exists in the
     * DbPrimaryClient store.
     */
Ji.key = "owner";
var Zi = function(t, e, n2) {
  this.userId = t, this.lastAcknowledgedBatchId = e, this.lastStreamToken = n2;
};
Zi.store = "mutationQueues", /** Keys are automatically assigned via the userId property. */
Zi.keyPath = "userId";
var to = function(t, e, n2, r2, i2) {
  this.userId = t, this.batchId = e, this.localWriteTimeMs = n2, this.baseMutations = r2, this.mutations = i2;
};
to.store = "mutations", /** Keys are automatically assigned via the userId, batchId properties. */
to.keyPath = "batchId", /** The index name for lookup of mutations by user. */
to.userMutationsIndex = "userMutationsIndex", /** The user mutations index is keyed by [userId, batchId] pairs. */
to.userMutationsKeyPath = ["userId", "batchId"];
var eo = (
  /** @class */
  function() {
    function t() {
    }
    return t.prefixForUser = function(t2) {
      return [t2];
    }, /**
     * Creates a [userId, encodedPath] key for use in the DbDocumentMutations
     * index to iterate over all at document mutations for a given path or lower.
     */
    t.prefixForPath = function(t2, e) {
      return [t2, Ei(e)];
    }, /**
     * Creates a full index key of [userId, encodedPath, batchId] for inserting
     * and deleting into the DbDocumentMutations index.
     */
    t.key = function(t2, e, n2) {
      return [t2, Ei(e), n2];
    }, t;
  }()
);
eo.store = "documentMutations", /**
     * Because we store all the useful information for this store in the key,
     * there is no useful information to store as the value. The raw (unencoded)
     * path cannot be stored because IndexedDb doesn't store prototype
     * information.
     */
eo.PLACEHOLDER = new eo();
var no = function(t, e) {
  this.path = t, this.readTime = e;
};
var ro = function(t, e) {
  this.path = t, this.version = e;
};
var io = (
  // TODO: We are currently storing full document keys almost three times
  // (once as part of the primary key, once - partly - as `parentPath` and once
  // inside the encoded documents). During our next migration, we should
  // rewrite the primary key as parentPath + document ID which would allow us
  // to drop one value.
  function(t, e, n2, r2, i2, o) {
    this.unknownDocument = t, this.noDocument = e, this.document = n2, this.hasCommittedMutations = r2, this.readTime = i2, this.parentPath = o;
  }
);
io.store = "remoteDocuments", /**
     * An index that provides access to all entries sorted by read time (which
     * corresponds to the last modification time of each row).
     *
     * This index is used to provide a changelog for Multi-Tab.
     */
io.readTimeIndex = "readTimeIndex", io.readTimeIndexPath = "readTime", /**
     * An index that provides access to documents in a collection sorted by read
     * time.
     *
     * This index is used to allow the RemoteDocumentCache to fetch newly changed
     * documents in a collection.
     */
io.collectionReadTimeIndex = "collectionReadTimeIndex", io.collectionReadTimeIndexPath = ["parentPath", "readTime"];
var oo = (
  /**
       * @param byteSize Approximately the total size in bytes of all the documents in the document
       * cache.
       */
  function(t) {
    this.byteSize = t;
  }
);
oo.store = "remoteDocumentGlobal", oo.key = "remoteDocumentGlobalKey";
var so = function(t, e, n2, r2, i2, o, s) {
  this.targetId = t, this.canonicalId = e, this.readTime = n2, this.resumeToken = r2, this.lastListenSequenceNumber = i2, this.lastLimboFreeSnapshotVersion = o, this.query = s;
};
so.store = "targets", /** Keys are automatically assigned via the targetId property. */
so.keyPath = "targetId", /** The name of the queryTargets index. */
so.queryTargetsIndexName = "queryTargetsIndex", /**
     * The index of all canonicalIds to the targets that they match. This is not
     * a unique mapping because canonicalId does not promise a unique name for all
     * possible queries, so we append the targetId to make the mapping unique.
     */
so.queryTargetsKeyPath = ["canonicalId", "targetId"];
var uo = function(t, e, n2) {
  this.targetId = t, this.path = e, this.sequenceNumber = n2;
};
uo.store = "targetDocuments", /** Keys are automatically assigned via the targetId, path properties. */
uo.keyPath = ["targetId", "path"], /** The index name for the reverse index. */
uo.documentTargetsIndex = "documentTargetsIndex", /** We also need to create the reverse index for these properties. */
uo.documentTargetsKeyPath = ["path", "targetId"];
var ao = function(t, e, n2, r2) {
  this.highestTargetId = t, this.highestListenSequenceNumber = e, this.lastRemoteSnapshotVersion = n2, this.targetCount = r2;
};
ao.key = "targetGlobalKey", ao.store = "targetGlobal";
var co = function(t, e) {
  this.collectionId = t, this.parent = e;
};
function ho(t) {
  t.createObjectStore(uo.store, {
    keyPath: uo.keyPath
  }).createIndex(uo.documentTargetsIndex, uo.documentTargetsKeyPath, {
    unique: true
  }), // NOTE: This is unique only because the TargetId is the suffix.
  t.createObjectStore(so.store, {
    keyPath: so.keyPath
  }).createIndex(so.queryTargetsIndexName, so.queryTargetsKeyPath, {
    unique: true
  }), t.createObjectStore(ao.store);
}
co.store = "collectionParents", /** Keys are automatically assigned via the collectionId, parent properties. */
co.keyPath = ["collectionId", "parent"];
var fo = function(t, e, n2, r2) {
  this.clientId = t, this.updateTimeMs = e, this.networkEnabled = n2, this.inForeground = r2;
};
fo.store = "clientMetadata", /** Keys are automatically assigned via the clientId properties. */
fo.keyPath = "clientId";
var lo = __spreadArrays(__spreadArrays(__spreadArrays([Zi.store, to.store, eo.store, io.store, so.store, Ji.store, ao.store, uo.store], [fo.store]), [oo.store]), [co.store]);
var po = (
  /** @class */
  function() {
    function t() {
      this.la = new Yi();
    }
    return t.prototype.Mo = function(t2, e) {
      var n2 = this;
      if (!this.la.has(e)) {
        var r2 = e._(), i2 = e.h();
        t2.pr(function() {
          n2.la.add(e);
        });
        var o = {
          collectionId: r2,
          parent: Ei(i2)
        };
        return vo(t2).put(o);
      }
      return Dr.resolve();
    }, t.prototype.Qr = function(t2, e) {
      var n2 = [], r2 = IDBKeyRange.bound(
        [e, ""],
        [at(e), ""],
        /*lowerOpen=*/
        false,
        /*upperOpen=*/
        true
      );
      return vo(t2).ts(r2).next(function(t3) {
        for (var r3 = 0, i2 = t3; r3 < i2.length; r3++) {
          var o = i2[r3];
          if (o.collectionId !== e)
            break;
          n2.push(Ni(o.parent));
        }
        return n2;
      });
    }, t;
  }()
);
function vo(t) {
  return _o.Qn(t, co.store);
}
var yo = (
  /** @class */
  function() {
    function t(t2) {
      this._a = t2;
    }
    return t.prototype.next = function() {
      return this._a += 2, this._a;
    }, t.fa = function() {
      return new t(0);
    }, t.da = function() {
      return new t(-1);
    }, t;
  }()
);
var mo = (
  /** @class */
  function() {
    function t(t2, e) {
      this.No = t2, this.serializer = e;
    }
    return t.prototype.wa = function(t2) {
      var e = this;
      return this.ma(t2).next(function(n2) {
        var r2 = new yo(n2.highestTargetId);
        return n2.highestTargetId = r2.next(), e.Ta(t2, n2).next(function() {
          return n2.highestTargetId;
        });
      });
    }, t.prototype.Ea = function(t2) {
      return this.ma(t2).next(function(t3) {
        return gt.J(new mt(t3.lastRemoteSnapshotVersion.seconds, t3.lastRemoteSnapshotVersion.nanoseconds));
      });
    }, t.prototype.Ia = function(t2) {
      return this.ma(t2).next(function(t3) {
        return t3.highestListenSequenceNumber;
      });
    }, t.prototype.Aa = function(t2, e, n2) {
      var r2 = this;
      return this.ma(t2).next(function(i2) {
        return i2.highestListenSequenceNumber = e, n2 && (i2.lastRemoteSnapshotVersion = n2.Z()), e > i2.highestListenSequenceNumber && (i2.highestListenSequenceNumber = e), r2.Ta(t2, i2);
      });
    }, t.prototype.Ra = function(t2, e) {
      var n2 = this;
      return this.ga(t2, e).next(function() {
        return n2.ma(t2).next(function(r2) {
          return r2.targetCount += 1, n2.Pa(e, r2), n2.Ta(t2, r2);
        });
      });
    }, t.prototype.ya = function(t2, e) {
      return this.ga(t2, e);
    }, t.prototype.Va = function(t2, e) {
      var n2 = this;
      return this.pa(t2, e.targetId).next(function() {
        return go(t2).delete(e.targetId);
      }).next(function() {
        return n2.ma(t2);
      }).next(function(e2) {
        return k2(e2.targetCount > 0), e2.targetCount -= 1, n2.Ta(t2, e2);
      });
    }, /**
     * Drops any targets with sequence number less than or equal to the upper bound, excepting those
     * present in `activeTargetIds`. Document associations for the removed targets are also removed.
     * Returns the number of targets removed.
     */
    t.prototype.po = function(t2, e, n2) {
      var r2 = this, i2 = 0, o = [];
      return go(t2).rs(function(s, u4) {
        var a = Pi(u4);
        a.sequenceNumber <= e && null === n2.get(a.targetId) && (i2++, o.push(r2.Va(t2, a)));
      }).next(function() {
        return Dr.$n(o);
      }).next(function() {
        return i2;
      });
    }, /**
     * Call provided function with each `TargetData` that we have cached.
     */
    t.prototype.Ce = function(t2, e) {
      return go(t2).rs(function(t3, n2) {
        var r2 = Pi(n2);
        e(r2);
      });
    }, t.prototype.ma = function(t2) {
      return wo(t2).get(ao.key).next(function(t3) {
        return k2(null !== t3), t3;
      });
    }, t.prototype.Ta = function(t2, e) {
      return wo(t2).put(ao.key, e);
    }, t.prototype.ga = function(t2, e) {
      return go(t2).put(Vi(this.serializer, e));
    }, /**
     * In-place updates the provided metadata to account for values in the given
     * TargetData. Saving is done separately. Returns true if there were any
     * changes to the metadata.
     */
    t.prototype.Pa = function(t2, e) {
      var n2 = false;
      return t2.targetId > e.highestTargetId && (e.highestTargetId = t2.targetId, n2 = true), t2.sequenceNumber > e.highestListenSequenceNumber && (e.highestListenSequenceNumber = t2.sequenceNumber, n2 = true), n2;
    }, t.prototype.ba = function(t2) {
      return this.ma(t2).next(function(t3) {
        return t3.targetCount;
      });
    }, t.prototype.va = function(t2, e) {
      var n2 = Tt(e), r2 = IDBKeyRange.bound([n2, Number.NEGATIVE_INFINITY], [n2, Number.POSITIVE_INFINITY]), i2 = null;
      return go(t2).rs({
        range: r2,
        index: so.queryTargetsIndexName
      }, function(t3, n3, r3) {
        var o = Pi(n3);
        Nt(e, o.target) && (i2 = o, r3.done());
      }).next(function() {
        return i2;
      });
    }, t.prototype.Sa = function(t2, e, n2) {
      var r2 = this, i2 = [], o = bo(t2);
      return e.forEach(function(e2) {
        var s = Ei(e2.path);
        i2.push(o.put(new uo(n2, s))), i2.push(r2.No.Da(t2, n2, e2));
      }), Dr.$n(i2);
    }, t.prototype.Ca = function(t2, e, n2) {
      var r2 = this, i2 = bo(t2);
      return Dr.forEach(e, function(e2) {
        var o = Ei(e2.path);
        return Dr.$n([i2.delete([n2, o]), r2.No.Na(t2, n2, e2)]);
      });
    }, t.prototype.pa = function(t2, e) {
      var n2 = bo(t2), r2 = IDBKeyRange.bound(
        [e],
        [e + 1],
        /*lowerOpen=*/
        false,
        /*upperOpen=*/
        true
      );
      return n2.delete(r2);
    }, t.prototype.Fa = function(t2, e) {
      var n2 = IDBKeyRange.bound(
        [e],
        [e + 1],
        /*lowerOpen=*/
        false,
        /*upperOpen=*/
        true
      ), r2 = bo(t2), i2 = Kt();
      return r2.rs({
        range: n2,
        ss: true
      }, function(t3, e2, n3) {
        var r3 = Ni(t3[1]), o = new F2(r3);
        i2 = i2.add(o);
      }).next(function() {
        return i2;
      });
    }, t.prototype.Ho = function(t2, e) {
      var n2 = Ei(e.path), r2 = IDBKeyRange.bound(
        [n2],
        [at(n2)],
        /*lowerOpen=*/
        false,
        /*upperOpen=*/
        true
      ), i2 = 0;
      return bo(t2).rs({
        index: uo.documentTargetsIndex,
        ss: true,
        range: r2
      }, function(t3, e2, n3) {
        var r3 = t3[0];
        t3[1];
        0 !== r3 && (i2++, n3.done());
      }).next(function() {
        return i2 > 0;
      });
    }, /**
     * Looks up a TargetData entry by target ID.
     *
     * @param targetId The target ID of the TargetData entry to look up.
     * @return The cached TargetData entry, or null if the cache has no entry for
     * the target.
     */
    // PORTING NOTE: Multi-tab only.
    t.prototype.Ue = function(t2, e) {
      return go(t2).get(e).next(function(t3) {
        return t3 ? Pi(t3) : null;
      });
    }, t;
  }()
);
function go(t) {
  return _o.Qn(t, so.store);
}
function wo(t) {
  return _o.Qn(t, ao.store);
}
function bo(t) {
  return _o.Qn(t, uo.store);
}
var Io = "Failed to obtain exclusive access to the persistence layer. To allow shared access, make sure to invoke `enablePersistence()` with `synchronizeTabs:true` in all tabs. If you are using `experimentalForceOwningTab:true`, make sure that only one tab has persistence enabled at any given time.";
var Eo = (
  /** @class */
  function(e) {
    function n2(t, n3) {
      var r2 = this;
      return (r2 = e.call(this) || this).jo = t, r2.xa = n3, r2;
    }
    return __extends(n2, e), n2;
  }(pi)
);
var _o = (
  /** @class */
  function() {
    function t(e, n2, r2, i2, o, s, u4, a, c, h) {
      if (this.allowTabSynchronization = e, this.persistenceKey = n2, this.clientId = r2, this.fn = o, this.window = s, this.document = u4, this.$a = c, this.ka = h, this.Ma = null, this.Oa = false, this.isPrimary = false, this.networkEnabled = true, /** Our window.unload handler, if registered. */
      this.La = null, this.inForeground = false, /** Our 'visibilitychange' listener if registered. */
      this.Ba = null, /** The client metadata refresh task. */
      this.qa = null, /** The last time we garbage collected the client metadata object store. */
      this.Ua = Number.NEGATIVE_INFINITY, /** A listener to notify on primary state changes. */
      this.Qa = function(t2) {
        return Promise.resolve();
      }, !t.Ln())
        throw new I2(b.UNIMPLEMENTED, "This platform is either missing IndexedDB or is known to have an incomplete implementation. Offline persistence has been disabled.");
      this.No = new Ao(this, i2), this.Wa = n2 + "main", this.serializer = new Ai(a), this.ja = new kr(this.Wa, 10, new $i(this.serializer)), this.Ka = new mo(this.No, this.serializer), this.Dr = new po(), this.vr = function(t2, e2) {
        return new Gi(t2, e2);
      }(this.serializer, this.Dr), this.window && this.window.localStorage ? this.Ga = this.window.localStorage : (this.Ga = null, false === h && N2("IndexedDbPersistence", "LocalStorage is unavailable. As a result, persistence may not work reliably. In particular enablePersistence() could fail immediately after refreshing the page."));
    }
    return t.Qn = function(t2, e) {
      if (t2 instanceof Eo)
        return kr.Qn(t2.jo, e);
      throw D2();
    }, /**
     * Attempt to start IndexedDb persistence.
     *
     * @return {Promise<void>} Whether persistence was enabled.
     */
    t.prototype.start = function() {
      var t2 = this;
      return this.za().then(function() {
        if (!t2.isPrimary && !t2.allowTabSynchronization)
          throw new I2(b.FAILED_PRECONDITION, Io);
        return t2.Ha(), t2.Ya(), t2.Ja(), t2.runTransaction("getHighestListenSequenceNumber", "readonly", function(e) {
          return t2.Ka.Ia(e);
        });
      }).then(function(e) {
        t2.Ma = new Jr(e, t2.$a);
      }).then(function() {
        t2.Oa = true;
      }).catch(function(e) {
        return t2.ja && t2.ja.close(), Promise.reject(e);
      });
    }, /**
     * Registers a listener that gets called when the primary state of the
     * instance changes. Upon registering, this listener is invoked immediately
     * with the current primary state.
     *
     * PORTING NOTE: This is only used for Web multi-tab.
     */
    t.prototype.Xa = function(t2) {
      var r2 = this;
      return this.Qa = function(i2) {
        return __awaiter(r2, void 0, void 0, function() {
          return __generator(this, function(e) {
            return this.Ei ? [2, t2(i2)] : [
              2
              /*return*/
            ];
          });
        });
      }, t2(this.isPrimary);
    }, /**
     * Registers a listener that gets called when the database receives a
     * version change event indicating that it has deleted.
     *
     * PORTING NOTE: This is only used for Web multi-tab.
     */
    t.prototype.Za = function(t2) {
      var r2 = this;
      this.ja.Kn(function(i2) {
        return __awaiter(r2, void 0, void 0, function() {
          return __generator(this, function(e) {
            switch (e.label) {
              case 0:
                return null === i2.newVersion ? [4, t2()] : [3, 2];
              case 1:
                e.sent(), e.label = 2;
              case 2:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      });
    }, /**
     * Adjusts the current network state in the client's metadata, potentially
     * affecting the primary lease.
     *
     * PORTING NOTE: This is only used for Web multi-tab.
     */
    t.prototype.tc = function(t2) {
      var r2 = this;
      this.networkEnabled !== t2 && (this.networkEnabled = t2, // Schedule a primary lease refresh for immediate execution. The eventual
      // lease update will be propagated via `primaryStateListener`.
      this.fn.ws(function() {
        return __awaiter(r2, void 0, void 0, function() {
          return __generator(this, function(t3) {
            switch (t3.label) {
              case 0:
                return this.Ei ? [4, this.za()] : [3, 2];
              case 1:
                t3.sent(), t3.label = 2;
              case 2:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }));
    }, /**
     * Updates the client metadata in IndexedDb and attempts to either obtain or
     * extend the primary lease for the local client. Asynchronously notifies the
     * primary state listener if the client either newly obtained or released its
     * primary lease.
     */
    t.prototype.za = function() {
      var t2 = this;
      return this.runTransaction("updateClientMetadataAndTryBecomePrimary", "readwrite", function(e) {
        return No(e).put(new fo(t2.clientId, Date.now(), t2.networkEnabled, t2.inForeground)).next(function() {
          if (t2.isPrimary)
            return t2.ec(e).next(function(e2) {
              e2 || (t2.isPrimary = false, t2.fn.Cs(function() {
                return t2.Qa(false);
              }));
            });
        }).next(function() {
          return t2.nc(e);
        }).next(function(n2) {
          return t2.isPrimary && !n2 ? t2.sc(e).next(function() {
            return false;
          }) : !!n2 && t2.ic(e).next(function() {
            return true;
          });
        });
      }).catch(function(e) {
        if (Rr(e))
          return T2("IndexedDbPersistence", "Failed to extend owner lease: ", e), t2.isPrimary;
        if (!t2.allowTabSynchronization)
          throw e;
        return T2("IndexedDbPersistence", "Releasing owner lease after error during lease refresh", e), /* isPrimary= */
        false;
      }).then(function(e) {
        t2.isPrimary !== e && t2.fn.Cs(function() {
          return t2.Qa(e);
        }), t2.isPrimary = e;
      });
    }, t.prototype.ec = function(t2) {
      var e = this;
      return To(t2).get(Ji.key).next(function(t3) {
        return Dr.resolve(e.rc(t3));
      });
    }, t.prototype.oc = function(t2) {
      return No(t2).delete(this.clientId);
    }, /**
     * If the garbage collection threshold has passed, prunes the
     * RemoteDocumentChanges and the ClientMetadata store based on the last update
     * time of all clients.
     */
    t.prototype.ac = function() {
      return __awaiter(this, void 0, void 0, function() {
        var e, r2, i2, o, s = this;
        return __generator(this, function(n2) {
          switch (n2.label) {
            case 0:
              return !this.isPrimary || this.cc(this.Ua, 18e5) ? [3, 2] : (this.Ua = Date.now(), [4, this.runTransaction("maybeGarbageCollectMultiClientState", "readwrite-primary", function(e2) {
                var n3 = t.Qn(e2, fo.store);
                return n3.ts().next(function(t2) {
                  var e3 = s.uc(t2, 18e5), r3 = t2.filter(function(t3) {
                    return -1 === e3.indexOf(t3);
                  });
                  return Dr.forEach(r3, function(t3) {
                    return n3.delete(t3.clientId);
                  }).next(function() {
                    return r3;
                  });
                });
              }).catch(function() {
                return [];
              })]);
            case 1:
              if (e = n2.sent(), this.Ga)
                for (r2 = 0, i2 = e; r2 < i2.length; r2++)
                  o = i2[r2], this.Ga.removeItem(this.hc(o.clientId));
              n2.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, /**
     * Schedules a recurring timer to update the client metadata and to either
     * extend or acquire the primary lease if the client is eligible.
     */
    t.prototype.Ja = function() {
      var t2 = this;
      this.qa = this.fn.yn("client_metadata_refresh", 4e3, function() {
        return t2.za().then(function() {
          return t2.ac();
        }).then(function() {
          return t2.Ja();
        });
      });
    }, /** Checks whether `client` is the local client. */
    t.prototype.rc = function(t2) {
      return !!t2 && t2.ownerId === this.clientId;
    }, /**
     * Evaluate the state of all active clients and determine whether the local
     * client is or can act as the holder of the primary lease. Returns whether
     * the client is eligible for the lease, but does not actually acquire it.
     * May return 'false' even if there is no active leaseholder and another
     * (foreground) client should become leaseholder instead.
     */
    t.prototype.nc = function(t2) {
      var e = this;
      return this.ka ? Dr.resolve(true) : To(t2).get(Ji.key).next(function(n2) {
        if (null !== n2 && e.cc(n2.leaseTimestampMs, 5e3) && !e.lc(n2.ownerId)) {
          if (e.rc(n2) && e.networkEnabled)
            return true;
          if (!e.rc(n2)) {
            if (!n2.allowTabSynchronization)
              throw new I2(b.FAILED_PRECONDITION, Io);
            return false;
          }
        }
        return !(!e.networkEnabled || !e.inForeground) || No(t2).ts().next(function(t3) {
          return void 0 === e.uc(t3, 5e3).find(function(t4) {
            if (e.clientId !== t4.clientId) {
              var n3 = !e.networkEnabled && t4.networkEnabled, r2 = !e.inForeground && t4.inForeground, i2 = e.networkEnabled === t4.networkEnabled;
              if (n3 || r2 && i2)
                return true;
            }
            return false;
          });
        });
      }).next(function(t3) {
        return e.isPrimary !== t3 && T2("IndexedDbPersistence", "Client " + (t3 ? "is" : "is not") + " eligible for a primary lease."), t3;
      });
    }, t.prototype.Di = function() {
      return __awaiter(this, void 0, void 0, function() {
        var t2 = this;
        return __generator(this, function(e) {
          switch (e.label) {
            case 0:
              return this.Oa = false, this._c(), this.qa && (this.qa.cancel(), this.qa = null), this.fc(), this.dc(), [4, this.ja.runTransaction("shutdown", "readwrite", [Ji.store, fo.store], function(e2) {
                var n2 = new Eo(e2, Jr.ai);
                return t2.sc(n2).next(function() {
                  return t2.oc(n2);
                });
              })];
            case 1:
              return e.sent(), this.ja.close(), // Remove the entry marking the client as zombied from LocalStorage since
              // we successfully deleted its metadata from IndexedDb.
              this.wc(), [
                2
                /*return*/
              ];
          }
        });
      });
    }, /**
     * Returns clients that are not zombied and have an updateTime within the
     * provided threshold.
     */
    t.prototype.uc = function(t2, e) {
      var n2 = this;
      return t2.filter(function(t3) {
        return n2.cc(t3.updateTimeMs, e) && !n2.lc(t3.clientId);
      });
    }, /**
     * Returns the IDs of the clients that are currently active. If multi-tab
     * is not supported, returns an array that only contains the local client's
     * ID.
     *
     * PORTING NOTE: This is only used for Web multi-tab.
     */
    t.prototype.pi = function() {
      var t2 = this;
      return this.runTransaction("getActiveClients", "readonly", function(e) {
        return No(e).ts().next(function(e2) {
          return t2.uc(e2, 18e5).map(function(t3) {
            return t3.clientId;
          });
        });
      });
    }, Object.defineProperty(t.prototype, "Ei", {
      get: function() {
        return this.Oa;
      },
      enumerable: false,
      configurable: true
    }), t.prototype.mc = function(t2) {
      return Ui.xo(t2, this.serializer, this.Dr, this.No);
    }, t.prototype.Tc = function() {
      return this.Ka;
    }, t.prototype.Ec = function() {
      return this.vr;
    }, t.prototype.Ic = function() {
      return this.Dr;
    }, t.prototype.runTransaction = function(t2, e, n2) {
      var r2 = this;
      T2("IndexedDbPersistence", "Starting transaction:", t2);
      var i2, o = "readonly" === e ? "readonly" : "readwrite";
      return this.ja.runTransaction(t2, o, lo, function(o2) {
        return i2 = new Eo(o2, r2.Ma ? r2.Ma.next() : Jr.ai), "readwrite-primary" === e ? r2.ec(i2).next(function(t3) {
          return !!t3 || r2.nc(i2);
        }).next(function(e2) {
          if (!e2)
            throw N2("Failed to obtain primary lease for action '" + t2 + "'."), r2.isPrimary = false, r2.fn.Cs(function() {
              return r2.Qa(false);
            }), new I2(b.FAILED_PRECONDITION, li);
          return n2(i2);
        }).next(function(t3) {
          return r2.ic(i2).next(function() {
            return t3;
          });
        }) : r2.Ac(i2).next(function() {
          return n2(i2);
        });
      }).then(function(t3) {
        return i2.br(), t3;
      });
    }, /**
     * Verifies that the current tab is the primary leaseholder or alternatively
     * that the leaseholder has opted into multi-tab synchronization.
     */
    // TODO(b/114226234): Remove this check when `synchronizeTabs` can no longer
    // be turned off.
    t.prototype.Ac = function(t2) {
      var e = this;
      return To(t2).get(Ji.key).next(function(t3) {
        if (null !== t3 && e.cc(t3.leaseTimestampMs, 5e3) && !e.lc(t3.ownerId) && !e.rc(t3) && !(e.ka || e.allowTabSynchronization && t3.allowTabSynchronization))
          throw new I2(b.FAILED_PRECONDITION, Io);
      });
    }, /**
     * Obtains or extends the new primary lease for the local client. This
     * method does not verify that the client is eligible for this lease.
     */
    t.prototype.ic = function(t2) {
      var e = new Ji(this.clientId, this.allowTabSynchronization, Date.now());
      return To(t2).put(Ji.key, e);
    }, t.Ln = function() {
      return kr.Ln();
    }, /** Checks the primary lease and removes it if we are the current primary. */
    t.prototype.sc = function(t2) {
      var e = this, n2 = To(t2);
      return n2.get(Ji.key).next(function(t3) {
        return e.rc(t3) ? (T2("IndexedDbPersistence", "Releasing primary lease."), n2.delete(Ji.key)) : Dr.resolve();
      });
    }, /** Verifies that `updateTimeMs` is within `maxAgeMs`. */
    t.prototype.cc = function(t2, e) {
      var n2 = Date.now();
      return !(t2 < n2 - e || t2 > n2 && (N2("Detected an update time that is in the future: " + t2 + " > " + n2), 1));
    }, t.prototype.Ha = function() {
      var t2 = this;
      null !== this.document && "function" == typeof this.document.addEventListener && (this.Ba = function() {
        t2.fn.ws(function() {
          return t2.inForeground = "visible" === t2.document.visibilityState, t2.za();
        });
      }, this.document.addEventListener("visibilitychange", this.Ba), this.inForeground = "visible" === this.document.visibilityState);
    }, t.prototype.fc = function() {
      this.Ba && (this.document.removeEventListener("visibilitychange", this.Ba), this.Ba = null);
    }, /**
     * Attaches a window.unload handler that will synchronously write our
     * clientId to a "zombie client id" location in LocalStorage. This can be used
     * by tabs trying to acquire the primary lease to determine that the lease
     * is no longer valid even if the timestamp is recent. This is particularly
     * important for the refresh case (so the tab correctly re-acquires the
     * primary lease). LocalStorage is used for this rather than IndexedDb because
     * it is a synchronous API and so can be used reliably from  an unload
     * handler.
     */
    t.prototype.Ya = function() {
      var t2, e = this;
      "function" == typeof (null === (t2 = this.window) || void 0 === t2 ? void 0 : t2.addEventListener) && (this.La = function() {
        e._c(), e.fn.ws(function() {
          return e.Di();
        });
      }, this.window.addEventListener("unload", this.La));
    }, t.prototype.dc = function() {
      this.La && (this.window.removeEventListener("unload", this.La), this.La = null);
    }, /**
     * Returns whether a client is "zombied" based on its LocalStorage entry.
     * Clients become zombied when their tab closes without running all of the
     * cleanup logic in `shutdown()`.
     */
    t.prototype.lc = function(t2) {
      var e;
      try {
        var n2 = null !== (null === (e = this.Ga) || void 0 === e ? void 0 : e.getItem(this.hc(t2)));
        return T2("IndexedDbPersistence", "Client '" + t2 + "' " + (n2 ? "is" : "is not") + " zombied in LocalStorage"), n2;
      } catch (t3) {
        return N2("IndexedDbPersistence", "Failed to get zombied client id.", t3), false;
      }
    }, /**
     * Record client as zombied (a client that had its tab closed). Zombied
     * clients are ignored during primary tab selection.
     */
    t.prototype._c = function() {
      if (this.Ga)
        try {
          this.Ga.setItem(this.hc(this.clientId), String(Date.now()));
        } catch (t2) {
          N2("Failed to set zombie client id.", t2);
        }
    }, /** Removes the zombied client entry if it exists. */
    t.prototype.wc = function() {
      if (this.Ga)
        try {
          this.Ga.removeItem(this.hc(this.clientId));
        } catch (t2) {
        }
    }, t.prototype.hc = function(t2) {
      return "firestore_zombie_" + this.persistenceKey + "_" + t2;
    }, t;
  }()
);
function To(t) {
  return _o.Qn(t, Ji.store);
}
function No(t) {
  return _o.Qn(t, fo.store);
}
var Ao = (
  /** @class */
  function() {
    function t(t2, e) {
      this.db = t2, this.wo = new Ii(this, e);
    }
    return t.prototype.Po = function(t2) {
      var e = this.Rc(t2);
      return this.db.Tc().ba(t2).next(function(t3) {
        return e.next(function(e2) {
          return t3 + e2;
        });
      });
    }, t.prototype.Rc = function(t2) {
      var e = 0;
      return this.Vo(t2, function(t3) {
        e++;
      }).next(function() {
        return e;
      });
    }, t.prototype.Ce = function(t2, e) {
      return this.db.Tc().Ce(t2, e);
    }, t.prototype.Vo = function(t2, e) {
      return this.gc(t2, function(t3, n2) {
        return e(n2);
      });
    }, t.prototype.Da = function(t2, e, n2) {
      return So(t2, n2);
    }, t.prototype.Na = function(t2, e, n2) {
      return So(t2, n2);
    }, t.prototype.po = function(t2, e, n2) {
      return this.db.Tc().po(t2, e, n2);
    }, t.prototype.Go = function(t2, e) {
      return So(t2, e);
    }, /**
     * Returns true if anything would prevent this document from being garbage
     * collected, given that the document in question is not present in any
     * targets and has a sequence number less than or equal to the upper bound for
     * the collection run.
     */
    t.prototype.Pc = function(t2, e) {
      return function(t3, e2) {
        var n2 = false;
        return ji(t3).os(function(r2) {
          return Ci(t3, r2, e2).next(function(t4) {
            return t4 && (n2 = true), Dr.resolve(!t4);
          });
        }).next(function() {
          return n2;
        });
      }(t2, e);
    }, t.prototype.bo = function(t2, e) {
      var n2 = this, r2 = this.db.Ec().ra(), i2 = [], o = 0;
      return this.gc(t2, function(s, u4) {
        if (u4 <= e) {
          var a = n2.Pc(t2, s).next(function(e2) {
            if (!e2)
              return o++, r2.Rr(t2, s).next(function() {
                return r2.Ar(s), bo(t2).delete([0, Ei(s.path)]);
              });
          });
          i2.push(a);
        }
      }).next(function() {
        return Dr.$n(i2);
      }).next(function() {
        return r2.apply(t2);
      }).next(function() {
        return o;
      });
    }, t.prototype.removeTarget = function(t2, e) {
      var n2 = e.st(t2.xa);
      return this.db.Tc().ya(t2, n2);
    }, t.prototype.yc = function(t2, e) {
      return So(t2, e);
    }, /**
     * Call provided function for each document in the cache that is 'orphaned'. Orphaned
     * means not a part of any target, so the only entry in the target-document index for
     * that document will be the sentinel row (targetId 0), which will also have the sequence
     * number for the last time the document was accessed.
     */
    t.prototype.gc = function(t2, e) {
      var n2, r2 = bo(t2), i2 = Jr.ai;
      return r2.rs({
        index: uo.documentTargetsIndex
      }, function(t3, r3) {
        var o = t3[0], s = (t3[1], r3.path), u4 = r3.sequenceNumber;
        0 === o ? (
          // if nextToReport is valid, report it, this is a new key so the
          // last one must not be a member of any targets.
          (i2 !== Jr.ai && e(new F2(Ni(n2)), i2), // set nextToReport to be this sequence number. It's the next one we
          // might report, if we don't find any targets for this document.
          // Note that the sequence number must be defined when the targetId
          // is 0.
          i2 = u4, n2 = s)
        ) : (
          // set nextToReport to be invalid, we know we don't need to report
          // this one since we found a target for it.
          i2 = Jr.ai
        );
      }).next(function() {
        i2 !== Jr.ai && e(new F2(Ni(n2)), i2);
      });
    }, t.prototype.So = function(t2) {
      return this.db.Ec().aa(t2);
    }, t;
  }()
);
function So(t, e) {
  return bo(t).put(
    /**
    * @return A value suitable for writing a sentinel row in the target-document
    * store.
    */
    function(t2, e2) {
      return new uo(0, Ei(t2.path), e2);
    }(e, t.xa)
  );
}
function Do(t, e) {
  var n2 = t.projectId;
  return t.j || (n2 += "." + t.database), "firestore/" + e + "/" + n2 + "/";
}
var ko = (
  /** @class */
  function() {
    function t(t2, e, n2) {
      this.persistence = t2, this.Vc = e, /**
           * Maps a targetID to data about its target.
           *
           * PORTING NOTE: We are using an immutable data structure on Web to make re-runs
           * of `applyRemoteEvent()` idempotent.
           */
      this.bc = new Ot(st), /** Maps a target to its targetID. */
      // TODO(wuandy): Evaluate if TargetId can be part of Target.
      this.vc = new yt(function(t3) {
        return Tt(t3);
      }, Nt), /**
           * The read time of the last entry processed by `getNewDocumentChanges()`.
           *
           * PORTING NOTE: This is only used for multi-tab synchronization.
           */
      this.Sc = gt.min(), this.Sr = t2.mc(n2), this.Dc = t2.Ec(), this.Ka = t2.Tc(), this.Cc = new di(this.Dc, this.Sr, this.persistence.Ic()), this.Vc.Nc(this.Cc);
    }
    return t.prototype.Io = function(t2) {
      var e = this;
      return this.persistence.runTransaction("Collect garbage", "readwrite-primary", function(n2) {
        return t2.vo(n2, e.bc);
      });
    }, t;
  }()
);
function xo(t, e) {
  var n2 = x2(t);
  return n2.persistence.runTransaction("Acknowledge batch", "readwrite-primary", function(t2) {
    var r2 = e.batch.keys(), i2 = n2.Dc.ra({
      oa: true
    });
    return function(t3, e2, n3, r3) {
      var i3 = n3.batch, o = i3.keys(), s = Dr.resolve();
      return o.forEach(function(t4) {
        s = s.next(function() {
          return r3.Rr(e2, t4);
        }).next(function(e3) {
          var o2 = e3, s2 = n3.dr.get(t4);
          k2(null !== s2), (!o2 || o2.version.L(s2) < 0) && ((o2 = i3.cr(t4, o2, n3)) && // We use the commitVersion as the readTime rather than the
          // document's updateTime since the updateTime is not advanced
          // for updates that do not modify the underlying document.
          r3.Er(o2, n3._r));
        });
      }), s.next(function() {
        return t3.Sr.Wo(e2, i3);
      });
    }(n2, t2, e, i2).next(function() {
      return i2.apply(t2);
    }).next(function() {
      return n2.Sr.zo(t2);
    }).next(function() {
      return n2.Cc.kr(t2, r2);
    });
  });
}
function Lo(t) {
  var e = x2(t);
  return e.persistence.runTransaction("Get last remote snapshot version", "readonly", function(t2) {
    return e.Ka.Ea(t2);
  });
}
function Ro(t, e) {
  var n2 = x2(t), r2 = e.nt, i2 = n2.bc;
  return n2.persistence.runTransaction("Apply remote event", "readwrite-primary", function(t2) {
    var o = n2.Dc.ra({
      oa: true
    });
    i2 = n2.bc;
    var s = [];
    e.zt.forEach(function(e2, o2) {
      var u5 = i2.get(o2);
      if (u5) {
        s.push(n2.Ka.Ca(t2, e2.se, o2).next(function() {
          return n2.Ka.Sa(t2, e2.ee, o2);
        }));
        var a2 = e2.resumeToken;
        if (a2.O() > 0) {
          var c2 = u5.it(a2, r2).st(t2.xa);
          i2 = i2.ot(o2, c2), // Update the target data if there are target changes (or if
          // sufficient time has passed since the last update).
          /**
          * Returns true if the newTargetData should be persisted during an update of
          * an active target. TargetData should always be persisted when a target is
          * being released and should not call this function.
          *
          * While the target is active, TargetData updates can be omitted when nothing
          * about the target has changed except metadata like the resume token or
          * snapshot version. Occasionally it's worth the extra write to prevent these
          * values from getting too stale after a crash, but this doesn't have to be
          * too frequent.
          */
          function(t3, e3, n3) {
            return k2(e3.resumeToken.O() > 0), 0 === t3.resumeToken.O() || // Don't allow resume token changes to be buffered indefinitely. This
            // allows us to be reasonably up-to-date after a crash and avoids needing
            // to loop over all active queries on shutdown. Especially in the browser
            // we may not get time to do anything interesting while the current tab is
            // closing.
            (e3.nt.X() - t3.nt.X() >= 3e8 || n3.ee.size + n3.ne.size + n3.se.size > 0);
          }(u5, c2, e2) && s.push(n2.Ka.ya(t2, c2));
        }
      }
    });
    var u4 = Mt(), a = Kt();
    if (e.Yt.forEach(function(t3, e2) {
      a = a.add(t3);
    }), // Each loop iteration only affects its "own" doc, so it's safe to get all the remote
    // documents in advance in a single call.
    s.push(o.getEntries(t2, a).next(function(i3) {
      e.Yt.forEach(function(a2, c2) {
        var h = i3.get(a2);
        c2 instanceof Bn && c2.version.isEqual(gt.min()) ? (
          // NoDocuments with SnapshotVersion.min() are used in manufactured
          // events. We remove these documents from cache since we lost
          // access.
          (o.Ar(a2, r2), u4 = u4.ot(a2, c2))
        ) : null == h || c2.version.L(h.version) > 0 || 0 === c2.version.L(h.version) && h.hasPendingWrites ? (o.Er(c2, r2), u4 = u4.ot(a2, c2)) : T2("LocalStore", "Ignoring outdated watch update for ", a2, ". Current version:", h.version, " Watch version:", c2.version), e.Jt.has(a2) && s.push(n2.persistence.No.yc(t2, a2));
      });
    })), !r2.isEqual(gt.min())) {
      var c = n2.Ka.Ea(t2).next(function(e2) {
        return n2.Ka.Aa(t2, t2.xa, r2);
      });
      s.push(c);
    }
    return Dr.$n(s).next(function() {
      return o.apply(t2);
    }).next(function() {
      return n2.Cc.Mr(t2, u4);
    });
  }).then(function(t2) {
    return n2.bc = i2, t2;
  });
}
function Oo(t, e) {
  var n2 = x2(t);
  return n2.persistence.runTransaction("Get next mutation batch", "readonly", function(t2) {
    return void 0 === e && (e = -1), n2.Sr.Bo(t2, e);
  });
}
function Po(t, e) {
  var n2 = x2(t);
  return n2.persistence.runTransaction("Allocate target", "readwrite", function(t2) {
    var r2;
    return n2.Ka.va(t2, e).next(function(i2) {
      return i2 ? (
        // This target has been listened to previously, so reuse the
        // previous targetID.
        // TODO(mcg): freshen last accessed date?
        (r2 = i2, Dr.resolve(r2))
      ) : n2.Ka.wa(t2).next(function(i3) {
        return r2 = new kt(e, i3, 0, t2.xa), n2.Ka.Ra(t2, r2).next(function() {
          return r2;
        });
      });
    });
  }).then(function(t2) {
    var r2 = n2.bc.get(t2.targetId);
    return (null === r2 || t2.nt.L(r2.nt) > 0) && (n2.bc = n2.bc.ot(t2.targetId, t2), n2.vc.set(e, t2.targetId)), t2;
  });
}
function Vo(t, r2, i2) {
  return __awaiter(this, void 0, void 0, function() {
    var e, o, s, u4;
    return __generator(this, function(n2) {
      switch (n2.label) {
        case 0:
          e = x2(t), o = e.bc.get(r2), s = i2 ? "readwrite" : "readwrite-primary", n2.label = 1;
        case 1:
          return n2.trys.push([1, 4, , 5]), i2 ? [3, 3] : [4, e.persistence.runTransaction("Release target", s, function(t2) {
            return e.persistence.No.removeTarget(t2, o);
          })];
        case 2:
          n2.sent(), n2.label = 3;
        case 3:
          return [3, 5];
        case 4:
          if (!Rr(u4 = n2.sent()))
            throw u4;
          return T2("LocalStore", "Failed to update sequence numbers for target " + r2 + ": " + u4), [3, 5];
        case 5:
          return e.bc = e.bc.remove(r2), e.vc.delete(o.target), [
            2
            /*return*/
          ];
      }
    });
  });
}
function Uo(t, e, n2) {
  var r2 = x2(t), i2 = gt.min(), o = Kt();
  return r2.persistence.runTransaction("Execute query", "readonly", function(t2) {
    return function(t3, e2, n3) {
      var r3 = x2(t3), i3 = r3.vc.get(n3);
      return void 0 !== i3 ? Dr.resolve(r3.bc.get(i3)) : r3.Ka.va(e2, n3);
    }(r2, t2, er(e)).next(function(e2) {
      if (e2)
        return i2 = e2.lastLimboFreeSnapshotVersion, r2.Ka.Fa(t2, e2.targetId).next(function(t3) {
          o = t3;
        });
    }).next(function() {
      return r2.Vc.Lr(t2, e, n2 ? i2 : gt.min(), n2 ? o : Kt());
    }).next(function(t3) {
      return {
        documents: t3,
        Fc: o
      };
    });
  });
}
function Co(t, e) {
  var n2 = x2(t), r2 = x2(n2.Ka), i2 = n2.bc.get(e);
  return i2 ? Promise.resolve(i2.target) : n2.persistence.runTransaction("Get target data", "readonly", function(t2) {
    return r2.Ue(t2, e).next(function(t3) {
      return t3 ? t3.target : null;
    });
  });
}
function Fo(t) {
  var e = x2(t);
  return e.persistence.runTransaction("Get new document changes", "readonly", function(t2) {
    return function(t3, e2, n2) {
      var r2 = x2(t3), i2 = Mt(), o = ki(n2), s = Ki(e2), u4 = IDBKeyRange.lowerBound(o, true);
      return s.rs({
        index: io.readTimeIndex,
        range: u4
      }, function(t4, e3) {
        var n3 = Si(r2.serializer, e3);
        i2 = i2.ot(n3.key, n3), o = e3.readTime;
      }).next(function() {
        return {
          xc: i2,
          readTime: xi(o)
        };
      });
    }(e.Dc, t2, e.Sc);
  }).then(function(t2) {
    var n2 = t2.xc, r2 = t2.readTime;
    return e.Sc = r2, n2;
  });
}
function Mo(t) {
  return __awaiter(this, void 0, void 0, function() {
    var e;
    return __generator(this, function(n2) {
      return [2, (e = x2(t)).persistence.runTransaction("Synchronize last document change read time", "readonly", function(t2) {
        return function(t3) {
          var e2 = Ki(t3), n3 = gt.min();
          return e2.rs({
            index: io.readTimeIndex,
            reverse: true
          }, function(t4, e3, r2) {
            e3.readTime && (n3 = xi(e3.readTime)), r2.done();
          }).next(function() {
            return n3;
          });
        }(t2);
      }).then(function(t2) {
        e.Sc = t2;
      })];
    });
  });
}
function qo(t) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(e) {
      if (t.code !== b.FAILED_PRECONDITION || t.message !== li)
        throw t;
      return T2("LocalStore", "Unexpectedly lost primary lease"), [
        2
        /*return*/
      ];
    });
  });
}
var jo = (
  /** @class */
  function() {
    function t() {
      this.$c = new Ut(Go.kc), // A set of outstanding references to a document sorted by target id.
      this.Mc = new Ut(Go.Oc);
    }
    return t.prototype.m = function() {
      return this.$c.m();
    }, /** Adds a reference to the given document key for the given ID. */
    t.prototype.Da = function(t2, e) {
      var n2 = new Go(t2, e);
      this.$c = this.$c.add(n2), this.Mc = this.Mc.add(n2);
    }, /** Add references to the given document keys for the given ID. */
    t.prototype.Lc = function(t2, e) {
      var n2 = this;
      t2.forEach(function(t3) {
        return n2.Da(t3, e);
      });
    }, /**
     * Removes a reference to the given document key for the given
     * ID.
     */
    t.prototype.Na = function(t2, e) {
      this.Bc(new Go(t2, e));
    }, t.prototype.qc = function(t2, e) {
      var n2 = this;
      t2.forEach(function(t3) {
        return n2.Na(t3, e);
      });
    }, /**
     * Clears all references with a given ID. Calls removeRef() for each key
     * removed.
     */
    t.prototype.Uc = function(t2) {
      var e = this, n2 = new F2(new V2([])), r2 = new Go(n2, t2), i2 = new Go(n2, t2 + 1), o = [];
      return this.Mc.Ft([r2, i2], function(t3) {
        e.Bc(t3), o.push(t3.key);
      }), o;
    }, t.prototype.Qc = function() {
      var t2 = this;
      this.$c.forEach(function(e) {
        return t2.Bc(e);
      });
    }, t.prototype.Bc = function(t2) {
      this.$c = this.$c.delete(t2), this.Mc = this.Mc.delete(t2);
    }, t.prototype.Wc = function(t2) {
      var e = new F2(new V2([])), n2 = new Go(e, t2), r2 = new Go(e, t2 + 1), i2 = Kt();
      return this.Mc.Ft([n2, r2], function(t3) {
        i2 = i2.add(t3.key);
      }), i2;
    }, t.prototype.Ho = function(t2) {
      var e = new Go(t2, 0), n2 = this.$c.$t(e);
      return null !== n2 && t2.isEqual(n2.key);
    }, t;
  }()
);
var Go = (
  /** @class */
  function() {
    function t(t2, e) {
      this.key = t2, this.jc = e;
    }
    return t.kc = function(t2, e) {
      return F2.i(t2.key, e.key) || st(t2.jc, e.jc);
    }, /** Compare by ID then by key */
    t.Oc = function(t2, e) {
      return st(t2.jc, e.jc) || F2.i(t2.key, e.key);
    }, t;
  }()
);
var zo = function(t, e) {
  this.user = e, this.type = "OAuth", this.Kc = {}, // Set the headers using Object Literal notation to avoid minification
  this.Kc.Authorization = "Bearer " + t;
};
var Bo = (
  /** @class */
  function() {
    function t() {
      this.Gc = null;
    }
    return t.prototype.getToken = function() {
      return Promise.resolve(null);
    }, t.prototype.zc = function() {
    }, t.prototype.Hc = function(t2) {
      this.Gc = t2, // Fire with initial user.
      t2(Xr.UNAUTHENTICATED);
    }, t.prototype.Yc = function() {
      this.Gc = null;
    }, t;
  }()
);
var Ko = (
  /** @class */
  function() {
    function t(t2) {
      var e = this;
      this.Jc = null, /** Tracks the current User. */
      this.currentUser = Xr.UNAUTHENTICATED, this.Xc = false, /**
           * Counter used to detect if the token changed while a getToken request was
           * outstanding.
           */
      this.Zc = 0, /** The listener registered with setChangeListener(). */
      this.Gc = null, this.forceRefresh = false, this.Jc = function() {
        e.Zc++, e.currentUser = e.tu(), e.Xc = true, e.Gc && e.Gc(e.currentUser);
      }, this.Zc = 0, this.auth = t2.getImmediate({
        optional: true
      }), this.auth ? this.auth.addAuthTokenListener(this.Jc) : (
        // if auth is not available, invoke tokenListener once with null token
        (this.Jc(null), t2.get().then(function(t3) {
          e.auth = t3, e.Jc && // tokenListener can be removed by removeChangeListener()
          e.auth.addAuthTokenListener(e.Jc);
        }, function() {
        }))
      );
    }
    return t.prototype.getToken = function() {
      var t2 = this, e = this.Zc, n2 = this.forceRefresh;
      return this.forceRefresh = false, this.auth ? this.auth.getToken(n2).then(function(n3) {
        return t2.Zc !== e ? (T2("FirebaseCredentialsProvider", "getToken aborted due to token change."), t2.getToken()) : n3 ? (k2("string" == typeof n3.accessToken), new zo(n3.accessToken, t2.currentUser)) : null;
      }) : Promise.resolve(null);
    }, t.prototype.zc = function() {
      this.forceRefresh = true;
    }, t.prototype.Hc = function(t2) {
      this.Gc = t2, // Fire the initial event
      this.Xc && t2(this.currentUser);
    }, t.prototype.Yc = function() {
      this.auth && this.auth.removeAuthTokenListener(this.Jc), this.Jc = null, this.Gc = null;
    }, // Auth.getUid() can return null even with a user logged in. It is because
    // getUid() is synchronous, but the auth code populating Uid is asynchronous.
    // This method should only be called in the AuthTokenListener callback
    // to guarantee to get the actual user.
    t.prototype.tu = function() {
      var t2 = this.auth && this.auth.getUid();
      return k2(null === t2 || "string" == typeof t2), new Xr(t2);
    }, t;
  }()
);
var Wo = (
  /** @class */
  function() {
    function t(t2, e) {
      this.eu = t2, this.nu = e, this.type = "FirstParty", this.user = Xr.ni;
    }
    return Object.defineProperty(t.prototype, "Kc", {
      get: function() {
        var t2 = {
          "X-Goog-AuthUser": this.nu
        }, e = this.eu.auth.getAuthHeaderValueForFirstParty([]);
        return e && (t2.Authorization = e), t2;
      },
      enumerable: false,
      configurable: true
    }), t;
  }()
);
var Qo = (
  /** @class */
  function() {
    function t(t2, e) {
      this.eu = t2, this.nu = e;
    }
    return t.prototype.getToken = function() {
      return Promise.resolve(new Wo(this.eu, this.nu));
    }, t.prototype.Hc = function(t2) {
      t2(Xr.ni);
    }, t.prototype.Yc = function() {
    }, t.prototype.zc = function() {
    }, t;
  }()
);
var Ho = (
  /** @class */
  function() {
    function t(t2, e, n2, r2, i2, o) {
      this.fn = t2, this.su = n2, this.iu = r2, this.ru = i2, this.listener = o, this.state = 0, /**
           * A close count that's incremented every time the stream is closed; used by
           * getCloseGuardedDispatcher() to invalidate callbacks that happen after
           * close.
           */
      this.ou = 0, this.au = null, this.stream = null, this.ys = new Sr(t2, e);
    }
    return t.prototype.cu = function() {
      return 1 === this.state || 2 === this.state || 4 === this.state;
    }, /**
     * Returns true if the underlying RPC is open (the onOpen() listener has been
     * called) and the stream is ready for outbound requests.
     */
    t.prototype.uu = function() {
      return 2 === this.state;
    }, /**
     * Starts the RPC. Only allowed if isStarted() returns false. The stream is
     * not immediately ready for use: onOpen() will be invoked when the RPC is
     * ready for outbound requests, at which point isOpen() will return true.
     *
     * When start returns, isStarted() will return true.
     */
    t.prototype.start = function() {
      3 !== this.state ? this.auth() : this.hu();
    }, /**
     * Stops the RPC. This call is idempotent and allowed regardless of the
     * current isStarted() state.
     *
     * When stop returns, isStarted() and isOpen() will both return false.
     */
    t.prototype.stop = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(t2) {
          switch (t2.label) {
            case 0:
              return this.cu() ? [4, this.close(
                0
                /* Initial */
              )] : [3, 2];
            case 1:
              t2.sent(), t2.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, /**
     * After an error the stream will usually back off on the next attempt to
     * start it. If the error warrants an immediate restart of the stream, the
     * sender can use this to indicate that the receiver should not back off.
     *
     * Each error will call the onClose() listener. That function can decide to
     * inhibit backoff if required.
     */
    t.prototype.lu = function() {
      this.state = 0, this.ys.reset();
    }, /**
     * Marks this stream as idle. If no further actions are performed on the
     * stream for one minute, the stream will automatically close itself and
     * notify the stream's onClose() handler with Status.OK. The stream will then
     * be in a !isStarted() state, requiring the caller to start the stream again
     * before further use.
     *
     * Only streams that are in state 'Open' can be marked idle, as all other
     * states imply pending network operations.
     */
    t.prototype._u = function() {
      var t2 = this;
      this.uu() && null === this.au && (this.au = this.fn.yn(this.su, 6e4, function() {
        return t2.fu();
      }));
    }, /** Sends a message to the underlying stream. */
    t.prototype.du = function(t2) {
      this.wu(), this.stream.send(t2);
    }, /** Called by the idle timer when the stream should close due to inactivity. */
    t.prototype.fu = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(t2) {
          return this.uu() ? [2, this.close(
            0
            /* Initial */
          )] : [
            2
            /*return*/
          ];
        });
      });
    }, /** Marks the stream as active again. */
    t.prototype.wu = function() {
      this.au && (this.au.cancel(), this.au = null);
    }, /**
     * Closes the stream and cleans up as necessary:
     *
     * * closes the underlying GRPC stream;
     * * calls the onClose handler with the given 'error';
     * * sets internal stream state to 'finalState';
     * * adjusts the backoff timer based on the error
     *
     * A new stream can be opened by calling start().
     *
     * @param finalState the intended state of the stream after closing.
     * @param error the error the connection was closed with.
     */
    t.prototype.close = function(t2, r2) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(e) {
          switch (e.label) {
            case 0:
              return this.wu(), this.ys.cancel(), // Invalidates any stream-related callbacks (e.g. from auth or the
              // underlying stream), guaranteeing they won't execute.
              this.ou++, 3 !== t2 ? (
                // If this is an intentional close ensure we don't delay our next connection attempt.
                this.ys.reset()
              ) : r2 && r2.code === b.RESOURCE_EXHAUSTED ? (
                // Log the error. (Probably either 'quota exceeded' or 'max queue length reached'.)
                (N2(r2.toString()), N2("Using maximum backoff delay to prevent overloading the backend."), this.ys.Rn())
              ) : r2 && r2.code === b.UNAUTHENTICATED && // "unauthenticated" error means the token was rejected. Try force refreshing it in case it
              // just expired.
              this.ru.zc(), // Clean up the underlying stream because we are no longer interested in events.
              null !== this.stream && (this.mu(), this.stream.close(), this.stream = null), // This state must be assigned before calling onClose() to allow the callback to
              // inhibit backoff or otherwise manipulate the state in its non-started state.
              this.state = t2, [4, this.listener.Tu(r2)];
            case 1:
              return e.sent(), [
                2
                /*return*/
              ];
          }
        });
      });
    }, /**
     * Can be overridden to perform additional cleanup before the stream is closed.
     * Calling super.tearDown() is not required.
     */
    t.prototype.mu = function() {
    }, t.prototype.auth = function() {
      var t2 = this;
      this.state = 1;
      var e = this.Eu(this.ou), n2 = this.ou;
      this.ru.getToken().then(function(e2) {
        t2.ou === n2 && // Normally we'd have to schedule the callback on the AsyncQueue.
        // However, the following calls are safe to be called outside the
        // AsyncQueue since they don't chain asynchronous calls
        t2.Iu(e2);
      }, function(n3) {
        e(function() {
          var e2 = new I2(b.UNKNOWN, "Fetching auth token failed: " + n3.message);
          return t2.Au(e2);
        });
      });
    }, t.prototype.Iu = function(t2) {
      var e = this, n2 = this.Eu(this.ou);
      this.stream = this.Ru(t2), this.stream.gu(function() {
        n2(function() {
          return e.state = 2, e.listener.gu();
        });
      }), this.stream.Tu(function(t3) {
        n2(function() {
          return e.Au(t3);
        });
      }), this.stream.onMessage(function(t3) {
        n2(function() {
          return e.onMessage(t3);
        });
      });
    }, t.prototype.hu = function() {
      var t2 = this;
      this.state = 4, this.ys.gn(function() {
        return __awaiter(t2, void 0, void 0, function() {
          return __generator(this, function(t3) {
            return this.state = 0, this.start(), [
              2
              /*return*/
            ];
          });
        });
      });
    }, // Visible for tests
    t.prototype.Au = function(t2) {
      return T2("PersistentStream", "close with error: " + t2), this.stream = null, this.close(3, t2);
    }, /**
     * Returns a "dispatcher" function that dispatches operations onto the
     * AsyncQueue but only runs them if closeCount remains unchanged. This allows
     * us to turn auth / stream callbacks into no-ops if the stream is closed /
     * re-opened, etc.
     */
    t.prototype.Eu = function(t2) {
      var e = this;
      return function(n2) {
        e.fn.ws(function() {
          return e.ou === t2 ? n2() : (T2("PersistentStream", "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve());
        });
      };
    }, t;
  }()
);
var Yo = (
  /** @class */
  function(e) {
    function n2(t, n3, r2, i2, o) {
      var s = this;
      return (s = e.call(this, t, "listen_stream_connection_backoff", "listen_stream_idle", n3, r2, o) || this).serializer = i2, s;
    }
    return __extends(n2, e), n2.prototype.Ru = function(t) {
      return this.iu.Pu("Listen", t);
    }, n2.prototype.onMessage = function(t) {
      this.ys.reset();
      var e2 = function(t2, e3) {
        var n4;
        if ("targetChange" in e3) {
          e3.targetChange;
          var r2 = function(t3) {
            return "NO_CHANGE" === t3 ? 0 : "ADD" === t3 ? 1 : "REMOVE" === t3 ? 2 : "CURRENT" === t3 ? 3 : "RESET" === t3 ? 4 : D2();
          }(e3.targetChange.targetChangeType || "NO_CHANGE"), i2 = e3.targetChange.targetIds || [], o = function(t3, e4) {
            return t3.Qe ? (k2(void 0 === e4 || "string" == typeof e4), ct.fromBase64String(e4 || "")) : (k2(void 0 === e4 || e4 instanceof Uint8Array), ct.fromUint8Array(e4 || new Uint8Array()));
          }(t2, e3.targetChange.resumeToken), s = e3.targetChange.cause, u4 = s && function(t3) {
            var e4 = void 0 === t3.code ? b.UNKNOWN : Rt(t3.code);
            return new I2(e4, t3.message || "");
          }(s);
          n4 = new ee(r2, i2, o, u4 || null);
        } else if ("documentChange" in e3) {
          e3.documentChange;
          var a = e3.documentChange;
          a.document, a.document.name, a.document.updateTime;
          var c = Me(t2, a.document.name), h = Ve(a.document.updateTime), f = new Mn({
            mapValue: {
              fields: a.document.fields
            }
          }), l = new zn(c, h, f, {}), p2 = a.targetIds || [], d = a.removedTargetIds || [];
          n4 = new Zt(p2, d, l.key, l);
        } else if ("documentDelete" in e3) {
          e3.documentDelete;
          var v2 = e3.documentDelete;
          v2.document;
          var y2 = Me(t2, v2.document), m = v2.readTime ? Ve(v2.readTime) : gt.min(), g2 = new Bn(y2, m), w2 = v2.removedTargetIds || [];
          n4 = new Zt([], w2, g2.key, g2);
        } else if ("documentRemove" in e3) {
          e3.documentRemove;
          var E3 = e3.documentRemove;
          E3.document;
          var _2 = Me(t2, E3.document), T3 = E3.removedTargetIds || [];
          n4 = new Zt([], T3, _2, null);
        } else {
          if (!("filter" in e3))
            return D2();
          e3.filter;
          var N3 = e3.filter;
          N3.targetId;
          var A3 = N3.count || 0, S3 = new xt(A3), x3 = N3.targetId;
          n4 = new te(x3, S3);
        }
        return n4;
      }(this.serializer, t), n3 = function(t2) {
        if (!("targetChange" in t2))
          return gt.min();
        var e3 = t2.targetChange;
        return e3.targetIds && e3.targetIds.length ? gt.min() : e3.readTime ? Ve(e3.readTime) : gt.min();
      }(t);
      return this.listener.yu(e2, n3);
    }, /**
     * Registers interest in the results of the given target. If the target
     * includes a resumeToken it will be included in the request. Results that
     * affect the target will be streamed back as WatchChange messages that
     * reference the targetId.
     */
    n2.prototype.Vu = function(t) {
      var e2 = {};
      e2.database = Ge(this.serializer), e2.addTarget = function(t2, e3) {
        var n4, r2 = e3.target;
        return (n4 = At(r2) ? {
          documents: Qe(t2, r2)
        } : {
          query: He(t2, r2)
        }).targetId = e3.targetId, e3.resumeToken.O() > 0 && (n4.resumeToken = Oe(t2, e3.resumeToken)), n4;
      }(this.serializer, t);
      var n3 = function(t2, e3) {
        var n4 = function(t3, e4) {
          switch (e4) {
            case 0:
              return null;
            case 1:
              return "existence-filter-mismatch";
            case 2:
              return "limbo-document";
            default:
              return D2();
          }
        }(0, e3.et);
        return null == n4 ? null : {
          "goog-listen-tags": n4
        };
      }(this.serializer, t);
      n3 && (e2.labels = n3), this.du(e2);
    }, /**
     * Unregisters interest in the results of the target associated with the
     * given targetId.
     */
    n2.prototype.pu = function(t) {
      var e2 = {};
      e2.database = Ge(this.serializer), e2.removeTarget = t, this.du(e2);
    }, n2;
  }(Ho)
);
var $o = (
  /** @class */
  function(e) {
    function n2(t, n3, r2, i2, o) {
      var s = this;
      return (s = e.call(this, t, "write_stream_connection_backoff", "write_stream_idle", n3, r2, o) || this).serializer = i2, s.bu = false, s;
    }
    return __extends(n2, e), Object.defineProperty(n2.prototype, "vu", {
      /**
       * Tracks whether or not a handshake has been successfully exchanged and
       * the stream is ready to accept mutations.
       */
      get: function() {
        return this.bu;
      },
      enumerable: false,
      configurable: true
    }), // Override of PersistentStream.start
    n2.prototype.start = function() {
      this.bu = false, this.lastStreamToken = void 0, e.prototype.start.call(this);
    }, n2.prototype.mu = function() {
      this.bu && this.Su([]);
    }, n2.prototype.Ru = function(t) {
      return this.iu.Pu("Write", t);
    }, n2.prototype.onMessage = function(t) {
      if (
        // Always capture the last stream token.
        k2(!!t.streamToken), this.lastStreamToken = t.streamToken, this.bu
      ) {
        this.ys.reset();
        var e2 = function(t2, e3) {
          return t2 && t2.length > 0 ? (k2(void 0 !== e3), t2.map(function(t3) {
            return function(t4, e4) {
              var n4 = t4.updateTime ? Ve(t4.updateTime) : Ve(e4);
              n4.isEqual(gt.min()) && // The Firestore Emulator currently returns an update time of 0 for
              // deletes of non-existing documents (rather than null). This breaks the
              // test "get deleted doc while offline with source=cache" as NoDocuments
              // with version 0 are filtered by IndexedDb's RemoteDocumentCache.
              // TODO(#2149): Remove this when Emulator is fixed
              (n4 = Ve(e4));
              var r2 = null;
              return t4.transformResults && t4.transformResults.length > 0 && (r2 = t4.transformResults), new En(n4, r2);
            }(t3, e3);
          })) : [];
        }(t.writeResults, t.commitTime), n3 = Ve(t.commitTime);
        return this.listener.Du(n3, e2);
      }
      return k2(!t.writeResults || 0 === t.writeResults.length), this.bu = true, this.listener.Cu();
    }, /**
     * Sends an initial streamToken to the server, performing the handshake
     * required to make the StreamingWrite RPC work. Subsequent
     * calls should wait until onHandshakeComplete was called.
     */
    n2.prototype.Nu = function() {
      var t = {};
      t.database = Ge(this.serializer), this.du(t);
    }, /** Sends a group of mutations to the Firestore backend to apply. */
    n2.prototype.Su = function(t) {
      var e2 = this, n3 = {
        streamToken: this.lastStreamToken,
        writes: t.map(function(t2) {
          return Ke(e2.serializer, t2);
        })
      };
      this.du(n3);
    }, n2;
  }(Ho)
);
var Xo = (
  /** @class */
  function(e) {
    function n2(t, n3, r2) {
      var i2 = this;
      return (i2 = e.call(this) || this).credentials = t, i2.iu = n3, i2.serializer = r2, i2.Fu = false, i2;
    }
    return __extends(n2, e), n2.prototype.xu = function() {
      if (this.Fu)
        throw new I2(b.FAILED_PRECONDITION, "The client has already been terminated.");
    }, /** Gets an auth token and invokes the provided RPC. */
    n2.prototype.$u = function(t, e2, n3) {
      var r2 = this;
      return this.xu(), this.credentials.getToken().then(function(i2) {
        return r2.iu.$u(t, e2, n3, i2);
      }).catch(function(t2) {
        throw t2.code === b.UNAUTHENTICATED && r2.credentials.zc(), t2;
      });
    }, /** Gets an auth token and invokes the provided RPC with streamed results. */
    n2.prototype.ku = function(t, e2, n3) {
      var r2 = this;
      return this.xu(), this.credentials.getToken().then(function(i2) {
        return r2.iu.ku(t, e2, n3, i2);
      }).catch(function(t2) {
        throw t2.code === b.UNAUTHENTICATED && r2.credentials.zc(), t2;
      });
    }, n2.prototype.terminate = function() {
      this.Fu = false;
    }, n2;
  }(function() {
  })
);
var Jo = (
  /** @class */
  function() {
    function t(t2, e) {
      this.cs = t2, this.di = e, /** The current OnlineState. */
      this.state = "Unknown", /**
           * A count of consecutive failures to open the stream. If it reaches the
           * maximum defined by MAX_WATCH_STREAM_FAILURES, we'll set the OnlineState to
           * Offline.
           */
      this.Mu = 0, /**
           * A timer that elapses after ONLINE_STATE_TIMEOUT_MS, at which point we
           * transition from OnlineState.Unknown to OnlineState.Offline without waiting
           * for the stream to actually fail (MAX_WATCH_STREAM_FAILURES times).
           */
      this.Ou = null, /**
           * Whether the client should log a warning message if it fails to connect to
           * the backend (initially true, cleared after a successful stream, or if we've
           * logged the message already).
           */
      this.Lu = true;
    }
    return t.prototype.Bu = function() {
      var t2 = this;
      0 === this.Mu && (this.qu(
        "Unknown"
        /* Unknown */
      ), this.Ou = this.cs.yn("online_state_timeout", 1e4, function() {
        return t2.Ou = null, t2.Uu("Backend didn't respond within 10 seconds."), t2.qu(
          "Offline"
          /* Offline */
        ), Promise.resolve();
      }));
    }, /**
     * Updates our OnlineState as appropriate after the watch stream reports a
     * failure. The first failure moves us to the 'Unknown' state. We then may
     * allow multiple failures (based on MAX_WATCH_STREAM_FAILURES) before we
     * actually transition to the 'Offline' state.
     */
    t.prototype.Qu = function(t2) {
      "Online" === this.state ? this.qu(
        "Unknown"
        /* Unknown */
      ) : (this.Mu++, this.Mu >= 1 && (this.Wu(), this.Uu("Connection failed 1 times. Most recent error: " + t2.toString()), this.qu(
        "Offline"
        /* Offline */
      )));
    }, /**
     * Explicitly sets the OnlineState to the specified state.
     *
     * Note that this resets our timers / failure counters, etc. used by our
     * Offline heuristics, so must not be used in place of
     * handleWatchStreamStart() and handleWatchStreamFailure().
     */
    t.prototype.set = function(t2) {
      this.Wu(), this.Mu = 0, "Online" === t2 && // We've connected to watch at least once. Don't warn the developer
      // about being offline going forward.
      (this.Lu = false), this.qu(t2);
    }, t.prototype.qu = function(t2) {
      t2 !== this.state && (this.state = t2, this.di(t2));
    }, t.prototype.Uu = function(t2) {
      var e = "Could not reach Cloud Firestore backend. " + t2 + "\nThis typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.";
      this.Lu ? (N2(e), this.Lu = false) : T2("OnlineStateTracker", e);
    }, t.prototype.Wu = function() {
      null !== this.Ou && (this.Ou.cancel(), this.Ou = null);
    }, t;
  }()
);
var Zo = function(t, r2, i2, o, s) {
  var u4 = this;
  this.ju = t, this.Ku = r2, this.cs = i2, this.Gu = {}, /**
           * A list of up to MAX_PENDING_WRITES writes that we have fetched from the
           * LocalStore via fillWritePipeline() and have or will send to the write
           * stream.
           *
           * Whenever writePipeline.length > 0 the RemoteStore will attempt to start or
           * restart the write stream. When the stream is established the writes in the
           * pipeline will be sent in order.
           *
           * Writes remain in writePipeline until they are acknowledged by the backend
           * and thus will automatically be re-sent if the stream is interrupted /
           * restarted before they're acknowledged.
           *
           * Write responses from the backend are linked to their originating request
           * purely based on order, and so we can just shift() writes from the front of
           * the writePipeline as we receive responses.
           */
  this.zu = [], /**
           * A mapping of watched targets that the client cares about tracking and the
           * user has explicitly called a 'listen' for this target.
           *
           * These targets may or may not have been sent to or acknowledged by the
           * server. On re-establishing the listen stream, these targets should be sent
           * to the server. The targets removed with unlistens are removed eagerly
           * without waiting for confirmation from the listen stream.
           */
  this.Hu = /* @__PURE__ */ new Map(), /**
           * A set of reasons for why the RemoteStore may be offline. If empty, the
           * RemoteStore may start its network connections.
           */
  this.Yu = /* @__PURE__ */ new Set(), /**
           * Event handlers that get called when the network is disabled or enabled.
           *
           * PORTING NOTE: These functions are used on the Web client to create the
           * underlying streams (to support tree-shakeable streams). On Android and iOS,
           * the streams are created during construction of RemoteStore.
           */
  this.Ju = [], this.Xu = s, this.Xu.Zu(function(t2) {
    i2.ws(function() {
      return __awaiter(u4, void 0, void 0, function() {
        return __generator(this, function(t3) {
          switch (t3.label) {
            case 0:
              return cs(this) ? (T2("RemoteStore", "Restarting streams for network reachability change."), [4, function(t4) {
                return __awaiter(this, void 0, void 0, function() {
                  var e;
                  return __generator(this, function(n2) {
                    switch (n2.label) {
                      case 0:
                        return (e = x2(t4)).Yu.add(
                          4
                          /* ConnectivityChange */
                        ), [4, es(e)];
                      case 1:
                        return n2.sent(), e.th.set(
                          "Unknown"
                          /* Unknown */
                        ), e.Yu.delete(
                          4
                          /* ConnectivityChange */
                        ), [4, ts(e)];
                      case 2:
                        return n2.sent(), [
                          2
                          /*return*/
                        ];
                    }
                  });
                });
              }(this)]) : [3, 2];
            case 1:
              t3.sent(), t3.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    });
  }), this.th = new Jo(i2, o);
};
function ts(t) {
  return __awaiter(this, void 0, void 0, function() {
    var e, r2;
    return __generator(this, function(n2) {
      switch (n2.label) {
        case 0:
          if (!cs(t))
            return [3, 4];
          e = 0, r2 = t.Ju, n2.label = 1;
        case 1:
          return e < r2.length ? [4, (0, r2[e])(
            /* enabled= */
            true
          )] : [3, 4];
        case 2:
          n2.sent(), n2.label = 3;
        case 3:
          return e++, [3, 1];
        case 4:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function es(t) {
  return __awaiter(this, void 0, void 0, function() {
    var e, r2;
    return __generator(this, function(n2) {
      switch (n2.label) {
        case 0:
          e = 0, r2 = t.Ju, n2.label = 1;
        case 1:
          return e < r2.length ? [4, (0, r2[e])(
            /* enabled= */
            false
          )] : [3, 4];
        case 2:
          n2.sent(), n2.label = 3;
        case 3:
          return e++, [3, 1];
        case 4:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function ns(t) {
  return __awaiter(this, void 0, void 0, function() {
    var e;
    return __generator(this, function(n2) {
      switch (n2.label) {
        case 0:
          return e = x2(t), T2("RemoteStore", "RemoteStore shutting down."), e.Yu.add(
            5
            /* Shutdown */
          ), [4, es(e)];
        case 1:
          return n2.sent(), e.Xu.Di(), // Set the OnlineState to Unknown (rather than Offline) to avoid potentially
          // triggering spurious listener events with cached data, etc.
          e.th.set(
            "Unknown"
            /* Unknown */
          ), [
            2
            /*return*/
          ];
      }
    });
  });
}
function rs(t, e) {
  var n2 = x2(t);
  n2.Hu.has(e.targetId) || // Mark this as something the client is currently listening for.
  (n2.Hu.set(e.targetId, e), as(n2) ? (
    // The listen will be sent in onWatchStreamOpen
    us(n2)
  ) : Ts(n2).uu() && os(n2, e));
}
function is(t, e) {
  var n2 = x2(t), r2 = Ts(n2);
  n2.Hu.delete(e), r2.uu() && ss(n2, e), 0 === n2.Hu.size && (r2.uu() ? r2._u() : cs(n2) && // Revert to OnlineState.Unknown if the watch stream is not open and we
  // have no listeners, since without any listens to send we cannot
  // confirm if the stream is healthy and upgrade to OnlineState.Online.
  n2.th.set(
    "Unknown"
    /* Unknown */
  ));
}
function os(t, e) {
  t.eh.Ie(e.targetId), Ts(t).Vu(e);
}
function ss(t, e) {
  t.eh.Ie(e), Ts(t).pu(e);
}
function us(t) {
  t.eh = new re({
    qe: function(e) {
      return t.Gu.qe(e);
    },
    Ue: function(e) {
      return t.Hu.get(e) || null;
    }
  }), Ts(t).start(), t.th.Bu();
}
function as(t) {
  return cs(t) && !Ts(t).cu() && t.Hu.size > 0;
}
function cs(t) {
  return 0 === x2(t).Yu.size;
}
function hs(t) {
  t.eh = void 0;
}
function fs(t) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(e) {
      return t.Hu.forEach(function(e2, n2) {
        os(t, e2);
      }), [
        2
        /*return*/
      ];
    });
  });
}
function ls(t, r2) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(e) {
      return hs(t), // If we still need the watch stream, retry the connection.
      as(t) ? (t.th.Qu(r2), us(t)) : (
        // No need to restart watch stream because there are no active targets.
        // The online state is set to unknown because there is no active attempt
        // at establishing a connection
        t.th.set(
          "Unknown"
          /* Unknown */
        )
      ), [
        2
        /*return*/
      ];
    });
  });
}
function ps(t, r2, i2) {
  return __awaiter(this, void 0, void 0, function() {
    var o, s, u4;
    return __generator(this, function(a) {
      switch (a.label) {
        case 0:
          if (t.th.set(
            "Online"
            /* Online */
          ), !(r2 instanceof ee && 2 === r2.state && r2.cause))
            return [3, 6];
          a.label = 1;
        case 1:
          return a.trys.push([1, 3, , 5]), [
            4,
            /** Handles an error on a target */
            function(t2, r3) {
              return __awaiter(this, void 0, void 0, function() {
                var e, i3, o2, s2;
                return __generator(this, function(n2) {
                  switch (n2.label) {
                    case 0:
                      e = r3.cause, i3 = 0, o2 = r3.targetIds, n2.label = 1;
                    case 1:
                      return i3 < o2.length ? (s2 = o2[i3], t2.Hu.has(s2) ? [4, t2.Gu.nh(s2, e)] : [3, 3]) : [3, 5];
                    case 2:
                      n2.sent(), t2.Hu.delete(s2), t2.eh.removeTarget(s2), n2.label = 3;
                    case 3:
                      n2.label = 4;
                    case 4:
                      return i3++, [3, 1];
                    case 5:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            }(t, r2)
          ];
        case 2:
          return a.sent(), [3, 5];
        case 3:
          return o = a.sent(), T2("RemoteStore", "Failed to remove targets %s: %s ", r2.targetIds.join(","), o), [4, ds(t, o)];
        case 4:
          return a.sent(), [3, 5];
        case 5:
          return [3, 13];
        case 6:
          if (r2 instanceof Zt ? t.eh.be(r2) : r2 instanceof te ? t.eh.$e(r2) : t.eh.De(r2), i2.isEqual(gt.min()))
            return [3, 13];
          a.label = 7;
        case 7:
          return a.trys.push([7, 11, , 13]), [4, Lo(t.ju)];
        case 8:
          return s = a.sent(), i2.L(s) >= 0 ? [
            4,
            /**
             * Takes a batch of changes from the Datastore, repackages them as a
             * RemoteEvent, and passes that on to the listener, which is typically the
             * SyncEngine.
             */
            function(t2, e) {
              var n2 = t2.eh.Oe(e);
              return n2.zt.forEach(function(n3, r3) {
                if (n3.resumeToken.O() > 0) {
                  var i3 = t2.Hu.get(r3);
                  i3 && t2.Hu.set(r3, i3.it(n3.resumeToken, e));
                }
              }), // Re-establish listens for the targets that have been invalidated by
              // existence filter mismatches.
              n2.Ht.forEach(function(e2) {
                var n3 = t2.Hu.get(e2);
                if (n3) {
                  t2.Hu.set(e2, n3.it(ct.B, n3.nt)), // Cause a hard reset by unwatching and rewatching immediately, but
                  // deliberately don't send a resume token so that we get a full update.
                  ss(t2, e2);
                  var r3 = new kt(n3.target, e2, 1, n3.sequenceNumber);
                  os(t2, r3);
                }
              }), t2.Gu.sh(n2);
            }(t, i2)
          ] : [3, 10];
        case 9:
          a.sent(), a.label = 10;
        case 10:
          return [3, 13];
        case 11:
          return T2("RemoteStore", "Failed to raise snapshot:", u4 = a.sent()), [4, ds(t, u4)];
        case 12:
          return a.sent(), [3, 13];
        case 13:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function ds(t, r2, i2) {
  return __awaiter(this, void 0, void 0, function() {
    var o = this;
    return __generator(this, function(s) {
      switch (s.label) {
        case 0:
          if (!Rr(r2))
            throw r2;
          return t.Yu.add(
            1
            /* IndexedDbFailed */
          ), [4, es(t)];
        case 1:
          return s.sent(), t.th.set(
            "Offline"
            /* Offline */
          ), i2 || // Use a simple read operation to determine if IndexedDB recovered.
          // Ideally, we would expose a health check directly on SimpleDb, but
          // RemoteStore only has access to persistence through LocalStore.
          (i2 = function() {
            return Lo(t.ju);
          }), // Probe IndexedDB periodically and re-enable network
          t.cs.Cs(function() {
            return __awaiter(o, void 0, void 0, function() {
              return __generator(this, function(e) {
                switch (e.label) {
                  case 0:
                    return T2("RemoteStore", "Retrying IndexedDB access"), [4, i2()];
                  case 1:
                    return e.sent(), t.Yu.delete(
                      1
                      /* IndexedDbFailed */
                    ), [4, ts(t)];
                  case 2:
                    return e.sent(), [
                      2
                      /*return*/
                    ];
                }
              });
            });
          }), [
            2
            /*return*/
          ];
      }
    });
  });
}
function vs(t, e) {
  return e().catch(function(n2) {
    return ds(t, n2, e);
  });
}
function ys(t) {
  return __awaiter(this, void 0, void 0, function() {
    var e, r2, i2, o, s;
    return __generator(this, function(n2) {
      switch (n2.label) {
        case 0:
          e = x2(t), r2 = Ns(e), i2 = e.zu.length > 0 ? e.zu[e.zu.length - 1].batchId : -1, n2.label = 1;
        case 1:
          if (!/**
          * Returns true if we can add to the write pipeline (i.e. the network is
          * enabled and the write pipeline is not full).
          */
          function(t2) {
            return cs(t2) && t2.zu.length < 10;
          }(e))
            return [3, 7];
          n2.label = 2;
        case 2:
          return n2.trys.push([2, 4, , 6]), [4, Oo(e.ju, i2)];
        case 3:
          return null === (o = n2.sent()) ? (0 === e.zu.length && r2._u(), [3, 7]) : (i2 = o.batchId, function(t2, e2) {
            t2.zu.push(e2);
            var n3 = Ns(t2);
            n3.uu() && n3.vu && n3.Su(e2.mutations);
          }(e, o), [3, 6]);
        case 4:
          return s = n2.sent(), [4, ds(e, s)];
        case 5:
          return n2.sent(), [3, 6];
        case 6:
          return [3, 1];
        case 7:
          return ms(e) && gs(e), [
            2
            /*return*/
          ];
      }
    });
  });
}
function ms(t) {
  return cs(t) && !Ns(t).cu() && t.zu.length > 0;
}
function gs(t) {
  Ns(t).start();
}
function ws(t) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(e) {
      return Ns(t).Nu(), [
        2
        /*return*/
      ];
    });
  });
}
function bs(t) {
  return __awaiter(this, void 0, void 0, function() {
    var e, r2, i2, o;
    return __generator(this, function(n2) {
      for (e = Ns(t), r2 = 0, i2 = t.zu; r2 < i2.length; r2++)
        o = i2[r2], e.Su(o.mutations);
      return [
        2
        /*return*/
      ];
    });
  });
}
function Is(t, r2, i2) {
  return __awaiter(this, void 0, void 0, function() {
    var e, o;
    return __generator(this, function(n2) {
      switch (n2.label) {
        case 0:
          return e = t.zu.shift(), o = hi.from(e, r2, i2), [4, vs(t, function() {
            return t.Gu.ih(o);
          })];
        case 1:
          return n2.sent(), [4, ys(t)];
        case 2:
          return n2.sent(), [
            2
            /*return*/
          ];
      }
    });
  });
}
function Es(t, r2) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(i2) {
      switch (i2.label) {
        case 0:
          return r2 && Ns(t).vu ? [4, function(t2, r3) {
            return __awaiter(this, void 0, void 0, function() {
              var e, i3;
              return __generator(this, function(n2) {
                switch (n2.label) {
                  case 0:
                    return Lt(i3 = r3.code) && i3 !== b.ABORTED ? (e = t2.zu.shift(), // In this case it's also unlikely that the server itself is melting
                    // down -- this was just a bad request so inhibit backoff on the next
                    // restart.
                    Ns(t2).lu(), [4, vs(t2, function() {
                      return t2.Gu.rh(e.batchId, r3);
                    })]) : [3, 3];
                  case 1:
                    return n2.sent(), [4, ys(t2)];
                  case 2:
                    n2.sent(), n2.label = 3;
                  case 3:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          }(t, r2)] : [3, 2];
        case 1:
          i2.sent(), i2.label = 2;
        case 2:
          return ms(t) && gs(t), [
            2
            /*return*/
          ];
      }
    });
  });
}
function _s(t, r2) {
  return __awaiter(this, void 0, void 0, function() {
    var e, i2;
    return __generator(this, function(n2) {
      switch (n2.label) {
        case 0:
          return e = x2(t), r2 ? (e.Yu.delete(
            2
            /* IsSecondary */
          ), [4, ts(e)]) : [3, 2];
        case 1:
          return n2.sent(), [3, 5];
        case 2:
          return (i2 = r2) ? [3, 4] : (e.Yu.add(
            2
            /* IsSecondary */
          ), [4, es(e)]);
        case 3:
          n2.sent(), i2 = e.th.set(
            "Unknown"
            /* Unknown */
          ), n2.label = 4;
        case 4:
          i2, n2.label = 5;
        case 5:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function Ts(t) {
  var r2 = this;
  return t.oh || // Create stream (but note that it is not started yet).
  (t.oh = function(t2, e, n2) {
    var r3 = x2(t2);
    return r3.xu(), new Yo(e, r3.iu, r3.credentials, r3.serializer, n2);
  }(t.Ku, t.cs, {
    gu: fs.bind(null, t),
    Tu: ls.bind(null, t),
    yu: ps.bind(null, t)
  }), t.Ju.push(function(i2) {
    return __awaiter(r2, void 0, void 0, function() {
      return __generator(this, function(e) {
        switch (e.label) {
          case 0:
            return i2 ? (t.oh.lu(), as(t) ? us(t) : t.th.set(
              "Unknown"
              /* Unknown */
            ), [3, 3]) : [3, 1];
          case 1:
            return [4, t.oh.stop()];
          case 2:
            e.sent(), hs(t), e.label = 3;
          case 3:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  })), t.oh;
}
function Ns(t) {
  var r2 = this;
  return t.ah || // Create stream (but note that it is not started yet).
  (t.ah = function(t2, e, n2) {
    var r3 = x2(t2);
    return r3.xu(), new $o(e, r3.iu, r3.credentials, r3.serializer, n2);
  }(t.Ku, t.cs, {
    gu: ws.bind(null, t),
    Tu: Es.bind(null, t),
    Cu: bs.bind(null, t),
    Du: Is.bind(null, t)
  }), t.Ju.push(function(i2) {
    return __awaiter(r2, void 0, void 0, function() {
      return __generator(this, function(e) {
        switch (e.label) {
          case 0:
            return i2 ? (t.ah.lu(), [4, ys(t)]) : [3, 2];
          case 1:
            return e.sent(), [3, 4];
          case 2:
            return [4, t.ah.stop()];
          case 3:
            e.sent(), t.zu.length > 0 && (T2("RemoteStore", "Stopping write stream with " + t.zu.length + " pending writes"), t.zu = []), e.label = 4;
          case 4:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  })), t.ah;
}
var As = function(t) {
  this.key = t;
};
var Ss = function(t) {
  this.key = t;
};
var Ds = (
  /** @class */
  function() {
    function t(t2, e) {
      this.query = t2, this.uh = e, this.hh = null, /**
           * A flag whether the view is current with the backend. A view is considered
           * current after it has seen the current flag from the backend and did not
           * lose consistency within the watch stream (e.g. because of an existence
           * filter mismatch).
           */
      this.te = false, /** Documents in the view but not in the remote target */
      this.lh = Kt(), /** Document Keys that have local changes */
      this.Wt = Kt(), this._h = cr(t2), this.fh = new Ht(this._h);
    }
    return Object.defineProperty(t.prototype, "dh", {
      /**
       * The set of remote documents that the server has told us belongs to the target associated with
       * this view.
       */
      get: function() {
        return this.uh;
      },
      enumerable: false,
      configurable: true
    }), /**
     * Iterates over a set of doc changes, applies the query limit, and computes
     * what the new results should be, what the changes were, and whether we may
     * need to go back to the local cache for more results. Does not make any
     * changes to the view.
     * @param docChanges The doc changes to apply to this view.
     * @param previousChanges If this is being called with a refill, then start
     *        with this set of docs and changes instead of the current view.
     * @return a new set of docs, changes, and refill flag.
     */
    t.prototype.wh = function(t2, e) {
      var n2 = this, r2 = e ? e.mh : new Yt(), i2 = e ? e.fh : this.fh, o = e ? e.Wt : this.Wt, s = i2, u4 = false, a = Yn(this.query) && i2.size === this.query.limit ? i2.last() : null, c = $n(this.query) && i2.size === this.query.limit ? i2.first() : null;
      if (t2.ht(function(t3, e2) {
        var h2 = i2.get(t3), f = e2 instanceof zn ? e2 : null;
        f && (f = ar(n2.query, f) ? f : null);
        var l = !!h2 && n2.Wt.has(h2.key), p2 = !!f && (f.Je || // We only consider committed mutations for documents that were
        // mutated during the lifetime of the view.
        n2.Wt.has(f.key) && f.hasCommittedMutations), d = false;
        h2 && f ? h2.data().isEqual(f.data()) ? l !== p2 && (r2.track({
          type: 3,
          doc: f
        }), d = true) : n2.Th(h2, f) || (r2.track({
          type: 2,
          doc: f
        }), d = true, (a && n2._h(f, a) > 0 || c && n2._h(f, c) < 0) && // This doc moved from inside the limit to outside the limit.
        // That means there may be some other doc in the local cache
        // that should be included instead.
        (u4 = true)) : !h2 && f ? (r2.track({
          type: 0,
          doc: f
        }), d = true) : h2 && !f && (r2.track({
          type: 1,
          doc: h2
        }), d = true, (a || c) && // A doc was removed from a full limit query. We'll need to
        // requery from the local cache to see if we know about some other
        // doc that should be in the results.
        (u4 = true)), d && (f ? (s = s.add(f), o = p2 ? o.add(t3) : o.delete(t3)) : (s = s.delete(t3), o = o.delete(t3)));
      }), Yn(this.query) || $n(this.query))
        for (; s.size > this.query.limit; ) {
          var h = Yn(this.query) ? s.last() : s.first();
          s = s.delete(h.key), o = o.delete(h.key), r2.track({
            type: 1,
            doc: h
          });
        }
      return {
        fh: s,
        mh: r2,
        Eh: u4,
        Wt: o
      };
    }, t.prototype.Th = function(t2, e) {
      return t2.Je && e.hasCommittedMutations && !e.Je;
    }, /**
     * Updates the view with the given ViewDocumentChanges and optionally updates
     * limbo docs and sync state from the provided target change.
     * @param docChanges The set of changes to make to the view's docs.
     * @param updateLimboDocuments Whether to update limbo documents based on this
     *        change.
     * @param targetChange A target change to apply for computing limbo docs and
     *        sync state.
     * @return A new ViewChange with the given docs, changes, and sync state.
     */
    // PORTING NOTE: The iOS/Android clients always compute limbo document changes.
    t.prototype.yr = function(t2, e, n2) {
      var r2 = this, i2 = this.fh;
      this.fh = t2.fh, this.Wt = t2.Wt;
      var o = t2.mh.Ut();
      o.sort(function(t3, e2) {
        return function(t4, e3) {
          var n3 = function(t5) {
            switch (t5) {
              case 0:
                return 1;
              case 2:
              case 3:
                return 2;
              case 1:
                return 0;
              default:
                return D2();
            }
          };
          return n3(t4) - n3(e3);
        }(t3.type, e2.type) || r2._h(t3.doc, e2.doc);
      }), this.Ih(n2);
      var s = e ? this.Ah() : [], u4 = 0 === this.lh.size && this.te ? 1 : 0, a = u4 !== this.hh;
      return this.hh = u4, 0 !== o.length || a ? {
        snapshot: new $t(
          this.query,
          t2.fh,
          i2,
          o,
          t2.Wt,
          0 === u4,
          a,
          /* excludesMetadataChanges= */
          false
        ),
        Rh: s
      } : {
        Rh: s
      };
    }, /**
     * Applies an OnlineState change to the view, potentially generating a
     * ViewChange if the view's syncState changes as a result.
     */
    t.prototype.Qs = function(t2) {
      return this.te && "Offline" === t2 ? (
        // If we're offline, set `current` to false and then call applyChanges()
        // to refresh our syncState and generate a ViewChange as appropriate. We
        // are guaranteed to get a new TargetChange that sets `current` back to
        // true once the client is back online.
        (this.te = false, this.yr(
          {
            fh: this.fh,
            mh: new Yt(),
            Wt: this.Wt,
            Eh: false
          },
          /* updateLimboDocuments= */
          false
        ))
      ) : {
        Rh: []
      };
    }, /**
     * Returns whether the doc for the given key should be in limbo.
     */
    t.prototype.gh = function(t2) {
      return !this.uh.has(t2) && // The local store doesn't think it's a result, so it shouldn't be in limbo.
      !!this.fh.has(t2) && !this.fh.get(t2).Je;
    }, /**
     * Updates syncedDocuments, current, and limbo docs based on the given change.
     * Returns the list of changes to which docs are in limbo.
     */
    t.prototype.Ih = function(t2) {
      var e = this;
      t2 && (t2.ee.forEach(function(t3) {
        return e.uh = e.uh.add(t3);
      }), t2.ne.forEach(function(t3) {
      }), t2.se.forEach(function(t3) {
        return e.uh = e.uh.delete(t3);
      }), this.te = t2.te);
    }, t.prototype.Ah = function() {
      var t2 = this;
      if (!this.te)
        return [];
      var e = this.lh;
      this.lh = Kt(), this.fh.forEach(function(e2) {
        t2.gh(e2.key) && (t2.lh = t2.lh.add(e2.key));
      });
      var n2 = [];
      return e.forEach(function(e2) {
        t2.lh.has(e2) || n2.push(new Ss(e2));
      }), this.lh.forEach(function(t3) {
        e.has(t3) || n2.push(new As(t3));
      }), n2;
    }, /**
     * Update the in-memory state of the current view with the state read from
     * persistence.
     *
     * We update the query view whenever a client's primary status changes:
     * - When a client transitions from primary to secondary, it can miss
     *   LocalStorage updates and its query views may temporarily not be
     *   synchronized with the state on disk.
     * - For secondary to primary transitions, the client needs to update the list
     *   of `syncedDocuments` since secondary clients update their query views
     *   based purely on synthesized RemoteEvents.
     *
     * @param queryResult.documents - The documents that match the query according
     * to the LocalStore.
     * @param queryResult.remoteKeys - The keys of the documents that match the
     * query according to the backend.
     *
     * @return The ViewChange that resulted from this synchronization.
     */
    // PORTING NOTE: Multi-tab only.
    t.prototype.Ph = function(t2) {
      this.uh = t2.Fc, this.lh = Kt();
      var e = this.wh(t2.documents);
      return this.yr(
        e,
        /*updateLimboDocuments=*/
        true
      );
    }, /**
     * Returns a view snapshot as if this query was just listened to. Contains
     * a document add for every existing document and the `fromCache` and
     * `hasPendingWrites` status of the already established view.
     */
    // PORTING NOTE: Multi-tab only.
    t.prototype.yh = function() {
      return $t.Gt(this.query, this.fh, this.Wt, 0 === this.hh);
    }, t;
  }()
);
var ks = function(t, e, n2) {
  this.query = t, this.targetId = e, this.view = n2;
};
var xs = function(t) {
  this.key = t, /**
           * Set to true once we've received a document. This is used in
           * getRemoteKeysForTarget() and ultimately used by WatchChangeAggregator to
           * decide whether it needs to manufacture a delete event for the target once
           * the target is CURRENT.
           */
  this.Vh = false;
};
var Ls = (
  /** @class */
  function() {
    function t(t2, e, n2, r2, i2, o) {
      this.ju = t2, this.ph = e, this.bh = n2, this.Sh = r2, this.currentUser = i2, this.Dh = o, this.Ch = {}, this.Nh = new yt(function(t3) {
        return sr(t3);
      }, or), this.Fh = /* @__PURE__ */ new Map(), /**
           * The keys of documents that are in limbo for which we haven't yet started a
           * limbo resolution query.
           */
      this.xh = [], /**
           * Keeps track of the target ID for each document that is in limbo with an
           * active target.
           */
      this.$h = new Ot(F2.i), /**
           * Keeps track of the information about an active limbo resolution for each
           * active target ID that was started for the purpose of limbo resolution.
           */
      this.kh = /* @__PURE__ */ new Map(), this.Mh = new jo(), /** Stores user completion handlers, indexed by User and BatchId. */
      this.Oh = {}, /** Stores user callbacks waiting for all pending writes to be acknowledged. */
      this.Lh = /* @__PURE__ */ new Map(), this.Bh = yo.da(), this.onlineState = "Unknown", // The primary state is set to `true` or `false` immediately after Firestore
      // startup. In the interim, a client should only be considered primary if
      // `isPrimary` is true.
      this.qh = void 0;
    }
    return Object.defineProperty(t.prototype, "Uh", {
      get: function() {
        return true === this.qh;
      },
      enumerable: false,
      configurable: true
    }), t;
  }()
);
function Rs(t, r2) {
  return __awaiter(this, void 0, void 0, function() {
    var e, i2, o, s, u4, a;
    return __generator(this, function(n2) {
      switch (n2.label) {
        case 0:
          return e = iu(t), (s = e.Nh.get(r2)) ? (
            // PORTING NOTE: With Multi-Tab Web, it is possible that a query view
            // already exists when EventManager calls us for the first time. This
            // happens when the primary tab is already listening to this query on
            // behalf of another tab and the user of the primary also starts listening
            // to the query. EventManager will not have an assigned target ID in this
            // case and calls `listen` to obtain this ID.
            (i2 = s.targetId, e.Sh.Oi(i2), o = s.view.yh(), [3, 4])
          ) : [3, 1];
        case 1:
          return [4, Po(e.ju, er(r2))];
        case 2:
          return u4 = n2.sent(), a = e.Sh.Oi(u4.targetId), i2 = u4.targetId, [4, Os(e, r2, i2, "current" === a)];
        case 3:
          o = n2.sent(), e.Uh && rs(e.ph, u4), n2.label = 4;
        case 4:
          return [2, o];
      }
    });
  });
}
function Os(t, r2, i2, o) {
  return __awaiter(this, void 0, void 0, function() {
    var s, u4, a, c, h, f;
    return __generator(this, function(l) {
      switch (l.label) {
        case 0:
          return t.Qh = function(r3, i3, o2) {
            return function(t2, r4, i4, o3) {
              return __awaiter(this, void 0, void 0, function() {
                var e, s2, u5;
                return __generator(this, function(n2) {
                  switch (n2.label) {
                    case 0:
                      return e = r4.view.wh(i4), e.Eh ? [4, Uo(
                        t2.ju,
                        r4.query,
                        /* usePreviousResults= */
                        false
                      ).then(function(t3) {
                        var n3 = t3.documents;
                        return r4.view.wh(n3, e);
                      })] : [3, 2];
                    case 1:
                      e = n2.sent(), n2.label = 2;
                    case 2:
                      return s2 = o3 && o3.zt.get(r4.targetId), u5 = r4.view.yr(
                        e,
                        /* updateLimboDocuments= */
                        t2.Uh,
                        s2
                      ), [2, (Bs(t2, r4.targetId, u5.Rh), u5.snapshot)];
                  }
                });
              });
            }(t, r3, i3, o2);
          }, [4, Uo(
            t.ju,
            r2,
            /* usePreviousResults= */
            true
          )];
        case 1:
          return s = l.sent(), u4 = new Ds(r2, s.Fc), a = u4.wh(s.documents), c = Jt.Zt(i2, o && "Offline" !== t.onlineState), h = u4.yr(
            a,
            /* updateLimboDocuments= */
            t.Uh,
            c
          ), Bs(t, i2, h.Rh), f = new ks(r2, i2, u4), [2, (t.Nh.set(r2, f), t.Fh.has(i2) ? t.Fh.get(i2).push(r2) : t.Fh.set(i2, [r2]), h.snapshot)];
      }
    });
  });
}
function Ps(t, r2) {
  return __awaiter(this, void 0, void 0, function() {
    var e, i2, o;
    return __generator(this, function(n2) {
      switch (n2.label) {
        case 0:
          return e = x2(t), i2 = e.Nh.get(r2), (o = e.Fh.get(i2.targetId)).length > 1 ? [2, (e.Fh.set(i2.targetId, o.filter(function(t2) {
            return !or(t2, r2);
          })), void e.Nh.delete(r2))] : e.Uh ? (
            // We need to remove the local query target first to allow us to verify
            // whether any other client is still interested in this target.
            (e.Sh.Bi(i2.targetId), e.Sh.Fi(i2.targetId) ? [3, 2] : [4, Vo(
              e.ju,
              i2.targetId,
              /*keepPersistedTargetData=*/
              false
            ).then(function() {
              e.Sh.Ui(i2.targetId), is(e.ph, i2.targetId), Gs(e, i2.targetId);
            }).catch(qo)])
          ) : [3, 3];
        case 1:
          n2.sent(), n2.label = 2;
        case 2:
          return [3, 5];
        case 3:
          return Gs(e, i2.targetId), [4, Vo(
            e.ju,
            i2.targetId,
            /*keepPersistedTargetData=*/
            true
          )];
        case 4:
          n2.sent(), n2.label = 5;
        case 5:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function Vs(t, r2) {
  return __awaiter(this, void 0, void 0, function() {
    var e, i2;
    return __generator(this, function(n2) {
      switch (n2.label) {
        case 0:
          e = x2(t), n2.label = 1;
        case 1:
          return n2.trys.push([1, 4, , 6]), [4, Ro(e.ju, r2)];
        case 2:
          return i2 = n2.sent(), // Update `receivedDocument` as appropriate for any limbo targets.
          r2.zt.forEach(function(t2, n3) {
            var r3 = e.kh.get(n3);
            r3 && // Since this is a limbo resolution lookup, it's for a single document
            // and it could be added, modified, or removed, but not a combination.
            (k2(t2.ee.size + t2.ne.size + t2.se.size <= 1), t2.ee.size > 0 ? r3.Vh = true : t2.ne.size > 0 ? k2(r3.Vh) : t2.se.size > 0 && (k2(r3.Vh), r3.Vh = false));
          }), [4, Qs(e, i2, r2)];
        case 3:
          return n2.sent(), [3, 6];
        case 4:
          return [4, qo(n2.sent())];
        case 5:
          return n2.sent(), [3, 6];
        case 6:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function Us(t, e, n2) {
  var r2 = x2(t);
  if (r2.Uh && 0 === n2 || !r2.Uh && 1 === n2) {
    var i2 = [];
    r2.Nh.forEach(function(t2, n3) {
      var r3 = n3.view.Qs(e);
      r3.snapshot && i2.push(r3.snapshot);
    }), function(t2, e2) {
      var n3 = x2(t2);
      n3.onlineState = e2;
      var r3 = false;
      n3.Bs.forEach(function(t3, n4) {
        for (var i3 = 0, o = n4.listeners; i3 < o.length; i3++) {
          o[i3].Qs(e2) && (r3 = true);
        }
      }), r3 && Yr(n3);
    }(r2.bh, e), i2.length && r2.Ch.yu(i2), r2.onlineState = e, r2.Uh && r2.Sh.Ki(e);
  }
}
function Cs(t, r2, i2) {
  return __awaiter(this, void 0, void 0, function() {
    var e, o, s, u4, a, c;
    return __generator(this, function(n2) {
      switch (n2.label) {
        case 0:
          return (e = x2(t)).Sh.Qi(r2, "rejected", i2), o = e.kh.get(r2), (s = o && o.key) ? (u4 = (u4 = new Ot(F2.i)).ot(s, new Bn(s, gt.min())), a = Kt().add(s), c = new Xt(
            gt.min(),
            /* targetChanges= */
            /* @__PURE__ */ new Map(),
            /* targetMismatches= */
            new Ut(st),
            u4,
            a
          ), [4, Vs(e, c)]) : [3, 2];
        case 1:
          return n2.sent(), // Since this query failed, we won't want to manually unlisten to it.
          // We only remove it from bookkeeping after we successfully applied the
          // RemoteEvent. If `applyRemoteEvent()` throws, we want to re-listen to
          // this query when the RemoteStore restarts the Watch stream, which should
          // re-trigger the target failure.
          e.$h = e.$h.remove(s), e.kh.delete(r2), Ws(e), [3, 4];
        case 2:
          return [4, Vo(
            e.ju,
            r2,
            /* keepPersistedTargetData */
            false
          ).then(function() {
            return Gs(e, r2, i2);
          }).catch(qo)];
        case 3:
          n2.sent(), n2.label = 4;
        case 4:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function Fs(t, r2) {
  return __awaiter(this, void 0, void 0, function() {
    var e, i2, o;
    return __generator(this, function(n2) {
      switch (n2.label) {
        case 0:
          e = x2(t), i2 = r2.batch.batchId, n2.label = 1;
        case 1:
          return n2.trys.push([1, 4, , 6]), [4, xo(e.ju, r2)];
        case 2:
          return o = n2.sent(), // The local store may or may not be able to apply the write result and
          // raise events immediately (depending on whether the watcher is caught
          // up), so we raise user callbacks first so that they consistently happen
          // before listen events.
          js(
            e,
            i2,
            /*error=*/
            null
          ), qs(e, i2), e.Sh.ki(i2, "acknowledged"), [4, Qs(e, o)];
        case 3:
          return n2.sent(), [3, 6];
        case 4:
          return [4, qo(n2.sent())];
        case 5:
          return n2.sent(), [3, 6];
        case 6:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function Ms(t, r2, i2) {
  return __awaiter(this, void 0, void 0, function() {
    var e, o;
    return __generator(this, function(n2) {
      switch (n2.label) {
        case 0:
          e = x2(t), n2.label = 1;
        case 1:
          return n2.trys.push([1, 4, , 6]), [4, function(t2, e2) {
            var n3 = x2(t2);
            return n3.persistence.runTransaction("Reject batch", "readwrite-primary", function(t3) {
              var r3;
              return n3.Sr.Oo(t3, e2).next(function(e3) {
                return k2(null !== e3), r3 = e3.keys(), n3.Sr.Wo(t3, e3);
              }).next(function() {
                return n3.Sr.zo(t3);
              }).next(function() {
                return n3.Cc.kr(t3, r3);
              });
            });
          }(e.ju, r2)];
        case 2:
          return o = n2.sent(), // The local store may or may not be able to apply the write result and
          // raise events immediately (depending on whether the watcher is caught up),
          // so we raise user callbacks first so that they consistently happen before
          // listen events.
          js(e, r2, i2), qs(e, r2), e.Sh.ki(r2, "rejected", i2), [4, Qs(e, o)];
        case 3:
          return n2.sent(), [3, 6];
        case 4:
          return [4, qo(n2.sent())];
        case 5:
          return n2.sent(), [3, 6];
        case 6:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function qs(t, e) {
  (t.Lh.get(e) || []).forEach(function(t2) {
    t2.resolve();
  }), t.Lh.delete(e);
}
function js(t, e, n2) {
  var r2 = x2(t), i2 = r2.Oh[r2.currentUser.ti()];
  if (i2) {
    var o = i2.get(e);
    o && (n2 ? o.reject(n2) : o.resolve(), i2 = i2.remove(e)), r2.Oh[r2.currentUser.ti()] = i2;
  }
}
function Gs(t, e, n2) {
  void 0 === n2 && (n2 = null), t.Sh.Bi(e);
  for (var r2 = 0, i2 = t.Fh.get(e); r2 < i2.length; r2++) {
    var o = i2[r2];
    t.Nh.delete(o), n2 && t.Ch.Wh(o, n2);
  }
  t.Fh.delete(e), t.Uh && t.Mh.Uc(e).forEach(function(e2) {
    t.Mh.Ho(e2) || // We removed the last reference for this key
    zs(t, e2);
  });
}
function zs(t, e) {
  var n2 = t.$h.get(e);
  null !== n2 && (is(t.ph, n2), t.$h = t.$h.remove(e), t.kh.delete(n2), Ws(t));
}
function Bs(t, e, n2) {
  for (var r2 = 0, i2 = n2; r2 < i2.length; r2++) {
    var o = i2[r2];
    o instanceof As ? (t.Mh.Da(o.key, e), Ks(t, o)) : o instanceof Ss ? (T2("SyncEngine", "Document no longer in limbo: " + o.key), t.Mh.Na(o.key, e), t.Mh.Ho(o.key) || // We removed the last reference for this key
    zs(t, o.key)) : D2();
  }
}
function Ks(t, e) {
  var n2 = e.key;
  t.$h.get(n2) || (T2("SyncEngine", "New document in limbo: " + n2), t.xh.push(n2), Ws(t));
}
function Ws(t) {
  for (; t.xh.length > 0 && t.$h.size < t.Dh; ) {
    var e = t.xh.shift(), n2 = t.Bh.next();
    t.kh.set(n2, new xs(e)), t.$h = t.$h.ot(e, n2), rs(t.ph, new kt(er(Hn(e.path)), n2, 2, Jr.ai));
  }
}
function Qs(t, r2, i2) {
  return __awaiter(this, void 0, void 0, function() {
    var o, s, u4, a;
    return __generator(this, function(c) {
      switch (c.label) {
        case 0:
          return o = x2(t), s = [], u4 = [], a = [], o.Nh.m() ? [3, 3] : (o.Nh.forEach(function(t2, e) {
            a.push(o.Qh(e, r2, i2).then(function(t3) {
              if (t3) {
                o.Uh && o.Sh.Qi(e.targetId, t3.fromCache ? "not-current" : "current"), s.push(t3);
                var n2 = vi.zr(e.targetId, t3);
                u4.push(n2);
              }
            }));
          }), [4, Promise.all(a)]);
        case 1:
          return c.sent(), o.Ch.yu(s), [4, function(t2, r3) {
            return __awaiter(this, void 0, void 0, function() {
              var e, i3, o2, s2, u5, a2, c2, h, f;
              return __generator(this, function(n2) {
                switch (n2.label) {
                  case 0:
                    e = x2(t2), n2.label = 1;
                  case 1:
                    return n2.trys.push([1, 3, , 4]), [4, e.persistence.runTransaction("notifyLocalViewChanges", "readwrite", function(t3) {
                      return Dr.forEach(r3, function(n3) {
                        return Dr.forEach(n3.Kr, function(r4) {
                          return e.persistence.No.Da(t3, n3.targetId, r4);
                        }).next(function() {
                          return Dr.forEach(n3.Gr, function(r4) {
                            return e.persistence.No.Na(t3, n3.targetId, r4);
                          });
                        });
                      });
                    })];
                  case 2:
                    return n2.sent(), [3, 4];
                  case 3:
                    if (!Rr(i3 = n2.sent()))
                      throw i3;
                    return T2("LocalStore", "Failed to update sequence numbers: " + i3), [3, 4];
                  case 4:
                    for (o2 = 0, s2 = r3; o2 < s2.length; o2++)
                      u5 = s2[o2], a2 = u5.targetId, u5.fromCache || (c2 = e.bc.get(a2), h = c2.nt, f = c2.rt(h), // Advance the last limbo free snapshot version
                      e.bc = e.bc.ot(a2, f));
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          }(o.ju, u4)];
        case 2:
          c.sent(), c.label = 3;
        case 3:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function Hs(t, r2) {
  return __awaiter(this, void 0, void 0, function() {
    var i2, o;
    return __generator(this, function(s) {
      switch (s.label) {
        case 0:
          return (i2 = x2(t)).currentUser.isEqual(r2) ? [3, 3] : (T2("SyncEngine", "User change. New user:", r2.ti()), [
            4,
            /**
             * Tells the LocalStore that the currently authenticated user has changed.
             *
             * In response the local store switches the mutation queue to the new user and
             * returns any resulting document changes.
             */
            // PORTING NOTE: Android and iOS only return the documents affected by the
            // change.
            function(t2, r3) {
              return __awaiter(this, void 0, void 0, function() {
                var e, i3, o2, s2;
                return __generator(this, function(n2) {
                  switch (n2.label) {
                    case 0:
                      return e = x2(t2), i3 = e.Sr, o2 = e.Cc, [4, e.persistence.runTransaction("Handle user change", "readonly", function(t3) {
                        var n3;
                        return e.Sr.Uo(t3).next(function(s3) {
                          return n3 = s3, i3 = e.persistence.mc(r3), // Recreate our LocalDocumentsView using the new
                          // MutationQueue.
                          o2 = new di(e.Dc, i3, e.persistence.Ic()), i3.Uo(t3);
                        }).next(function(e2) {
                          for (var r4 = [], i4 = [], s3 = Kt(), u4 = 0, a = n3; u4 < a.length; u4++) {
                            var c = a[u4];
                            r4.push(c.batchId);
                            for (var h = 0, f = c.mutations; h < f.length; h++) {
                              var l = f[h];
                              s3 = s3.add(l.key);
                            }
                          }
                          for (var p2 = 0, d = e2; p2 < d.length; p2++) {
                            var v2 = d[p2];
                            i4.push(v2.batchId);
                            for (var y2 = 0, m = v2.mutations; y2 < m.length; y2++) {
                              var g2 = m[y2];
                              s3 = s3.add(g2.key);
                            }
                          }
                          return o2.kr(t3, s3).next(function(t4) {
                            return {
                              jh: t4,
                              Kh: r4,
                              Gh: i4
                            };
                          });
                        });
                      })];
                    case 1:
                      return s2 = n2.sent(), [2, (e.Sr = i3, e.Cc = o2, e.Vc.Nc(e.Cc), s2)];
                  }
                });
              });
            }(i2.ju, r2)
          ]);
        case 1:
          return o = s.sent(), i2.currentUser = r2, // Fails tasks waiting for pending writes requested by previous user.
          function(t2, e) {
            t2.Lh.forEach(function(t3) {
              t3.forEach(function(t4) {
                t4.reject(new I2(b.CANCELLED, "'waitForPendingWrites' promise is rejected due to a user change."));
              });
            }), t2.Lh.clear();
          }(i2), // TODO(b/114226417): Consider calling this only in the primary tab.
          i2.Sh.ji(r2, o.Kh, o.Gh), [4, Qs(i2, o.jh)];
        case 2:
          s.sent(), s.label = 3;
        case 3:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function Ys(t, e) {
  var n2 = x2(t), r2 = n2.kh.get(e);
  if (r2 && r2.Vh)
    return Kt().add(r2.key);
  var i2 = Kt(), o = n2.Fh.get(e);
  if (!o)
    return i2;
  for (var s = 0, u4 = o; s < u4.length; s++) {
    var a = u4[s], c = n2.Nh.get(a);
    i2 = i2.kt(c.view.dh);
  }
  return i2;
}
function $s(t, r2) {
  return __awaiter(this, void 0, void 0, function() {
    var e, i2, o;
    return __generator(this, function(n2) {
      switch (n2.label) {
        case 0:
          return [4, Uo(
            (e = x2(t)).ju,
            r2.query,
            /* usePreviousResults= */
            true
          )];
        case 1:
          return i2 = n2.sent(), o = r2.view.Ph(i2), [2, (e.Uh && Bs(e, r2.targetId, o.Rh), o)];
      }
    });
  });
}
function Xs(t, r2, i2, o) {
  return __awaiter(this, void 0, void 0, function() {
    var e, s;
    return __generator(this, function(n2) {
      switch (n2.label) {
        case 0:
          return [4, function(t2, e2) {
            var n3 = x2(t2), r3 = x2(n3.Sr);
            return n3.persistence.runTransaction("Lookup mutation documents", "readonly", function(t3) {
              return r3.Lo(t3, e2).next(function(e3) {
                return e3 ? n3.Cc.kr(t3, e3) : Dr.resolve(null);
              });
            });
          }((e = x2(t)).ju, r2)];
        case 1:
          return null === (s = n2.sent()) ? [3, 6] : "pending" !== i2 ? [3, 3] : [4, ys(e.ph)];
        case 2:
          return n2.sent(), [3, 4];
        case 3:
          "acknowledged" === i2 || "rejected" === i2 ? (
            // NOTE: Both these methods are no-ops for batches that originated from
            // other clients.
            (js(e, r2, o || null), qs(e, r2), function(t2, e2) {
              x2(x2(t2).Sr).Ko(e2);
            }(e.ju, r2))
          ) : D2(), n2.label = 4;
        case 4:
          return [4, Qs(e, s)];
        case 5:
          return n2.sent(), [3, 7];
        case 6:
          T2("SyncEngine", "Cannot apply mutation batch with id: " + r2), n2.label = 7;
        case 7:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function Js(t, r2) {
  return __awaiter(this, void 0, void 0, function() {
    var e, i2, o, s, u4, a, c, h;
    return __generator(this, function(n2) {
      switch (n2.label) {
        case 0:
          return iu(e = x2(t)), ou(e), true !== r2 || true === e.qh ? [3, 3] : (i2 = e.Sh.Ci(), [4, Zs(e, i2.A())]);
        case 1:
          return o = n2.sent(), e.qh = true, [4, _s(e.ph, true)];
        case 2:
          for (n2.sent(), s = 0, u4 = o; s < u4.length; s++)
            a = u4[s], rs(e.ph, a);
          return [3, 7];
        case 3:
          return false !== r2 || false === e.qh ? [3, 7] : (c = [], h = Promise.resolve(), e.Fh.forEach(function(t2, n3) {
            e.Sh.qi(n3) ? c.push(n3) : h = h.then(function() {
              return Gs(e, n3), Vo(
                e.ju,
                n3,
                /*keepPersistedTargetData=*/
                true
              );
            }), is(e.ph, n3);
          }), [4, h]);
        case 4:
          return n2.sent(), [4, Zs(e, c)];
        case 5:
          return n2.sent(), // PORTING NOTE: Multi-Tab only.
          function(t2) {
            var e2 = x2(t2);
            e2.kh.forEach(function(t3, n3) {
              is(e2.ph, n3);
            }), e2.Mh.Qc(), e2.kh = /* @__PURE__ */ new Map(), e2.$h = new Ot(F2.i);
          }(e), e.qh = false, [4, _s(e.ph, false)];
        case 6:
          n2.sent(), n2.label = 7;
        case 7:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function Zs(t, r2, i2) {
  return __awaiter(this, void 0, void 0, function() {
    var e, i3, o, s, u4, a, c, h, f, l, p2, d, v2, y2;
    return __generator(this, function(n2) {
      switch (n2.label) {
        case 0:
          e = x2(t), i3 = [], o = [], s = 0, u4 = r2, n2.label = 1;
        case 1:
          return s < u4.length ? (a = u4[s], c = void 0, (h = e.Fh.get(a)) && 0 !== h.length ? [4, Po(e.ju, er(h[0]))] : [3, 7]) : [3, 13];
        case 2:
          c = n2.sent(), f = 0, l = h, n2.label = 3;
        case 3:
          return f < l.length ? (p2 = l[f], d = e.Nh.get(p2), [4, $s(e, d)]) : [3, 6];
        case 4:
          (v2 = n2.sent()).snapshot && o.push(v2.snapshot), n2.label = 5;
        case 5:
          return f++, [3, 3];
        case 6:
          return [3, 11];
        case 7:
          return [4, Co(e.ju, a)];
        case 8:
          return y2 = n2.sent(), [4, Po(e.ju, y2)];
        case 9:
          return c = n2.sent(), [4, Os(
            e,
            tu(y2),
            a,
            /*current=*/
            false
          )];
        case 10:
          n2.sent(), n2.label = 11;
        case 11:
          i3.push(c), n2.label = 12;
        case 12:
          return s++, [3, 1];
        case 13:
          return [2, (e.Ch.yu(o), i3)];
      }
    });
  });
}
function tu(t) {
  return Qn(t.path, t.collectionGroup, t.orderBy, t.filters, t.limit, "F", t.startAt, t.endAt);
}
function eu(t) {
  var e = x2(t);
  return x2(x2(e.ju).persistence).pi();
}
function nu(t, r2, i2, o) {
  return __awaiter(this, void 0, void 0, function() {
    var e, s, u4;
    return __generator(this, function(n2) {
      switch (n2.label) {
        case 0:
          return (e = x2(t)).qh ? (
            // If we receive a target state notification via WebStorage, we are
            // either already secondary or another tab has taken the primary lease.
            (T2("SyncEngine", "Ignoring unexpected query state notification."), [3, 8])
          ) : [3, 1];
        case 1:
          if (!e.Fh.has(r2))
            return [3, 8];
          switch (i2) {
            case "current":
            case "not-current":
              return [3, 2];
            case "rejected":
              return [3, 5];
          }
          return [3, 7];
        case 2:
          return [4, Fo(e.ju)];
        case 3:
          return s = n2.sent(), u4 = Xt.Xt(r2, "current" === i2), [4, Qs(e, s, u4)];
        case 4:
          return n2.sent(), [3, 8];
        case 5:
          return [4, Vo(
            e.ju,
            r2,
            /* keepPersistedTargetData */
            true
          )];
        case 6:
          return n2.sent(), Gs(e, r2, o), [3, 8];
        case 7:
          D2(), n2.label = 8;
        case 8:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function ru(t, r2, i2) {
  return __awaiter(this, void 0, void 0, function() {
    var e, o, s, u4, a, c, h, f, l, p2;
    return __generator(this, function(d) {
      switch (d.label) {
        case 0:
          if (!(e = iu(t)).qh)
            return [3, 10];
          o = 0, s = r2, d.label = 1;
        case 1:
          return o < s.length ? (u4 = s[o], e.Fh.has(u4) ? (
            // A target might have been added in a previous attempt
            (T2("SyncEngine", "Adding an already active target " + u4), [3, 5])
          ) : [4, Co(e.ju, u4)]) : [3, 6];
        case 2:
          return a = d.sent(), [4, Po(e.ju, a)];
        case 3:
          return c = d.sent(), [4, Os(
            e,
            tu(a),
            c.targetId,
            /*current=*/
            false
          )];
        case 4:
          d.sent(), rs(e.ph, c), d.label = 5;
        case 5:
          return o++, [3, 1];
        case 6:
          h = function(t2) {
            return __generator(this, function(n2) {
              switch (n2.label) {
                case 0:
                  return e.Fh.has(t2) ? [4, Vo(
                    e.ju,
                    t2,
                    /* keepPersistedTargetData */
                    false
                  ).then(function() {
                    is(e.ph, t2), Gs(e, t2);
                  }).catch(qo)] : [3, 2];
                case 1:
                  n2.sent(), n2.label = 2;
                case 2:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          }, f = 0, l = i2, d.label = 7;
        case 7:
          return f < l.length ? (p2 = l[f], [5, h(p2)]) : [3, 10];
        case 8:
          d.sent(), d.label = 9;
        case 9:
          return f++, [3, 7];
        case 10:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function iu(t) {
  var e = x2(t);
  return e.ph.Gu.sh = Vs.bind(null, e), e.ph.Gu.qe = Ys.bind(null, e), e.ph.Gu.nh = Cs.bind(null, e), e.Ch.yu = Qr.bind(null, e.bh), e.Ch.Wh = Hr.bind(null, e.bh), e;
}
function ou(t) {
  var e = x2(t);
  return e.ph.Gu.ih = Fs.bind(null, e), e.ph.Gu.rh = Ms.bind(null, e), e;
}
var su = (
  /** @class */
  function() {
    function t() {
    }
    return t.prototype.Nc = function(t2) {
      this.zh = t2;
    }, t.prototype.Lr = function(t2, e, n2, r2) {
      var i2 = this;
      return function(t3) {
        return 0 === t3.filters.length && null === t3.limit && null == t3.startAt && null == t3.endAt && (0 === t3.on.length || 1 === t3.on.length && t3.on[0].field.p());
      }(e) || n2.isEqual(gt.min()) ? this.Hh(t2, e) : this.zh.kr(t2, r2).next(function(o) {
        var u4 = i2.Yh(e, o);
        return (Yn(e) || $n(e)) && i2.Eh(e.an, u4, r2, n2) ? i2.Hh(t2, e) : (_() <= LogLevel.DEBUG && T2("IndexFreeQueryEngine", "Re-using previous result from %s to execute query: %s", n2.toString(), ur(e)), i2.zh.Lr(t2, e, n2).next(function(t3) {
          return u4.forEach(function(e2) {
            t3 = t3.ot(e2.key, e2);
          }), t3;
        }));
      });
    }, /** Applies the query filter and sorting to the provided documents.  */
    t.prototype.Yh = function(t2, e) {
      var n2 = new Ut(cr(t2));
      return e.forEach(function(e2, r2) {
        r2 instanceof zn && ar(t2, r2) && (n2 = n2.add(r2));
      }), n2;
    }, /**
     * Determines if a limit query needs to be refilled from cache, making it
     * ineligible for index-free execution.
     *
     * @param sortedPreviousResults The documents that matched the query when it
     * was last synchronized, sorted by the query's comparator.
     * @param remoteKeys The document keys that matched the query at the last
     * snapshot.
     * @param limboFreeSnapshotVersion The version of the snapshot when the query
     * was last synchronized.
     */
    t.prototype.Eh = function(t2, e, n2, r2) {
      if (n2.size !== e.size)
        return true;
      var i2 = "F" === t2 ? e.last() : e.first();
      return !!i2 && (i2.hasPendingWrites || i2.version.L(r2) > 0);
    }, t.prototype.Hh = function(t2, e) {
      return _() <= LogLevel.DEBUG && T2("IndexFreeQueryEngine", "Using full collection scan to execute query:", ur(e)), this.zh.Lr(t2, e, gt.min());
    }, t;
  }()
);
var uu = (
  /** @class */
  function() {
    function t(t2, e) {
      this.Dr = t2, this.No = e, /**
           * The set of all mutations that have been sent but not yet been applied to
           * the backend.
           */
      this.Sr = [], /** Next value to use when assigning sequential IDs to each mutation batch. */
      this.Jh = 1, /** An ordered mapping between documents and the mutations batch IDs. */
      this.Xh = new Ut(Go.kc);
    }
    return t.prototype.$o = function(t2) {
      return Dr.resolve(0 === this.Sr.length);
    }, t.prototype.ko = function(t2, e, n2, r2) {
      var i2 = this.Jh;
      this.Jh++, this.Sr.length > 0 && this.Sr[this.Sr.length - 1];
      var o = new ci(i2, e, n2, r2);
      this.Sr.push(o);
      for (var s = 0, u4 = r2; s < u4.length; s++) {
        var a = u4[s];
        this.Xh = this.Xh.add(new Go(a.key, i2)), this.Dr.Mo(t2, a.key.path.h());
      }
      return Dr.resolve(o);
    }, t.prototype.Oo = function(t2, e) {
      return Dr.resolve(this.Zh(e));
    }, t.prototype.Bo = function(t2, e) {
      var n2 = e + 1, r2 = this.tl(n2), i2 = r2 < 0 ? 0 : r2;
      return Dr.resolve(this.Sr.length > i2 ? this.Sr[i2] : null);
    }, t.prototype.qo = function() {
      return Dr.resolve(0 === this.Sr.length ? -1 : this.Jh - 1);
    }, t.prototype.Uo = function(t2) {
      return Dr.resolve(this.Sr.slice());
    }, t.prototype.Nr = function(t2, e) {
      var n2 = this, r2 = new Go(e, 0), i2 = new Go(e, Number.POSITIVE_INFINITY), o = [];
      return this.Xh.Ft([r2, i2], function(t3) {
        var e2 = n2.Zh(t3.jc);
        o.push(e2);
      }), Dr.resolve(o);
    }, t.prototype.Or = function(t2, e) {
      var n2 = this, r2 = new Ut(st);
      return e.forEach(function(t3) {
        var e2 = new Go(t3, 0), i2 = new Go(t3, Number.POSITIVE_INFINITY);
        n2.Xh.Ft([e2, i2], function(t4) {
          r2 = r2.add(t4.jc);
        });
      }), Dr.resolve(this.el(r2));
    }, t.prototype.Wr = function(t2, e) {
      var n2 = e.path, r2 = n2.length + 1, i2 = n2;
      F2.F(i2) || (i2 = i2.child(""));
      var o = new Go(new F2(i2), 0), s = new Ut(st);
      return this.Xh.xt(function(t3) {
        var e2 = t3.key.path;
        return !!n2.T(e2) && // Rows with document keys more than one segment longer than the query
        // path can't be matches. For example, a query on 'rooms' can't match
        // the document /rooms/abc/messages/xyx.
        // TODO(mcg): we'll need a different scanner when we implement
        // ancestor queries.
        (e2.length === r2 && (s = s.add(t3.jc)), true);
      }, o), Dr.resolve(this.el(s));
    }, t.prototype.el = function(t2) {
      var e = this, n2 = [];
      return t2.forEach(function(t3) {
        var r2 = e.Zh(t3);
        null !== r2 && n2.push(r2);
      }), n2;
    }, t.prototype.Wo = function(t2, e) {
      var n2 = this;
      k2(0 === this.nl(e.batchId, "removed")), this.Sr.shift();
      var r2 = this.Xh;
      return Dr.forEach(e.mutations, function(i2) {
        var o = new Go(i2.key, e.batchId);
        return r2 = r2.delete(o), n2.No.Go(t2, i2.key);
      }).next(function() {
        n2.Xh = r2;
      });
    }, t.prototype.Ko = function(t2) {
    }, t.prototype.Ho = function(t2, e) {
      var n2 = new Go(e, 0), r2 = this.Xh.$t(n2);
      return Dr.resolve(e.isEqual(r2 && r2.key));
    }, t.prototype.zo = function(t2) {
      return this.Sr.length, Dr.resolve();
    }, /**
     * Finds the index of the given batchId in the mutation queue and asserts that
     * the resulting index is within the bounds of the queue.
     *
     * @param batchId The batchId to search for
     * @param action A description of what the caller is doing, phrased in passive
     * form (e.g. "acknowledged" in a routine that acknowledges batches).
     */
    t.prototype.nl = function(t2, e) {
      return this.tl(t2);
    }, /**
     * Finds the index of the given batchId in the mutation queue. This operation
     * is O(1).
     *
     * @return The computed index of the batch with the given batchId, based on
     * the state of the queue. Note this index can be negative if the requested
     * batchId has already been remvoed from the queue or past the end of the
     * queue if the batchId is larger than the last added batch.
     */
    t.prototype.tl = function(t2) {
      return 0 === this.Sr.length ? 0 : t2 - this.Sr[0].batchId;
    }, /**
     * A version of lookupMutationBatch that doesn't return a promise, this makes
     * other functions that uses this code easier to read and more efficent.
     */
    t.prototype.Zh = function(t2) {
      var e = this.tl(t2);
      return e < 0 || e >= this.Sr.length ? null : this.Sr[e];
    }, t;
  }()
);
var au = (
  /** @class */
  function() {
    function t(t2, e) {
      this.Dr = t2, this.sl = e, /** Underlying cache of documents and their read times. */
      this.docs = new Ot(F2.i), /** Size of all cached documents. */
      this.size = 0;
    }
    return t.prototype.Er = function(t2, e, n2) {
      var r2 = e.key, i2 = this.docs.get(r2), o = i2 ? i2.size : 0, s = this.sl(e);
      return this.docs = this.docs.ot(r2, {
        ta: e,
        size: s,
        readTime: n2
      }), this.size += s - o, this.Dr.Mo(t2, r2.path.h());
    }, /**
     * Removes the specified entry from the cache and updates the cache size as appropriate.
     *
     * All calls of `removeEntry` are required to go through the RemoteDocumentChangeBuffer
     * returned by `newChangeBuffer()`.
     */
    t.prototype.Ar = function(t2) {
      var e = this.docs.get(t2);
      e && (this.docs = this.docs.remove(t2), this.size -= e.size);
    }, t.prototype.Rr = function(t2, e) {
      var n2 = this.docs.get(e);
      return Dr.resolve(n2 ? n2.ta : null);
    }, t.prototype.getEntries = function(t2, e) {
      var n2 = this, r2 = qt();
      return e.forEach(function(t3) {
        var e2 = n2.docs.get(t3);
        r2 = r2.ot(t3, e2 ? e2.ta : null);
      }), Dr.resolve(r2);
    }, t.prototype.Lr = function(t2, e, n2) {
      for (var r2 = Gt(), i2 = new F2(e.path.child("")), o = this.docs.ft(i2); o.At(); ) {
        var s = o.It(), u4 = s.key, a = s.value, c = a.ta, h = a.readTime;
        if (!e.path.T(u4.path))
          break;
        h.L(n2) <= 0 || c instanceof zn && ar(e, c) && (r2 = r2.ot(c.key, c));
      }
      return Dr.resolve(r2);
    }, t.prototype.il = function(t2, e) {
      return Dr.forEach(this.docs, function(t3) {
        return e(t3);
      });
    }, t.prototype.ra = function(t2) {
      return new cu(this);
    }, t.prototype.aa = function(t2) {
      return Dr.resolve(this.size);
    }, t;
  }()
);
var cu = (
  /** @class */
  function(e) {
    function n2(t) {
      var n3 = this;
      return (n3 = e.call(this) || this).ca = t, n3;
    }
    return __extends(n2, e), n2.prototype.yr = function(t) {
      var e2 = this, n3 = [];
      return this.wr.forEach(function(r2, i2) {
        i2 ? n3.push(e2.ca.Er(t, i2, e2.readTime)) : e2.ca.Ar(r2);
      }), Dr.$n(n3);
    }, n2.prototype.gr = function(t, e2) {
      return this.ca.Rr(t, e2);
    }, n2.prototype.Pr = function(t, e2) {
      return this.ca.getEntries(t, e2);
    }, n2;
  }(fi)
);
var hu = (
  /** @class */
  function() {
    function t(t2) {
      this.persistence = t2, /**
           * Maps a target to the data about that target
           */
      this.rl = new yt(function(t3) {
        return Tt(t3);
      }, Nt), /** The last received snapshot version. */
      this.lastRemoteSnapshotVersion = gt.min(), /** The highest numbered target ID encountered. */
      this.highestTargetId = 0, /** The highest sequence number encountered. */
      this.ol = 0, /**
           * A ordered bidirectional mapping between documents and the remote target
           * IDs.
           */
      this.al = new jo(), this.targetCount = 0, this.cl = yo.fa();
    }
    return t.prototype.Ce = function(t2, e) {
      return this.rl.forEach(function(t3, n2) {
        return e(n2);
      }), Dr.resolve();
    }, t.prototype.Ea = function(t2) {
      return Dr.resolve(this.lastRemoteSnapshotVersion);
    }, t.prototype.Ia = function(t2) {
      return Dr.resolve(this.ol);
    }, t.prototype.wa = function(t2) {
      return this.highestTargetId = this.cl.next(), Dr.resolve(this.highestTargetId);
    }, t.prototype.Aa = function(t2, e, n2) {
      return n2 && (this.lastRemoteSnapshotVersion = n2), e > this.ol && (this.ol = e), Dr.resolve();
    }, t.prototype.ga = function(t2) {
      this.rl.set(t2.target, t2);
      var e = t2.targetId;
      e > this.highestTargetId && (this.cl = new yo(e), this.highestTargetId = e), t2.sequenceNumber > this.ol && (this.ol = t2.sequenceNumber);
    }, t.prototype.Ra = function(t2, e) {
      return this.ga(e), this.targetCount += 1, Dr.resolve();
    }, t.prototype.ya = function(t2, e) {
      return this.ga(e), Dr.resolve();
    }, t.prototype.Va = function(t2, e) {
      return this.rl.delete(e.target), this.al.Uc(e.targetId), this.targetCount -= 1, Dr.resolve();
    }, t.prototype.po = function(t2, e, n2) {
      var r2 = this, i2 = 0, o = [];
      return this.rl.forEach(function(s, u4) {
        u4.sequenceNumber <= e && null === n2.get(u4.targetId) && (r2.rl.delete(s), o.push(r2.pa(t2, u4.targetId)), i2++);
      }), Dr.$n(o).next(function() {
        return i2;
      });
    }, t.prototype.ba = function(t2) {
      return Dr.resolve(this.targetCount);
    }, t.prototype.va = function(t2, e) {
      var n2 = this.rl.get(e) || null;
      return Dr.resolve(n2);
    }, t.prototype.Sa = function(t2, e, n2) {
      return this.al.Lc(e, n2), Dr.resolve();
    }, t.prototype.Ca = function(t2, e, n2) {
      this.al.qc(e, n2);
      var r2 = this.persistence.No, i2 = [];
      return r2 && e.forEach(function(e2) {
        i2.push(r2.Go(t2, e2));
      }), Dr.$n(i2);
    }, t.prototype.pa = function(t2, e) {
      return this.al.Uc(e), Dr.resolve();
    }, t.prototype.Fa = function(t2, e) {
      var n2 = this.al.Wc(e);
      return Dr.resolve(n2);
    }, t.prototype.Ho = function(t2, e) {
      return Dr.resolve(this.al.Ho(e));
    }, t;
  }()
);
var fu = (
  /** @class */
  function() {
    function t(t2) {
      var e = this;
      this.ul = {}, this.Ma = new Jr(0), this.Oa = false, this.Oa = true, this.No = t2(this), this.Ka = new hu(this), this.Dr = new Hi(), this.vr = function(t3, n2) {
        return new au(t3, function(t4) {
          return e.No.hl(t4);
        });
      }(this.Dr);
    }
    return t.prototype.start = function() {
      return Promise.resolve();
    }, t.prototype.Di = function() {
      return this.Oa = false, Promise.resolve();
    }, Object.defineProperty(t.prototype, "Ei", {
      get: function() {
        return this.Oa;
      },
      enumerable: false,
      configurable: true
    }), t.prototype.Za = function() {
    }, t.prototype.tc = function() {
    }, t.prototype.Ic = function() {
      return this.Dr;
    }, t.prototype.mc = function(t2) {
      var e = this.ul[t2.ti()];
      return e || (e = new uu(this.Dr, this.No), this.ul[t2.ti()] = e), e;
    }, t.prototype.Tc = function() {
      return this.Ka;
    }, t.prototype.Ec = function() {
      return this.vr;
    }, t.prototype.runTransaction = function(t2, e, n2) {
      var r2 = this;
      T2("MemoryPersistence", "Starting transaction:", t2);
      var i2 = new lu(this.Ma.next());
      return this.No.ll(), n2(i2).next(function(t3) {
        return r2.No._l(i2).next(function() {
          return t3;
        });
      }).Fn().then(function(t3) {
        return i2.br(), t3;
      });
    }, t.prototype.fl = function(t2, e) {
      return Dr.kn(Object.values(this.ul).map(function(n2) {
        return function() {
          return n2.Ho(t2, e);
        };
      }));
    }, t;
  }()
);
var lu = (
  /** @class */
  function(e) {
    function n2(t) {
      var n3 = this;
      return (n3 = e.call(this) || this).xa = t, n3;
    }
    return __extends(n2, e), n2;
  }(pi)
);
var pu = (
  /** @class */
  function() {
    function t(t2) {
      this.persistence = t2, /** Tracks all documents that are active in Query views. */
      this.dl = new jo(), /** The list of documents that are potentially GCed after each transaction. */
      this.wl = null;
    }
    return t.ml = function(e) {
      return new t(e);
    }, Object.defineProperty(t.prototype, "Tl", {
      get: function() {
        if (this.wl)
          return this.wl;
        throw D2();
      },
      enumerable: false,
      configurable: true
    }), t.prototype.Da = function(t2, e, n2) {
      return this.dl.Da(n2, e), this.Tl.delete(n2.toString()), Dr.resolve();
    }, t.prototype.Na = function(t2, e, n2) {
      return this.dl.Na(n2, e), this.Tl.add(n2.toString()), Dr.resolve();
    }, t.prototype.Go = function(t2, e) {
      return this.Tl.add(e.toString()), Dr.resolve();
    }, t.prototype.removeTarget = function(t2, e) {
      var n2 = this;
      this.dl.Uc(e.targetId).forEach(function(t3) {
        return n2.Tl.add(t3.toString());
      });
      var r2 = this.persistence.Tc();
      return r2.Fa(t2, e.targetId).next(function(t3) {
        t3.forEach(function(t4) {
          return n2.Tl.add(t4.toString());
        });
      }).next(function() {
        return r2.Va(t2, e);
      });
    }, t.prototype.ll = function() {
      this.wl = /* @__PURE__ */ new Set();
    }, t.prototype._l = function(t2) {
      var e = this, n2 = this.persistence.Ec().ra();
      return Dr.forEach(this.Tl, function(r2) {
        var i2 = F2.D(r2);
        return e.El(t2, i2).next(function(t3) {
          t3 || n2.Ar(i2);
        });
      }).next(function() {
        return e.wl = null, n2.apply(t2);
      });
    }, t.prototype.yc = function(t2, e) {
      var n2 = this;
      return this.El(t2, e).next(function(t3) {
        t3 ? n2.Tl.delete(e.toString()) : n2.Tl.add(e.toString());
      });
    }, t.prototype.hl = function(t2) {
      return 0;
    }, t.prototype.El = function(t2, e) {
      var n2 = this;
      return Dr.kn([function() {
        return Dr.resolve(n2.dl.Ho(e));
      }, function() {
        return n2.persistence.Tc().Ho(t2, e);
      }, function() {
        return n2.persistence.fl(t2, e);
      }]);
    }, t;
  }()
);
var du = (
  /** @class */
  function() {
    function t(t2) {
      this.Il = t2.Il, this.Al = t2.Al;
    }
    return t.prototype.gu = function(t2) {
      this.Rl = t2;
    }, t.prototype.Tu = function(t2) {
      this.gl = t2;
    }, t.prototype.onMessage = function(t2) {
      this.Pl = t2;
    }, t.prototype.close = function() {
      this.Al();
    }, t.prototype.send = function(t2) {
      this.Il(t2);
    }, t.prototype.yl = function() {
      this.Rl();
    }, t.prototype.Vl = function(t2) {
      this.gl(t2);
    }, t.prototype.pl = function(t2) {
      this.Pl(t2);
    }, t;
  }()
);
var vu = {
  BatchGetDocuments: "batchGet",
  Commit: "commit",
  RunQuery: "runQuery"
};
var yu = (
  /** @class */
  function(e) {
    function n2(t) {
      var n3 = this;
      return (n3 = e.call(this, t) || this).forceLongPolling = t.forceLongPolling, n3.W = t.W, n3;
    }
    return __extends(n2, e), n2.prototype.Nl = function(t, e2, n3, r2) {
      return new Promise(function(i2, o) {
        var s = new XhrIo();
        s.listenOnce(EventType.COMPLETE, function() {
          try {
            switch (s.getLastErrorCode()) {
              case ErrorCode.NO_ERROR:
                var e3 = s.getResponseJson();
                T2("Connection", "XHR received:", JSON.stringify(e3)), i2(e3);
                break;
              case ErrorCode.TIMEOUT:
                T2("Connection", 'RPC "' + t + '" timed out'), o(new I2(b.DEADLINE_EXCEEDED, "Request time out"));
                break;
              case ErrorCode.HTTP_ERROR:
                var n4 = s.getStatus();
                if (T2("Connection", 'RPC "' + t + '" failed with status:', n4, "response text:", s.getResponseText()), n4 > 0) {
                  var r3 = s.getResponseJson().error;
                  if (r3 && r3.status && r3.message) {
                    var u5 = function(t2) {
                      var e4 = t2.toLowerCase().replace("_", "-");
                      return Object.values(b).indexOf(e4) >= 0 ? e4 : b.UNKNOWN;
                    }(r3.status);
                    o(new I2(u5, r3.message));
                  } else
                    o(new I2(b.UNKNOWN, "Server responded with status " + s.getStatus()));
                } else
                  o(new I2(b.UNAVAILABLE, "Connection failed."));
                break;
              default:
                D2();
            }
          } finally {
            T2("Connection", 'RPC "' + t + '" completed.');
          }
        });
        var u4 = JSON.stringify(r2);
        s.send(e2, "POST", u4, n3, 15);
      });
    }, n2.prototype.Pu = function(t, e2) {
      var n3 = [this.vl, "/", "google.firestore.v1.Firestore", "/", t, "/channel"], r2 = createWebChannelTransport(), i2 = {
        // Required for backend stickiness, routing behavior is based on this
        // parameter.
        httpSessionIdParam: "gsessionid",
        initMessageHeaders: {},
        messageUrlParams: {
          // This param is used to improve routing and project isolation by the
          // backend and must be included in every request.
          database: "projects/" + this.U.projectId + "/databases/" + this.U.database
        },
        sendRawJson: true,
        supportsCrossDomainXhr: true,
        internalChannelParams: {
          // Override the default timeout (randomized between 10-20 seconds) since
          // a large write batch on a slow internet connection may take a long
          // time to send to the backend. Rather than have WebChannel impose a
          // tight timeout which could lead to infinite timeouts and retries, we
          // set it very large (5-10 minutes) and rely on the browser's builtin
          // timeouts to kick in if the request isn't working.
          forwardChannelRequestTimeoutMs: 6e5
        },
        forceLongPolling: this.forceLongPolling,
        detectBufferingProxy: this.W
      };
      this.Cl(i2.initMessageHeaders, e2), // Sending the custom headers we just added to request.initMessageHeaders
      // (Authorization, etc.) will trigger the browser to make a CORS preflight
      // request because the XHR will no longer meet the criteria for a "simple"
      // CORS request:
      // https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Simple_requests
      // Therefore to avoid the CORS preflight request (an extra network
      // roundtrip), we use the httpHeadersOverwriteParam option to specify that
      // the headers should instead be encoded into a special "$httpHeaders" query
      // parameter, which is recognized by the webchannel backend. This is
      // formally defined here:
      // https://github.com/google/closure-library/blob/b0e1815b13fb92a46d7c9b3c30de5d6a396a3245/closure/goog/net/rpc/httpcors.js#L32
      // TODO(b/145624756): There is a backend bug where $httpHeaders isn't respected if the request
      // doesn't have an Origin header. So we have to exclude a few browser environments that are
      // known to (sometimes) not include an Origin. See
      // https://github.com/firebase/firebase-js-sdk/issues/1491.
      isMobileCordova() || isReactNative() || isElectron() || isIE() || isUWP() || isBrowserExtension() || (i2.httpHeadersOverwriteParam = "$httpHeaders");
      var o = n3.join("");
      T2("Connection", "Creating WebChannel: " + o, i2);
      var s = r2.createWebChannel(o, i2), u4 = false, d = false, v2 = new du({
        Il: function(t2) {
          d ? T2("Connection", "Not sending because WebChannel is closed:", t2) : (u4 || (T2("Connection", "Opening WebChannel transport."), s.open(), u4 = true), T2("Connection", "WebChannel sending:", t2), s.send(t2));
        },
        Al: function() {
          return s.close();
        }
      }), y2 = function(t2, e3) {
        s.listen(t2, function(t3) {
          try {
            e3(t3);
          } catch (t4) {
            setTimeout(function() {
              throw t4;
            }, 0);
          }
        });
      };
      return y2(WebChannel.EventType.OPEN, function() {
        d || T2("Connection", "WebChannel transport opened.");
      }), y2(WebChannel.EventType.CLOSE, function() {
        d || (d = true, T2("Connection", "WebChannel transport closed"), v2.Vl());
      }), y2(WebChannel.EventType.ERROR, function(t2) {
        d || (d = true, A2("Connection", "WebChannel transport errored:", t2), v2.Vl(new I2(b.UNAVAILABLE, "The operation could not be completed")));
      }), y2(WebChannel.EventType.MESSAGE, function(t2) {
        var e3;
        if (!d) {
          var n4 = t2.data[0];
          k2(!!n4);
          var r3 = n4, i3 = r3.error || (null === (e3 = r3[0]) || void 0 === e3 ? void 0 : e3.error);
          if (i3) {
            T2("Connection", "WebChannel received error:", i3);
            var o2 = i3.status, u5 = function(t3) {
              var e4 = St[t3];
              if (void 0 !== e4)
                return Rt(e4);
            }(o2), a = i3.message;
            void 0 === u5 && (u5 = b.INTERNAL, a = "Unknown error status: " + o2 + " with message " + i3.message), // Mark closed so no further events are propagated
            d = true, v2.Vl(new I2(u5, a)), s.close();
          } else
            T2("Connection", "WebChannel received:", n4), v2.pl(n4);
        }
      }), setTimeout(function() {
        v2.yl();
      }, 0), v2;
    }, n2;
  }(
    /** @class */
    function() {
      function t(t2) {
        this.bl = t2, this.U = t2.U;
        var e = t2.ssl ? "https" : "http";
        this.vl = e + "://" + t2.host, this.Sl = "projects/" + this.U.projectId + "/databases/" + this.U.database + "/documents";
      }
      return t.prototype.$u = function(t2, e, n2, r2) {
        var i2 = this.Dl(t2, e);
        T2("RestConnection", "Sending: ", i2, n2);
        var o = {};
        return this.Cl(o, r2), this.Nl(t2, i2, o, n2).then(function(t3) {
          return T2("RestConnection", "Received: ", t3), t3;
        }, function(e2) {
          throw A2("RestConnection", t2 + " failed with error: ", e2, "url: ", i2, "request:", n2), e2;
        });
      }, t.prototype.ku = function(t2, e, n2, r2) {
        return this.$u(t2, e, n2, r2);
      }, /**
       * Modifies the headers for a request, adding any authorization token if
       * present and any additional headers for the request.
       */
      t.prototype.Cl = function(t2, e) {
        if (t2["X-Goog-Api-Client"] = "gl-js/ fire/7.24.0", // Content-Type: text/plain will avoid preflight requests which might
        // mess with CORS and redirects by proxies. If we add custom headers
        // we will need to change this code to potentially use the $httpOverwrite
        // parameter supported by ESF to avoid triggering preflight requests.
        t2["Content-Type"] = "text/plain", e)
          for (var n2 in e.Kc)
            e.Kc.hasOwnProperty(n2) && (t2[n2] = e.Kc[n2]);
      }, t.prototype.Dl = function(t2, e) {
        var n2 = vu[t2];
        return this.vl + "/v1/" + e + ":" + n2;
      }, t;
    }()
  )
);
var mu = (
  /** @class */
  function() {
    function t() {
      var t2 = this;
      this.Fl = function() {
        return t2.xl();
      }, this.$l = function() {
        return t2.kl();
      }, this.Ml = [], this.Ol();
    }
    return t.prototype.Zu = function(t2) {
      this.Ml.push(t2);
    }, t.prototype.Di = function() {
      window.removeEventListener("online", this.Fl), window.removeEventListener("offline", this.$l);
    }, t.prototype.Ol = function() {
      window.addEventListener("online", this.Fl), window.addEventListener("offline", this.$l);
    }, t.prototype.xl = function() {
      T2("ConnectivityMonitor", "Network connectivity changed: AVAILABLE");
      for (var t2 = 0, e = this.Ml; t2 < e.length; t2++) {
        (0, e[t2])(
          0
          /* AVAILABLE */
        );
      }
    }, t.prototype.kl = function() {
      T2("ConnectivityMonitor", "Network connectivity changed: UNAVAILABLE");
      for (var t2 = 0, e = this.Ml; t2 < e.length; t2++) {
        (0, e[t2])(
          1
          /* UNAVAILABLE */
        );
      }
    }, // TODO(chenbrian): Consider passing in window either into this component or
    // here for testing via FakeWindow.
    /** Checks that all used attributes of window are available. */
    t.Ln = function() {
      return "undefined" != typeof window && void 0 !== window.addEventListener && void 0 !== window.removeEventListener;
    }, t;
  }()
);
var gu = (
  /** @class */
  function() {
    function t() {
    }
    return t.prototype.Zu = function(t2) {
    }, t.prototype.Di = function() {
    }, t;
  }()
);
function wu(t) {
  return new De(
    t,
    /* useProto3Json= */
    true
  );
}
var bu = "You are using the memory-only build of Firestore. Persistence support is only available via the @firebase/firestore bundle or the firebase-firestore.js build.";
var Iu = (
  /** @class */
  function() {
    function t() {
    }
    return t.prototype.initialize = function(t2) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(e) {
          switch (e.label) {
            case 0:
              return this.Sh = this.Ll(t2), this.persistence = this.Bl(t2), [4, this.persistence.start()];
            case 1:
              return e.sent(), this.ql = this.Ul(t2), this.ju = this.Ql(t2), [
                2
                /*return*/
              ];
          }
        });
      });
    }, t.prototype.Ul = function(t2) {
      return null;
    }, t.prototype.Ql = function(t2) {
      return e = this.persistence, n2 = new su(), r2 = t2.Wl, new ko(e, n2, r2);
      var e, n2, r2;
    }, t.prototype.Bl = function(t2) {
      if (t2.persistenceSettings.jl)
        throw new I2(b.FAILED_PRECONDITION, bu);
      return new fu(pu.ml);
    }, t.prototype.Ll = function(t2) {
      return new ai();
    }, t.prototype.terminate = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(t2) {
          switch (t2.label) {
            case 0:
              return this.ql && this.ql.stop(), [4, this.Sh.Di()];
            case 1:
              return t2.sent(), [4, this.persistence.Di()];
            case 2:
              return t2.sent(), [
                2
                /*return*/
              ];
          }
        });
      });
    }, t.prototype.clearPersistence = function(t2, e) {
      throw new I2(b.FAILED_PRECONDITION, bu);
    }, t;
  }()
);
var Eu = (
  /** @class */
  function(r2) {
    function i2() {
      return null !== r2 && r2.apply(this, arguments) || this;
    }
    return __extends(i2, r2), i2.prototype.initialize = function(t) {
      return __awaiter(this, void 0, void 0, function() {
        var i3, o = this;
        return __generator(this, function(s) {
          switch (s.label) {
            case 0:
              return [4, r2.prototype.initialize.call(this, t)];
            case 1:
              return s.sent(), i3 = this.Kl.fi, this.Sh instanceof ui ? (this.Sh.fi = {
                er: Xs.bind(null, i3),
                nr: nu.bind(null, i3),
                sr: ru.bind(null, i3),
                pi: eu.bind(null, i3)
              }, [4, this.Sh.start()]) : [3, 3];
            case 2:
              s.sent(), s.label = 3;
            case 3:
              return [4, this.persistence.Xa(function(t2) {
                return __awaiter(o, void 0, void 0, function() {
                  return __generator(this, function(e) {
                    switch (e.label) {
                      case 0:
                        return [4, Js(this.Kl.fi, t2)];
                      case 1:
                        return e.sent(), this.ql && (t2 && !this.ql.Ei ? this.ql.start(this.ju) : t2 || this.ql.stop()), [
                          2
                          /*return*/
                        ];
                    }
                  });
                });
              })];
            case 4:
              return s.sent(), [
                2
                /*return*/
              ];
          }
        });
      });
    }, i2.prototype.Ll = function(t) {
      if (t.persistenceSettings.jl && t.persistenceSettings.synchronizeTabs) {
        var e = Fr();
        if (!ui.Ln(e))
          throw new I2(b.UNIMPLEMENTED, "IndexedDB persistence is only available on platforms that support LocalStorage.");
        var n2 = Do(t.bl.U, t.bl.persistenceKey);
        return new ui(e, t.cs, n2, t.clientId, t.Wl);
      }
      return new ai();
    }, i2;
  }(
    /** @class */
    function(r2) {
      function i2(t) {
        var e = this;
        return (e = r2.call(this) || this).Kl = t, e;
      }
      return __extends(i2, r2), i2.prototype.initialize = function(t) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(e) {
            switch (e.label) {
              case 0:
                return [4, r2.prototype.initialize.call(this, t)];
              case 1:
                return e.sent(), [4, Mo(this.ju)];
              case 2:
                return e.sent(), [4, this.Kl.initialize(this, t)];
              case 3:
                return e.sent(), [4, ou(this.Kl.fi)];
              case 4:
                return e.sent(), [4, ys(this.Kl.ph)];
              case 5:
                return e.sent(), [
                  2
                  /*return*/
                ];
            }
          });
        });
      }, i2.prototype.Ul = function(t) {
        var e = this.persistence.No.wo;
        return new bi(e, t.cs);
      }, i2.prototype.Bl = function(t) {
        var e = Do(t.bl.U, t.bl.persistenceKey), n2 = wu(t.bl.U);
        return new _o(t.persistenceSettings.synchronizeTabs, e, t.clientId, wi.ao(t.persistenceSettings.cacheSizeBytes), t.cs, Fr(), Mr(), n2, this.Sh, t.persistenceSettings.ka);
      }, i2.prototype.Ll = function(t) {
        return new ai();
      }, i2.prototype.clearPersistence = function(t, r3) {
        return function(t2) {
          return __awaiter(this, void 0, void 0, function() {
            var e;
            return __generator(this, function(n2) {
              switch (n2.label) {
                case 0:
                  return kr.Ln() ? (e = t2 + "main", [4, kr.delete(e)]) : [2, Promise.resolve()];
                case 1:
                  return n2.sent(), [
                    2
                    /*return*/
                  ];
              }
            });
          });
        }(Do(t, r3));
      }, i2;
    }(Iu)
  )
);
var _u = (
  /** @class */
  function() {
    function t() {
    }
    return t.prototype.initialize = function(t2, r2) {
      return __awaiter(this, void 0, void 0, function() {
        var e = this;
        return __generator(this, function(n2) {
          switch (n2.label) {
            case 0:
              return this.ju ? [3, 2] : (this.ju = t2.ju, this.Sh = t2.Sh, this.Ku = this.Gl(r2), this.ph = this.zl(r2), this.bh = this.Hl(r2), this.fi = this.Yl(r2), this.Sh.di = function(t3) {
                return Us(
                  e.fi,
                  t3,
                  1
                  /* SharedClientState */
                );
              }, this.ph.Gu.Jl = Hs.bind(null, this.fi), [4, _s(this.ph, this.fi.Uh)]);
            case 1:
              n2.sent(), n2.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, t.prototype.Hl = function(t2) {
      return new Br();
    }, t.prototype.Gl = function(t2) {
      var e, n2 = wu(t2.bl.U), r2 = (e = t2.bl, new yu(e));
      return function(t3, e2, n3) {
        return new Xo(t3, e2, n3);
      }(t2.credentials, r2, n2);
    }, t.prototype.zl = function(t2) {
      var e, n2, r2, i2, o, s = this;
      return e = this.ju, n2 = this.Ku, r2 = t2.cs, i2 = function(t3) {
        return Us(
          s.fi,
          t3,
          0
          /* RemoteStore */
        );
      }, o = mu.Ln() ? new mu() : new gu(), new Zo(e, n2, r2, i2, o);
    }, t.prototype.Yl = function(t2) {
      return function(t3, e, n2, r2, i2, o, s) {
        var u4 = new Ls(t3, e, n2, r2, i2, o);
        return s && (u4.qh = true), u4;
      }(this.ju, this.ph, this.bh, this.Sh, t2.Wl, t2.Dh, !t2.persistenceSettings.jl || !t2.persistenceSettings.synchronizeTabs);
    }, t.prototype.terminate = function() {
      return ns(this.ph);
    }, t;
  }()
);
var Tu = (
  /** @class */
  function() {
    function t(t2) {
      this.observer = t2, /**
           * When set to true, will not raise future events. Necessary to deal with
           * async detachment of listener.
           */
      this.muted = false;
    }
    return t.prototype.next = function(t2) {
      this.observer.next && this.Xl(this.observer.next, t2);
    }, t.prototype.error = function(t2) {
      this.observer.error ? this.Xl(this.observer.error, t2) : console.error("Uncaught Error in snapshot listener:", t2);
    }, t.prototype.Zl = function() {
      this.muted = true;
    }, t.prototype.Xl = function(t2, e) {
      var n2 = this;
      this.muted || setTimeout(function() {
        n2.muted || t2(e);
      }, 0);
    }, t;
  }()
);
var Nu = function(t) {
  !function(t2, e2, n2, r2) {
    if (!(e2 instanceof Array) || e2.length < 1)
      throw new I2(b.INVALID_ARGUMENT, "Function FieldPath() requires its fieldNames argument to be an array with at least " + rt(1, "element") + ".");
  }(0, t);
  for (var e = 0; e < t.length; ++e)
    if (z("FieldPath", "string", e, t[e]), 0 === t[e].length)
      throw new I2(b.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty.");
  this.t_ = new C2(t);
};
var Au = (
  /** @class */
  function(e) {
    function n2() {
      for (var t = [], n3 = 0; n3 < arguments.length; n3++)
        t[n3] = arguments[n3];
      return e.call(this, t) || this;
    }
    return __extends(n2, e), n2.documentId = function() {
      return new n2(C2.v().R());
    }, n2.prototype.isEqual = function(t) {
      if (!(t instanceof n2))
        throw tt("isEqual", "FieldPath", 1, t);
      return this.t_.isEqual(t.t_);
    }, n2;
  }(Nu)
);
var Su = new RegExp("[~\\*/\\[\\]]");
var Du = (
  /**
       * @param _methodName The public API endpoint that returns this class.
       */
  function(t) {
    this.e_ = t;
  }
);
var ku = (
  /** @class */
  function(e) {
    function n2() {
      return null !== e && e.apply(this, arguments) || this;
    }
    return __extends(n2, e), n2.prototype.n_ = function(t) {
      if (2 !== t.s_)
        throw 1 === t.s_ ? t.i_(this.e_ + "() can only appear at the top level of your update data") : t.i_(this.e_ + "() cannot be used with set() unless you pass {merge:true}");
      return t.We.push(t.path), null;
    }, n2.prototype.isEqual = function(t) {
      return t instanceof n2;
    }, n2;
  }(Du)
);
function xu(t, e, n2) {
  return new Gu({
    s_: 3,
    r_: e.settings.r_,
    methodName: t.e_,
    o_: n2
  }, e.U, e.serializer, e.ignoreUndefinedProperties);
}
var Lu = (
  /** @class */
  function(e) {
    function n2() {
      return null !== e && e.apply(this, arguments) || this;
    }
    return __extends(n2, e), n2.prototype.n_ = function(t) {
      return new In(t.path, new ln());
    }, n2.prototype.isEqual = function(t) {
      return t instanceof n2;
    }, n2;
  }(Du)
);
var Ru = (
  /** @class */
  function(e) {
    function n2(t, n3) {
      var r2 = this;
      return (r2 = e.call(this, t) || this).a_ = n3, r2;
    }
    return __extends(n2, e), n2.prototype.n_ = function(t) {
      var e2 = xu(
        this,
        t,
        /*array=*/
        true
      ), n3 = this.a_.map(function(t2) {
        return Hu(t2, e2);
      }), r2 = new pn(n3);
      return new In(t.path, r2);
    }, n2.prototype.isEqual = function(t) {
      return this === t;
    }, n2;
  }(Du)
);
var Ou = (
  /** @class */
  function(e) {
    function n2(t, n3) {
      var r2 = this;
      return (r2 = e.call(this, t) || this).a_ = n3, r2;
    }
    return __extends(n2, e), n2.prototype.n_ = function(t) {
      var e2 = xu(
        this,
        t,
        /*array=*/
        true
      ), n3 = this.a_.map(function(t2) {
        return Hu(t2, e2);
      }), r2 = new vn(n3);
      return new In(t.path, r2);
    }, n2.prototype.isEqual = function(t) {
      return this === t;
    }, n2;
  }(Du)
);
var Pu = (
  /** @class */
  function(e) {
    function n2(t, n3) {
      var r2 = this;
      return (r2 = e.call(this, t) || this).c_ = n3, r2;
    }
    return __extends(n2, e), n2.prototype.n_ = function(t) {
      var e2 = new mn(t.serializer, Le(t.serializer, this.c_));
      return new In(t.path, e2);
    }, n2.prototype.isEqual = function(t) {
      return this === t;
    }, n2;
  }(Du)
);
var Vu = (
  /** @class */
  function() {
    function t(t2, e) {
      if (q2("GeoPoint", arguments, 2), z("GeoPoint", "number", 1, t2), z("GeoPoint", "number", 2, e), !isFinite(t2) || t2 < -90 || t2 > 90)
        throw new I2(b.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + t2);
      if (!isFinite(e) || e < -180 || e > 180)
        throw new I2(b.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + e);
      this.u_ = t2, this.h_ = e;
    }
    return Object.defineProperty(t.prototype, "latitude", {
      /**
       * The latitude of this `GeoPoint` instance.
       */
      get: function() {
        return this.u_;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "longitude", {
      /**
       * The longitude of this `GeoPoint` instance.
       */
      get: function() {
        return this.h_;
      },
      enumerable: false,
      configurable: true
    }), /**
     * Returns true if this `GeoPoint` is equal to the provided one.
     *
     * @param other The `GeoPoint` to compare against.
     * @return true if this `GeoPoint` is equal to the provided one.
     */
    t.prototype.isEqual = function(t2) {
      return this.u_ === t2.u_ && this.h_ === t2.h_;
    }, t.prototype.toJSON = function() {
      return {
        latitude: this.u_,
        longitude: this.h_
      };
    }, /**
     * Actually private to JS consumers of our API, so this function is prefixed
     * with an underscore.
     */
    t.prototype.Y = function(t2) {
      return st(this.u_, t2.u_) || st(this.h_, t2.h_);
    }, t;
  }()
);
var Uu = function(t) {
  this.l_ = t;
};
var Cu = /^__.*__$/;
var Fu = function(t, e, n2) {
  this.__ = t, this.f_ = e, this.d_ = n2;
};
var Mu = (
  /** @class */
  function() {
    function t(t2, e, n2) {
      this.data = t2, this.We = e, this.fieldTransforms = n2;
    }
    return t.prototype.w_ = function(t2, e) {
      var n2 = [];
      return null !== this.We ? n2.push(new Rn(t2, this.data, this.We, e)) : n2.push(new Ln(t2, this.data, e)), this.fieldTransforms.length > 0 && n2.push(new Pn(t2, this.fieldTransforms)), n2;
    }, t;
  }()
);
var qu = (
  /** @class */
  function() {
    function t(t2, e, n2) {
      this.data = t2, this.We = e, this.fieldTransforms = n2;
    }
    return t.prototype.w_ = function(t2, e) {
      var n2 = [new Rn(t2, this.data, this.We, e)];
      return this.fieldTransforms.length > 0 && n2.push(new Pn(t2, this.fieldTransforms)), n2;
    }, t;
  }()
);
function ju(t) {
  switch (t) {
    case 0:
    case 2:
    case 1:
      return true;
    case 3:
    case 4:
      return false;
    default:
      throw D2();
  }
}
var Gu = (
  /** @class */
  function() {
    function t(t2, e, n2, r2, i2, o) {
      this.settings = t2, this.U = e, this.serializer = n2, this.ignoreUndefinedProperties = r2, // Minor hack: If fieldTransforms is undefined, we assume this is an
      // external call and we need to validate the entire path.
      void 0 === i2 && this.m_(), this.fieldTransforms = i2 || [], this.We = o || [];
    }
    return Object.defineProperty(t.prototype, "path", {
      get: function() {
        return this.settings.path;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "s_", {
      get: function() {
        return this.settings.s_;
      },
      enumerable: false,
      configurable: true
    }), /** Returns a new context with the specified settings overwritten. */
    t.prototype.T_ = function(e) {
      return new t(Object.assign(Object.assign({}, this.settings), e), this.U, this.serializer, this.ignoreUndefinedProperties, this.fieldTransforms, this.We);
    }, t.prototype.E_ = function(t2) {
      var e, n2 = null === (e = this.path) || void 0 === e ? void 0 : e.child(t2), r2 = this.T_({
        path: n2,
        o_: false
      });
      return r2.I_(t2), r2;
    }, t.prototype.A_ = function(t2) {
      var e, n2 = null === (e = this.path) || void 0 === e ? void 0 : e.child(t2), r2 = this.T_({
        path: n2,
        o_: false
      });
      return r2.m_(), r2;
    }, t.prototype.R_ = function(t2) {
      return this.T_({
        path: void 0,
        o_: true
      });
    }, t.prototype.i_ = function(t2) {
      return ta2(t2, this.settings.methodName, this.settings.g_ || false, this.path, this.settings.r_);
    }, /** Returns 'true' if 'fieldPath' was traversed when creating this context. */
    t.prototype.contains = function(t2) {
      return void 0 !== this.We.find(function(e) {
        return t2.T(e);
      }) || void 0 !== this.fieldTransforms.find(function(e) {
        return t2.T(e.field);
      });
    }, t.prototype.m_ = function() {
      if (this.path)
        for (var t2 = 0; t2 < this.path.length; t2++)
          this.I_(this.path.get(t2));
    }, t.prototype.I_ = function(t2) {
      if (0 === t2.length)
        throw this.i_("Document fields must not be empty");
      if (ju(this.s_) && Cu.test(t2))
        throw this.i_('Document fields cannot begin and end with "__"');
    }, t;
  }()
);
var zu = (
  /** @class */
  function() {
    function t(t2, e, n2) {
      this.U = t2, this.ignoreUndefinedProperties = e, this.serializer = n2 || wu(t2);
    }
    return t.prototype.P_ = function(t2, e, n2, r2) {
      return void 0 === r2 && (r2 = false), new Gu({
        s_: t2,
        methodName: e,
        r_: n2,
        path: C2.P(),
        o_: false,
        g_: r2
      }, this.U, this.serializer, this.ignoreUndefinedProperties);
    }, t;
  }()
);
function Bu(t, e, n2, r2, i2, o) {
  void 0 === o && (o = {});
  var s = t.P_(o.merge || o.mergeFields ? 2 : 0, e, n2, i2);
  Xu("Data must be an object, but it was:", s, r2);
  var u4, a, c = Yu(r2, s);
  if (o.merge)
    u4 = new bn(s.We), a = s.fieldTransforms;
  else if (o.mergeFields) {
    for (var h = [], f = 0, l = o.mergeFields; f < l.length; f++) {
      var p2 = l[f], d = void 0;
      if (p2 instanceof Nu)
        d = p2.t_;
      else {
        if ("string" != typeof p2)
          throw D2();
        d = Zu(e, p2, n2);
      }
      if (!s.contains(d))
        throw new I2(b.INVALID_ARGUMENT, "Field '" + d + "' is specified in your field mask but missing from your input data.");
      ea2(h, d) || h.push(d);
    }
    u4 = new bn(h), a = s.fieldTransforms.filter(function(t2) {
      return u4.Ye(t2.field);
    });
  } else
    u4 = null, a = s.fieldTransforms;
  return new Mu(new Mn(c), u4, a);
}
function Ku(t, e, n2, r2) {
  var i2 = t.P_(1, e, n2);
  Xu("Data must be an object, but it was:", i2, r2);
  var o = [], s = new qn();
  R2(r2, function(t2, r3) {
    var u5 = Zu(e, t2, n2), a = i2.A_(u5);
    if (r3 instanceof ku || r3 instanceof Uu && r3.l_ instanceof ku)
      o.push(u5);
    else {
      var c = Hu(r3, a);
      null != c && (o.push(u5), s.set(u5, c));
    }
  });
  var u4 = new bn(o);
  return new qu(s.Xe(), u4, i2.fieldTransforms);
}
function Wu(t, e, n2, r2, i2, o) {
  var s = t.P_(1, e, n2), u4 = [Ju(e, r2, n2)], a = [i2];
  if (o.length % 2 != 0)
    throw new I2(b.INVALID_ARGUMENT, "Function " + e + "() needs to be called with an even number of arguments that alternate between field names and values.");
  for (var c = 0; c < o.length; c += 2)
    u4.push(Ju(e, o[c])), a.push(o[c + 1]);
  for (var h = [], f = new qn(), l = u4.length - 1; l >= 0; --l)
    if (!ea2(h, u4[l])) {
      var p2 = u4[l], d = a[l], v2 = s.A_(p2);
      if (d instanceof ku || d instanceof Uu && d.l_ instanceof ku)
        h.push(p2);
      else {
        var y2 = Hu(d, v2);
        null != y2 && (h.push(p2), f.set(p2, y2));
      }
    }
  var m = new bn(h);
  return new qu(f.Xe(), m, s.fieldTransforms);
}
function Qu(t, e, n2, r2) {
  return void 0 === r2 && (r2 = false), Hu(n2, t.P_(r2 ? 4 : 3, e));
}
function Hu(t, e) {
  if (
    // Unwrap the API type from the Compat SDK. This will return the API type
    // from firestore-exp.
    t instanceof Uu && (t = t.l_), $u(t)
  )
    return Xu("Unsupported field value:", e, t), Yu(t, e);
  if (t instanceof Du)
    return function(t2, e2) {
      if (!ju(e2.s_))
        throw e2.i_(t2.e_ + "() can only be used with update() and set()");
      if (!e2.path)
        throw e2.i_(t2.e_ + "() is not currently supported inside arrays");
      var n2 = t2.n_(e2);
      n2 && e2.fieldTransforms.push(n2);
    }(t, e), null;
  if (
    // If context.path is null we are inside an array and we don't support
    // field mask paths more granular than the top-level array.
    e.path && e.We.push(e.path), t instanceof Array
  ) {
    if (e.settings.o_ && 4 !== e.s_)
      throw e.i_("Nested arrays are not supported");
    return function(t2, e2) {
      for (var n2 = [], r2 = 0, i2 = 0, o = t2; i2 < o.length; i2++) {
        var s = Hu(o[i2], e2.R_(r2));
        null == s && // Just include nulls in the array for fields being replaced with a
        // sentinel.
        (s = {
          nullValue: "NULL_VALUE"
        }), n2.push(s), r2++;
      }
      return {
        arrayValue: {
          values: n2
        }
      };
    }(t, e);
  }
  return function(t2, e2) {
    if (null === t2)
      return {
        nullValue: "NULL_VALUE"
      };
    if ("number" == typeof t2)
      return Le(e2.serializer, t2);
    if ("boolean" == typeof t2)
      return {
        booleanValue: t2
      };
    if ("string" == typeof t2)
      return {
        stringValue: t2
      };
    if (t2 instanceof Date) {
      var n2 = mt.fromDate(t2);
      return {
        timestampValue: Re(e2.serializer, n2)
      };
    }
    if (t2 instanceof mt) {
      var r2 = new mt(t2.seconds, 1e3 * Math.floor(t2.nanoseconds / 1e3));
      return {
        timestampValue: Re(e2.serializer, r2)
      };
    }
    if (t2 instanceof Vu)
      return {
        geoPointValue: {
          latitude: t2.latitude,
          longitude: t2.longitude
        }
      };
    if (t2 instanceof ht)
      return {
        bytesValue: Oe(e2.serializer, t2.q)
      };
    if (t2 instanceof Fu) {
      var i2 = e2.U, o = t2.__;
      if (!o.isEqual(i2))
        throw e2.i_("Document reference is for database " + o.projectId + "/" + o.database + " but should be for database " + i2.projectId + "/" + i2.database);
      return {
        referenceValue: Ue(t2.__ || e2.U, t2.f_.path)
      };
    }
    if (void 0 === t2 && e2.ignoreUndefinedProperties)
      return null;
    throw e2.i_("Unsupported field value: " + X2(t2));
  }(t, e);
}
function Yu(t, e) {
  var n2 = {};
  return O2(t) ? (
    // If we encounter an empty object, we explicitly add it to the update
    // mask to ensure that the server creates a map entry.
    e.path && e.path.length > 0 && e.We.push(e.path)
  ) : R2(t, function(t2, r2) {
    var i2 = Hu(r2, e.E_(t2));
    null != i2 && (n2[t2] = i2);
  }), {
    mapValue: {
      fields: n2
    }
  };
}
function $u(t) {
  return !("object" != typeof t || null === t || t instanceof Array || t instanceof Date || t instanceof mt || t instanceof Vu || t instanceof ht || t instanceof Fu || t instanceof Du);
}
function Xu(t, e, n2) {
  if (!$u(n2) || !$2(n2)) {
    var r2 = X2(n2);
    throw "an object" === r2 ? e.i_(t + " a custom object") : e.i_(t + " " + r2);
  }
}
function Ju(t, e, n2) {
  if (e instanceof Nu)
    return e.t_;
  if ("string" == typeof e)
    return Zu(t, e);
  throw ta2(
    "Field path arguments must be of type string or FieldPath.",
    t,
    /* hasConverter= */
    false,
    /* path= */
    void 0,
    n2
  );
}
function Zu(t, e, n2) {
  try {
    return function(t2) {
      if (t2.search(Su) >= 0)
        throw new I2(b.INVALID_ARGUMENT, "Invalid field path (" + t2 + "). Paths must not contain '~', '*', '/', '[', or ']'");
      try {
        return new (Au.bind.apply(Au, __spreadArrays([void 0], t2.split("."))))();
      } catch (e2) {
        throw new I2(b.INVALID_ARGUMENT, "Invalid field path (" + t2 + "). Paths must not be empty, begin with '.', end with '.', or contain '..'");
      }
    }(e).t_;
  } catch (e2) {
    throw ta2(
      (i2 = e2) instanceof Error ? i2.message : i2.toString(),
      t,
      /* hasConverter= */
      false,
      /* path= */
      void 0,
      n2
    );
  }
  var i2;
}
function ta2(t, e, n2, r2, i2) {
  var o = r2 && !r2.m(), s = void 0 !== i2, u4 = "Function " + e + "() called with invalid data";
  n2 && (u4 += " (via `toFirestore()`)");
  var a = "";
  return (o || s) && (a += " (found", o && (a += " in field " + r2), s && (a += " in document " + i2), a += ")"), new I2(b.INVALID_ARGUMENT, (u4 += ". ") + t + a);
}
function ea2(t, e) {
  return t.some(function(t2) {
    return t2.isEqual(e);
  });
}
var na2 = (
  /** @class */
  function() {
    function t(t2) {
      this.Ku = t2, // The version of each document that was read during this transaction.
      this.y_ = /* @__PURE__ */ new Map(), this.mutations = [], this.V_ = false, /**
           * A deferred usage error that occurred previously in this transaction that
           * will cause the transaction to fail once it actually commits.
           */
      this.p_ = null, /**
           * Set of documents that have been written in the transaction.
           *
           * When there's more than one write to the same key in a transaction, any
           * writes after the first are handled differently.
           */
      this.b_ = /* @__PURE__ */ new Set();
    }
    return t.prototype.v_ = function(t2) {
      return __awaiter(this, void 0, void 0, function() {
        var r2, i2 = this;
        return __generator(this, function(o) {
          switch (o.label) {
            case 0:
              if (this.S_(), this.mutations.length > 0)
                throw new I2(b.INVALID_ARGUMENT, "Firestore transactions require all reads to be executed before all writes.");
              return [4, function(t3, r3) {
                return __awaiter(this, void 0, void 0, function() {
                  var e, i3, o2, s, u4, a;
                  return __generator(this, function(n2) {
                    switch (n2.label) {
                      case 0:
                        return e = x2(t3), i3 = Ge(e.serializer) + "/documents", o2 = {
                          documents: r3.map(function(t4) {
                            return Fe(e.serializer, t4);
                          })
                        }, [4, e.ku("BatchGetDocuments", i3, o2)];
                      case 1:
                        return s = n2.sent(), u4 = /* @__PURE__ */ new Map(), s.forEach(function(t4) {
                          var n3 = function(t5, e2) {
                            return "found" in e2 ? function(t6, e3) {
                              k2(!!e3.found), e3.found.name, e3.found.updateTime;
                              var n4 = Me(t6, e3.found.name), r4 = Ve(e3.found.updateTime), i4 = new Mn({
                                mapValue: {
                                  fields: e3.found.fields
                                }
                              });
                              return new zn(n4, r4, i4, {});
                            }(t5, e2) : "missing" in e2 ? function(t6, e3) {
                              k2(!!e3.missing), k2(!!e3.readTime);
                              var n4 = Me(t6, e3.missing), r4 = Ve(e3.readTime);
                              return new Bn(n4, r4);
                            }(t5, e2) : D2();
                          }(e.serializer, t4);
                          u4.set(n3.key.toString(), n3);
                        }), a = [], [2, (r3.forEach(function(t4) {
                          var e2 = u4.get(t4.toString());
                          k2(!!e2), a.push(e2);
                        }), a)];
                    }
                  });
                });
              }(this.Ku, t2)];
            case 1:
              return [2, ((r2 = o.sent()).forEach(function(t3) {
                t3 instanceof Bn || t3 instanceof zn ? i2.D_(t3) : D2();
              }), r2)];
          }
        });
      });
    }, t.prototype.set = function(t2, e) {
      this.write(e.w_(t2, this.Ge(t2))), this.b_.add(t2.toString());
    }, t.prototype.update = function(t2, e) {
      try {
        this.write(e.w_(t2, this.C_(t2)));
      } catch (t3) {
        this.p_ = t3;
      }
      this.b_.add(t2.toString());
    }, t.prototype.delete = function(t2) {
      this.write([new Cn(t2, this.Ge(t2))]), this.b_.add(t2.toString());
    }, t.prototype.commit = function() {
      return __awaiter(this, void 0, void 0, function() {
        var t2, r2 = this;
        return __generator(this, function(i2) {
          switch (i2.label) {
            case 0:
              if (this.S_(), this.p_)
                throw this.p_;
              return t2 = this.y_, // For each mutation, note that the doc was written.
              this.mutations.forEach(function(e) {
                t2.delete(e.key.toString());
              }), // For each document that was read but not written to, we want to perform
              // a `verify` operation.
              t2.forEach(function(t3, e) {
                var n2 = F2.D(e);
                r2.mutations.push(new Fn(n2, r2.Ge(n2)));
              }), [4, function(t3, r3) {
                return __awaiter(this, void 0, void 0, function() {
                  var e, i3, o;
                  return __generator(this, function(n2) {
                    switch (n2.label) {
                      case 0:
                        return e = x2(t3), i3 = Ge(e.serializer) + "/documents", o = {
                          writes: r3.map(function(t4) {
                            return Ke(e.serializer, t4);
                          })
                        }, [4, e.$u("Commit", i3, o)];
                      case 1:
                        return n2.sent(), [
                          2
                          /*return*/
                        ];
                    }
                  });
                });
              }(this.Ku, this.mutations)];
            case 1:
              return i2.sent(), this.V_ = true, [
                2
                /*return*/
              ];
          }
        });
      });
    }, t.prototype.D_ = function(t2) {
      var e;
      if (t2 instanceof zn)
        e = t2.version;
      else {
        if (!(t2 instanceof Bn))
          throw D2();
        e = gt.min();
      }
      var n2 = this.y_.get(t2.key.toString());
      if (n2) {
        if (!e.isEqual(n2))
          throw new I2(b.ABORTED, "Document version changed between two reads.");
      } else
        this.y_.set(t2.key.toString(), e);
    }, /**
     * Returns the version of this document when it was read in this transaction,
     * as a precondition, or no precondition if it was not read.
     */
    t.prototype.Ge = function(t2) {
      var e = this.y_.get(t2.toString());
      return !this.b_.has(t2.toString()) && e ? _n.updateTime(e) : _n.ze();
    }, /**
     * Returns the precondition for a document if the operation is an update.
     */
    t.prototype.C_ = function(t2) {
      var e = this.y_.get(t2.toString());
      if (!this.b_.has(t2.toString()) && e) {
        if (e.isEqual(gt.min()))
          throw new I2(b.INVALID_ARGUMENT, "Can't update a document that doesn't exist.");
        return _n.updateTime(e);
      }
      return _n.exists(true);
    }, t.prototype.write = function(t2) {
      this.S_(), this.mutations = this.mutations.concat(t2);
    }, t.prototype.S_ = function() {
    }, t;
  }()
);
var ra2 = (
  /** @class */
  function() {
    function t(t2, e, n2, r2) {
      this.cs = t2, this.Ku = e, this.updateFunction = n2, this.ls = r2, this.N_ = 5, this.ys = new Sr(
        this.cs,
        "transaction_retry"
        /* TransactionRetry */
      );
    }
    return t.prototype.run = function() {
      this.F_();
    }, t.prototype.F_ = function() {
      var t2 = this;
      this.ys.gn(function() {
        return __awaiter(t2, void 0, void 0, function() {
          var t3, e, r2 = this;
          return __generator(this, function(n2) {
            return t3 = new na2(this.Ku), (e = this.x_(t3)) && e.then(function(e2) {
              r2.cs.ws(function() {
                return t3.commit().then(function() {
                  r2.ls.resolve(e2);
                }).catch(function(t4) {
                  r2.k_(t4);
                });
              });
            }).catch(function(t4) {
              r2.k_(t4);
            }), [
              2
              /*return*/
            ];
          });
        });
      });
    }, t.prototype.x_ = function(t2) {
      try {
        var e = this.updateFunction(t2);
        return !wt(e) && e.catch && e.then ? e : (this.ls.reject(Error("Transaction callback must return a Promise")), null);
      } catch (t3) {
        return this.ls.reject(t3), null;
      }
    }, t.prototype.k_ = function(t2) {
      var e = this;
      this.N_ > 0 && this.M_(t2) ? (this.N_ -= 1, this.cs.ws(function() {
        return e.F_(), Promise.resolve();
      })) : this.ls.reject(t2);
    }, t.prototype.M_ = function(t2) {
      if ("FirebaseError" === t2.name) {
        var e = t2.code;
        return "aborted" === e || "failed-precondition" === e || !Lt(e);
      }
      return false;
    }, t;
  }()
);
var ia = (
  /** @class */
  function() {
    function t(t2, e) {
      this.credentials = t2, this.cs = e, this.clientId = ot.k(), // We defer our initialization until we get the current user from
      // setChangeListener(). We block the async queue until we got the initial
      // user and the initialization is completed. This will prevent any scheduled
      // work from happening before initialization is completed.
      // If initializationDone resolved then the FirestoreClient is in a usable
      // state.
      this.O_ = new Ar();
    }
    return t.prototype.start = function(t2, r2, i2, o) {
      var s = this;
      this.L_(), this.bl = t2;
      var u4 = new Ar(), a = false;
      return this.credentials.Hc(function(t3) {
        if (!a)
          return a = true, T2("FirestoreClient", "Initializing. user=", t3.uid), s.B_(r2, i2, o, t3, u4).then(s.O_.resolve, s.O_.reject);
        s.cs.Cs(function() {
          return function(t4, r3) {
            return __awaiter(this, void 0, void 0, function() {
              var e, i3;
              return __generator(this, function(n2) {
                switch (n2.label) {
                  case 0:
                    return (e = x2(t4)).cs.xs(), T2("RemoteStore", "RemoteStore received new credentials"), i3 = cs(e), // Tear down and re-create our network streams. This will ensure we get a
                    // fresh auth token for the new user and re-fill the write pipeline with
                    // new mutations from the LocalStore (since mutations are per-user).
                    e.Yu.add(
                      3
                      /* CredentialChange */
                    ), [4, es(e)];
                  case 1:
                    return n2.sent(), i3 && // Don't set the network status to Unknown if we are offline.
                    e.th.set(
                      "Unknown"
                      /* Unknown */
                    ), [4, e.Gu.Jl(r3)];
                  case 2:
                    return n2.sent(), e.Yu.delete(
                      3
                      /* CredentialChange */
                    ), [4, ts(e)];
                  case 3:
                    return n2.sent(), [
                      2
                      /*return*/
                    ];
                }
              });
            });
          }(s.ph, t3);
        });
      }), // Block the async queue until initialization is done
      this.cs.ws(function() {
        return s.O_.promise;
      }), u4.promise;
    }, /** Enables the network connection and requeues all pending operations. */
    t.prototype.enableNetwork = function() {
      var t2 = this;
      return this.L_(), this.cs.enqueue(function() {
        return t2.persistence.tc(true), function(t3) {
          var e = x2(t3);
          return e.Yu.delete(
            0
            /* UserDisabled */
          ), ts(e);
        }(t2.ph);
      });
    }, /**
     * Initializes persistent storage, attempting to use IndexedDB if
     * usePersistence is true or memory-only if false.
     *
     * If IndexedDB fails because it's already open in another tab or because the
     * platform can't possibly support our implementation then this method rejects
     * the persistenceResult and falls back on memory-only persistence.
     *
     * @param offlineComponentProvider Provider that returns all components
     * required for memory-only or IndexedDB persistence.
     * @param onlineComponentProvider Provider that returns all components
     * required for online support.
     * @param persistenceSettings Settings object to configure offline persistence
     * @param user The initial user
     * @param persistenceResult A deferred result indicating the user-visible
     *     result of enabling offline persistence. This method will reject this if
     *     IndexedDB fails to start for any reason. If usePersistence is false
     *     this is unconditionally resolved.
     * @returns a Promise indicating whether or not initialization should
     *     continue, i.e. that one of the persistence implementations actually
     *     succeeded.
     */
    t.prototype.B_ = function(t2, r2, i2, o, s) {
      return __awaiter(this, void 0, void 0, function() {
        var u4, a, c = this;
        return __generator(this, function(h) {
          switch (h.label) {
            case 0:
              return h.trys.push([0, 3, , 4]), u4 = {
                cs: this.cs,
                bl: this.bl,
                clientId: this.clientId,
                credentials: this.credentials,
                Wl: o,
                Dh: 100,
                persistenceSettings: i2
              }, [4, t2.initialize(u4)];
            case 1:
              return h.sent(), [4, r2.initialize(t2, u4)];
            case 2:
              return h.sent(), this.persistence = t2.persistence, this.Sh = t2.Sh, this.ju = t2.ju, this.ql = t2.ql, this.Ku = r2.Ku, this.ph = r2.ph, this.fi = r2.fi, this.q_ = r2.bh, this.q_.Us = Rs.bind(null, this.fi), this.q_.js = Ps.bind(null, this.fi), // When a user calls clearPersistence() in one client, all other clients
              // need to be terminated to allow the delete to succeed.
              this.persistence.Za(function() {
                return __awaiter(c, void 0, void 0, function() {
                  return __generator(this, function(t3) {
                    switch (t3.label) {
                      case 0:
                        return [4, this.terminate()];
                      case 1:
                        return t3.sent(), [
                          2
                          /*return*/
                        ];
                    }
                  });
                });
              }), s.resolve(), [3, 4];
            case 3:
              if (a = h.sent(), // Regardless of whether or not the retry succeeds, from an user
              // perspective, offline persistence has failed.
              s.reject(a), !this.U_(a))
                throw a;
              return [2, (console.warn("Error enabling offline persistence. Falling back to persistence disabled: " + a), this.B_(new Iu(), new _u(), {
                jl: false
              }, o, s))];
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, /**
     * Decides whether the provided error allows us to gracefully disable
     * persistence (as opposed to crashing the client).
     */
    t.prototype.U_ = function(t2) {
      return "FirebaseError" === t2.name ? t2.code === b.FAILED_PRECONDITION || t2.code === b.UNIMPLEMENTED : !("undefined" != typeof DOMException && t2 instanceof DOMException) || // When the browser is out of quota we could get either quota exceeded
      // or an aborted error depending on whether the error happened during
      // schema migration.
      22 === t2.code || 20 === t2.code || // Firefox Private Browsing mode disables IndexedDb and returns
      // INVALID_STATE for any usage.
      11 === t2.code;
    }, /**
     * Checks that the client has not been terminated. Ensures that other methods on
     * this class cannot be called after the client is terminated.
     */
    t.prototype.L_ = function() {
      if (this.cs.ps)
        throw new I2(b.FAILED_PRECONDITION, "The client has already been terminated.");
    }, /** Disables the network connection. Pending operations will not complete. */
    t.prototype.disableNetwork = function() {
      var t2 = this;
      return this.L_(), this.cs.enqueue(function() {
        return t2.persistence.tc(false), function(t3) {
          return __awaiter(this, void 0, void 0, function() {
            var e;
            return __generator(this, function(n2) {
              switch (n2.label) {
                case 0:
                  return (e = x2(t3)).Yu.add(
                    0
                    /* UserDisabled */
                  ), [4, es(e)];
                case 1:
                  return n2.sent(), // Set the OnlineState to Offline so get()s return from cache, etc.
                  e.th.set(
                    "Offline"
                    /* Offline */
                  ), [
                    2
                    /*return*/
                  ];
              }
            });
          });
        }(t2.ph);
      });
    }, t.prototype.terminate = function() {
      var t2 = this;
      this.cs.Ds();
      var r2 = new Ar();
      return this.cs.bs(function() {
        return __awaiter(t2, void 0, void 0, function() {
          var t3, e;
          return __generator(this, function(n2) {
            switch (n2.label) {
              case 0:
                return n2.trys.push([0, 4, , 5]), // PORTING NOTE: LocalStore does not need an explicit shutdown on web.
                this.ql && this.ql.stop(), [4, ns(this.ph)];
              case 1:
                return n2.sent(), [4, this.Sh.Di()];
              case 2:
                return n2.sent(), [4, this.persistence.Di()];
              case 3:
                return n2.sent(), // `removeChangeListener` must be called after shutting down the
                // RemoteStore as it will prevent the RemoteStore from retrieving
                // auth tokens.
                this.credentials.Yc(), r2.resolve(), [3, 5];
              case 4:
                return t3 = n2.sent(), e = Gr(t3, "Failed to shutdown persistence"), r2.reject(e), [3, 5];
              case 5:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }), r2.promise;
    }, /**
     * Returns a Promise that resolves when all writes that were pending at the time this
     * method was called received server acknowledgement. An acknowledgement can be either acceptance
     * or rejection.
     */
    t.prototype.waitForPendingWrites = function() {
      var t2 = this;
      this.L_();
      var r2 = new Ar();
      return this.cs.ws(function() {
        return function(t3, r3) {
          return __awaiter(this, void 0, void 0, function() {
            var e, i2, o, s, u4;
            return __generator(this, function(n2) {
              switch (n2.label) {
                case 0:
                  cs((e = x2(t3)).ph) || T2("SyncEngine", "The network is disabled. The task returned by 'awaitPendingWrites()' will not complete until the network is enabled."), n2.label = 1;
                case 1:
                  return n2.trys.push([1, 3, , 4]), [4, function(t4) {
                    var e2 = x2(t4);
                    return e2.persistence.runTransaction("Get highest unacknowledged batch id", "readonly", function(t5) {
                      return e2.Sr.qo(t5);
                    });
                  }(e.ju)];
                case 2:
                  return -1 === (i2 = n2.sent()) ? [2, void r3.resolve()] : ((o = e.Lh.get(i2) || []).push(r3), e.Lh.set(i2, o), [3, 4]);
                case 3:
                  return s = n2.sent(), u4 = Gr(s, "Initialization of waitForPendingWrites() operation failed"), r3.reject(u4), [3, 4];
                case 4:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        }(t2.fi, r2);
      }), r2.promise;
    }, t.prototype.listen = function(t2, e, n2) {
      var r2 = this;
      this.L_();
      var i2 = new Tu(n2), o = new $r(t2, i2, e);
      return this.cs.ws(function() {
        return Kr(r2.q_, o);
      }), function() {
        i2.Zl(), r2.cs.ws(function() {
          return Wr(r2.q_, o);
        });
      };
    }, t.prototype.Q_ = function(t2) {
      return __awaiter(this, void 0, void 0, function() {
        var r2, i2 = this;
        return __generator(this, function(o) {
          switch (o.label) {
            case 0:
              return this.L_(), [4, this.O_.promise];
            case 1:
              return o.sent(), r2 = new Ar(), [2, (this.cs.ws(function() {
                return function(t3, r3, i3) {
                  return __awaiter(this, void 0, void 0, function() {
                    var e, o2, s;
                    return __generator(this, function(n2) {
                      switch (n2.label) {
                        case 0:
                          return n2.trys.push([0, 2, , 3]), [4, function(t4, e2) {
                            var n3 = x2(t4);
                            return n3.persistence.runTransaction("read document", "readonly", function(t5) {
                              return n3.Cc.Cr(t5, e2);
                            });
                          }(t3, r3)];
                        case 1:
                          return (e = n2.sent()) instanceof zn ? i3.resolve(e) : e instanceof Bn ? i3.resolve(null) : i3.reject(new I2(b.UNAVAILABLE, "Failed to get document from cache. (However, this document may exist on the server. Run again without setting 'source' in the GetOptions to attempt to retrieve the document from the server.)")), [3, 3];
                        case 2:
                          return o2 = n2.sent(), s = Gr(o2, "Failed to get document '" + r3 + " from cache"), i3.reject(s), [3, 3];
                        case 3:
                          return [
                            2
                            /*return*/
                          ];
                      }
                    });
                  });
                }(i2.ju, t2, r2);
              }), r2.promise)];
          }
        });
      });
    }, t.prototype.W_ = function(t2, r2) {
      return void 0 === r2 && (r2 = {}), __awaiter(this, void 0, void 0, function() {
        var e, i2 = this;
        return __generator(this, function(n2) {
          switch (n2.label) {
            case 0:
              return this.L_(), [4, this.O_.promise];
            case 1:
              return n2.sent(), e = new Ar(), [2, (this.cs.ws(function() {
                return function(t3, e2, n3, r3, i3) {
                  var o = new Tu({
                    next: function(o2) {
                      e2.ws(function() {
                        return Wr(t3, s);
                      });
                      var u4 = o2.docs.has(n3);
                      !u4 && o2.fromCache ? (
                        // TODO(dimond): If we're online and the document doesn't
                        // exist then we resolve with a doc.exists set to false. If
                        // we're offline however, we reject the Promise in this
                        // case. Two options: 1) Cache the negative response from
                        // the server so we can deliver that even when you're
                        // offline 2) Actually reject the Promise in the online case
                        // if the document doesn't exist.
                        i3.reject(new I2(b.UNAVAILABLE, "Failed to get document because the client is offline."))
                      ) : u4 && o2.fromCache && r3 && "server" === r3.source ? i3.reject(new I2(b.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)')) : i3.resolve(o2);
                    },
                    error: function(t4) {
                      return i3.reject(t4);
                    }
                  }), s = new $r(Hn(n3.path), o, {
                    includeMetadataChanges: true,
                    Xs: true
                  });
                  return Kr(t3, s);
                }(i2.q_, i2.cs, t2, r2, e);
              }), e.promise)];
          }
        });
      });
    }, t.prototype.j_ = function(t2) {
      return __awaiter(this, void 0, void 0, function() {
        var r2, i2 = this;
        return __generator(this, function(o) {
          switch (o.label) {
            case 0:
              return this.L_(), [4, this.O_.promise];
            case 1:
              return o.sent(), r2 = new Ar(), [2, (this.cs.ws(function() {
                return function(t3, r3, i3) {
                  return __awaiter(this, void 0, void 0, function() {
                    var e, o2, s, u4, a, c;
                    return __generator(this, function(n2) {
                      switch (n2.label) {
                        case 0:
                          return n2.trys.push([0, 2, , 3]), [4, Uo(
                            t3,
                            r3,
                            /* usePreviousResults= */
                            true
                          )];
                        case 1:
                          return e = n2.sent(), o2 = new Ds(r3, e.Fc), s = o2.wh(e.documents), u4 = o2.yr(
                            s,
                            /* updateLimboDocuments= */
                            false
                          ), i3.resolve(u4.snapshot), [3, 3];
                        case 2:
                          return a = n2.sent(), c = Gr(a, "Failed to execute query '" + r3 + " against cache"), i3.reject(c), [3, 3];
                        case 3:
                          return [
                            2
                            /*return*/
                          ];
                      }
                    });
                  });
                }(i2.ju, t2, r2);
              }), r2.promise)];
          }
        });
      });
    }, t.prototype.K_ = function(t2, r2) {
      return void 0 === r2 && (r2 = {}), __awaiter(this, void 0, void 0, function() {
        var e, i2 = this;
        return __generator(this, function(n2) {
          switch (n2.label) {
            case 0:
              return this.L_(), [4, this.O_.promise];
            case 1:
              return n2.sent(), e = new Ar(), [2, (this.cs.ws(function() {
                return function(t3, e2, n3, r3, i3) {
                  var o = new Tu({
                    next: function(n4) {
                      e2.ws(function() {
                        return Wr(t3, s);
                      }), n4.fromCache && "server" === r3.source ? i3.reject(new I2(b.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)')) : i3.resolve(n4);
                    },
                    error: function(t4) {
                      return i3.reject(t4);
                    }
                  }), s = new $r(n3, o, {
                    includeMetadataChanges: true,
                    Xs: true
                  });
                  return Kr(t3, s);
                }(i2.q_, i2.cs, t2, r2, e);
              }), e.promise)];
          }
        });
      });
    }, t.prototype.write = function(t2) {
      var r2 = this;
      this.L_();
      var i2 = new Ar();
      return this.cs.ws(function() {
        return function(t3, r3, i3) {
          return __awaiter(this, void 0, void 0, function() {
            var e, o, s, u4;
            return __generator(this, function(n2) {
              switch (n2.label) {
                case 0:
                  e = ou(t3), n2.label = 1;
                case 1:
                  return n2.trys.push([1, 5, , 6]), [
                    4,
                    /* Accepts locally generated Mutations and commit them to storage. */
                    function(t4, e2) {
                      var n3, r4 = x2(t4), i4 = mt.now(), o2 = e2.reduce(function(t5, e3) {
                        return t5.add(e3.key);
                      }, Kt());
                      return r4.persistence.runTransaction("Locally write mutations", "readwrite", function(t5) {
                        return r4.Cc.kr(t5, o2).next(function(o3) {
                          n3 = o3;
                          for (var s2 = [], u5 = 0, a = e2; u5 < a.length; u5++) {
                            var c = a[u5], h = Dn(c, n3.get(c.key));
                            null != h && // NOTE: The base state should only be applied if there's some
                            // existing document to override, so use a Precondition of
                            // exists=true
                            s2.push(new Rn(c.key, h, jn(h.proto.mapValue), _n.exists(true)));
                          }
                          return r4.Sr.ko(t5, i4, s2, e2);
                        });
                      }).then(function(t5) {
                        var e3 = t5.lr(n3);
                        return {
                          batchId: t5.batchId,
                          wr: e3
                        };
                      });
                    }(e.ju, r3)
                  ];
                case 2:
                  return o = n2.sent(), e.Sh.xi(o.batchId), function(t4, e2, n3) {
                    var r4 = t4.Oh[t4.currentUser.ti()];
                    r4 || (r4 = new Ot(st)), r4 = r4.ot(e2, n3), t4.Oh[t4.currentUser.ti()] = r4;
                  }(e, o.batchId, i3), [4, Qs(e, o.wr)];
                case 3:
                  return n2.sent(), [4, ys(e.ph)];
                case 4:
                  return n2.sent(), [3, 6];
                case 5:
                  return s = n2.sent(), u4 = Gr(s, "Failed to persist write"), i3.reject(u4), [3, 6];
                case 6:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        }(r2.fi, t2, i2);
      }), i2.promise;
    }, t.prototype.U = function() {
      return this.bl.U;
    }, t.prototype.G_ = function(t2) {
      var r2 = this;
      this.L_();
      var i2 = new Tu(t2);
      return this.cs.ws(function() {
        return __awaiter(r2, void 0, void 0, function() {
          return __generator(this, function(t3) {
            return [2, function(t4, e) {
              x2(t4).qs.add(e), // Immediately fire an initial event, indicating all existing listeners
              // are in-sync.
              e.next();
            }(this.q_, i2)];
          });
        });
      }), function() {
        i2.Zl(), r2.cs.ws(function() {
          return __awaiter(r2, void 0, void 0, function() {
            return __generator(this, function(t3) {
              return [2, function(t4, e) {
                x2(t4).qs.delete(e);
              }(this.q_, i2)];
            });
          });
        });
      };
    }, Object.defineProperty(t.prototype, "z_", {
      get: function() {
        return this.cs.ps;
      },
      enumerable: false,
      configurable: true
    }), /**
     * Takes an updateFunction in which a set of reads and writes can be performed
     * atomically. In the updateFunction, the client can read and write values
     * using the supplied transaction object. After the updateFunction, all
     * changes will be committed. If a retryable error occurs (ex: some other
     * client has changed any of the data referenced), then the updateFunction
     * will be called again after a backoff. If the updateFunction still fails
     * after all retries, then the transaction will be rejected.
     *
     * The transaction object passed to the updateFunction contains methods for
     * accessing documents and collections. Unlike other datastore access, data
     * accessed with the transaction will not reflect local changes that have not
     * been committed. For this reason, it is required that all reads are
     * performed before any writes. Transactions must be performed while online.
     */
    t.prototype.transaction = function(t2) {
      var e = this;
      this.L_();
      var n2 = new Ar();
      return this.cs.ws(function() {
        return new ra2(e.cs, e.Ku, t2, n2).run(), Promise.resolve();
      }), n2.promise;
    }, t;
  }()
);
function oa2(t) {
  return function(t2, e) {
    if ("object" != typeof t2 || null === t2)
      return false;
    for (var n2 = t2, r2 = 0, i2 = ["next", "error", "complete"]; r2 < i2.length; r2++) {
      var o = i2[r2];
      if (o in n2 && "function" == typeof n2[o])
        return true;
    }
    return false;
  }(t);
}
var sa2 = (
  /** @class */
  function() {
    function t(t2, e, n2, r2, i2) {
      this.U = t2, this.timestampsInSnapshots = e, this.H_ = n2, this.Y_ = r2, this.J_ = i2;
    }
    return t.prototype.X_ = function(t2) {
      switch (he(t2)) {
        case 0:
          return null;
        case 1:
          return t2.booleanValue;
        case 2:
          return ge(t2.integerValue || t2.doubleValue);
        case 3:
          return this.Z_(t2.timestampValue);
        case 4:
          return this.tf(t2);
        case 5:
          return t2.stringValue;
        case 6:
          return this.J_(we(t2.bytesValue));
        case 7:
          return this.ef(t2.referenceValue);
        case 8:
          return this.nf(t2.geoPointValue);
        case 9:
          return this.sf(t2.arrayValue);
        case 10:
          return this.if(t2.mapValue);
        default:
          throw D2();
      }
    }, t.prototype.if = function(t2) {
      var e = this, n2 = {};
      return R2(t2.fields || {}, function(t3, r2) {
        n2[t3] = e.X_(r2);
      }), n2;
    }, t.prototype.nf = function(t2) {
      return new Vu(ge(t2.latitude), ge(t2.longitude));
    }, t.prototype.sf = function(t2) {
      var e = this;
      return (t2.values || []).map(function(t3) {
        return e.X_(t3);
      });
    }, t.prototype.tf = function(t2) {
      switch (this.H_) {
        case "previous":
          var e = ue(t2);
          return null == e ? null : this.X_(e);
        case "estimate":
          return this.Z_(ae(t2));
        default:
          return null;
      }
    }, t.prototype.Z_ = function(t2) {
      var e = me(t2), n2 = new mt(e.seconds, e.nanos);
      return this.timestampsInSnapshots ? n2 : n2.toDate();
    }, t.prototype.ef = function(t2) {
      var e = V2.g(t2);
      k2(un(e));
      var n2 = new vt(e.get(1), e.get(3)), r2 = new F2(e.u(5));
      return n2.isEqual(this.U) || // TODO(b/64130202): Somehow support foreign references.
      N2("Document " + r2 + " contains a document reference within a different database (" + n2.projectId + "/" + n2.database + ") which is not supported. It will be treated as a reference in the current database (" + this.U.projectId + "/" + this.U.database + ") instead."), this.Y_(r2);
    }, t;
  }()
);
var ua2 = wi.ho;
var aa2 = (
  /** @class */
  function() {
    function t(t2) {
      var e, n2, r2, i2, o;
      if (void 0 === t2.host) {
        if (void 0 !== t2.ssl)
          throw new I2(b.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
        this.host = "firestore.googleapis.com", this.ssl = true;
      } else
        K2("settings", "non-empty string", "host", t2.host), this.host = t2.host, W2("settings", "boolean", "ssl", t2.ssl), this.ssl = null === (e = t2.ssl) || void 0 === e || e;
      if (Z2("settings", t2, ["host", "ssl", "credentials", "timestampsInSnapshots", "cacheSizeBytes", "experimentalForceLongPolling", "experimentalAutoDetectLongPolling", "ignoreUndefinedProperties"]), W2("settings", "object", "credentials", t2.credentials), this.credentials = t2.credentials, W2("settings", "boolean", "timestampsInSnapshots", t2.timestampsInSnapshots), W2("settings", "boolean", "ignoreUndefinedProperties", t2.ignoreUndefinedProperties), // Nobody should set timestampsInSnapshots anymore, but the error depends on
      // whether they set it to true or false...
      true === t2.timestampsInSnapshots ? N2("The setting 'timestampsInSnapshots: true' is no longer required and should be removed.") : false === t2.timestampsInSnapshots && N2("Support for 'timestampsInSnapshots: false' will be removed soon. You must update your code to handle Timestamp objects."), this.timestampsInSnapshots = null === (n2 = t2.timestampsInSnapshots) || void 0 === n2 || n2, this.ignoreUndefinedProperties = null !== (r2 = t2.ignoreUndefinedProperties) && void 0 !== r2 && r2, W2("settings", "number", "cacheSizeBytes", t2.cacheSizeBytes), void 0 === t2.cacheSizeBytes)
        this.cacheSizeBytes = wi._o;
      else {
        if (t2.cacheSizeBytes !== ua2 && t2.cacheSizeBytes < wi.lo)
          throw new I2(b.INVALID_ARGUMENT, "cacheSizeBytes must be at least " + wi.lo);
        this.cacheSizeBytes = t2.cacheSizeBytes;
      }
      W2("settings", "boolean", "experimentalForceLongPolling", t2.experimentalForceLongPolling), this.experimentalForceLongPolling = null !== (i2 = t2.experimentalForceLongPolling) && void 0 !== i2 && i2, W2("settings", "boolean", "experimentalAutoDetectLongPolling", t2.experimentalAutoDetectLongPolling), this.experimentalAutoDetectLongPolling = null !== (o = t2.experimentalAutoDetectLongPolling) && void 0 !== o && o, function(t3, e2, n3, r3) {
        if (true === e2 && true === r3)
          throw new I2(b.INVALID_ARGUMENT, "experimentalForceLongPolling and experimentalAutoDetectLongPolling cannot be used together.");
      }(0, t2.experimentalForceLongPolling, 0, t2.experimentalAutoDetectLongPolling);
    }
    return t.prototype.isEqual = function(t2) {
      return this.host === t2.host && this.ssl === t2.ssl && this.timestampsInSnapshots === t2.timestampsInSnapshots && this.credentials === t2.credentials && this.cacheSizeBytes === t2.cacheSizeBytes && this.experimentalForceLongPolling === t2.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === t2.experimentalAutoDetectLongPolling && this.ignoreUndefinedProperties === t2.ignoreUndefinedProperties;
    }, t;
  }()
);
var ca2 = (
  /** @class */
  function() {
    function t(r2, i2, o, s) {
      var u4 = this;
      if (void 0 === o && (o = new Iu()), void 0 === s && (s = new _u()), this.rf = o, this.af = s, this.cf = null, // Public for use in tests.
      // TODO(mikelehen): Use modularized initialization instead.
      this.uf = new jr(), this.INTERNAL = {
        delete: function() {
          return __awaiter(u4, void 0, void 0, function() {
            return __generator(this, function(t2) {
              switch (t2.label) {
                case 0:
                  return this.hf(), [4, this.lf.terminate()];
                case 1:
                  return t2.sent(), [
                    2
                    /*return*/
                  ];
              }
            });
          });
        }
      }, "object" == typeof r2.options) {
        var a = r2;
        this.cf = a, this.__ = t._f(a), this.ff = a.name, this.df = new Ko(i2);
      } else {
        var c = r2;
        if (!c.projectId)
          throw new I2(b.INVALID_ARGUMENT, "Must provide projectId");
        this.__ = new vt(c.projectId, c.database), // Use a default persistenceKey that lines up with FirebaseApp.
        this.ff = "[DEFAULT]", this.df = new Bo();
      }
      this.wf = new aa2({});
    }
    return Object.defineProperty(t.prototype, "mf", {
      get: function() {
        return this.Tf || // Lazy initialize UserDataReader once the settings are frozen
        (this.Tf = new zu(this.__, this.wf.ignoreUndefinedProperties)), this.Tf;
      },
      enumerable: false,
      configurable: true
    }), t.prototype.settings = function(t2) {
      q2("Firestore.settings", arguments, 1), z("Firestore.settings", "object", 1, t2), t2.merge && // Remove the property from the settings once the merge is completed
      delete (t2 = Object.assign(Object.assign({}, this.wf), t2)).merge;
      var e = new aa2(t2);
      if (this.lf && !this.wf.isEqual(e))
        throw new I2(b.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only call settings() before calling any other methods on a Firestore object.");
      this.wf = e, void 0 !== e.credentials && (this.df = function(t3) {
        if (!t3)
          return new Bo();
        switch (t3.type) {
          case "gapi":
            var e2 = t3.client;
            return k2(!("object" != typeof e2 || null === e2 || !e2.auth || !e2.auth.getAuthHeaderValueForFirstParty)), new Qo(e2, t3.sessionIndex || "0");
          case "provider":
            return t3.client;
          default:
            throw new I2(b.INVALID_ARGUMENT, "makeCredentialsProvider failed due to invalid credential type");
        }
      }(e.credentials));
    }, t.prototype.enableNetwork = function() {
      return this.hf(), this.lf.enableNetwork();
    }, t.prototype.disableNetwork = function() {
      return this.hf(), this.lf.disableNetwork();
    }, t.prototype.enablePersistence = function(t2) {
      var e, n2;
      if (this.lf)
        throw new I2(b.FAILED_PRECONDITION, "Firestore has already been started and persistence can no longer be enabled. You can only call enablePersistence() before calling any other methods on a Firestore object.");
      var r2 = false, i2 = false;
      if (t2 && (void 0 !== t2.experimentalTabSynchronization && N2("The 'experimentalTabSynchronization' setting will be removed. Use 'synchronizeTabs' instead."), r2 = null !== (n2 = null !== (e = t2.synchronizeTabs) && void 0 !== e ? e : t2.experimentalTabSynchronization) && void 0 !== n2 && n2, i2 = !!t2.experimentalForceOwningTab && t2.experimentalForceOwningTab, r2 && i2))
        throw new I2(b.INVALID_ARGUMENT, "The 'experimentalForceOwningTab' setting cannot be used with 'synchronizeTabs'.");
      return this.Ef(this.rf, this.af, {
        jl: true,
        cacheSizeBytes: this.wf.cacheSizeBytes,
        synchronizeTabs: r2,
        ka: i2
      });
    }, t.prototype.clearPersistence = function() {
      return __awaiter(this, void 0, void 0, function() {
        var t2, r2 = this;
        return __generator(this, function(i2) {
          if (void 0 !== this.lf && !this.lf.z_)
            throw new I2(b.FAILED_PRECONDITION, "Persistence can only be cleared before a Firestore instance is initialized or after it is terminated.");
          return t2 = new Ar(), [2, (this.uf.bs(function() {
            return __awaiter(r2, void 0, void 0, function() {
              var e;
              return __generator(this, function(n2) {
                switch (n2.label) {
                  case 0:
                    return n2.trys.push([0, 2, , 3]), [4, this.rf.clearPersistence(this.__, this.ff)];
                  case 1:
                    return n2.sent(), t2.resolve(), [3, 3];
                  case 2:
                    return e = n2.sent(), t2.reject(e), [3, 3];
                  case 3:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          }), t2.promise)];
        });
      });
    }, t.prototype.terminate = function() {
      return this.app._removeServiceInstance("firestore"), this.INTERNAL.delete();
    }, Object.defineProperty(t.prototype, "If", {
      get: function() {
        return this.hf(), this.lf.z_;
      },
      enumerable: false,
      configurable: true
    }), t.prototype.waitForPendingWrites = function() {
      return this.hf(), this.lf.waitForPendingWrites();
    }, t.prototype.onSnapshotsInSync = function(t2) {
      if (this.hf(), oa2(t2))
        return this.lf.G_(t2);
      z("Firestore.onSnapshotsInSync", "function", 1, t2);
      var e = {
        next: t2
      };
      return this.lf.G_(e);
    }, t.prototype.hf = function() {
      return this.lf || // Kick off starting the client but don't actually wait for it.
      // eslint-disable-next-line @typescript-eslint/no-floating-promises
      this.Ef(new Iu(), new _u(), {
        jl: false
      }), this.lf;
    }, t.prototype.Af = function() {
      return new dt(this.__, this.ff, this.wf.host, this.wf.ssl, this.wf.experimentalForceLongPolling, this.wf.experimentalAutoDetectLongPolling);
    }, t.prototype.Ef = function(t2, e, n2) {
      var r2 = this.Af();
      return this.lf = new ia(this.df, this.uf), this.lf.start(r2, t2, e, n2);
    }, t._f = function(t2) {
      if (e = t2.options, "projectId", !Object.prototype.hasOwnProperty.call(e, "projectId"))
        throw new I2(b.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
      var e, n2 = t2.options.projectId;
      if (!n2 || "string" != typeof n2)
        throw new I2(b.INVALID_ARGUMENT, "projectId must be a string in FirebaseApp.options");
      return new vt(n2);
    }, Object.defineProperty(t.prototype, "app", {
      get: function() {
        if (!this.cf)
          throw new I2(b.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
        return this.cf;
      },
      enumerable: false,
      configurable: true
    }), t.prototype.collection = function(t2) {
      return q2("Firestore.collection", arguments, 1), z("Firestore.collection", "non-empty string", 1, t2), this.hf(), new Ta(
        V2.g(t2),
        this,
        /* converter= */
        null
      );
    }, t.prototype.doc = function(t2) {
      return q2("Firestore.doc", arguments, 1), z("Firestore.doc", "non-empty string", 1, t2), this.hf(), la2.Rf(
        V2.g(t2),
        this,
        /* converter= */
        null
      );
    }, t.prototype.collectionGroup = function(t2) {
      if (q2("Firestore.collectionGroup", arguments, 1), z("Firestore.collectionGroup", "non-empty string", 1, t2), t2.indexOf("/") >= 0)
        throw new I2(b.INVALID_ARGUMENT, "Invalid collection ID '" + t2 + "' passed to function Firestore.collectionGroup(). Collection IDs must not contain '/'.");
      return this.hf(), new Ea2(
        /**
        * Creates a new Query for a collection group query that matches all documents
        * within the provided collection group.
        */
        function(t3) {
          return new Wn(V2.P(), t3);
        }(t2),
        this,
        /* converter= */
        null
      );
    }, t.prototype.runTransaction = function(t2) {
      var e = this;
      return q2("Firestore.runTransaction", arguments, 1), z("Firestore.runTransaction", "function", 1, t2), this.hf().transaction(function(n2) {
        return t2(new ha2(e, n2));
      });
    }, t.prototype.batch = function() {
      return this.hf(), new fa2(this);
    }, Object.defineProperty(t, "logLevel", {
      get: function() {
        switch (_()) {
          case LogLevel.DEBUG:
            return "debug";
          case LogLevel.ERROR:
            return "error";
          case LogLevel.SILENT:
            return "silent";
          case LogLevel.WARN:
            return "warn";
          case LogLevel.INFO:
            return "info";
          case LogLevel.VERBOSE:
            return "verbose";
          default:
            return "error";
        }
      },
      enumerable: false,
      configurable: true
    }), t.setLogLevel = function(t2) {
      var e;
      q2("Firestore.setLogLevel", arguments, 1), H2("setLogLevel", ["debug", "error", "silent", "warn", "info", "verbose"], 1, t2), e = t2, E2.setLogLevel(e);
    }, // Note: this is not a property because the minifier can't work correctly with
    // the way TypeScript compiler outputs properties.
    t.prototype.gf = function() {
      return this.wf.timestampsInSnapshots;
    }, // Visible for testing.
    t.prototype.Pf = function() {
      return this.wf;
    }, t;
  }()
);
var ha2 = (
  /** @class */
  function() {
    function t(t2, e) {
      this.yf = t2, this.Vf = e;
    }
    return t.prototype.get = function(t2) {
      var e = this;
      q2("Transaction.get", arguments, 1);
      var n2 = Da2("Transaction.get", t2, this.yf);
      return this.Vf.v_([n2.f_]).then(function(t3) {
        if (!t3 || 1 !== t3.length)
          return D2();
        var r2 = t3[0];
        if (r2 instanceof Bn)
          return new da2(
            e.yf,
            n2.f_,
            null,
            /* fromCache= */
            false,
            /* hasPendingWrites= */
            false,
            n2.d_
          );
        if (r2 instanceof zn)
          return new da2(
            e.yf,
            n2.f_,
            r2,
            /* fromCache= */
            false,
            /* hasPendingWrites= */
            false,
            n2.d_
          );
        throw D2();
      });
    }, t.prototype.set = function(t2, e, n2) {
      G2("Transaction.set", arguments, 2, 3);
      var r2 = Da2("Transaction.set", t2, this.yf);
      n2 = Na2("Transaction.set", n2);
      var i2 = xa2(r2.d_, e, n2), o = Bu(this.yf.mf, "Transaction.set", r2.f_, i2, null !== r2.d_, n2);
      return this.Vf.set(r2.f_, o), this;
    }, t.prototype.update = function(t2, e, n2) {
      for (var r2, i2, o = [], s = 3; s < arguments.length; s++)
        o[s - 3] = arguments[s];
      return "string" == typeof e || e instanceof Au ? (j("Transaction.update", arguments, 3), r2 = Da2("Transaction.update", t2, this.yf), i2 = Wu(this.yf.mf, "Transaction.update", r2.f_, e, n2, o)) : (q2("Transaction.update", arguments, 2), r2 = Da2("Transaction.update", t2, this.yf), i2 = Ku(this.yf.mf, "Transaction.update", r2.f_, e)), this.Vf.update(r2.f_, i2), this;
    }, t.prototype.delete = function(t2) {
      q2("Transaction.delete", arguments, 1);
      var e = Da2("Transaction.delete", t2, this.yf);
      return this.Vf.delete(e.f_), this;
    }, t;
  }()
);
var fa2 = (
  /** @class */
  function() {
    function t(t2) {
      this.yf = t2, this.pf = [], this.bf = false;
    }
    return t.prototype.set = function(t2, e, n2) {
      G2("WriteBatch.set", arguments, 2, 3), this.vf();
      var r2 = Da2("WriteBatch.set", t2, this.yf);
      n2 = Na2("WriteBatch.set", n2);
      var i2 = xa2(r2.d_, e, n2), o = Bu(this.yf.mf, "WriteBatch.set", r2.f_, i2, null !== r2.d_, n2);
      return this.pf = this.pf.concat(o.w_(r2.f_, _n.ze())), this;
    }, t.prototype.update = function(t2, e, n2) {
      for (var r2, i2, o = [], s = 3; s < arguments.length; s++)
        o[s - 3] = arguments[s];
      return this.vf(), "string" == typeof e || e instanceof Au ? (j("WriteBatch.update", arguments, 3), r2 = Da2("WriteBatch.update", t2, this.yf), i2 = Wu(this.yf.mf, "WriteBatch.update", r2.f_, e, n2, o)) : (q2("WriteBatch.update", arguments, 2), r2 = Da2("WriteBatch.update", t2, this.yf), i2 = Ku(this.yf.mf, "WriteBatch.update", r2.f_, e)), this.pf = this.pf.concat(i2.w_(r2.f_, _n.exists(true))), this;
    }, t.prototype.delete = function(t2) {
      q2("WriteBatch.delete", arguments, 1), this.vf();
      var e = Da2("WriteBatch.delete", t2, this.yf);
      return this.pf = this.pf.concat(new Cn(e.f_, _n.ze())), this;
    }, t.prototype.commit = function() {
      return this.vf(), this.bf = true, this.pf.length > 0 ? this.yf.hf().write(this.pf) : Promise.resolve();
    }, t.prototype.vf = function() {
      if (this.bf)
        throw new I2(b.FAILED_PRECONDITION, "A write batch can no longer be used after commit() has been called.");
    }, t;
  }()
);
var la2 = (
  /** @class */
  function(e) {
    function n2(t, n3, r2) {
      var i2 = this;
      return (i2 = e.call(this, n3.__, t, r2) || this).f_ = t, i2.firestore = n3, i2.d_ = r2, i2.lf = i2.firestore.hf(), i2;
    }
    return __extends(n2, e), n2.Rf = function(t, e2, r2) {
      if (t.length % 2 != 0)
        throw new I2(b.INVALID_ARGUMENT, "Invalid document reference. Document references must have an even number of segments, but " + t.R() + " has " + t.length);
      return new n2(new F2(t), e2, r2);
    }, Object.defineProperty(n2.prototype, "id", {
      get: function() {
        return this.f_.path._();
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(n2.prototype, "parent", {
      get: function() {
        return new Ta(this.f_.path.h(), this.firestore, this.d_);
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(n2.prototype, "path", {
      get: function() {
        return this.f_.path.R();
      },
      enumerable: false,
      configurable: true
    }), n2.prototype.collection = function(t) {
      if (q2("DocumentReference.collection", arguments, 1), z("DocumentReference.collection", "non-empty string", 1, t), !t)
        throw new I2(b.INVALID_ARGUMENT, "Must provide a non-empty collection name to collection()");
      var e2 = V2.g(t);
      return new Ta(
        this.f_.path.child(e2),
        this.firestore,
        /* converter= */
        null
      );
    }, n2.prototype.isEqual = function(t) {
      if (!(t instanceof n2))
        throw tt("isEqual", "DocumentReference", 1, t);
      return this.firestore === t.firestore && this.f_.isEqual(t.f_) && this.d_ === t.d_;
    }, n2.prototype.set = function(t, e2) {
      G2("DocumentReference.set", arguments, 1, 2), e2 = Na2("DocumentReference.set", e2);
      var n3 = xa2(this.d_, t, e2), r2 = Bu(this.firestore.mf, "DocumentReference.set", this.f_, n3, null !== this.d_, e2);
      return this.lf.write(r2.w_(this.f_, _n.ze()));
    }, n2.prototype.update = function(t, e2) {
      for (var n3, r2 = [], i2 = 2; i2 < arguments.length; i2++)
        r2[i2 - 2] = arguments[i2];
      return "string" == typeof t || t instanceof Au ? (j("DocumentReference.update", arguments, 2), n3 = Wu(this.firestore.mf, "DocumentReference.update", this.f_, t, e2, r2)) : (q2("DocumentReference.update", arguments, 1), n3 = Ku(this.firestore.mf, "DocumentReference.update", this.f_, t)), this.lf.write(n3.w_(this.f_, _n.exists(true)));
    }, n2.prototype.delete = function() {
      return q2("DocumentReference.delete", arguments, 0), this.lf.write([new Cn(this.f_, _n.ze())]);
    }, n2.prototype.onSnapshot = function() {
      for (var t, e2, n3, r2 = this, i2 = [], o = 0; o < arguments.length; o++)
        i2[o] = arguments[o];
      G2("DocumentReference.onSnapshot", arguments, 1, 4);
      var s = {
        includeMetadataChanges: false
      }, u4 = 0;
      "object" != typeof i2[u4] || oa2(i2[u4]) || (Z2("DocumentReference.onSnapshot", s = i2[u4], ["includeMetadataChanges"]), W2("DocumentReference.onSnapshot", "boolean", "includeMetadataChanges", s.includeMetadataChanges), u4++);
      var a = {
        includeMetadataChanges: s.includeMetadataChanges
      };
      if (oa2(i2[u4])) {
        var c = i2[u4];
        i2[u4] = null === (t = c.next) || void 0 === t ? void 0 : t.bind(c), i2[u4 + 1] = null === (e2 = c.error) || void 0 === e2 ? void 0 : e2.bind(c), i2[u4 + 2] = null === (n3 = c.complete) || void 0 === n3 ? void 0 : n3.bind(c);
      } else
        z("DocumentReference.onSnapshot", "function", u4, i2[u4]), B("DocumentReference.onSnapshot", "function", u4 + 1, i2[u4 + 1]), B("DocumentReference.onSnapshot", "function", u4 + 2, i2[u4 + 2]);
      var h = {
        next: function(t2) {
          i2[u4] && i2[u4](r2.Sf(t2));
        },
        error: i2[u4 + 1],
        complete: i2[u4 + 2]
      };
      return this.lf.listen(Hn(this.f_.path), a, h);
    }, n2.prototype.get = function(t) {
      var e2 = this;
      G2("DocumentReference.get", arguments, 0, 1), Sa2("DocumentReference.get", t);
      var n3 = this.firestore.hf();
      return t && "cache" === t.source ? n3.Q_(this.f_).then(function(t2) {
        return new da2(
          e2.firestore,
          e2.f_,
          t2,
          /*fromCache=*/
          true,
          t2 instanceof zn && t2.Je,
          e2.d_
        );
      }) : n3.W_(this.f_, t).then(function(t2) {
        return e2.Sf(t2);
      });
    }, n2.prototype.withConverter = function(t) {
      return new n2(this.f_, this.firestore, t);
    }, /**
     * Converts a ViewSnapshot that contains the current document to a
     * DocumentSnapshot.
     */
    n2.prototype.Sf = function(t) {
      var e2 = t.docs.get(this.f_);
      return new da2(this.firestore, this.f_, e2, t.fromCache, t.hasPendingWrites, this.d_);
    }, n2;
  }(Fu)
);
var pa2 = (
  /** @class */
  function() {
    function t(t2, e) {
      this.hasPendingWrites = t2, this.fromCache = e;
    }
    return t.prototype.isEqual = function(t2) {
      return this.hasPendingWrites === t2.hasPendingWrites && this.fromCache === t2.fromCache;
    }, t;
  }()
);
var da2 = (
  /** @class */
  function() {
    function t(t2, e, n2, r2, i2, o) {
      this.yf = t2, this.f_ = e, this.Df = n2, this.Cf = r2, this.Nf = i2, this.d_ = o;
    }
    return t.prototype.data = function(t2) {
      var e = this;
      if (G2("DocumentSnapshot.data", arguments, 0, 1), t2 = Aa2("DocumentSnapshot.data", t2), this.Df) {
        if (this.d_) {
          var n2 = new va(
            this.yf,
            this.f_,
            this.Df,
            this.Cf,
            this.Nf,
            /* converter= */
            null
          );
          return this.d_.fromFirestore(n2, t2);
        }
        return new sa2(this.yf.__, this.yf.gf(), t2.serverTimestamps || "none", function(t3) {
          return new la2(
            t3,
            e.yf,
            /* converter= */
            null
          );
        }, function(t3) {
          return new pt(t3);
        }).X_(this.Df.rn());
      }
    }, t.prototype.get = function(t2, e) {
      var n2 = this;
      if (G2("DocumentSnapshot.get", arguments, 1, 2), e = Aa2("DocumentSnapshot.get", e), this.Df) {
        var r2 = this.Df.data().field(Ju("DocumentSnapshot.get", t2, this.f_));
        if (null !== r2)
          return new sa2(this.yf.__, this.yf.gf(), e.serverTimestamps || "none", function(t3) {
            return new la2(t3, n2.yf, n2.d_);
          }, function(t3) {
            return new pt(t3);
          }).X_(r2);
      }
    }, Object.defineProperty(t.prototype, "id", {
      get: function() {
        return this.f_.path._();
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "ref", {
      get: function() {
        return new la2(this.f_, this.yf, this.d_);
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "exists", {
      get: function() {
        return null !== this.Df;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "metadata", {
      get: function() {
        return new pa2(this.Nf, this.Cf);
      },
      enumerable: false,
      configurable: true
    }), t.prototype.isEqual = function(e) {
      if (!(e instanceof t))
        throw tt("isEqual", "DocumentSnapshot", 1, e);
      return this.yf === e.yf && this.Cf === e.Cf && this.f_.isEqual(e.f_) && (null === this.Df ? null === e.Df : this.Df.isEqual(e.Df)) && this.d_ === e.d_;
    }, t;
  }()
);
var va = (
  /** @class */
  function(e) {
    function n2() {
      return null !== e && e.apply(this, arguments) || this;
    }
    return __extends(n2, e), n2.prototype.data = function(t) {
      return e.prototype.data.call(this, t);
    }, n2;
  }(da2)
);
function ya(t, e, n2, r2, i2, o, s) {
  var u4;
  if (i2.p()) {
    if ("array-contains" === o || "array-contains-any" === o)
      throw new I2(b.INVALID_ARGUMENT, "Invalid Query. You can't perform '" + o + "' queries on FieldPath.documentId().");
    if ("in" === o || "not-in" === o) {
      wa(s, o);
      for (var a = [], c = 0, h = s; c < h.length; c++) {
        var f = h[c];
        a.push(ga(r2, t, f));
      }
      u4 = {
        arrayValue: {
          values: a
        }
      };
    } else
      u4 = ga(r2, t, s);
  } else
    "in" !== o && "not-in" !== o && "array-contains-any" !== o || wa(s, o), u4 = Qu(
      n2,
      e,
      s,
      /* allowArrays= */
      "in" === o || "not-in" === o
    );
  var l = hr.create(i2, o, u4);
  return function(t2, e2) {
    if (e2.hn()) {
      var n3 = Jn(t2);
      if (null !== n3 && !n3.isEqual(e2.field))
        throw new I2(b.INVALID_ARGUMENT, "Invalid query. All where filters with an inequality (<, <=, >, or >=) must be on the same field. But you have inequality filters on '" + n3.toString() + "' and '" + e2.field.toString() + "'");
      var r3 = Xn(t2);
      null !== r3 && ba2(t2, e2.field, r3);
    }
    var i3 = function(t3, e3) {
      for (var n4 = 0, r4 = t3.filters; n4 < r4.length; n4++) {
        var i4 = r4[n4];
        if (e3.indexOf(i4.op) >= 0)
          return i4.op;
      }
      return null;
    }(
      t2,
      /**
      * Given an operator, returns the set of operators that cannot be used with it.
      *
      * Operators in a query must adhere to the following set of rules:
      * 1. Only one array operator is allowed.
      * 2. Only one disjunctive operator is allowed.
      * 3. NOT_EQUAL cannot be used with another NOT_EQUAL operator.
      * 4. NOT_IN cannot be used with array, disjunctive, or NOT_EQUAL operators.
      *
      * Array operators: ARRAY_CONTAINS, ARRAY_CONTAINS_ANY
      * Disjunctive operators: IN, ARRAY_CONTAINS_ANY, NOT_IN
      */
      function(t3) {
        switch (t3) {
          case "!=":
            return [
              "!=",
              "not-in"
              /* NOT_IN */
            ];
          case "array-contains":
            return [
              "array-contains",
              "array-contains-any",
              "not-in"
              /* NOT_IN */
            ];
          case "in":
            return [
              "array-contains-any",
              "in",
              "not-in"
              /* NOT_IN */
            ];
          case "array-contains-any":
            return [
              "array-contains",
              "array-contains-any",
              "in",
              "not-in"
              /* NOT_IN */
            ];
          case "not-in":
            return [
              "array-contains",
              "array-contains-any",
              "in",
              "not-in",
              "!="
              /* NOT_EQUAL */
            ];
          default:
            return [];
        }
      }(e2.op)
    );
    if (null !== i3)
      throw i3 === e2.op ? new I2(b.INVALID_ARGUMENT, "Invalid query. You cannot use more than one '" + e2.op.toString() + "' filter.") : new I2(b.INVALID_ARGUMENT, "Invalid query. You cannot use '" + e2.op.toString() + "' filters with '" + i3.toString() + "' filters.");
  }(t, l), l;
}
function ma(t, e, n2) {
  if (null !== t.startAt)
    throw new I2(b.INVALID_ARGUMENT, "Invalid query. You must not call startAt() or startAfter() before calling orderBy().");
  if (null !== t.endAt)
    throw new I2(b.INVALID_ARGUMENT, "Invalid query. You must not call endAt() or endBefore() before calling orderBy().");
  var r2 = new _r(e, n2);
  return function(t2, e2) {
    if (null === Xn(t2)) {
      var n3 = Jn(t2);
      null !== n3 && ba2(t2, n3, e2.field);
    }
  }(t, r2), r2;
}
function ga(t, e, n2) {
  if ("string" == typeof n2) {
    if ("" === n2)
      throw new I2(b.INVALID_ARGUMENT, "Invalid query. When querying with FieldPath.documentId(), you must provide a valid document ID, but it was an empty string.");
    if (!Zn(e) && -1 !== n2.indexOf("/"))
      throw new I2(b.INVALID_ARGUMENT, "Invalid query. When querying a collection by FieldPath.documentId(), you must provide a plain document ID, but '" + n2 + "' contains a '/' character.");
    var r2 = e.path.child(V2.g(n2));
    if (!F2.F(r2))
      throw new I2(b.INVALID_ARGUMENT, "Invalid query. When querying a collection group by FieldPath.documentId(), the value provided must result in a valid document path, but '" + r2 + "' is not because it has an odd number of segments (" + r2.length + ").");
    return be(t, new F2(r2));
  }
  if (n2 instanceof Fu)
    return be(t, n2.f_);
  throw new I2(b.INVALID_ARGUMENT, "Invalid query. When querying with FieldPath.documentId(), you must provide a valid string or a DocumentReference, but it was: " + X2(n2) + ".");
}
function wa(t, e) {
  if (!Array.isArray(t) || 0 === t.length)
    throw new I2(b.INVALID_ARGUMENT, "Invalid Query. A non-empty array is required for '" + e.toString() + "' filters.");
  if (t.length > 10)
    throw new I2(b.INVALID_ARGUMENT, "Invalid Query. '" + e.toString() + "' filters support a maximum of 10 elements in the value array.");
  if ("in" === e || "array-contains-any" === e) {
    if (t.indexOf(null) >= 0)
      throw new I2(b.INVALID_ARGUMENT, "Invalid Query. '" + e.toString() + "' filters cannot contain 'null' in the value array.");
    if (t.filter(function(t2) {
      return Number.isNaN(t2);
    }).length > 0)
      throw new I2(b.INVALID_ARGUMENT, "Invalid Query. '" + e.toString() + "' filters cannot contain 'NaN' in the value array.");
  }
}
function ba2(t, e, n2) {
  if (!n2.isEqual(e))
    throw new I2(b.INVALID_ARGUMENT, "Invalid query. You have a where filter with an inequality (<, <=, >, or >=) on field '" + e.toString() + "' and so you must also use '" + e.toString() + "' as your first orderBy(), but your first orderBy() is on field '" + n2.toString() + "' instead.");
}
function Ia2(t) {
  if ($n(t) && 0 === t.on.length)
    throw new I2(b.UNIMPLEMENTED, "limitToLast() queries require specifying at least one orderBy() clause");
}
var Ea2 = (
  /** @class */
  function() {
    function t(t2, e, n2) {
      this.Ff = t2, this.firestore = e, this.d_ = n2;
    }
    return t.prototype.where = function(e, n2, r2) {
      q2("Query.where", arguments, 3), J2("Query.where", 3, r2);
      var i2 = H2("Query.where", [
        "<",
        "<=",
        "==",
        "!=",
        ">=",
        ">",
        "array-contains",
        "in",
        "array-contains-any",
        "not-in"
        /* NOT_IN */
      ], 2, n2), o = Ju("Query.where", e), s = ya(this.Ff, "Query.where", this.firestore.mf, this.firestore.__, o, i2, r2);
      return new t(function(t2, e2) {
        var n3 = t2.filters.concat([e2]);
        return new Wn(t2.path, t2.collectionGroup, t2.on.slice(), n3, t2.limit, t2.an, t2.startAt, t2.endAt);
      }(this.Ff, s), this.firestore, this.d_);
    }, t.prototype.orderBy = function(e, n2) {
      var r2;
      if (G2("Query.orderBy", arguments, 1, 2), B("Query.orderBy", "non-empty string", 2, n2), void 0 === n2 || "asc" === n2)
        r2 = "asc";
      else {
        if ("desc" !== n2)
          throw new I2(b.INVALID_ARGUMENT, "Function Query.orderBy() has unknown direction '" + n2 + "', expected 'asc' or 'desc'.");
        r2 = "desc";
      }
      var i2 = Ju("Query.orderBy", e), o = ma(this.Ff, i2, r2);
      return new t(function(t2, e2) {
        var n3 = t2.on.concat([e2]);
        return new Wn(t2.path, t2.collectionGroup, n3, t2.filters.slice(), t2.limit, t2.an, t2.startAt, t2.endAt);
      }(this.Ff, o), this.firestore, this.d_);
    }, t.prototype.limit = function(e) {
      return q2("Query.limit", arguments, 1), z("Query.limit", "number", 1, e), et("Query.limit", 1, e), new t(nr(
        this.Ff,
        e,
        "F"
        /* First */
      ), this.firestore, this.d_);
    }, t.prototype.limitToLast = function(e) {
      return q2("Query.limitToLast", arguments, 1), z("Query.limitToLast", "number", 1, e), et("Query.limitToLast", 1, e), new t(nr(
        this.Ff,
        e,
        "L"
        /* Last */
      ), this.firestore, this.d_);
    }, t.prototype.startAt = function(e) {
      for (var n2 = [], r2 = 1; r2 < arguments.length; r2++)
        n2[r2 - 1] = arguments[r2];
      j("Query.startAt", arguments, 1);
      var i2 = this.xf(
        "Query.startAt",
        e,
        n2,
        /*before=*/
        true
      );
      return new t(rr(this.Ff, i2), this.firestore, this.d_);
    }, t.prototype.startAfter = function(e) {
      for (var n2 = [], r2 = 1; r2 < arguments.length; r2++)
        n2[r2 - 1] = arguments[r2];
      j("Query.startAfter", arguments, 1);
      var i2 = this.xf(
        "Query.startAfter",
        e,
        n2,
        /*before=*/
        false
      );
      return new t(rr(this.Ff, i2), this.firestore, this.d_);
    }, t.prototype.endBefore = function(e) {
      for (var n2 = [], r2 = 1; r2 < arguments.length; r2++)
        n2[r2 - 1] = arguments[r2];
      j("Query.endBefore", arguments, 1);
      var i2 = this.xf(
        "Query.endBefore",
        e,
        n2,
        /*before=*/
        true
      );
      return new t(ir(this.Ff, i2), this.firestore, this.d_);
    }, t.prototype.endAt = function(e) {
      for (var n2 = [], r2 = 1; r2 < arguments.length; r2++)
        n2[r2 - 1] = arguments[r2];
      j("Query.endAt", arguments, 1);
      var i2 = this.xf(
        "Query.endAt",
        e,
        n2,
        /*before=*/
        false
      );
      return new t(ir(this.Ff, i2), this.firestore, this.d_);
    }, t.prototype.isEqual = function(e) {
      if (!(e instanceof t))
        throw tt("isEqual", "Query", 1, e);
      return this.firestore === e.firestore && or(this.Ff, e.Ff) && this.d_ === e.d_;
    }, t.prototype.withConverter = function(e) {
      return new t(this.Ff, this.firestore, e);
    }, /** Helper function to create a bound from a document or fields */
    t.prototype.xf = function(t2, e, n2, i2) {
      if (J2(t2, 1, e), e instanceof da2)
        return q2(t2, __spreadArrays([e], n2), 1), function(t3, e2, n3, r2, i3) {
          if (!r2)
            throw new I2(b.NOT_FOUND, "Can't use a DocumentSnapshot that doesn't exist for " + n3 + "().");
          for (var o2 = [], s = 0, u4 = tr(t3); s < u4.length; s++) {
            var a = u4[s];
            if (a.field.p())
              o2.push(be(e2, r2.key));
            else {
              var c = r2.field(a.field);
              if (se(c))
                throw new I2(b.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a document for which the field "' + a.field + '" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)');
              if (null === c) {
                var h = a.field.R();
                throw new I2(b.INVALID_ARGUMENT, "Invalid query. You are trying to start or end a query using a document for which the field '" + h + "' (used as the orderBy) does not exist.");
              }
              o2.push(c);
            }
          }
          return new wr(o2, i3);
        }(this.Ff, this.firestore.__, t2, e.Df, i2);
      var o = [e].concat(n2);
      return function(t3, e2, n3, r2, i3, o2) {
        var s = t3.on;
        if (i3.length > s.length)
          throw new I2(b.INVALID_ARGUMENT, "Too many arguments provided to " + r2 + "(). The number of arguments must be less than or equal to the number of orderBy() clauses");
        for (var u4 = [], a = 0; a < i3.length; a++) {
          var c = i3[a];
          if (s[a].field.p()) {
            if ("string" != typeof c)
              throw new I2(b.INVALID_ARGUMENT, "Invalid query. Expected a string for document ID in " + r2 + "(), but got a " + typeof c);
            if (!Zn(t3) && -1 !== c.indexOf("/"))
              throw new I2(b.INVALID_ARGUMENT, "Invalid query. When querying a collection and ordering by FieldPath.documentId(), the value passed to " + r2 + "() must be a plain document ID, but '" + c + "' contains a slash.");
            var h = t3.path.child(V2.g(c));
            if (!F2.F(h))
              throw new I2(b.INVALID_ARGUMENT, "Invalid query. When querying a collection group and ordering by FieldPath.documentId(), the value passed to " + r2 + "() must result in a valid document path, but '" + h + "' is not because it contains an odd number of segments.");
            var f = new F2(h);
            u4.push(be(e2, f));
          } else {
            var l = Qu(n3, r2, c);
            u4.push(l);
          }
        }
        return new wr(u4, o2);
      }(this.Ff, this.firestore.__, this.firestore.mf, t2, o, i2);
    }, t.prototype.onSnapshot = function() {
      for (var t2, e, n2, r2 = this, i2 = [], o = 0; o < arguments.length; o++)
        i2[o] = arguments[o];
      G2("Query.onSnapshot", arguments, 1, 4);
      var s = {}, u4 = 0;
      if ("object" != typeof i2[u4] || oa2(i2[u4]) || (Z2("Query.onSnapshot", s = i2[u4], ["includeMetadataChanges"]), W2("Query.onSnapshot", "boolean", "includeMetadataChanges", s.includeMetadataChanges), u4++), oa2(i2[u4])) {
        var a = i2[u4];
        i2[u4] = null === (t2 = a.next) || void 0 === t2 ? void 0 : t2.bind(a), i2[u4 + 1] = null === (e = a.error) || void 0 === e ? void 0 : e.bind(a), i2[u4 + 2] = null === (n2 = a.complete) || void 0 === n2 ? void 0 : n2.bind(a);
      } else
        z("Query.onSnapshot", "function", u4, i2[u4]), B("Query.onSnapshot", "function", u4 + 1, i2[u4 + 1]), B("Query.onSnapshot", "function", u4 + 2, i2[u4 + 2]);
      var c = {
        next: function(t3) {
          i2[u4] && i2[u4](new _a2(r2.firestore, r2.Ff, t3, r2.d_));
        },
        error: i2[u4 + 1],
        complete: i2[u4 + 2]
      };
      return Ia2(this.Ff), this.firestore.hf().listen(this.Ff, s, c);
    }, t.prototype.get = function(t2) {
      var e = this;
      G2("Query.get", arguments, 0, 1), Sa2("Query.get", t2), Ia2(this.Ff);
      var n2 = this.firestore.hf();
      return (t2 && "cache" === t2.source ? n2.j_(this.Ff) : n2.K_(this.Ff, t2)).then(function(t3) {
        return new _a2(e.firestore, e.Ff, t3, e.d_);
      });
    }, t;
  }()
);
var _a2 = (
  /** @class */
  function() {
    function t(t2, e, n2, r2) {
      this.yf = t2, this.$f = e, this.kf = n2, this.d_ = r2, this.Mf = null, this.Of = null, this.metadata = new pa2(n2.hasPendingWrites, n2.fromCache);
    }
    return Object.defineProperty(t.prototype, "docs", {
      get: function() {
        var t2 = [];
        return this.forEach(function(e) {
          return t2.push(e);
        }), t2;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "empty", {
      get: function() {
        return this.kf.docs.m();
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "size", {
      get: function() {
        return this.kf.docs.size;
      },
      enumerable: false,
      configurable: true
    }), t.prototype.forEach = function(t2, e) {
      var n2 = this;
      G2("QuerySnapshot.forEach", arguments, 1, 2), z("QuerySnapshot.forEach", "function", 1, t2), this.kf.docs.forEach(function(r2) {
        t2.call(e, n2.Lf(r2, n2.metadata.fromCache, n2.kf.Wt.has(r2.key)));
      });
    }, Object.defineProperty(t.prototype, "query", {
      get: function() {
        return new Ea2(this.$f, this.yf, this.d_);
      },
      enumerable: false,
      configurable: true
    }), t.prototype.docChanges = function(t2) {
      t2 && (Z2("QuerySnapshot.docChanges", t2, ["includeMetadataChanges"]), W2("QuerySnapshot.docChanges", "boolean", "includeMetadataChanges", t2.includeMetadataChanges));
      var e = !(!t2 || !t2.includeMetadataChanges);
      if (e && this.kf.Kt)
        throw new I2(b.INVALID_ARGUMENT, "To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().");
      return this.Mf && this.Of === e || (this.Mf = /**
      * Calculates the array of DocumentChanges for a given ViewSnapshot.
      *
      * Exported for testing.
      *
      * @param snapshot The ViewSnapshot that represents the expected state.
      * @param includeMetadataChanges Whether to include metadata changes.
      * @param converter A factory function that returns a QueryDocumentSnapshot.
      * @return An object that matches the DocumentChange API.
      */
      function(t3, e2, n2) {
        if (t3.Qt.m()) {
          var r2 = 0;
          return t3.docChanges.map(function(e3) {
            var i3 = n2(e3.doc, t3.fromCache, t3.Wt.has(e3.doc.key));
            return e3.doc, {
              type: "added",
              doc: i3,
              oldIndex: -1,
              newIndex: r2++
            };
          });
        }
        var i2 = t3.Qt;
        return t3.docChanges.filter(function(t4) {
          return e2 || 3 !== t4.type;
        }).map(function(e3) {
          var r3 = n2(e3.doc, t3.fromCache, t3.Wt.has(e3.doc.key)), o = -1, s = -1;
          return 0 !== e3.type && (o = i2.indexOf(e3.doc.key), i2 = i2.delete(e3.doc.key)), 1 !== e3.type && (s = (i2 = i2.add(e3.doc)).indexOf(e3.doc.key)), {
            type: ka2(e3.type),
            doc: r3,
            oldIndex: o,
            newIndex: s
          };
        });
      }(this.kf, e, this.Lf.bind(this)), this.Of = e), this.Mf;
    }, /** Check the equality. The call can be very expensive. */
    t.prototype.isEqual = function(e) {
      if (!(e instanceof t))
        throw tt("isEqual", "QuerySnapshot", 1, e);
      return this.yf === e.yf && or(this.$f, e.$f) && this.kf.isEqual(e.kf) && this.d_ === e.d_;
    }, t.prototype.Lf = function(t2, e, n2) {
      return new va(this.yf, t2.key, t2, e, n2, this.d_);
    }, t;
  }()
);
var Ta = (
  /** @class */
  function(e) {
    function n2(t, n3, r2) {
      var i2 = this;
      if ((i2 = e.call(this, Hn(t), n3, r2) || this).Bf = t, t.length % 2 != 1)
        throw new I2(b.INVALID_ARGUMENT, "Invalid collection reference. Collection references must have an odd number of segments, but " + t.R() + " has " + t.length);
      return i2;
    }
    return __extends(n2, e), Object.defineProperty(n2.prototype, "id", {
      get: function() {
        return this.Ff.path._();
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(n2.prototype, "parent", {
      get: function() {
        var t = this.Ff.path.h();
        return t.m() ? null : new la2(
          new F2(t),
          this.firestore,
          /* converter= */
          null
        );
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(n2.prototype, "path", {
      get: function() {
        return this.Ff.path.R();
      },
      enumerable: false,
      configurable: true
    }), n2.prototype.doc = function(t) {
      G2("CollectionReference.doc", arguments, 0, 1), // We allow omission of 'pathString' but explicitly prohibit passing in both
      // 'undefined' and 'null'.
      0 === arguments.length && (t = ot.k()), z("CollectionReference.doc", "non-empty string", 1, t);
      var e2 = V2.g(t);
      return la2.Rf(this.Ff.path.child(e2), this.firestore, this.d_);
    }, n2.prototype.add = function(t) {
      q2("CollectionReference.add", arguments, 1);
      var e2 = this.d_ ? this.d_.toFirestore(t) : t;
      z("CollectionReference.add", "object", 1, e2);
      var n3 = this.doc();
      return new la2(n3.f_, this.firestore, null).set(e2).then(function() {
        return n3;
      });
    }, n2.prototype.withConverter = function(t) {
      return new n2(this.Bf, this.firestore, t);
    }, n2;
  }(Ea2)
);
function Na2(t, e) {
  if (void 0 === e)
    return {
      merge: false
    };
  if (Z2(t, e, ["merge", "mergeFields"]), W2(t, "boolean", "merge", e.merge), function(t2, e2, n2, r2, i2) {
    void 0 !== r2 && function(t3, e3, n3, r3, i3) {
      if (!(r3 instanceof Array))
        throw new I2(b.INVALID_ARGUMENT, "Function " + t3 + "() requires its " + e3 + " option to be an array, but it was: " + X2(r3));
      for (var o = 0; o < r3.length; ++o)
        if (!i3(r3[o]))
          throw new I2(b.INVALID_ARGUMENT, "Function " + t3 + "() requires all " + e3 + " elements to be " + n3 + ", but the value at index " + o + " was: " + X2(r3[o]));
    }(t2, e2, n2, r2, i2);
  }(t, "mergeFields", "a string or a FieldPath", e.mergeFields, function(t2) {
    return "string" == typeof t2 || t2 instanceof Au;
  }), void 0 !== e.mergeFields && void 0 !== e.merge)
    throw new I2(b.INVALID_ARGUMENT, "Invalid options passed to function " + t + '(): You cannot specify both "merge" and "mergeFields".');
  return e;
}
function Aa2(t, e) {
  return void 0 === e ? {} : (Z2(t, e, ["serverTimestamps"]), Q2(t, 0, "serverTimestamps", e.serverTimestamps, ["estimate", "previous", "none"]), e);
}
function Sa2(t, e) {
  B(t, "object", 1, e), e && (Z2(t, e, ["source"]), Q2(t, 0, "source", e.source, ["default", "server", "cache"]));
}
function Da2(t, e, n2) {
  if (e instanceof Fu) {
    if (e.firestore !== n2)
      throw new I2(b.INVALID_ARGUMENT, "Provided document reference is from a different Firestore instance.");
    return e;
  }
  throw tt(t, "DocumentReference", 1, e);
}
function ka2(t) {
  switch (t) {
    case 0:
      return "added";
    case 2:
    case 3:
      return "modified";
    case 1:
      return "removed";
    default:
      return D2();
  }
}
function xa2(t, e, n2) {
  return t ? n2 && (n2.merge || n2.mergeFields) ? t.toFirestore(e, n2) : t.toFirestore(e) : e;
}
var La2 = (
  /** @class */
  function(e) {
    function n2() {
      return null !== e && e.apply(this, arguments) || this;
    }
    return __extends(n2, e), n2.serverTimestamp = function() {
      M2("FieldValue.serverTimestamp", arguments);
      var t = new Lu("serverTimestamp");
      return t.e_ = "FieldValue.serverTimestamp", new n2(t);
    }, n2.delete = function() {
      M2("FieldValue.delete", arguments);
      var t = new ku("deleteField");
      return t.e_ = "FieldValue.delete", new n2(t);
    }, n2.arrayUnion = function() {
      for (var t = [], e2 = 0; e2 < arguments.length; e2++)
        t[e2] = arguments[e2];
      j("FieldValue.arrayUnion", arguments, 1);
      var r2 = (
        /**
        * Returns a special value that can be used with {@link setDoc()} or {@link
        * updateDoc()} that tells the server to union the given elements with any array
        * value that already exists on the server. Each specified element that doesn't
        * already exist in the array will be added to the end. If the field being
        * modified is not already an array it will be overwritten with an array
        * containing exactly the specified elements.
        *
        * @param elements The elements to union into the array.
        * @return The `FieldValue` sentinel for use in a call to `setDoc()` or
        * `updateDoc()`.
        */
        (function() {
          for (var t2 = [], e3 = 0; e3 < arguments.length; e3++)
            t2[e3] = arguments[e3];
          return j("arrayUnion()", arguments, 1), new Ru("arrayUnion", t2);
        }).apply(void 0, t)
      );
      return r2.e_ = "FieldValue.arrayUnion", new n2(r2);
    }, n2.arrayRemove = function() {
      for (var t = [], e2 = 0; e2 < arguments.length; e2++)
        t[e2] = arguments[e2];
      j("FieldValue.arrayRemove", arguments, 1);
      var r2 = (function() {
        for (var t2 = [], e3 = 0; e3 < arguments.length; e3++)
          t2[e3] = arguments[e3];
        return j("arrayRemove()", arguments, 1), new Ou("arrayRemove", t2);
      }).apply(void 0, t);
      return r2.e_ = "FieldValue.arrayRemove", new n2(r2);
    }, n2.increment = function(t) {
      z("FieldValue.increment", "number", 1, t), q2("FieldValue.increment", arguments, 1);
      var e2 = function(t2) {
        return new Pu("increment", t2);
      }(t);
      return e2.e_ = "FieldValue.increment", new n2(e2);
    }, n2.prototype.isEqual = function(t) {
      return this.l_.isEqual(t.l_);
    }, n2;
  }(Uu)
);
var Ra2 = {
  Firestore: ca2,
  GeoPoint: Vu,
  Timestamp: mt,
  Blob: pt,
  Transaction: ha2,
  WriteBatch: fa2,
  DocumentReference: la2,
  DocumentSnapshot: da2,
  Query: Ea2,
  QueryDocumentSnapshot: va,
  QuerySnapshot: _a2,
  CollectionReference: Ta,
  FieldPath: Au,
  FieldValue: La2,
  setLogLevel: ca2.setLogLevel,
  CACHE_SIZE_UNLIMITED: ua2
};
function Oa(t) {
  !function(t2, e) {
    t2.INTERNAL.registerComponent(new Component2(
      "firestore",
      function(t3) {
        return function(t4, e2) {
          var n2 = new _u(), r2 = new Eu(n2);
          return new ca2(t4, e2, r2, n2);
        }(t3.getProvider("app").getImmediate(), t3.getProvider("auth-internal"));
      },
      "PUBLIC"
      /* PUBLIC */
    ).setServiceProps(Object.assign({}, Ra2)));
  }(t), t.registerVersion("@firebase/firestore", "1.18.0");
}
Oa(import_app5.default);

// node_modules/ng-fire-admin/node_modules/@angular/fire/firestore/firestore.module.js
var __decorate4 = function(decorators, target, key, desc) {
  var c = arguments.length, r2 = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d = decorators[i2])
        r2 = (c < 3 ? d(r2) : c > 3 ? d(target, key, r2) : d(target, key)) || r2;
  return c > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var AngularFirestoreModule = function() {
  function AngularFirestoreModule2() {
  }
  AngularFirestoreModule_1 = AngularFirestoreModule2;
  AngularFirestoreModule2.enablePersistence = function(persistenceSettings) {
    return {
      ngModule: AngularFirestoreModule_1,
      providers: [
        { provide: EnablePersistenceToken, useValue: true },
        { provide: PersistenceSettingsToken, useValue: persistenceSettings }
      ]
    };
  };
  var AngularFirestoreModule_1;
  AngularFirestoreModule2 = AngularFirestoreModule_1 = __decorate4([
    NgModule({
      providers: [AngularFirestore]
    })
  ], AngularFirestoreModule2);
  return AngularFirestoreModule2;
}();

// node_modules/ng-fire-admin/node_modules/@angular/fire/storage/observable/fromTask.js
function fromTask(task) {
  return new Observable(function(subscriber) {
    var progress = function(snap) {
      return subscriber.next(snap);
    };
    var error = function(e) {
      return subscriber.error(e);
    };
    var complete = function() {
      return subscriber.complete();
    };
    task.on("state_changed", progress, error, complete);
    return function() {
      return task.cancel();
    };
  });
}

// node_modules/ng-fire-admin/node_modules/@angular/fire/storage/task.js
function createUploadTask(task) {
  var inner$ = fromTask(task);
  return {
    task,
    then: task.then.bind(task),
    catch: task.catch.bind(task),
    pause: task.pause.bind(task),
    cancel: task.cancel.bind(task),
    resume: task.resume.bind(task),
    snapshotChanges: function() {
      return inner$;
    },
    percentageChanges: function() {
      return inner$.pipe(map(function(s) {
        return s.bytesTransferred / s.totalBytes * 100;
      }));
    }
  };
}

// node_modules/ng-fire-admin/node_modules/@angular/fire/storage/ref.js
function createStorageRef(ref, schedulers, keepUnstableUntilFirst) {
  return {
    getDownloadURL: function() {
      return from(ref.getDownloadURL(), schedulers.outsideAngular).pipe(keepUnstableUntilFirst);
    },
    getMetadata: function() {
      return from(ref.getMetadata()).pipe(keepUnstableUntilFirst);
    },
    delete: function() {
      return from(ref.delete());
    },
    child: function(path) {
      return createStorageRef(ref.child(path), schedulers, keepUnstableUntilFirst);
    },
    updateMetatdata: function(meta) {
      return from(ref.updateMetadata(meta));
    },
    updateMetadata: function(meta) {
      return from(ref.updateMetadata(meta));
    },
    put: function(data, metadata) {
      var task = ref.put(data, metadata);
      return createUploadTask(task);
    },
    putString: function(data, format, metadata) {
      var task = ref.putString(data, format, metadata);
      return createUploadTask(task);
    }
  };
}

// node_modules/ng-fire-admin/node_modules/@angular/fire/storage/storage.js
var __decorate5 = function(decorators, target, key, desc) {
  var c = arguments.length, r2 = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d = decorators[i2])
        r2 = (c < 3 ? d(r2) : c > 3 ? d(target, key, r2) : d(target, key)) || r2;
  return c > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata4 = function(k3, v2) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k3, v2);
};
var __param4 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var StorageBucket = new InjectionToken("angularfire2.storageBucket");
var BUCKET = StorageBucket;
var AngularFireStorage = function() {
  function AngularFireStorage2(options, nameOrConfig, storageBucket, platformId, zone) {
    this.schedulers = new ɵAngularFireSchedulers(zone);
    this.keepUnstableUntilFirst = ɵkeepUnstableUntilFirstFactory(this.schedulers, platformId);
    this.storage = zone.runOutsideAngular(function() {
      var app = _firebaseAppFactory(options, zone, nameOrConfig);
      return app.storage(storageBucket || void 0);
    });
  }
  AngularFireStorage2.prototype.ref = function(path) {
    return createStorageRef(this.storage.ref(path), this.schedulers, this.keepUnstableUntilFirst);
  };
  AngularFireStorage2.prototype.upload = function(path, data, metadata) {
    var storageRef = this.storage.ref(path);
    var ref = createStorageRef(storageRef, this.schedulers, this.keepUnstableUntilFirst);
    return ref.put(data, metadata);
  };
  AngularFireStorage2 = __decorate5([
    Injectable(),
    __param4(0, Inject(FIREBASE_OPTIONS)),
    __param4(1, Optional()),
    __param4(1, Inject(FIREBASE_APP_NAME)),
    __param4(2, Optional()),
    __param4(2, Inject(BUCKET)),
    __param4(3, Inject(PLATFORM_ID)),
    __metadata4("design:paramtypes", [
      Object,
      Object,
      Object,
      Object,
      NgZone
    ])
  ], AngularFireStorage2);
  return AngularFireStorage2;
}();

// node_modules/ng-fire-admin/node_modules/@firebase/storage/dist/index.esm.js
var import_app6 = __toESM(require_index_cjs3());
init_tslib_es6();
var DEFAULT_HOST = "firebasestorage.googleapis.com";
var CONFIG_STORAGE_BUCKET_KEY = "storageBucket";
var DEFAULT_MAX_OPERATION_RETRY_TIME = 2 * 60 * 1e3;
var DEFAULT_MAX_UPLOAD_RETRY_TIME = 10 * 60 * 1e3;
var FirebaseStorageError = (
  /** @class */
  function() {
    function FirebaseStorageError2(code, message) {
      this.code_ = prependCode(code);
      this.message_ = "Firebase Storage: " + message;
      this.serverResponse_ = null;
      this.name_ = "FirebaseError";
    }
    FirebaseStorageError2.prototype.codeProp = function() {
      return this.code;
    };
    FirebaseStorageError2.prototype.codeEquals = function(code) {
      return prependCode(code) === this.codeProp();
    };
    FirebaseStorageError2.prototype.serverResponseProp = function() {
      return this.serverResponse_;
    };
    FirebaseStorageError2.prototype.setServerResponseProp = function(serverResponse) {
      this.serverResponse_ = serverResponse;
    };
    Object.defineProperty(FirebaseStorageError2.prototype, "name", {
      get: function() {
        return this.name_;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FirebaseStorageError2.prototype, "code", {
      get: function() {
        return this.code_;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FirebaseStorageError2.prototype, "message", {
      get: function() {
        if (this.serverResponse_) {
          return this.message_ + "\n" + this.serverResponse_;
        } else {
          return this.message_;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FirebaseStorageError2.prototype, "serverResponse", {
      get: function() {
        return this.serverResponse_;
      },
      enumerable: false,
      configurable: true
    });
    return FirebaseStorageError2;
  }()
);
var Code = {
  // Shared between all platforms
  UNKNOWN: "unknown",
  OBJECT_NOT_FOUND: "object-not-found",
  BUCKET_NOT_FOUND: "bucket-not-found",
  PROJECT_NOT_FOUND: "project-not-found",
  QUOTA_EXCEEDED: "quota-exceeded",
  UNAUTHENTICATED: "unauthenticated",
  UNAUTHORIZED: "unauthorized",
  RETRY_LIMIT_EXCEEDED: "retry-limit-exceeded",
  INVALID_CHECKSUM: "invalid-checksum",
  CANCELED: "canceled",
  // JS specific
  INVALID_EVENT_NAME: "invalid-event-name",
  INVALID_URL: "invalid-url",
  INVALID_DEFAULT_BUCKET: "invalid-default-bucket",
  NO_DEFAULT_BUCKET: "no-default-bucket",
  CANNOT_SLICE_BLOB: "cannot-slice-blob",
  SERVER_FILE_WRONG_SIZE: "server-file-wrong-size",
  NO_DOWNLOAD_URL: "no-download-url",
  INVALID_ARGUMENT: "invalid-argument",
  INVALID_ARGUMENT_COUNT: "invalid-argument-count",
  APP_DELETED: "app-deleted",
  INVALID_ROOT_OPERATION: "invalid-root-operation",
  INVALID_FORMAT: "invalid-format",
  INTERNAL_ERROR: "internal-error"
};
function prependCode(code) {
  return "storage/" + code;
}
function unknown() {
  var message = "An unknown error occurred, please check the error payload for server response.";
  return new FirebaseStorageError(Code.UNKNOWN, message);
}
function objectNotFound(path) {
  return new FirebaseStorageError(Code.OBJECT_NOT_FOUND, "Object '" + path + "' does not exist.");
}
function quotaExceeded(bucket) {
  return new FirebaseStorageError(Code.QUOTA_EXCEEDED, "Quota for bucket '" + bucket + "' exceeded, please view quota on https://firebase.google.com/pricing/.");
}
function unauthenticated() {
  var message = "User is not authenticated, please authenticate using Firebase Authentication and try again.";
  return new FirebaseStorageError(Code.UNAUTHENTICATED, message);
}
function unauthorized(path) {
  return new FirebaseStorageError(Code.UNAUTHORIZED, "User does not have permission to access '" + path + "'.");
}
function retryLimitExceeded() {
  return new FirebaseStorageError(Code.RETRY_LIMIT_EXCEEDED, "Max retry time for operation exceeded, please try again.");
}
function canceled() {
  return new FirebaseStorageError(Code.CANCELED, "User canceled the upload/download.");
}
function invalidUrl(url) {
  return new FirebaseStorageError(Code.INVALID_URL, "Invalid URL '" + url + "'.");
}
function invalidDefaultBucket(bucket) {
  return new FirebaseStorageError(Code.INVALID_DEFAULT_BUCKET, "Invalid default bucket '" + bucket + "'.");
}
function cannotSliceBlob() {
  return new FirebaseStorageError(Code.CANNOT_SLICE_BLOB, "Cannot slice blob for upload. Please retry the upload.");
}
function serverFileWrongSize() {
  return new FirebaseStorageError(Code.SERVER_FILE_WRONG_SIZE, "Server recorded incorrect upload file size, please retry the upload.");
}
function noDownloadURL() {
  return new FirebaseStorageError(Code.NO_DOWNLOAD_URL, "The given file does not have any download URLs.");
}
function invalidArgument(index, fnName, message) {
  return new FirebaseStorageError(Code.INVALID_ARGUMENT, "Invalid argument in `" + fnName + "` at index " + index + ": " + message);
}
function invalidArgumentCount(argMin, argMax, fnName, real) {
  var countPart;
  var plural3;
  if (argMin === argMax) {
    countPart = argMin;
    plural3 = argMin === 1 ? "argument" : "arguments";
  } else {
    countPart = "between " + argMin + " and " + argMax;
    plural3 = "arguments";
  }
  return new FirebaseStorageError(Code.INVALID_ARGUMENT_COUNT, "Invalid argument count in `" + fnName + "`: Expected " + countPart + " " + plural3 + ", received " + real + ".");
}
function appDeleted() {
  return new FirebaseStorageError(Code.APP_DELETED, "The Firebase app was deleted.");
}
function invalidRootOperation(name4) {
  return new FirebaseStorageError(Code.INVALID_ROOT_OPERATION, "The operation '" + name4 + "' cannot be performed on a root reference, create a non-root reference using child, such as .child('file.png').");
}
function invalidFormat(format, message) {
  return new FirebaseStorageError(Code.INVALID_FORMAT, "String does not match format '" + format + "': " + message);
}
function internalError(message) {
  throw new FirebaseStorageError(Code.INTERNAL_ERROR, "Internal error: " + message);
}
var StringFormat = {
  RAW: "raw",
  BASE64: "base64",
  BASE64URL: "base64url",
  DATA_URL: "data_url"
};
function formatValidator(stringFormat) {
  switch (stringFormat) {
    case StringFormat.RAW:
    case StringFormat.BASE64:
    case StringFormat.BASE64URL:
    case StringFormat.DATA_URL:
      return;
    default:
      throw "Expected one of the event types: [" + StringFormat.RAW + ", " + StringFormat.BASE64 + ", " + StringFormat.BASE64URL + ", " + StringFormat.DATA_URL + "].";
  }
}
var StringData = (
  /** @class */
  /* @__PURE__ */ function() {
    function StringData2(data, contentType) {
      this.data = data;
      this.contentType = contentType || null;
    }
    return StringData2;
  }()
);
function dataFromString(format, stringData) {
  switch (format) {
    case StringFormat.RAW:
      return new StringData(utf8Bytes_(stringData));
    case StringFormat.BASE64:
    case StringFormat.BASE64URL:
      return new StringData(base64Bytes_(format, stringData));
    case StringFormat.DATA_URL:
      return new StringData(dataURLBytes_(stringData), dataURLContentType_(stringData));
  }
  throw unknown();
}
function utf8Bytes_(value) {
  var b2 = [];
  for (var i2 = 0; i2 < value.length; i2++) {
    var c = value.charCodeAt(i2);
    if (c <= 127) {
      b2.push(c);
    } else {
      if (c <= 2047) {
        b2.push(192 | c >> 6, 128 | c & 63);
      } else {
        if ((c & 64512) === 55296) {
          var valid = i2 < value.length - 1 && (value.charCodeAt(i2 + 1) & 64512) === 56320;
          if (!valid) {
            b2.push(239, 191, 189);
          } else {
            var hi2 = c;
            var lo2 = value.charCodeAt(++i2);
            c = 65536 | (hi2 & 1023) << 10 | lo2 & 1023;
            b2.push(240 | c >> 18, 128 | c >> 12 & 63, 128 | c >> 6 & 63, 128 | c & 63);
          }
        } else {
          if ((c & 64512) === 56320) {
            b2.push(239, 191, 189);
          } else {
            b2.push(224 | c >> 12, 128 | c >> 6 & 63, 128 | c & 63);
          }
        }
      }
    }
  }
  return new Uint8Array(b2);
}
function percentEncodedBytes_(value) {
  var decoded;
  try {
    decoded = decodeURIComponent(value);
  } catch (e) {
    throw invalidFormat(StringFormat.DATA_URL, "Malformed data URL.");
  }
  return utf8Bytes_(decoded);
}
function base64Bytes_(format, value) {
  switch (format) {
    case StringFormat.BASE64: {
      var hasMinus = value.indexOf("-") !== -1;
      var hasUnder = value.indexOf("_") !== -1;
      if (hasMinus || hasUnder) {
        var invalidChar = hasMinus ? "-" : "_";
        throw invalidFormat(format, "Invalid character '" + invalidChar + "' found: is it base64url encoded?");
      }
      break;
    }
    case StringFormat.BASE64URL: {
      var hasPlus = value.indexOf("+") !== -1;
      var hasSlash = value.indexOf("/") !== -1;
      if (hasPlus || hasSlash) {
        var invalidChar = hasPlus ? "+" : "/";
        throw invalidFormat(format, "Invalid character '" + invalidChar + "' found: is it base64 encoded?");
      }
      value = value.replace(/-/g, "+").replace(/_/g, "/");
      break;
    }
  }
  var bytes;
  try {
    bytes = atob(value);
  } catch (e) {
    throw invalidFormat(format, "Invalid character found");
  }
  var array = new Uint8Array(bytes.length);
  for (var i2 = 0; i2 < bytes.length; i2++) {
    array[i2] = bytes.charCodeAt(i2);
  }
  return array;
}
var DataURLParts = (
  /** @class */
  /* @__PURE__ */ function() {
    function DataURLParts2(dataURL) {
      this.base64 = false;
      this.contentType = null;
      var matches = dataURL.match(/^data:([^,]+)?,/);
      if (matches === null) {
        throw invalidFormat(StringFormat.DATA_URL, "Must be formatted 'data:[<mediatype>][;base64],<data>");
      }
      var middle = matches[1] || null;
      if (middle != null) {
        this.base64 = endsWith(middle, ";base64");
        this.contentType = this.base64 ? middle.substring(0, middle.length - ";base64".length) : middle;
      }
      this.rest = dataURL.substring(dataURL.indexOf(",") + 1);
    }
    return DataURLParts2;
  }()
);
function dataURLBytes_(dataUrl) {
  var parts = new DataURLParts(dataUrl);
  if (parts.base64) {
    return base64Bytes_(StringFormat.BASE64, parts.rest);
  } else {
    return percentEncodedBytes_(parts.rest);
  }
}
function dataURLContentType_(dataUrl) {
  var parts = new DataURLParts(dataUrl);
  return parts.contentType;
}
function endsWith(s, end) {
  var longEnough = s.length >= end.length;
  if (!longEnough) {
    return false;
  }
  return s.substring(s.length - end.length) === end;
}
var TaskEvent = {
  /** Triggered whenever the task changes or progress is updated. */
  STATE_CHANGED: "state_changed"
};
var InternalTaskState = {
  RUNNING: "running",
  PAUSING: "pausing",
  PAUSED: "paused",
  SUCCESS: "success",
  CANCELING: "canceling",
  CANCELED: "canceled",
  ERROR: "error"
};
var TaskState = {
  /** The task is currently transferring data. */
  RUNNING: "running",
  /** The task was paused by the user. */
  PAUSED: "paused",
  /** The task completed successfully. */
  SUCCESS: "success",
  /** The task was canceled. */
  CANCELED: "canceled",
  /** The task failed with an error. */
  ERROR: "error"
};
function taskStateFromInternalTaskState(state) {
  switch (state) {
    case InternalTaskState.RUNNING:
    case InternalTaskState.PAUSING:
    case InternalTaskState.CANCELING:
      return TaskState.RUNNING;
    case InternalTaskState.PAUSED:
      return TaskState.PAUSED;
    case InternalTaskState.SUCCESS:
      return TaskState.SUCCESS;
    case InternalTaskState.CANCELED:
      return TaskState.CANCELED;
    case InternalTaskState.ERROR:
      return TaskState.ERROR;
    default:
      return TaskState.ERROR;
  }
}
function isDef(p2) {
  return p2 != null;
}
function isJustDef(p2) {
  return p2 !== void 0;
}
function isFunction(p2) {
  return typeof p2 === "function";
}
function isObject(p2) {
  return typeof p2 === "object";
}
function isNonNullObject(p2) {
  return isObject(p2) && p2 !== null;
}
function isNonArrayObject(p2) {
  return isObject(p2) && !Array.isArray(p2);
}
function isString(p2) {
  return typeof p2 === "string" || p2 instanceof String;
}
function isInteger(p2) {
  return isNumber(p2) && Number.isInteger(p2);
}
function isNumber(p2) {
  return typeof p2 === "number" || p2 instanceof Number;
}
function isNativeBlob(p2) {
  return isNativeBlobDefined() && p2 instanceof Blob;
}
function isNativeBlobDefined() {
  return typeof Blob !== "undefined";
}
var ErrorCode2;
(function(ErrorCode3) {
  ErrorCode3[ErrorCode3["NO_ERROR"] = 0] = "NO_ERROR";
  ErrorCode3[ErrorCode3["NETWORK_ERROR"] = 1] = "NETWORK_ERROR";
  ErrorCode3[ErrorCode3["ABORT"] = 2] = "ABORT";
})(ErrorCode2 || (ErrorCode2 = {}));
var NetworkXhrIo = (
  /** @class */
  function() {
    function NetworkXhrIo2() {
      var _this = this;
      this.sent_ = false;
      this.xhr_ = new XMLHttpRequest();
      this.errorCode_ = ErrorCode2.NO_ERROR;
      this.sendPromise_ = new Promise(function(resolve2) {
        _this.xhr_.addEventListener("abort", function() {
          _this.errorCode_ = ErrorCode2.ABORT;
          resolve2(_this);
        });
        _this.xhr_.addEventListener("error", function() {
          _this.errorCode_ = ErrorCode2.NETWORK_ERROR;
          resolve2(_this);
        });
        _this.xhr_.addEventListener("load", function() {
          resolve2(_this);
        });
      });
    }
    NetworkXhrIo2.prototype.send = function(url, method, body, headers) {
      if (this.sent_) {
        throw internalError("cannot .send() more than once");
      }
      this.sent_ = true;
      this.xhr_.open(method, url, true);
      if (isDef(headers)) {
        for (var key in headers) {
          if (headers.hasOwnProperty(key)) {
            this.xhr_.setRequestHeader(key, headers[key].toString());
          }
        }
      }
      if (isDef(body)) {
        this.xhr_.send(body);
      } else {
        this.xhr_.send();
      }
      return this.sendPromise_;
    };
    NetworkXhrIo2.prototype.getErrorCode = function() {
      if (!this.sent_) {
        throw internalError("cannot .getErrorCode() before sending");
      }
      return this.errorCode_;
    };
    NetworkXhrIo2.prototype.getStatus = function() {
      if (!this.sent_) {
        throw internalError("cannot .getStatus() before sending");
      }
      try {
        return this.xhr_.status;
      } catch (e) {
        return -1;
      }
    };
    NetworkXhrIo2.prototype.getResponseText = function() {
      if (!this.sent_) {
        throw internalError("cannot .getResponseText() before sending");
      }
      return this.xhr_.responseText;
    };
    NetworkXhrIo2.prototype.abort = function() {
      this.xhr_.abort();
    };
    NetworkXhrIo2.prototype.getResponseHeader = function(header) {
      return this.xhr_.getResponseHeader(header);
    };
    NetworkXhrIo2.prototype.addUploadProgressListener = function(listener) {
      if (isDef(this.xhr_.upload)) {
        this.xhr_.upload.addEventListener("progress", listener);
      }
    };
    NetworkXhrIo2.prototype.removeUploadProgressListener = function(listener) {
      if (isDef(this.xhr_.upload)) {
        this.xhr_.upload.removeEventListener("progress", listener);
      }
    };
    return NetworkXhrIo2;
  }()
);
var XhrIoPool = (
  /** @class */
  function() {
    function XhrIoPool2() {
    }
    XhrIoPool2.prototype.createXhrIo = function() {
      return new NetworkXhrIo();
    };
    return XhrIoPool2;
  }()
);
function getBlobBuilder() {
  if (typeof BlobBuilder !== "undefined") {
    return BlobBuilder;
  } else if (typeof WebKitBlobBuilder !== "undefined") {
    return WebKitBlobBuilder;
  } else {
    return void 0;
  }
}
function getBlob() {
  var args = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    args[_i2] = arguments[_i2];
  }
  var BlobBuilder2 = getBlobBuilder();
  if (BlobBuilder2 !== void 0) {
    var bb2 = new BlobBuilder2();
    for (var i2 = 0; i2 < args.length; i2++) {
      bb2.append(args[i2]);
    }
    return bb2.getBlob();
  } else {
    if (isNativeBlobDefined()) {
      return new Blob(args);
    } else {
      throw Error("This browser doesn't seem to support creating Blobs");
    }
  }
}
function sliceBlob(blob, start2, end) {
  if (blob.webkitSlice) {
    return blob.webkitSlice(start2, end);
  } else if (blob.mozSlice) {
    return blob.mozSlice(start2, end);
  } else if (blob.slice) {
    return blob.slice(start2, end);
  }
  return null;
}
var FbsBlob = (
  /** @class */
  function() {
    function FbsBlob2(data, elideCopy) {
      var size = 0;
      var blobType = "";
      if (isNativeBlob(data)) {
        this.data_ = data;
        size = data.size;
        blobType = data.type;
      } else if (data instanceof ArrayBuffer) {
        if (elideCopy) {
          this.data_ = new Uint8Array(data);
        } else {
          this.data_ = new Uint8Array(data.byteLength);
          this.data_.set(new Uint8Array(data));
        }
        size = this.data_.length;
      } else if (data instanceof Uint8Array) {
        if (elideCopy) {
          this.data_ = data;
        } else {
          this.data_ = new Uint8Array(data.length);
          this.data_.set(data);
        }
        size = data.length;
      }
      this.size_ = size;
      this.type_ = blobType;
    }
    FbsBlob2.prototype.size = function() {
      return this.size_;
    };
    FbsBlob2.prototype.type = function() {
      return this.type_;
    };
    FbsBlob2.prototype.slice = function(startByte, endByte) {
      if (isNativeBlob(this.data_)) {
        var realBlob = this.data_;
        var sliced = sliceBlob(realBlob, startByte, endByte);
        if (sliced === null) {
          return null;
        }
        return new FbsBlob2(sliced);
      } else {
        var slice = new Uint8Array(this.data_.buffer, startByte, endByte - startByte);
        return new FbsBlob2(slice, true);
      }
    };
    FbsBlob2.getBlob = function() {
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      if (isNativeBlobDefined()) {
        var blobby = args.map(function(val) {
          if (val instanceof FbsBlob2) {
            return val.data_;
          } else {
            return val;
          }
        });
        return new FbsBlob2(getBlob.apply(null, blobby));
      } else {
        var uint8Arrays = args.map(function(val) {
          if (isString(val)) {
            return dataFromString(StringFormat.RAW, val).data;
          } else {
            return val.data_;
          }
        });
        var finalLength_1 = 0;
        uint8Arrays.forEach(function(array) {
          finalLength_1 += array.byteLength;
        });
        var merged_1 = new Uint8Array(finalLength_1);
        var index_1 = 0;
        uint8Arrays.forEach(function(array) {
          for (var i2 = 0; i2 < array.length; i2++) {
            merged_1[index_1++] = array[i2];
          }
        });
        return new FbsBlob2(merged_1, true);
      }
    };
    FbsBlob2.prototype.uploadData = function() {
      return this.data_;
    };
    return FbsBlob2;
  }()
);
var Location = (
  /** @class */
  function() {
    function Location2(bucket, path) {
      this.bucket = bucket;
      this.path_ = path;
    }
    Object.defineProperty(Location2.prototype, "path", {
      get: function() {
        return this.path_;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Location2.prototype, "isRoot", {
      get: function() {
        return this.path.length === 0;
      },
      enumerable: false,
      configurable: true
    });
    Location2.prototype.fullServerUrl = function() {
      var encode = encodeURIComponent;
      return "/b/" + encode(this.bucket) + "/o/" + encode(this.path);
    };
    Location2.prototype.bucketOnlyServerUrl = function() {
      var encode = encodeURIComponent;
      return "/b/" + encode(this.bucket) + "/o";
    };
    Location2.makeFromBucketSpec = function(bucketString) {
      var bucketLocation;
      try {
        bucketLocation = Location2.makeFromUrl(bucketString);
      } catch (e) {
        return new Location2(bucketString, "");
      }
      if (bucketLocation.path === "") {
        return bucketLocation;
      } else {
        throw invalidDefaultBucket(bucketString);
      }
    };
    Location2.makeFromUrl = function(url) {
      var location = null;
      var bucketDomain = "([A-Za-z0-9.\\-_]+)";
      function gsModify(loc) {
        if (loc.path.charAt(loc.path.length - 1) === "/") {
          loc.path_ = loc.path_.slice(0, -1);
        }
      }
      var gsPath = "(/(.*))?$";
      var gsRegex = new RegExp("^gs://" + bucketDomain + gsPath, "i");
      var gsIndices = { bucket: 1, path: 3 };
      function httpModify(loc) {
        loc.path_ = decodeURIComponent(loc.path);
      }
      var version3 = "v[A-Za-z0-9_]+";
      var firebaseStorageHost = DEFAULT_HOST.replace(/[.]/g, "\\.");
      var firebaseStoragePath = "(/([^?#]*).*)?$";
      var firebaseStorageRegExp = new RegExp("^https?://" + firebaseStorageHost + "/" + version3 + "/b/" + bucketDomain + "/o" + firebaseStoragePath, "i");
      var firebaseStorageIndices = { bucket: 1, path: 3 };
      var cloudStorageHost = "(?:storage.googleapis.com|storage.cloud.google.com)";
      var cloudStoragePath = "([^?#]*)";
      var cloudStorageRegExp = new RegExp("^https?://" + cloudStorageHost + "/" + bucketDomain + "/" + cloudStoragePath, "i");
      var cloudStorageIndices = { bucket: 1, path: 2 };
      var groups = [
        { regex: gsRegex, indices: gsIndices, postModify: gsModify },
        {
          regex: firebaseStorageRegExp,
          indices: firebaseStorageIndices,
          postModify: httpModify
        },
        {
          regex: cloudStorageRegExp,
          indices: cloudStorageIndices,
          postModify: httpModify
        }
      ];
      for (var i2 = 0; i2 < groups.length; i2++) {
        var group = groups[i2];
        var captures = group.regex.exec(url);
        if (captures) {
          var bucketValue = captures[group.indices.bucket];
          var pathValue = captures[group.indices.path];
          if (!pathValue) {
            pathValue = "";
          }
          location = new Location2(bucketValue, pathValue);
          group.postModify(location);
          break;
        }
      }
      if (location == null) {
        throw invalidUrl(url);
      }
      return location;
    };
    return Location2;
  }()
);
function jsonObjectOrNull(s) {
  var obj;
  try {
    obj = JSON.parse(s);
  } catch (e) {
    return null;
  }
  if (isNonArrayObject(obj)) {
    return obj;
  } else {
    return null;
  }
}
function parent(path) {
  if (path.length === 0) {
    return null;
  }
  var index = path.lastIndexOf("/");
  if (index === -1) {
    return "";
  }
  var newPath = path.slice(0, index);
  return newPath;
}
function child(path, childPath) {
  var canonicalChildPath = childPath.split("/").filter(function(component) {
    return component.length > 0;
  }).join("/");
  if (path.length === 0) {
    return canonicalChildPath;
  } else {
    return path + "/" + canonicalChildPath;
  }
}
function lastComponent(path) {
  var index = path.lastIndexOf("/", path.length - 2);
  if (index === -1) {
    return path;
  } else {
    return path.slice(index + 1);
  }
}
function makeUrl(urlPart) {
  return "https://" + DEFAULT_HOST + "/v0" + urlPart;
}
function makeQueryString(params) {
  var encode = encodeURIComponent;
  var queryPart = "?";
  for (var key in params) {
    if (params.hasOwnProperty(key)) {
      var nextPart = encode(key) + "=" + encode(params[key]);
      queryPart = queryPart + nextPart + "&";
    }
  }
  queryPart = queryPart.slice(0, -1);
  return queryPart;
}
function noXform_(metadata, value) {
  return value;
}
var Mapping = (
  /** @class */
  /* @__PURE__ */ function() {
    function Mapping2(server, local, writable, xform) {
      this.server = server;
      this.local = local || server;
      this.writable = !!writable;
      this.xform = xform || noXform_;
    }
    return Mapping2;
  }()
);
var mappings_ = null;
function xformPath(fullPath) {
  if (!isString(fullPath) || fullPath.length < 2) {
    return fullPath;
  } else {
    return lastComponent(fullPath);
  }
}
function getMappings() {
  if (mappings_) {
    return mappings_;
  }
  var mappings = [];
  mappings.push(new Mapping("bucket"));
  mappings.push(new Mapping("generation"));
  mappings.push(new Mapping("metageneration"));
  mappings.push(new Mapping("name", "fullPath", true));
  function mappingsXformPath(_metadata, fullPath) {
    return xformPath(fullPath);
  }
  var nameMapping = new Mapping("name");
  nameMapping.xform = mappingsXformPath;
  mappings.push(nameMapping);
  function xformSize(_metadata, size) {
    if (isDef(size)) {
      return Number(size);
    } else {
      return size;
    }
  }
  var sizeMapping = new Mapping("size");
  sizeMapping.xform = xformSize;
  mappings.push(sizeMapping);
  mappings.push(new Mapping("timeCreated"));
  mappings.push(new Mapping("updated"));
  mappings.push(new Mapping("md5Hash", null, true));
  mappings.push(new Mapping("cacheControl", null, true));
  mappings.push(new Mapping("contentDisposition", null, true));
  mappings.push(new Mapping("contentEncoding", null, true));
  mappings.push(new Mapping("contentLanguage", null, true));
  mappings.push(new Mapping("contentType", null, true));
  mappings.push(new Mapping("metadata", "customMetadata", true));
  mappings_ = mappings;
  return mappings_;
}
function addRef(metadata, service) {
  function generateRef() {
    var bucket = metadata["bucket"];
    var path = metadata["fullPath"];
    var loc = new Location(bucket, path);
    return service.makeStorageReference(loc);
  }
  Object.defineProperty(metadata, "ref", { get: generateRef });
}
function fromResource(service, resource, mappings) {
  var metadata = {};
  metadata["type"] = "file";
  var len = mappings.length;
  for (var i2 = 0; i2 < len; i2++) {
    var mapping = mappings[i2];
    metadata[mapping.local] = mapping.xform(metadata, resource[mapping.server]);
  }
  addRef(metadata, service);
  return metadata;
}
function fromResourceString(service, resourceString, mappings) {
  var obj = jsonObjectOrNull(resourceString);
  if (obj === null) {
    return null;
  }
  var resource = obj;
  return fromResource(service, resource, mappings);
}
function downloadUrlFromResourceString(metadata, resourceString) {
  var obj = jsonObjectOrNull(resourceString);
  if (obj === null) {
    return null;
  }
  if (!isString(obj["downloadTokens"])) {
    return null;
  }
  var tokens = obj["downloadTokens"];
  if (tokens.length === 0) {
    return null;
  }
  var encode = encodeURIComponent;
  var tokensList = tokens.split(",");
  var urls = tokensList.map(function(token) {
    var bucket = metadata["bucket"];
    var path = metadata["fullPath"];
    var urlPart = "/b/" + encode(bucket) + "/o/" + encode(path);
    var base = makeUrl(urlPart);
    var queryString = makeQueryString({
      alt: "media",
      token
    });
    return base + queryString;
  });
  return urls[0];
}
function toResourceString(metadata, mappings) {
  var resource = {};
  var len = mappings.length;
  for (var i2 = 0; i2 < len; i2++) {
    var mapping = mappings[i2];
    if (mapping.writable) {
      resource[mapping.server] = metadata[mapping.local];
    }
  }
  return JSON.stringify(resource);
}
function metadataValidator(p2) {
  if (!isObject(p2) || !p2) {
    throw "Expected Metadata object.";
  }
  for (var key in p2) {
    if (p2.hasOwnProperty(key)) {
      var val = p2[key];
      if (key === "customMetadata") {
        if (!isObject(val)) {
          throw "Expected object for 'customMetadata' mapping.";
        }
      } else {
        if (isNonNullObject(val)) {
          throw "Mapping for '" + key + "' cannot be an object.";
        }
      }
    }
  }
}
var MAX_RESULTS_KEY = "maxResults";
var MAX_MAX_RESULTS = 1e3;
var PAGE_TOKEN_KEY = "pageToken";
var PREFIXES_KEY = "prefixes";
var ITEMS_KEY = "items";
function fromBackendResponse(service, bucket, resource) {
  var listResult = {
    prefixes: [],
    items: [],
    nextPageToken: resource["nextPageToken"]
  };
  if (resource[PREFIXES_KEY]) {
    for (var _i2 = 0, _a3 = resource[PREFIXES_KEY]; _i2 < _a3.length; _i2++) {
      var path = _a3[_i2];
      var pathWithoutTrailingSlash = path.replace(/\/$/, "");
      var reference = service.makeStorageReference(new Location(bucket, pathWithoutTrailingSlash));
      listResult.prefixes.push(reference);
    }
  }
  if (resource[ITEMS_KEY]) {
    for (var _b = 0, _c = resource[ITEMS_KEY]; _b < _c.length; _b++) {
      var item = _c[_b];
      var reference = service.makeStorageReference(new Location(bucket, item["name"]));
      listResult.items.push(reference);
    }
  }
  return listResult;
}
function fromResponseString(service, bucket, resourceString) {
  var obj = jsonObjectOrNull(resourceString);
  if (obj === null) {
    return null;
  }
  var resource = obj;
  return fromBackendResponse(service, bucket, resource);
}
function listOptionsValidator(p2) {
  if (!isObject(p2) || !p2) {
    throw "Expected ListOptions object.";
  }
  for (var key in p2) {
    if (key === MAX_RESULTS_KEY) {
      if (!isInteger(p2[MAX_RESULTS_KEY]) || p2[MAX_RESULTS_KEY] <= 0) {
        throw "Expected maxResults to be a positive number.";
      }
      if (p2[MAX_RESULTS_KEY] > 1e3) {
        throw "Expected maxResults to be less than or equal to " + MAX_MAX_RESULTS + ".";
      }
    } else if (key === PAGE_TOKEN_KEY) {
      if (p2[PAGE_TOKEN_KEY] && !isString(p2[PAGE_TOKEN_KEY])) {
        throw "Expected pageToken to be string.";
      }
    } else {
      throw "Unknown option: " + key;
    }
  }
}
var RequestInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function RequestInfo2(url, method, handler, timeout) {
      this.url = url;
      this.method = method;
      this.handler = handler;
      this.timeout = timeout;
      this.urlParams = {};
      this.headers = {};
      this.body = null;
      this.errorHandler = null;
      this.progressCallback = null;
      this.successCodes = [200];
      this.additionalRetryCodes = [];
    }
    return RequestInfo2;
  }()
);
function handlerCheck(cndn) {
  if (!cndn) {
    throw unknown();
  }
}
function metadataHandler(service, mappings) {
  function handler(xhr, text) {
    var metadata = fromResourceString(service, text, mappings);
    handlerCheck(metadata !== null);
    return metadata;
  }
  return handler;
}
function listHandler(service, bucket) {
  function handler(xhr, text) {
    var listResult = fromResponseString(service, bucket, text);
    handlerCheck(listResult !== null);
    return listResult;
  }
  return handler;
}
function downloadUrlHandler(service, mappings) {
  function handler(xhr, text) {
    var metadata = fromResourceString(service, text, mappings);
    handlerCheck(metadata !== null);
    return downloadUrlFromResourceString(metadata, text);
  }
  return handler;
}
function sharedErrorHandler(location) {
  function errorHandler(xhr, err) {
    var newErr;
    if (xhr.getStatus() === 401) {
      newErr = unauthenticated();
    } else {
      if (xhr.getStatus() === 402) {
        newErr = quotaExceeded(location.bucket);
      } else {
        if (xhr.getStatus() === 403) {
          newErr = unauthorized(location.path);
        } else {
          newErr = err;
        }
      }
    }
    newErr.setServerResponseProp(err.serverResponseProp());
    return newErr;
  }
  return errorHandler;
}
function objectErrorHandler(location) {
  var shared = sharedErrorHandler(location);
  function errorHandler(xhr, err) {
    var newErr = shared(xhr, err);
    if (xhr.getStatus() === 404) {
      newErr = objectNotFound(location.path);
    }
    newErr.setServerResponseProp(err.serverResponseProp());
    return newErr;
  }
  return errorHandler;
}
function getMetadata(service, location, mappings) {
  var urlPart = location.fullServerUrl();
  var url = makeUrl(urlPart);
  var method = "GET";
  var timeout = service.maxOperationRetryTime;
  var requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);
  requestInfo.errorHandler = objectErrorHandler(location);
  return requestInfo;
}
function list(service, location, delimiter, pageToken, maxResults) {
  var urlParams = {};
  if (location.isRoot) {
    urlParams["prefix"] = "";
  } else {
    urlParams["prefix"] = location.path + "/";
  }
  if (delimiter && delimiter.length > 0) {
    urlParams["delimiter"] = delimiter;
  }
  if (pageToken) {
    urlParams["pageToken"] = pageToken;
  }
  if (maxResults) {
    urlParams["maxResults"] = maxResults;
  }
  var urlPart = location.bucketOnlyServerUrl();
  var url = makeUrl(urlPart);
  var method = "GET";
  var timeout = service.maxOperationRetryTime;
  var requestInfo = new RequestInfo(url, method, listHandler(service, location.bucket), timeout);
  requestInfo.urlParams = urlParams;
  requestInfo.errorHandler = sharedErrorHandler(location);
  return requestInfo;
}
function getDownloadUrl(service, location, mappings) {
  var urlPart = location.fullServerUrl();
  var url = makeUrl(urlPart);
  var method = "GET";
  var timeout = service.maxOperationRetryTime;
  var requestInfo = new RequestInfo(url, method, downloadUrlHandler(service, mappings), timeout);
  requestInfo.errorHandler = objectErrorHandler(location);
  return requestInfo;
}
function updateMetadata(service, location, metadata, mappings) {
  var urlPart = location.fullServerUrl();
  var url = makeUrl(urlPart);
  var method = "PATCH";
  var body = toResourceString(metadata, mappings);
  var headers = { "Content-Type": "application/json; charset=utf-8" };
  var timeout = service.maxOperationRetryTime;
  var requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);
  requestInfo.headers = headers;
  requestInfo.body = body;
  requestInfo.errorHandler = objectErrorHandler(location);
  return requestInfo;
}
function deleteObject(service, location) {
  var urlPart = location.fullServerUrl();
  var url = makeUrl(urlPart);
  var method = "DELETE";
  var timeout = service.maxOperationRetryTime;
  function handler(_xhr, _text) {
  }
  var requestInfo = new RequestInfo(url, method, handler, timeout);
  requestInfo.successCodes = [200, 204];
  requestInfo.errorHandler = objectErrorHandler(location);
  return requestInfo;
}
function determineContentType_(metadata, blob) {
  return metadata && metadata["contentType"] || blob && blob.type() || "application/octet-stream";
}
function metadataForUpload_(location, blob, metadata) {
  var metadataClone = Object.assign({}, metadata);
  metadataClone["fullPath"] = location.path;
  metadataClone["size"] = blob.size();
  if (!metadataClone["contentType"]) {
    metadataClone["contentType"] = determineContentType_(null, blob);
  }
  return metadataClone;
}
function multipartUpload(service, location, mappings, blob, metadata) {
  var urlPart = location.bucketOnlyServerUrl();
  var headers = {
    "X-Goog-Upload-Protocol": "multipart"
  };
  function genBoundary() {
    var str = "";
    for (var i2 = 0; i2 < 2; i2++) {
      str = str + Math.random().toString().slice(2);
    }
    return str;
  }
  var boundary = genBoundary();
  headers["Content-Type"] = "multipart/related; boundary=" + boundary;
  var metadata_ = metadataForUpload_(location, blob, metadata);
  var metadataString = toResourceString(metadata_, mappings);
  var preBlobPart = "--" + boundary + "\r\nContent-Type: application/json; charset=utf-8\r\n\r\n" + metadataString + "\r\n--" + boundary + "\r\nContent-Type: " + metadata_["contentType"] + "\r\n\r\n";
  var postBlobPart = "\r\n--" + boundary + "--";
  var body = FbsBlob.getBlob(preBlobPart, blob, postBlobPart);
  if (body === null) {
    throw cannotSliceBlob();
  }
  var urlParams = { name: metadata_["fullPath"] };
  var url = makeUrl(urlPart);
  var method = "POST";
  var timeout = service.maxUploadRetryTime;
  var requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);
  requestInfo.urlParams = urlParams;
  requestInfo.headers = headers;
  requestInfo.body = body.uploadData();
  requestInfo.errorHandler = sharedErrorHandler(location);
  return requestInfo;
}
var ResumableUploadStatus = (
  /** @class */
  /* @__PURE__ */ function() {
    function ResumableUploadStatus2(current, total, finalized, metadata) {
      this.current = current;
      this.total = total;
      this.finalized = !!finalized;
      this.metadata = metadata || null;
    }
    return ResumableUploadStatus2;
  }()
);
function checkResumeHeader_(xhr, allowed) {
  var status = null;
  try {
    status = xhr.getResponseHeader("X-Goog-Upload-Status");
  } catch (e) {
    handlerCheck(false);
  }
  var allowedStatus = allowed || ["active"];
  handlerCheck(!!status && allowedStatus.indexOf(status) !== -1);
  return status;
}
function createResumableUpload(service, location, mappings, blob, metadata) {
  var urlPart = location.bucketOnlyServerUrl();
  var metadataForUpload = metadataForUpload_(location, blob, metadata);
  var urlParams = { name: metadataForUpload["fullPath"] };
  var url = makeUrl(urlPart);
  var method = "POST";
  var headers = {
    "X-Goog-Upload-Protocol": "resumable",
    "X-Goog-Upload-Command": "start",
    "X-Goog-Upload-Header-Content-Length": blob.size(),
    "X-Goog-Upload-Header-Content-Type": metadataForUpload["contentType"],
    "Content-Type": "application/json; charset=utf-8"
  };
  var body = toResourceString(metadataForUpload, mappings);
  var timeout = service.maxUploadRetryTime;
  function handler(xhr) {
    checkResumeHeader_(xhr);
    var url2;
    try {
      url2 = xhr.getResponseHeader("X-Goog-Upload-URL");
    } catch (e) {
      handlerCheck(false);
    }
    handlerCheck(isString(url2));
    return url2;
  }
  var requestInfo = new RequestInfo(url, method, handler, timeout);
  requestInfo.urlParams = urlParams;
  requestInfo.headers = headers;
  requestInfo.body = body;
  requestInfo.errorHandler = sharedErrorHandler(location);
  return requestInfo;
}
function getResumableUploadStatus(service, location, url, blob) {
  var headers = { "X-Goog-Upload-Command": "query" };
  function handler(xhr) {
    var status = checkResumeHeader_(xhr, ["active", "final"]);
    var sizeString = null;
    try {
      sizeString = xhr.getResponseHeader("X-Goog-Upload-Size-Received");
    } catch (e) {
      handlerCheck(false);
    }
    if (!sizeString) {
      handlerCheck(false);
    }
    var size = Number(sizeString);
    handlerCheck(!isNaN(size));
    return new ResumableUploadStatus(size, blob.size(), status === "final");
  }
  var method = "POST";
  var timeout = service.maxUploadRetryTime;
  var requestInfo = new RequestInfo(url, method, handler, timeout);
  requestInfo.headers = headers;
  requestInfo.errorHandler = sharedErrorHandler(location);
  return requestInfo;
}
var resumableUploadChunkSize = 256 * 1024;
function continueResumableUpload(location, service, url, blob, chunkSize, mappings, status, progressCallback) {
  var status_ = new ResumableUploadStatus(0, 0);
  if (status) {
    status_.current = status.current;
    status_.total = status.total;
  } else {
    status_.current = 0;
    status_.total = blob.size();
  }
  if (blob.size() !== status_.total) {
    throw serverFileWrongSize();
  }
  var bytesLeft = status_.total - status_.current;
  var bytesToUpload = bytesLeft;
  if (chunkSize > 0) {
    bytesToUpload = Math.min(bytesToUpload, chunkSize);
  }
  var startByte = status_.current;
  var endByte = startByte + bytesToUpload;
  var uploadCommand = bytesToUpload === bytesLeft ? "upload, finalize" : "upload";
  var headers = {
    "X-Goog-Upload-Command": uploadCommand,
    "X-Goog-Upload-Offset": status_.current
  };
  var body = blob.slice(startByte, endByte);
  if (body === null) {
    throw cannotSliceBlob();
  }
  function handler(xhr, text) {
    var uploadStatus = checkResumeHeader_(xhr, ["active", "final"]);
    var newCurrent = status_.current + bytesToUpload;
    var size = blob.size();
    var metadata;
    if (uploadStatus === "final") {
      metadata = metadataHandler(service, mappings)(xhr, text);
    } else {
      metadata = null;
    }
    return new ResumableUploadStatus(newCurrent, size, uploadStatus === "final", metadata);
  }
  var method = "POST";
  var timeout = service.maxUploadRetryTime;
  var requestInfo = new RequestInfo(url, method, handler, timeout);
  requestInfo.headers = headers;
  requestInfo.body = body.uploadData();
  requestInfo.progressCallback = progressCallback || null;
  requestInfo.errorHandler = sharedErrorHandler(location);
  return requestInfo;
}
var Observer = (
  /** @class */
  /* @__PURE__ */ function() {
    function Observer2(nextOrObserver, error, complete) {
      var asFunctions = isFunction(nextOrObserver) || isDef(error) || isDef(complete);
      if (asFunctions) {
        this.next = nextOrObserver;
        this.error = error || null;
        this.complete = complete || null;
      } else {
        var observer = nextOrObserver;
        this.next = observer.next || null;
        this.error = observer.error || null;
        this.complete = observer.complete || null;
      }
    }
    return Observer2;
  }()
);
var UploadTaskSnapshot = (
  /** @class */
  /* @__PURE__ */ function() {
    function UploadTaskSnapshot2(bytesTransferred, totalBytes, state, metadata, task, ref) {
      this.bytesTransferred = bytesTransferred;
      this.totalBytes = totalBytes;
      this.state = state;
      this.metadata = metadata;
      this.task = task;
      this.ref = ref;
    }
    return UploadTaskSnapshot2;
  }()
);
function validate(name4, specs, passed) {
  var minArgs = specs.length;
  var maxArgs = specs.length;
  for (var i2 = 0; i2 < specs.length; i2++) {
    if (specs[i2].optional) {
      minArgs = i2;
      break;
    }
  }
  var validLength = minArgs <= passed.length && passed.length <= maxArgs;
  if (!validLength) {
    throw invalidArgumentCount(minArgs, maxArgs, name4, passed.length);
  }
  for (var i2 = 0; i2 < passed.length; i2++) {
    try {
      specs[i2].validator(passed[i2]);
    } catch (e) {
      if (e instanceof Error) {
        throw invalidArgument(i2, name4, e.message);
      } else {
        throw invalidArgument(i2, name4, e);
      }
    }
  }
}
var ArgSpec = (
  /** @class */
  /* @__PURE__ */ function() {
    function ArgSpec2(validator, optional) {
      var self2 = this;
      this.validator = function(p2) {
        if (self2.optional && !isJustDef(p2)) {
          return;
        }
        validator(p2);
      };
      this.optional = !!optional;
    }
    return ArgSpec2;
  }()
);
function and_(v1, v2) {
  return function(p2) {
    v1(p2);
    v2(p2);
  };
}
function stringSpec(validator, optional) {
  function stringValidator(p2) {
    if (!isString(p2)) {
      throw "Expected string.";
    }
  }
  var chainedValidator;
  if (validator) {
    chainedValidator = and_(stringValidator, validator);
  } else {
    chainedValidator = stringValidator;
  }
  return new ArgSpec(chainedValidator, optional);
}
function uploadDataSpec() {
  function validator(p2) {
    var valid = p2 instanceof Uint8Array || p2 instanceof ArrayBuffer || isNativeBlobDefined() && p2 instanceof Blob;
    if (!valid) {
      throw "Expected Blob or File.";
    }
  }
  return new ArgSpec(validator);
}
function metadataSpec(optional) {
  return new ArgSpec(metadataValidator, optional);
}
function listOptionSpec(optional) {
  return new ArgSpec(listOptionsValidator, optional);
}
function nonNegativeNumberSpec() {
  function validator(p2) {
    var valid = isNumber(p2) && p2 >= 0;
    if (!valid) {
      throw "Expected a number 0 or greater.";
    }
  }
  return new ArgSpec(validator);
}
function looseObjectSpec(validator, optional) {
  function isLooseObjectValidator(p2) {
    var isLooseObject = p2 === null || isDef(p2) && p2 instanceof Object;
    if (!isLooseObject) {
      throw "Expected an Object.";
    }
    if (validator !== void 0 && validator !== null) {
      validator(p2);
    }
  }
  return new ArgSpec(isLooseObjectValidator, optional);
}
function nullFunctionSpec(optional) {
  function validator(p2) {
    var valid = p2 === null || isFunction(p2);
    if (!valid) {
      throw "Expected a Function.";
    }
  }
  return new ArgSpec(validator, optional);
}
function async(f) {
  return function() {
    var argsToForward = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      argsToForward[_i2] = arguments[_i2];
    }
    Promise.resolve().then(function() {
      return f.apply(void 0, argsToForward);
    });
  };
}
var UploadTask = (
  /** @class */
  function() {
    function UploadTask2(ref, service, location, mappings, blob, metadata) {
      var _this = this;
      if (metadata === void 0) {
        metadata = null;
      }
      this.transferred_ = 0;
      this.needToFetchStatus_ = false;
      this.needToFetchMetadata_ = false;
      this.observers_ = [];
      this.error_ = null;
      this.uploadUrl_ = null;
      this.request_ = null;
      this.chunkMultiplier_ = 1;
      this.resolve_ = null;
      this.reject_ = null;
      this.ref_ = ref;
      this.service_ = service;
      this.location_ = location;
      this.blob_ = blob;
      this.metadata_ = metadata;
      this.mappings_ = mappings;
      this.resumable_ = this.shouldDoResumable_(this.blob_);
      this.state_ = InternalTaskState.RUNNING;
      this.errorHandler_ = function(error) {
        _this.request_ = null;
        _this.chunkMultiplier_ = 1;
        if (error.codeEquals(Code.CANCELED)) {
          _this.needToFetchStatus_ = true;
          _this.completeTransitions_();
        } else {
          _this.error_ = error;
          _this.transition_(InternalTaskState.ERROR);
        }
      };
      this.metadataErrorHandler_ = function(error) {
        _this.request_ = null;
        if (error.codeEquals(Code.CANCELED)) {
          _this.completeTransitions_();
        } else {
          _this.error_ = error;
          _this.transition_(InternalTaskState.ERROR);
        }
      };
      this.promise_ = new Promise(function(resolve2, reject) {
        _this.resolve_ = resolve2;
        _this.reject_ = reject;
        _this.start_();
      });
      this.promise_.then(null, function() {
      });
    }
    UploadTask2.prototype.makeProgressCallback_ = function() {
      var _this = this;
      var sizeBefore = this.transferred_;
      return function(loaded) {
        return _this.updateProgress_(sizeBefore + loaded);
      };
    };
    UploadTask2.prototype.shouldDoResumable_ = function(blob) {
      return blob.size() > 256 * 1024;
    };
    UploadTask2.prototype.start_ = function() {
      if (this.state_ !== InternalTaskState.RUNNING) {
        return;
      }
      if (this.request_ !== null) {
        return;
      }
      if (this.resumable_) {
        if (this.uploadUrl_ === null) {
          this.createResumable_();
        } else {
          if (this.needToFetchStatus_) {
            this.fetchStatus_();
          } else {
            if (this.needToFetchMetadata_) {
              this.fetchMetadata_();
            } else {
              this.continueUpload_();
            }
          }
        }
      } else {
        this.oneShotUpload_();
      }
    };
    UploadTask2.prototype.resolveToken_ = function(callback) {
      var _this = this;
      this.service_.getAuthToken().then(function(authToken) {
        switch (_this.state_) {
          case InternalTaskState.RUNNING:
            callback(authToken);
            break;
          case InternalTaskState.CANCELING:
            _this.transition_(InternalTaskState.CANCELED);
            break;
          case InternalTaskState.PAUSING:
            _this.transition_(InternalTaskState.PAUSED);
            break;
        }
      });
    };
    UploadTask2.prototype.createResumable_ = function() {
      var _this = this;
      this.resolveToken_(function(authToken) {
        var requestInfo = createResumableUpload(_this.service_, _this.location_, _this.mappings_, _this.blob_, _this.metadata_);
        var createRequest = _this.service_.makeRequest(requestInfo, authToken);
        _this.request_ = createRequest;
        createRequest.getPromise().then(function(url) {
          _this.request_ = null;
          _this.uploadUrl_ = url;
          _this.needToFetchStatus_ = false;
          _this.completeTransitions_();
        }, _this.errorHandler_);
      });
    };
    UploadTask2.prototype.fetchStatus_ = function() {
      var _this = this;
      var url = this.uploadUrl_;
      this.resolveToken_(function(authToken) {
        var requestInfo = getResumableUploadStatus(_this.service_, _this.location_, url, _this.blob_);
        var statusRequest = _this.service_.makeRequest(requestInfo, authToken);
        _this.request_ = statusRequest;
        statusRequest.getPromise().then(function(status) {
          status = status;
          _this.request_ = null;
          _this.updateProgress_(status.current);
          _this.needToFetchStatus_ = false;
          if (status.finalized) {
            _this.needToFetchMetadata_ = true;
          }
          _this.completeTransitions_();
        }, _this.errorHandler_);
      });
    };
    UploadTask2.prototype.continueUpload_ = function() {
      var _this = this;
      var chunkSize = resumableUploadChunkSize * this.chunkMultiplier_;
      var status = new ResumableUploadStatus(this.transferred_, this.blob_.size());
      var url = this.uploadUrl_;
      this.resolveToken_(function(authToken) {
        var requestInfo;
        try {
          requestInfo = continueResumableUpload(_this.location_, _this.service_, url, _this.blob_, chunkSize, _this.mappings_, status, _this.makeProgressCallback_());
        } catch (e) {
          _this.error_ = e;
          _this.transition_(InternalTaskState.ERROR);
          return;
        }
        var uploadRequest = _this.service_.makeRequest(requestInfo, authToken);
        _this.request_ = uploadRequest;
        uploadRequest.getPromise().then(function(newStatus) {
          _this.increaseMultiplier_();
          _this.request_ = null;
          _this.updateProgress_(newStatus.current);
          if (newStatus.finalized) {
            _this.metadata_ = newStatus.metadata;
            _this.transition_(InternalTaskState.SUCCESS);
          } else {
            _this.completeTransitions_();
          }
        }, _this.errorHandler_);
      });
    };
    UploadTask2.prototype.increaseMultiplier_ = function() {
      var currentSize = resumableUploadChunkSize * this.chunkMultiplier_;
      if (currentSize < 32 * 1024 * 1024) {
        this.chunkMultiplier_ *= 2;
      }
    };
    UploadTask2.prototype.fetchMetadata_ = function() {
      var _this = this;
      this.resolveToken_(function(authToken) {
        var requestInfo = getMetadata(_this.service_, _this.location_, _this.mappings_);
        var metadataRequest = _this.service_.makeRequest(requestInfo, authToken);
        _this.request_ = metadataRequest;
        metadataRequest.getPromise().then(function(metadata) {
          _this.request_ = null;
          _this.metadata_ = metadata;
          _this.transition_(InternalTaskState.SUCCESS);
        }, _this.metadataErrorHandler_);
      });
    };
    UploadTask2.prototype.oneShotUpload_ = function() {
      var _this = this;
      this.resolveToken_(function(authToken) {
        var requestInfo = multipartUpload(_this.service_, _this.location_, _this.mappings_, _this.blob_, _this.metadata_);
        var multipartRequest = _this.service_.makeRequest(requestInfo, authToken);
        _this.request_ = multipartRequest;
        multipartRequest.getPromise().then(function(metadata) {
          _this.request_ = null;
          _this.metadata_ = metadata;
          _this.updateProgress_(_this.blob_.size());
          _this.transition_(InternalTaskState.SUCCESS);
        }, _this.errorHandler_);
      });
    };
    UploadTask2.prototype.updateProgress_ = function(transferred) {
      var old = this.transferred_;
      this.transferred_ = transferred;
      if (this.transferred_ !== old) {
        this.notifyObservers_();
      }
    };
    UploadTask2.prototype.transition_ = function(state) {
      if (this.state_ === state) {
        return;
      }
      switch (state) {
        case InternalTaskState.CANCELING:
          this.state_ = state;
          if (this.request_ !== null) {
            this.request_.cancel();
          }
          break;
        case InternalTaskState.PAUSING:
          this.state_ = state;
          if (this.request_ !== null) {
            this.request_.cancel();
          }
          break;
        case InternalTaskState.RUNNING:
          var wasPaused = this.state_ === InternalTaskState.PAUSED;
          this.state_ = state;
          if (wasPaused) {
            this.notifyObservers_();
            this.start_();
          }
          break;
        case InternalTaskState.PAUSED:
          this.state_ = state;
          this.notifyObservers_();
          break;
        case InternalTaskState.CANCELED:
          this.error_ = canceled();
          this.state_ = state;
          this.notifyObservers_();
          break;
        case InternalTaskState.ERROR:
          this.state_ = state;
          this.notifyObservers_();
          break;
        case InternalTaskState.SUCCESS:
          this.state_ = state;
          this.notifyObservers_();
          break;
      }
    };
    UploadTask2.prototype.completeTransitions_ = function() {
      switch (this.state_) {
        case InternalTaskState.PAUSING:
          this.transition_(InternalTaskState.PAUSED);
          break;
        case InternalTaskState.CANCELING:
          this.transition_(InternalTaskState.CANCELED);
          break;
        case InternalTaskState.RUNNING:
          this.start_();
          break;
      }
    };
    Object.defineProperty(UploadTask2.prototype, "snapshot", {
      get: function() {
        var externalState = taskStateFromInternalTaskState(this.state_);
        return new UploadTaskSnapshot(this.transferred_, this.blob_.size(), externalState, this.metadata_, this, this.ref_);
      },
      enumerable: false,
      configurable: true
    });
    UploadTask2.prototype.on = function(type, nextOrObserver, error, completed) {
      function typeValidator() {
        if (type !== TaskEvent.STATE_CHANGED) {
          throw "Expected one of the event types: [" + TaskEvent.STATE_CHANGED + "].";
        }
      }
      var nextOrObserverMessage = "Expected a function or an Object with one of `next`, `error`, `complete` properties.";
      var nextValidator = nullFunctionSpec(true).validator;
      var observerValidator = looseObjectSpec(null, true).validator;
      function nextOrObserverValidator(p2) {
        try {
          nextValidator(p2);
          return;
        } catch (e) {
        }
        try {
          observerValidator(p2);
          var anyDefined = isJustDef(p2["next"]) || isJustDef(p2["error"]) || isJustDef(p2["complete"]);
          if (!anyDefined) {
            throw "";
          }
          return;
        } catch (e) {
          throw nextOrObserverMessage;
        }
      }
      var specs = [
        stringSpec(typeValidator),
        looseObjectSpec(nextOrObserverValidator, true),
        nullFunctionSpec(true),
        nullFunctionSpec(true)
      ];
      validate("on", specs, arguments);
      var self2 = this;
      function makeBinder(specs2) {
        function binder(nextOrObserver2, error2, complete) {
          if (specs2 !== null) {
            validate("on", specs2, arguments);
          }
          var observer = new Observer(nextOrObserver2, error2, completed);
          self2.addObserver_(observer);
          return function() {
            self2.removeObserver_(observer);
          };
        }
        return binder;
      }
      function binderNextOrObserverValidator(p2) {
        if (p2 === null) {
          throw nextOrObserverMessage;
        }
        nextOrObserverValidator(p2);
      }
      var binderSpecs = [
        looseObjectSpec(binderNextOrObserverValidator),
        nullFunctionSpec(true),
        nullFunctionSpec(true)
      ];
      var typeOnly = !(isJustDef(nextOrObserver) || isJustDef(error) || isJustDef(completed));
      if (typeOnly) {
        return makeBinder(binderSpecs);
      } else {
        return makeBinder(null)(nextOrObserver, error, completed);
      }
    };
    UploadTask2.prototype.then = function(onFulfilled, onRejected) {
      return this.promise_.then(onFulfilled, onRejected);
    };
    UploadTask2.prototype.catch = function(onRejected) {
      return this.then(null, onRejected);
    };
    UploadTask2.prototype.addObserver_ = function(observer) {
      this.observers_.push(observer);
      this.notifyObserver_(observer);
    };
    UploadTask2.prototype.removeObserver_ = function(observer) {
      var i2 = this.observers_.indexOf(observer);
      if (i2 !== -1) {
        this.observers_.splice(i2, 1);
      }
    };
    UploadTask2.prototype.notifyObservers_ = function() {
      var _this = this;
      this.finishPromise_();
      var observers = this.observers_.slice();
      observers.forEach(function(observer) {
        _this.notifyObserver_(observer);
      });
    };
    UploadTask2.prototype.finishPromise_ = function() {
      if (this.resolve_ !== null) {
        var triggered = true;
        switch (taskStateFromInternalTaskState(this.state_)) {
          case TaskState.SUCCESS:
            async(this.resolve_.bind(null, this.snapshot))();
            break;
          case TaskState.CANCELED:
          case TaskState.ERROR:
            var toCall = this.reject_;
            async(toCall.bind(null, this.error_))();
            break;
          default:
            triggered = false;
            break;
        }
        if (triggered) {
          this.resolve_ = null;
          this.reject_ = null;
        }
      }
    };
    UploadTask2.prototype.notifyObserver_ = function(observer) {
      var externalState = taskStateFromInternalTaskState(this.state_);
      switch (externalState) {
        case TaskState.RUNNING:
        case TaskState.PAUSED:
          if (observer.next) {
            async(observer.next.bind(observer, this.snapshot))();
          }
          break;
        case TaskState.SUCCESS:
          if (observer.complete) {
            async(observer.complete.bind(observer))();
          }
          break;
        case TaskState.CANCELED:
        case TaskState.ERROR:
          if (observer.error) {
            async(observer.error.bind(observer, this.error_))();
          }
          break;
        default:
          if (observer.error) {
            async(observer.error.bind(observer, this.error_))();
          }
      }
    };
    UploadTask2.prototype.resume = function() {
      validate("resume", [], arguments);
      var valid = this.state_ === InternalTaskState.PAUSED || this.state_ === InternalTaskState.PAUSING;
      if (valid) {
        this.transition_(InternalTaskState.RUNNING);
      }
      return valid;
    };
    UploadTask2.prototype.pause = function() {
      validate("pause", [], arguments);
      var valid = this.state_ === InternalTaskState.RUNNING;
      if (valid) {
        this.transition_(InternalTaskState.PAUSING);
      }
      return valid;
    };
    UploadTask2.prototype.cancel = function() {
      validate("cancel", [], arguments);
      var valid = this.state_ === InternalTaskState.RUNNING || this.state_ === InternalTaskState.PAUSING;
      if (valid) {
        this.transition_(InternalTaskState.CANCELING);
      }
      return valid;
    };
    return UploadTask2;
  }()
);
var Reference = (
  /** @class */
  function() {
    function Reference2(service, location) {
      this.service = service;
      if (location instanceof Location) {
        this.location = location;
      } else {
        this.location = Location.makeFromUrl(location);
      }
    }
    Reference2.prototype.toString = function() {
      validate("toString", [], arguments);
      return "gs://" + this.location.bucket + "/" + this.location.path;
    };
    Reference2.prototype.newRef = function(service, location) {
      return new Reference2(service, location);
    };
    Reference2.prototype.mappings = function() {
      return getMappings();
    };
    Reference2.prototype.child = function(childPath) {
      validate("child", [stringSpec()], arguments);
      var newPath = child(this.location.path, childPath);
      var location = new Location(this.location.bucket, newPath);
      return this.newRef(this.service, location);
    };
    Object.defineProperty(Reference2.prototype, "parent", {
      /**
       * @return A reference to the parent of the
       *     current object, or null if the current object is the root.
       */
      get: function() {
        var newPath = parent(this.location.path);
        if (newPath === null) {
          return null;
        }
        var location = new Location(this.location.bucket, newPath);
        return this.newRef(this.service, location);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Reference2.prototype, "root", {
      /**
       * @return An reference to the root of this
       *     object's bucket.
       */
      get: function() {
        var location = new Location(this.location.bucket, "");
        return this.newRef(this.service, location);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Reference2.prototype, "bucket", {
      get: function() {
        return this.location.bucket;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Reference2.prototype, "fullPath", {
      get: function() {
        return this.location.path;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Reference2.prototype, "name", {
      get: function() {
        return lastComponent(this.location.path);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Reference2.prototype, "storage", {
      get: function() {
        return this.service;
      },
      enumerable: false,
      configurable: true
    });
    Reference2.prototype.put = function(data, metadata) {
      if (metadata === void 0) {
        metadata = null;
      }
      validate("put", [uploadDataSpec(), metadataSpec(true)], arguments);
      this.throwIfRoot_("put");
      return new UploadTask(this, this.service, this.location, this.mappings(), new FbsBlob(data), metadata);
    };
    Reference2.prototype.putString = function(value, format, metadata) {
      if (format === void 0) {
        format = StringFormat.RAW;
      }
      validate("putString", [stringSpec(), stringSpec(formatValidator, true), metadataSpec(true)], arguments);
      this.throwIfRoot_("putString");
      var data = dataFromString(format, value);
      var metadataClone = Object.assign({}, metadata);
      if (!isDef(metadataClone["contentType"]) && isDef(data.contentType)) {
        metadataClone["contentType"] = data.contentType;
      }
      return new UploadTask(this, this.service, this.location, this.mappings(), new FbsBlob(data.data, true), metadataClone);
    };
    Reference2.prototype.delete = function() {
      var _this = this;
      validate("delete", [], arguments);
      this.throwIfRoot_("delete");
      return this.service.getAuthToken().then(function(authToken) {
        var requestInfo = deleteObject(_this.service, _this.location);
        return _this.service.makeRequest(requestInfo, authToken).getPromise();
      });
    };
    Reference2.prototype.listAll = function() {
      validate("listAll", [], arguments);
      var accumulator = {
        prefixes: [],
        items: []
      };
      return this.listAllHelper(accumulator).then(function() {
        return accumulator;
      });
    };
    Reference2.prototype.listAllHelper = function(accumulator, pageToken) {
      return __awaiter(this, void 0, void 0, function() {
        var opt, nextPage;
        var _a3, _b;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              opt = {
                // maxResults is 1000 by default.
                pageToken
              };
              return [4, this.list(opt)];
            case 1:
              nextPage = _c.sent();
              (_a3 = accumulator.prefixes).push.apply(_a3, nextPage.prefixes);
              (_b = accumulator.items).push.apply(_b, nextPage.items);
              if (!(nextPage.nextPageToken != null))
                return [3, 3];
              return [4, this.listAllHelper(accumulator, nextPage.nextPageToken)];
            case 2:
              _c.sent();
              _c.label = 3;
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Reference2.prototype.list = function(options) {
      validate("list", [listOptionSpec(true)], arguments);
      var self2 = this;
      return this.service.getAuthToken().then(function(authToken) {
        var op = options || {};
        var requestInfo = list(
          self2.service,
          self2.location,
          /*delimiter= */
          "/",
          op.pageToken,
          op.maxResults
        );
        return self2.service.makeRequest(requestInfo, authToken).getPromise();
      });
    };
    Reference2.prototype.getMetadata = function() {
      var _this = this;
      validate("getMetadata", [], arguments);
      this.throwIfRoot_("getMetadata");
      return this.service.getAuthToken().then(function(authToken) {
        var requestInfo = getMetadata(_this.service, _this.location, _this.mappings());
        return _this.service.makeRequest(requestInfo, authToken).getPromise();
      });
    };
    Reference2.prototype.updateMetadata = function(metadata) {
      var _this = this;
      validate("updateMetadata", [metadataSpec()], arguments);
      this.throwIfRoot_("updateMetadata");
      return this.service.getAuthToken().then(function(authToken) {
        var requestInfo = updateMetadata(_this.service, _this.location, metadata, _this.mappings());
        return _this.service.makeRequest(requestInfo, authToken).getPromise();
      });
    };
    Reference2.prototype.getDownloadURL = function() {
      var _this = this;
      validate("getDownloadURL", [], arguments);
      this.throwIfRoot_("getDownloadURL");
      return this.service.getAuthToken().then(function(authToken) {
        var requestInfo = getDownloadUrl(_this.service, _this.location, _this.mappings());
        return _this.service.makeRequest(requestInfo, authToken).getPromise().then(function(url) {
          if (url === null) {
            throw noDownloadURL();
          }
          return url;
        });
      });
    };
    Reference2.prototype.throwIfRoot_ = function(name4) {
      if (this.location.path === "") {
        throw invalidRootOperation(name4);
      }
    };
    return Reference2;
  }()
);
var FailRequest = (
  /** @class */
  function() {
    function FailRequest2(error) {
      this.promise_ = Promise.reject(error);
    }
    FailRequest2.prototype.getPromise = function() {
      return this.promise_;
    };
    FailRequest2.prototype.cancel = function(_appDelete) {
    };
    return FailRequest2;
  }()
);
function start(f, callback, timeout) {
  var waitSeconds = 1;
  var timeoutId = null;
  var hitTimeout = false;
  var cancelState = 0;
  function canceled2() {
    return cancelState === 2;
  }
  var triggeredCallback = false;
  function triggerCallback() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    if (!triggeredCallback) {
      triggeredCallback = true;
      callback.apply(null, args);
    }
  }
  function callWithDelay(millis) {
    timeoutId = setTimeout(function() {
      timeoutId = null;
      f(handler, canceled2());
    }, millis);
  }
  function handler(success) {
    var args = [];
    for (var _i2 = 1; _i2 < arguments.length; _i2++) {
      args[_i2 - 1] = arguments[_i2];
    }
    if (triggeredCallback) {
      return;
    }
    if (success) {
      triggerCallback.call.apply(triggerCallback, __spreadArrays([null, success], args));
      return;
    }
    var mustStop = canceled2() || hitTimeout;
    if (mustStop) {
      triggerCallback.call.apply(triggerCallback, __spreadArrays([null, success], args));
      return;
    }
    if (waitSeconds < 64) {
      waitSeconds *= 2;
    }
    var waitMillis;
    if (cancelState === 1) {
      cancelState = 2;
      waitMillis = 0;
    } else {
      waitMillis = (waitSeconds + Math.random()) * 1e3;
    }
    callWithDelay(waitMillis);
  }
  var stopped = false;
  function stop2(wasTimeout) {
    if (stopped) {
      return;
    }
    stopped = true;
    if (triggeredCallback) {
      return;
    }
    if (timeoutId !== null) {
      if (!wasTimeout) {
        cancelState = 2;
      }
      clearTimeout(timeoutId);
      callWithDelay(0);
    } else {
      if (!wasTimeout) {
        cancelState = 1;
      }
    }
  }
  callWithDelay(0);
  setTimeout(function() {
    hitTimeout = true;
    stop2(true);
  }, timeout);
  return stop2;
}
function stop(id2) {
  id2(false);
}
var NetworkRequest = (
  /** @class */
  function() {
    function NetworkRequest2(url, method, headers, body, successCodes, additionalRetryCodes, callback, errorCallback, timeout, progressCallback, pool) {
      var _this = this;
      this.pendingXhr_ = null;
      this.backoffId_ = null;
      this.canceled_ = false;
      this.appDelete_ = false;
      this.url_ = url;
      this.method_ = method;
      this.headers_ = headers;
      this.body_ = body;
      this.successCodes_ = successCodes.slice();
      this.additionalRetryCodes_ = additionalRetryCodes.slice();
      this.callback_ = callback;
      this.errorCallback_ = errorCallback;
      this.progressCallback_ = progressCallback;
      this.timeout_ = timeout;
      this.pool_ = pool;
      this.promise_ = new Promise(function(resolve2, reject) {
        _this.resolve_ = resolve2;
        _this.reject_ = reject;
        _this.start_();
      });
    }
    NetworkRequest2.prototype.start_ = function() {
      var self2 = this;
      function doTheRequest(backoffCallback, canceled2) {
        if (canceled2) {
          backoffCallback(false, new RequestEndStatus(false, null, true));
          return;
        }
        var xhr = self2.pool_.createXhrIo();
        self2.pendingXhr_ = xhr;
        function progressListener(progressEvent) {
          var loaded = progressEvent.loaded;
          var total = progressEvent.lengthComputable ? progressEvent.total : -1;
          if (self2.progressCallback_ !== null) {
            self2.progressCallback_(loaded, total);
          }
        }
        if (self2.progressCallback_ !== null) {
          xhr.addUploadProgressListener(progressListener);
        }
        xhr.send(self2.url_, self2.method_, self2.body_, self2.headers_).then(function(xhr2) {
          if (self2.progressCallback_ !== null) {
            xhr2.removeUploadProgressListener(progressListener);
          }
          self2.pendingXhr_ = null;
          xhr2 = xhr2;
          var hitServer = xhr2.getErrorCode() === ErrorCode2.NO_ERROR;
          var status = xhr2.getStatus();
          if (!hitServer || self2.isRetryStatusCode_(status)) {
            var wasCanceled = xhr2.getErrorCode() === ErrorCode2.ABORT;
            backoffCallback(false, new RequestEndStatus(false, null, wasCanceled));
            return;
          }
          var successCode = self2.successCodes_.indexOf(status) !== -1;
          backoffCallback(true, new RequestEndStatus(successCode, xhr2));
        });
      }
      function backoffDone(requestWentThrough, status) {
        var resolve2 = self2.resolve_;
        var reject = self2.reject_;
        var xhr = status.xhr;
        if (status.wasSuccessCode) {
          try {
            var result = self2.callback_(xhr, xhr.getResponseText());
            if (isJustDef(result)) {
              resolve2(result);
            } else {
              resolve2();
            }
          } catch (e) {
            reject(e);
          }
        } else {
          if (xhr !== null) {
            var err = unknown();
            err.setServerResponseProp(xhr.getResponseText());
            if (self2.errorCallback_) {
              reject(self2.errorCallback_(xhr, err));
            } else {
              reject(err);
            }
          } else {
            if (status.canceled) {
              var err = self2.appDelete_ ? appDeleted() : canceled();
              reject(err);
            } else {
              var err = retryLimitExceeded();
              reject(err);
            }
          }
        }
      }
      if (this.canceled_) {
        backoffDone(false, new RequestEndStatus(false, null, true));
      } else {
        this.backoffId_ = start(doTheRequest, backoffDone, this.timeout_);
      }
    };
    NetworkRequest2.prototype.getPromise = function() {
      return this.promise_;
    };
    NetworkRequest2.prototype.cancel = function(appDelete) {
      this.canceled_ = true;
      this.appDelete_ = appDelete || false;
      if (this.backoffId_ !== null) {
        stop(this.backoffId_);
      }
      if (this.pendingXhr_ !== null) {
        this.pendingXhr_.abort();
      }
    };
    NetworkRequest2.prototype.isRetryStatusCode_ = function(status) {
      var isFiveHundredCode = status >= 500 && status < 600;
      var extraRetryCodes = [
        // Request Timeout: web server didn't receive full request in time.
        408,
        // Too Many Requests: you're getting rate-limited, basically.
        429
      ];
      var isExtraRetryCode = extraRetryCodes.indexOf(status) !== -1;
      var isRequestSpecificRetryCode = this.additionalRetryCodes_.indexOf(status) !== -1;
      return isFiveHundredCode || isExtraRetryCode || isRequestSpecificRetryCode;
    };
    return NetworkRequest2;
  }()
);
var RequestEndStatus = (
  /** @class */
  /* @__PURE__ */ function() {
    function RequestEndStatus2(wasSuccessCode, xhr, canceled2) {
      this.wasSuccessCode = wasSuccessCode;
      this.xhr = xhr;
      this.canceled = !!canceled2;
    }
    return RequestEndStatus2;
  }()
);
function addAuthHeader_(headers, authToken) {
  if (authToken !== null && authToken.length > 0) {
    headers["Authorization"] = "Firebase " + authToken;
  }
}
function addVersionHeader_(headers) {
  var version3 = typeof import_app6.default !== "undefined" ? import_app6.default.SDK_VERSION : "AppManager";
  headers["X-Firebase-Storage-Version"] = "webjs/" + version3;
}
function addGmpidHeader_(headers, appId) {
  if (appId) {
    headers["X-Firebase-GMPID"] = appId;
  }
}
function makeRequest(requestInfo, appId, authToken, pool) {
  var queryPart = makeQueryString(requestInfo.urlParams);
  var url = requestInfo.url + queryPart;
  var headers = Object.assign({}, requestInfo.headers);
  addGmpidHeader_(headers, appId);
  addAuthHeader_(headers, authToken);
  addVersionHeader_(headers);
  return new NetworkRequest(url, requestInfo.method, headers, requestInfo.body, requestInfo.successCodes, requestInfo.additionalRetryCodes, requestInfo.handler, requestInfo.errorHandler, requestInfo.timeout, requestInfo.progressCallback, pool);
}
var StorageService = (
  /** @class */
  function() {
    function StorageService3(app, authProvider, pool, url) {
      var _a3;
      this.bucket_ = null;
      this.appId_ = null;
      this.deleted_ = false;
      this.app_ = app;
      this.authProvider_ = authProvider;
      this.maxOperationRetryTime_ = DEFAULT_MAX_OPERATION_RETRY_TIME;
      this.maxUploadRetryTime_ = DEFAULT_MAX_UPLOAD_RETRY_TIME;
      this.requests_ = /* @__PURE__ */ new Set();
      this.pool_ = pool;
      if (url != null) {
        this.bucket_ = Location.makeFromBucketSpec(url);
      } else {
        this.bucket_ = StorageService3.extractBucket_((_a3 = this.app_) === null || _a3 === void 0 ? void 0 : _a3.options);
      }
      this.internals_ = new ServiceInternals(this);
    }
    StorageService3.extractBucket_ = function(config2) {
      var bucketString = config2 === null || config2 === void 0 ? void 0 : config2[CONFIG_STORAGE_BUCKET_KEY];
      if (bucketString == null) {
        return null;
      }
      return Location.makeFromBucketSpec(bucketString);
    };
    StorageService3.prototype.getAuthToken = function() {
      return __awaiter(this, void 0, void 0, function() {
        var auth2, tokenData;
        return __generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              auth2 = this.authProvider_.getImmediate({ optional: true });
              if (!auth2)
                return [3, 2];
              return [4, auth2.getToken()];
            case 1:
              tokenData = _a3.sent();
              if (tokenData !== null) {
                return [2, tokenData.accessToken];
              }
              _a3.label = 2;
            case 2:
              return [2, null];
          }
        });
      });
    };
    StorageService3.prototype.deleteApp = function() {
      this.deleted_ = true;
      this.app_ = null;
      this.requests_.forEach(function(request) {
        return request.cancel();
      });
      this.requests_.clear();
    };
    StorageService3.prototype.makeStorageReference = function(loc) {
      return new Reference(this, loc);
    };
    StorageService3.prototype.makeRequest = function(requestInfo, authToken) {
      var _this = this;
      if (!this.deleted_) {
        var request_1 = makeRequest(requestInfo, this.appId_, authToken, this.pool_);
        this.requests_.add(request_1);
        request_1.getPromise().then(function() {
          return _this.requests_.delete(request_1);
        }, function() {
          return _this.requests_.delete(request_1);
        });
        return request_1;
      } else {
        return new FailRequest(appDeleted());
      }
    };
    StorageService3.prototype.ref = function(path) {
      function validator(path2) {
        if (typeof path2 !== "string") {
          throw "Path is not a string.";
        }
        if (/^[A-Za-z]+:\/\//.test(path2)) {
          throw "Expected child path but got a URL, use refFromURL instead.";
        }
      }
      validate("ref", [stringSpec(validator, true)], arguments);
      if (this.bucket_ == null) {
        throw new Error("No Storage Bucket defined in Firebase Options.");
      }
      var ref = new Reference(this, this.bucket_);
      if (path != null) {
        return ref.child(path);
      } else {
        return ref;
      }
    };
    StorageService3.prototype.refFromURL = function(url) {
      function validator(p2) {
        if (typeof p2 !== "string") {
          throw "Path is not a string.";
        }
        if (!/^[A-Za-z]+:\/\//.test(p2)) {
          throw "Expected full URL but got a child path, use ref instead.";
        }
        try {
          Location.makeFromUrl(p2);
        } catch (e) {
          throw "Expected valid full URL but got an invalid one.";
        }
      }
      validate("refFromURL", [stringSpec(validator, false)], arguments);
      return new Reference(this, url);
    };
    Object.defineProperty(StorageService3.prototype, "maxUploadRetryTime", {
      get: function() {
        return this.maxUploadRetryTime_;
      },
      enumerable: false,
      configurable: true
    });
    StorageService3.prototype.setMaxUploadRetryTime = function(time) {
      validate("setMaxUploadRetryTime", [nonNegativeNumberSpec()], arguments);
      this.maxUploadRetryTime_ = time;
    };
    Object.defineProperty(StorageService3.prototype, "maxOperationRetryTime", {
      get: function() {
        return this.maxOperationRetryTime_;
      },
      enumerable: false,
      configurable: true
    });
    StorageService3.prototype.setMaxOperationRetryTime = function(time) {
      validate("setMaxOperationRetryTime", [nonNegativeNumberSpec()], arguments);
      this.maxOperationRetryTime_ = time;
    };
    Object.defineProperty(StorageService3.prototype, "app", {
      get: function() {
        return this.app_;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(StorageService3.prototype, "INTERNAL", {
      get: function() {
        return this.internals_;
      },
      enumerable: false,
      configurable: true
    });
    return StorageService3;
  }()
);
var ServiceInternals = (
  /** @class */
  function() {
    function ServiceInternals2(service) {
      this.service_ = service;
    }
    ServiceInternals2.prototype.delete = function() {
      this.service_.deleteApp();
      return Promise.resolve();
    };
    return ServiceInternals2;
  }()
);
var name3 = "@firebase/storage";
var version2 = "0.3.43";
var STORAGE_TYPE = "storage";
function factory(container, url) {
  var app = container.getProvider("app").getImmediate();
  var authProvider = container.getProvider("auth-internal");
  return new StorageService(app, authProvider, new XhrIoPool(), url);
}
function registerStorage(instance) {
  var namespaceExports = {
    // no-inline
    TaskState,
    TaskEvent,
    StringFormat,
    Storage: StorageService,
    Reference
  };
  instance.INTERNAL.registerComponent(new Component2(
    STORAGE_TYPE,
    factory,
    "PUBLIC"
    /* PUBLIC */
  ).setServiceProps(namespaceExports).setMultipleInstances(true));
  instance.registerVersion(name3, version2);
}
registerStorage(import_app6.default);

// node_modules/ng-fire-admin/node_modules/@angular/fire/storage/storage.module.js
var __decorate6 = function(decorators, target, key, desc) {
  var c = arguments.length, r2 = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d = decorators[i2])
        r2 = (c < 3 ? d(r2) : c > 3 ? d(target, key, r2) : d(target, key)) || r2;
  return c > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var AngularFireStorageModule = function() {
  function AngularFireStorageModule2() {
  }
  AngularFireStorageModule2 = __decorate6([
    NgModule({
      providers: [AngularFireStorage]
    })
  ], AngularFireStorageModule2);
  return AngularFireStorageModule2;
}();

// node_modules/firebase-admin/lib/esm/app/index.js
var import_app7 = __toESM(require_app());
var SDK_VERSION = import_app7.default.SDK_VERSION;
var applicationDefault = import_app7.default.applicationDefault;
var cert = import_app7.default.cert;
var deleteApp = import_app7.default.deleteApp;
var getApp = import_app7.default.getApp;
var getApps = import_app7.default.getApps;
var initializeApp = import_app7.default.initializeApp;
var refreshToken = import_app7.default.refreshToken;

// node_modules/ng-fire-admin/node_modules/@angular/fire/auth/auth.js
var __decorate7 = function(decorators, target, key, desc) {
  var c = arguments.length, r2 = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d = decorators[i2])
        r2 = (c < 3 ? d(r2) : c > 3 ? d(target, key, r2) : d(target, key)) || r2;
  return c > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata5 = function(k3, v2) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k3, v2);
};
var __param5 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var AngularFireAuth = function() {
  function AngularFireAuth2(options, nameOrConfig, platformId, zone) {
    var _this = this;
    var keepUnstableUntilFirst = ɵkeepUnstableUntilFirstFactory(new ɵAngularFireSchedulers(zone), platformId);
    this.auth = zone.runOutsideAngular(function() {
      var app = _firebaseAppFactory(options, zone, nameOrConfig);
      return app.auth();
    });
    this.authState = new Observable(function(subscriber) {
      return zone.runOutsideAngular(function() {
        return _this.auth.onAuthStateChanged(subscriber);
      });
    }).pipe(keepUnstableUntilFirst);
    ;
    this.user = new Observable(function(subscriber) {
      return zone.runOutsideAngular(function() {
        return _this.auth.onIdTokenChanged(subscriber);
      });
    }).pipe(keepUnstableUntilFirst);
    this.idToken = this.user.pipe(switchMap(function(user) {
      return user ? from(user.getIdToken()) : of(null);
    }));
    this.idTokenResult = this.user.pipe(switchMap(function(user) {
      return user ? from(user.getIdTokenResult()) : of(null);
    }));
  }
  AngularFireAuth2 = __decorate7([
    Injectable(),
    __param5(0, Inject(FIREBASE_OPTIONS)),
    __param5(1, Optional()),
    __param5(1, Inject(FIREBASE_APP_NAME)),
    __param5(2, Inject(PLATFORM_ID)),
    __metadata5("design:paramtypes", [
      Object,
      Object,
      Object,
      NgZone
    ])
  ], AngularFireAuth2);
  return AngularFireAuth2;
}();

// node_modules/ng-fire-admin/node_modules/@firebase/auth/dist/auth.esm.js
var import_app8 = __toESM(require_index_cjs3());
(function() {
  var k3, aa3 = "function" == typeof Object.defineProperties ? Object.defineProperty : function(a, b2, c) {
    a != Array.prototype && a != Object.prototype && (a[b2] = c.value);
  };
  function ba3(a) {
    a = ["object" == typeof window && window, "object" == typeof self && self, "object" == typeof global && global, a];
    for (var b2 = 0; b2 < a.length; ++b2) {
      var c = a[b2];
      if (c && c.Math == Math)
        return c;
    }
    return globalThis;
  }
  var ca3 = ba3(this);
  function da3(a, b2) {
    if (b2) {
      var c = ca3;
      a = a.split(".");
      for (var d = 0; d < a.length - 1; d++) {
        var e = a[d];
        e in c || (c[e] = {});
        c = c[e];
      }
      a = a[a.length - 1];
      d = c[a];
      b2 = b2(d);
      b2 != d && null != b2 && aa3(c, a, { configurable: true, writable: true, value: b2 });
    }
  }
  function ea3(a) {
    var b2 = 0;
    return function() {
      return b2 < a.length ? { done: false, value: a[b2++] } : { done: true };
    };
  }
  function fa3(a) {
    var b2 = "undefined" != typeof Symbol && Symbol.iterator && a[Symbol.iterator];
    return b2 ? b2.call(a) : { next: ea3(a) };
  }
  da3("Promise", function(a) {
    function b2(g2) {
      this.b = 0;
      this.c = void 0;
      this.a = [];
      var h = this.f();
      try {
        g2(h.resolve, h.reject);
      } catch (m) {
        h.reject(m);
      }
    }
    function c() {
      this.a = null;
    }
    function d(g2) {
      return g2 instanceof b2 ? g2 : new b2(function(h) {
        h(g2);
      });
    }
    if (a)
      return a;
    c.prototype.b = function(g2) {
      if (null == this.a) {
        this.a = [];
        var h = this;
        this.c(function() {
          h.g();
        });
      }
      this.a.push(g2);
    };
    var e = ca3.setTimeout;
    c.prototype.c = function(g2) {
      e(g2, 0);
    };
    c.prototype.g = function() {
      for (; this.a && this.a.length; ) {
        var g2 = this.a;
        this.a = [];
        for (var h = 0; h < g2.length; ++h) {
          var m = g2[h];
          g2[h] = null;
          try {
            m();
          } catch (p2) {
            this.f(p2);
          }
        }
      }
      this.a = null;
    };
    c.prototype.f = function(g2) {
      this.c(function() {
        throw g2;
      });
    };
    b2.prototype.f = function() {
      function g2(p2) {
        return function(v2) {
          m || (m = true, p2.call(h, v2));
        };
      }
      var h = this, m = false;
      return { resolve: g2(this.v), reject: g2(this.g) };
    };
    b2.prototype.v = function(g2) {
      if (g2 === this)
        this.g(new TypeError("A Promise cannot resolve to itself"));
      else if (g2 instanceof b2)
        this.o(g2);
      else {
        a:
          switch (typeof g2) {
            case "object":
              var h = null != g2;
              break a;
            case "function":
              h = true;
              break a;
            default:
              h = false;
          }
        h ? this.m(g2) : this.h(g2);
      }
    };
    b2.prototype.m = function(g2) {
      var h = void 0;
      try {
        h = g2.then;
      } catch (m) {
        this.g(m);
        return;
      }
      "function" == typeof h ? this.u(h, g2) : this.h(g2);
    };
    b2.prototype.g = function(g2) {
      this.i(2, g2);
    };
    b2.prototype.h = function(g2) {
      this.i(1, g2);
    };
    b2.prototype.i = function(g2, h) {
      if (0 != this.b)
        throw Error("Cannot settle(" + g2 + ", " + h + "): Promise already settled in state" + this.b);
      this.b = g2;
      this.c = h;
      this.l();
    };
    b2.prototype.l = function() {
      if (null != this.a) {
        for (var g2 = 0; g2 < this.a.length; ++g2)
          f.b(this.a[g2]);
        this.a = null;
      }
    };
    var f = new c();
    b2.prototype.o = function(g2) {
      var h = this.f();
      g2.Pa(h.resolve, h.reject);
    };
    b2.prototype.u = function(g2, h) {
      var m = this.f();
      try {
        g2.call(h, m.resolve, m.reject);
      } catch (p2) {
        m.reject(p2);
      }
    };
    b2.prototype.then = function(g2, h) {
      function m(A3, Q3) {
        return "function" == typeof A3 ? function(xa3) {
          try {
            p2(A3(xa3));
          } catch (yd2) {
            v2(yd2);
          }
        } : Q3;
      }
      var p2, v2, B2 = new b2(function(A3, Q3) {
        p2 = A3;
        v2 = Q3;
      });
      this.Pa(m(g2, p2), m(h, v2));
      return B2;
    };
    b2.prototype.catch = function(g2) {
      return this.then(void 0, g2);
    };
    b2.prototype.Pa = function(g2, h) {
      function m() {
        switch (p2.b) {
          case 1:
            g2(p2.c);
            break;
          case 2:
            h(p2.c);
            break;
          default:
            throw Error("Unexpected state: " + p2.b);
        }
      }
      var p2 = this;
      null == this.a ? f.b(m) : this.a.push(m);
    };
    b2.resolve = d;
    b2.reject = function(g2) {
      return new b2(function(h, m) {
        m(g2);
      });
    };
    b2.race = function(g2) {
      return new b2(function(h, m) {
        for (var p2 = fa3(g2), v2 = p2.next(); !v2.done; v2 = p2.next())
          d(v2.value).Pa(h, m);
      });
    };
    b2.all = function(g2) {
      var h = fa3(g2), m = h.next();
      return m.done ? d([]) : new b2(function(p2, v2) {
        function B2(xa3) {
          return function(yd2) {
            A3[xa3] = yd2;
            Q3--;
            0 == Q3 && p2(A3);
          };
        }
        var A3 = [], Q3 = 0;
        do
          A3.push(void 0), Q3++, d(m.value).Pa(B2(A3.length - 1), v2), m = h.next();
        while (!m.done);
      });
    };
    return b2;
  });
  var ha3 = ha3 || {}, l = this || self, ia2 = /^[\w+/_-]+[=]{0,2}$/, ja2 = null;
  function ka3() {
  }
  function la3(a) {
    var b2 = typeof a;
    if ("object" == b2)
      if (a) {
        if (a instanceof Array)
          return "array";
        if (a instanceof Object)
          return b2;
        var c = Object.prototype.toString.call(a);
        if ("[object Window]" == c)
          return "object";
        if ("[object Array]" == c || "number" == typeof a.length && "undefined" != typeof a.splice && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("splice"))
          return "array";
        if ("[object Function]" == c || "undefined" != typeof a.call && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("call"))
          return "function";
      } else
        return "null";
    else if ("function" == b2 && "undefined" == typeof a.call)
      return "object";
    return b2;
  }
  function ma2(a) {
    var b2 = la3(a);
    return "array" == b2 || "object" == b2 && "number" == typeof a.length;
  }
  function na3(a) {
    return "function" == la3(a);
  }
  function n2(a) {
    var b2 = typeof a;
    return "object" == b2 && null != a || "function" == b2;
  }
  function oa3(a) {
    return Object.prototype.hasOwnProperty.call(a, pa3) && a[pa3] || (a[pa3] = ++qa2);
  }
  var pa3 = "closure_uid_" + (1e9 * Math.random() >>> 0), qa2 = 0;
  function ra3(a, b2, c) {
    return a.call.apply(a.bind, arguments);
  }
  function sa3(a, b2, c) {
    if (!a)
      throw Error();
    if (2 < arguments.length) {
      var d = Array.prototype.slice.call(arguments, 2);
      return function() {
        var e = Array.prototype.slice.call(arguments);
        Array.prototype.unshift.apply(e, d);
        return a.apply(b2, e);
      };
    }
    return function() {
      return a.apply(b2, arguments);
    };
  }
  function q3(a, b2, c) {
    Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? q3 = ra3 : q3 = sa3;
    return q3.apply(null, arguments);
  }
  function ta3(a, b2) {
    var c = Array.prototype.slice.call(arguments, 1);
    return function() {
      var d = c.slice();
      d.push.apply(d, arguments);
      return a.apply(this, d);
    };
  }
  var ua3 = Date.now || function() {
    return +/* @__PURE__ */ new Date();
  };
  function r2(a, b2) {
    function c() {
    }
    c.prototype = b2.prototype;
    a.$a = b2.prototype;
    a.prototype = new c();
    a.prototype.constructor = a;
  }
  ;
  function t(a, b2, c) {
    this.code = va2 + a;
    this.message = b2 || wa2[a] || "";
    this.a = c || null;
  }
  r2(t, Error);
  t.prototype.w = function() {
    var a = { code: this.code, message: this.message };
    this.a && (a.serverResponse = this.a);
    return a;
  };
  t.prototype.toJSON = function() {
    return this.w();
  };
  function ya2(a) {
    var b2 = a && a.code;
    return b2 ? new t(b2.substring(va2.length), a.message, a.serverResponse) : null;
  }
  var va2 = "auth/", wa2 = {
    "admin-restricted-operation": "This operation is restricted to administrators only.",
    "argument-error": "",
    "app-not-authorized": "This app, identified by the domain where it's hosted, is not authorized to use Firebase Authentication with the provided API key. Review your key configuration in the Google API console.",
    "app-not-installed": "The requested mobile application corresponding to the identifier (Android package name or iOS bundle ID) provided is not installed on this device.",
    "captcha-check-failed": "The reCAPTCHA response token provided is either invalid, expired, already used or the domain associated with it does not match the list of whitelisted domains.",
    "code-expired": "The SMS code has expired. Please re-send the verification code to try again.",
    "cordova-not-ready": "Cordova framework is not ready.",
    "cors-unsupported": "This browser is not supported.",
    "credential-already-in-use": "This credential is already associated with a different user account.",
    "custom-token-mismatch": "The custom token corresponds to a different audience.",
    "requires-recent-login": "This operation is sensitive and requires recent authentication. Log in again before retrying this request.",
    "dynamic-link-not-activated": "Please activate Dynamic Links in the Firebase Console and agree to the terms and conditions.",
    "email-change-needs-verification": "Multi-factor users must always have a verified email.",
    "email-already-in-use": "The email address is already in use by another account.",
    "expired-action-code": "The action code has expired. ",
    "cancelled-popup-request": "This operation has been cancelled due to another conflicting popup being opened.",
    "internal-error": "An internal error has occurred.",
    "invalid-app-credential": "The phone verification request contains an invalid application verifier. The reCAPTCHA token response is either invalid or expired.",
    "invalid-app-id": "The mobile app identifier is not registed for the current project.",
    "invalid-user-token": "This user's credential isn't valid for this project. This can happen if the user's token has been tampered with, or if the user isn't for the project associated with this API key.",
    "invalid-auth-event": "An internal error has occurred.",
    "invalid-verification-code": "The SMS verification code used to create the phone auth credential is invalid. Please resend the verification code sms and be sure use the verification code provided by the user.",
    "invalid-continue-uri": "The continue URL provided in the request is invalid.",
    "invalid-cordova-configuration": "The following Cordova plugins must be installed to enable OAuth sign-in: cordova-plugin-buildinfo, cordova-universal-links-plugin, cordova-plugin-browsertab, cordova-plugin-inappbrowser and cordova-plugin-customurlscheme.",
    "invalid-custom-token": "The custom token format is incorrect. Please check the documentation.",
    "invalid-dynamic-link-domain": "The provided dynamic link domain is not configured or authorized for the current project.",
    "invalid-email": "The email address is badly formatted.",
    "invalid-api-key": "Your API key is invalid, please check you have copied it correctly.",
    "invalid-cert-hash": "The SHA-1 certificate hash provided is invalid.",
    "invalid-credential": "The supplied auth credential is malformed or has expired.",
    "invalid-message-payload": "The email template corresponding to this action contains invalid characters in its message. Please fix by going to the Auth email templates section in the Firebase Console.",
    "invalid-multi-factor-session": "The request does not contain a valid proof of first factor successful sign-in.",
    "invalid-oauth-provider": "EmailAuthProvider is not supported for this operation. This operation only supports OAuth providers.",
    "invalid-oauth-client-id": "The OAuth client ID provided is either invalid or does not match the specified API key.",
    "unauthorized-domain": "This domain is not authorized for OAuth operations for your Firebase project. Edit the list of authorized domains from the Firebase console.",
    "invalid-action-code": "The action code is invalid. This can happen if the code is malformed, expired, or has already been used.",
    "wrong-password": "The password is invalid or the user does not have a password.",
    "invalid-persistence-type": "The specified persistence type is invalid. It can only be local, session or none.",
    "invalid-phone-number": "The format of the phone number provided is incorrect. Please enter the phone number in a format that can be parsed into E.164 format. E.164 phone numbers are written in the format [+][country code][subscriber number including area code].",
    "invalid-provider-id": "The specified provider ID is invalid.",
    "invalid-recipient-email": "The email corresponding to this action failed to send as the provided recipient email address is invalid.",
    "invalid-sender": "The email template corresponding to this action contains an invalid sender email or name. Please fix by going to the Auth email templates section in the Firebase Console.",
    "invalid-verification-id": "The verification ID used to create the phone auth credential is invalid.",
    "invalid-tenant-id": "The Auth instance's tenant ID is invalid.",
    "multi-factor-info-not-found": "The user does not have a second factor matching the identifier provided.",
    "multi-factor-auth-required": "Proof of ownership of a second factor is required to complete sign-in.",
    "missing-android-pkg-name": "An Android Package Name must be provided if the Android App is required to be installed.",
    "auth-domain-config-required": "Be sure to include authDomain when calling firebase.initializeApp(), by following the instructions in the Firebase console.",
    "missing-app-credential": "The phone verification request is missing an application verifier assertion. A reCAPTCHA response token needs to be provided.",
    "missing-verification-code": "The phone auth credential was created with an empty SMS verification code.",
    "missing-continue-uri": "A continue URL must be provided in the request.",
    "missing-iframe-start": "An internal error has occurred.",
    "missing-ios-bundle-id": "An iOS Bundle ID must be provided if an App Store ID is provided.",
    "missing-multi-factor-info": "No second factor identifier is provided.",
    "missing-multi-factor-session": "The request is missing proof of first factor successful sign-in.",
    "missing-or-invalid-nonce": "The request does not contain a valid nonce. This can occur if the SHA-256 hash of the provided raw nonce does not match the hashed nonce in the ID token payload.",
    "missing-phone-number": "To send verification codes, provide a phone number for the recipient.",
    "missing-verification-id": "The phone auth credential was created with an empty verification ID.",
    "app-deleted": "This instance of FirebaseApp has been deleted.",
    "account-exists-with-different-credential": "An account already exists with the same email address but different sign-in credentials. Sign in using a provider associated with this email address.",
    "network-request-failed": "A network error (such as timeout, interrupted connection or unreachable host) has occurred.",
    "no-auth-event": "An internal error has occurred.",
    "no-such-provider": "User was not linked to an account with the given provider.",
    "null-user": "A null user object was provided as the argument for an operation which requires a non-null user object.",
    "operation-not-allowed": "The given sign-in provider is disabled for this Firebase project. Enable it in the Firebase console, under the sign-in method tab of the Auth section.",
    "operation-not-supported-in-this-environment": 'This operation is not supported in the environment this application is running on. "location.protocol" must be http, https or chrome-extension and web storage must be enabled.',
    "popup-blocked": "Unable to establish a connection with the popup. It may have been blocked by the browser.",
    "popup-closed-by-user": "The popup has been closed by the user before finalizing the operation.",
    "provider-already-linked": "User can only be linked to one identity for the given provider.",
    "quota-exceeded": "The project's quota for this operation has been exceeded.",
    "redirect-cancelled-by-user": "The redirect operation has been cancelled by the user before finalizing.",
    "redirect-operation-pending": "A redirect sign-in operation is already pending.",
    "rejected-credential": "The request contains malformed or mismatching credentials.",
    "second-factor-already-in-use": "The second factor is already enrolled on this account.",
    "maximum-second-factor-count-exceeded": "The maximum allowed number of second factors on a user has been exceeded.",
    "tenant-id-mismatch": "The provided tenant ID does not match the Auth instance's tenant ID",
    timeout: "The operation has timed out.",
    "user-token-expired": "The user's credential is no longer valid. The user must sign in again.",
    "too-many-requests": "We have blocked all requests from this device due to unusual activity. Try again later.",
    "unauthorized-continue-uri": "The domain of the continue URL is not whitelisted.  Please whitelist the domain in the Firebase console.",
    "unsupported-first-factor": "Enrolling a second factor or signing in with a multi-factor account requires sign-in with a supported first factor.",
    "unsupported-persistence-type": "The current environment does not support the specified persistence type.",
    "unsupported-tenant-operation": "This operation is not supported in a multi-tenant context.",
    "unverified-email": "The operation requires a verified email.",
    "user-cancelled": "The user did not grant your application the permissions it requested.",
    "user-not-found": "There is no user record corresponding to this identifier. The user may have been deleted.",
    "user-disabled": "The user account has been disabled by an administrator.",
    "user-mismatch": "The supplied credentials do not correspond to the previously signed in user.",
    "user-signed-out": "",
    "weak-password": "The password must be 6 characters long or more.",
    "web-storage-unsupported": "This browser is not supported or 3rd party cookies and data may be disabled."
  };
  var za = { kd: { Sa: "https://staging-identitytoolkit.sandbox.googleapis.com/identitytoolkit/v3/relyingparty/", Ya: "https://staging-securetoken.sandbox.googleapis.com/v1/token", Va: "https://staging-identitytoolkit.sandbox.googleapis.com/v2/", id: "b" }, rd: { Sa: "https://www.googleapis.com/identitytoolkit/v3/relyingparty/", Ya: "https://securetoken.googleapis.com/v1/token", Va: "https://identitytoolkit.googleapis.com/v2/", id: "p" }, td: {
    Sa: "https://staging-www.sandbox.googleapis.com/identitytoolkit/v3/relyingparty/",
    Ya: "https://staging-securetoken.sandbox.googleapis.com/v1/token",
    Va: "https://staging-identitytoolkit.sandbox.googleapis.com/v2/",
    id: "s"
  }, ud: { Sa: "https://www-googleapis-test.sandbox.google.com/identitytoolkit/v3/relyingparty/", Ya: "https://test-securetoken.sandbox.googleapis.com/v1/token", Va: "https://test-identitytoolkit.sandbox.googleapis.com/v2/", id: "t" } };
  function Aa3(a) {
    for (var b2 in za)
      if (za[b2].id === a)
        return a = za[b2], { firebaseEndpoint: a.Sa, secureTokenEndpoint: a.Ya, identityPlatformEndpoint: a.Va };
    return null;
  }
  var Ba2;
  Ba2 = Aa3("__EID__") ? "__EID__" : void 0;
  function Ca2(a) {
    if (!a)
      return false;
    try {
      return !!a.$goog_Thenable;
    } catch (b2) {
      return false;
    }
  }
  ;
  function u4(a) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, u4);
    else {
      var b2 = Error().stack;
      b2 && (this.stack = b2);
    }
    a && (this.message = String(a));
  }
  r2(u4, Error);
  u4.prototype.name = "CustomError";
  function Da3(a, b2) {
    a = a.split("%s");
    for (var c = "", d = a.length - 1, e = 0; e < d; e++)
      c += a[e] + (e < b2.length ? b2[e] : "%s");
    u4.call(this, c + a[d]);
  }
  r2(Da3, u4);
  Da3.prototype.name = "AssertionError";
  function Ea3(a, b2) {
    throw new Da3("Failure" + (a ? ": " + a : ""), Array.prototype.slice.call(arguments, 1));
  }
  ;
  function Fa2(a, b2) {
    this.c = a;
    this.f = b2;
    this.b = 0;
    this.a = null;
  }
  Fa2.prototype.get = function() {
    if (0 < this.b) {
      this.b--;
      var a = this.a;
      this.a = a.next;
      a.next = null;
    } else
      a = this.c();
    return a;
  };
  function Ga2(a, b2) {
    a.f(b2);
    100 > a.b && (a.b++, b2.next = a.a, a.a = b2);
  }
  ;
  function Ha2() {
    this.b = this.a = null;
  }
  var Ja2 = new Fa2(function() {
    return new Ia3();
  }, function(a) {
    a.reset();
  });
  Ha2.prototype.add = function(a, b2) {
    var c = Ja2.get();
    c.set(a, b2);
    this.b ? this.b.next = c : this.a = c;
    this.b = c;
  };
  function Ka2() {
    var a = La3, b2 = null;
    a.a && (b2 = a.a, a.a = a.a.next, a.a || (a.b = null), b2.next = null);
    return b2;
  }
  function Ia3() {
    this.next = this.b = this.a = null;
  }
  Ia3.prototype.set = function(a, b2) {
    this.a = a;
    this.b = b2;
    this.next = null;
  };
  Ia3.prototype.reset = function() {
    this.next = this.b = this.a = null;
  };
  var Ma2 = Array.prototype.indexOf ? function(a, b2) {
    return Array.prototype.indexOf.call(a, b2, void 0);
  } : function(a, b2) {
    if ("string" === typeof a)
      return "string" !== typeof b2 || 1 != b2.length ? -1 : a.indexOf(b2, 0);
    for (var c = 0; c < a.length; c++)
      if (c in a && a[c] === b2)
        return c;
    return -1;
  }, w2 = Array.prototype.forEach ? function(a, b2, c) {
    Array.prototype.forEach.call(a, b2, c);
  } : function(a, b2, c) {
    for (var d = a.length, e = "string" === typeof a ? a.split("") : a, f = 0; f < d; f++)
      f in e && b2.call(c, e[f], f, a);
  };
  function Na3(a, b2) {
    for (var c = "string" === typeof a ? a.split("") : a, d = a.length - 1; 0 <= d; --d)
      d in c && b2.call(void 0, c[d], d, a);
  }
  var Oa2 = Array.prototype.filter ? function(a, b2) {
    return Array.prototype.filter.call(a, b2, void 0);
  } : function(a, b2) {
    for (var c = a.length, d = [], e = 0, f = "string" === typeof a ? a.split("") : a, g2 = 0; g2 < c; g2++)
      if (g2 in f) {
        var h = f[g2];
        b2.call(void 0, h, g2, a) && (d[e++] = h);
      }
    return d;
  }, Pa = Array.prototype.map ? function(a, b2) {
    return Array.prototype.map.call(a, b2, void 0);
  } : function(a, b2) {
    for (var c = a.length, d = Array(c), e = "string" === typeof a ? a.split("") : a, f = 0; f < c; f++)
      f in e && (d[f] = b2.call(void 0, e[f], f, a));
    return d;
  }, Qa = Array.prototype.some ? function(a, b2) {
    return Array.prototype.some.call(a, b2, void 0);
  } : function(a, b2) {
    for (var c = a.length, d = "string" === typeof a ? a.split("") : a, e = 0; e < c; e++)
      if (e in d && b2.call(void 0, d[e], e, a))
        return true;
    return false;
  };
  function Ra3(a) {
    a: {
      var b2 = Sa3;
      for (var c = a.length, d = "string" === typeof a ? a.split("") : a, e = 0; e < c; e++)
        if (e in d && b2.call(void 0, d[e], e, a)) {
          b2 = e;
          break a;
        }
      b2 = -1;
    }
    return 0 > b2 ? null : "string" === typeof a ? a.charAt(b2) : a[b2];
  }
  function Ta2(a, b2) {
    return 0 <= Ma2(a, b2);
  }
  function Ua2(a, b2) {
    b2 = Ma2(a, b2);
    var c;
    (c = 0 <= b2) && Array.prototype.splice.call(a, b2, 1);
    return c;
  }
  function Va2(a, b2) {
    var c = 0;
    Na3(a, function(d, e) {
      b2.call(void 0, d, e, a) && 1 == Array.prototype.splice.call(a, e, 1).length && c++;
    });
  }
  function Wa2(a) {
    return Array.prototype.concat.apply([], arguments);
  }
  function Xa2(a) {
    var b2 = a.length;
    if (0 < b2) {
      for (var c = Array(b2), d = 0; d < b2; d++)
        c[d] = a[d];
      return c;
    }
    return [];
  }
  ;
  var Ya2 = String.prototype.trim ? function(a) {
    return a.trim();
  } : function(a) {
    return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a)[1];
  }, Za2 = /&/g, $a2 = /</g, ab2 = />/g, bb2 = /"/g, cb2 = /'/g, db2 = /\x00/g, eb2 = /[\x00&<>"']/;
  function x3(a, b2) {
    return -1 != a.indexOf(b2);
  }
  function fb2(a, b2) {
    return a < b2 ? -1 : a > b2 ? 1 : 0;
  }
  ;
  var gb;
  a: {
    var hb2 = l.navigator;
    if (hb2) {
      var ib2 = hb2.userAgent;
      if (ib2) {
        gb = ib2;
        break a;
      }
    }
    gb = "";
  }
  function y2(a) {
    return x3(gb, a);
  }
  ;
  function jb2(a, b2) {
    for (var c in a)
      b2.call(void 0, a[c], c, a);
  }
  function kb2(a) {
    for (var b2 in a)
      return false;
    return true;
  }
  function lb2(a) {
    var b2 = {}, c;
    for (c in a)
      b2[c] = a[c];
    return b2;
  }
  var mb2 = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
  function z2(a, b2) {
    for (var c, d, e = 1; e < arguments.length; e++) {
      d = arguments[e];
      for (c in d)
        a[c] = d[c];
      for (var f = 0; f < mb2.length; f++)
        c = mb2[f], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
    }
  }
  ;
  function nb2(a, b2) {
    a: {
      try {
        var c = a && a.ownerDocument, d = c && (c.defaultView || c.parentWindow);
        d = d || l;
        if (d.Element && d.Location) {
          var e = d;
          break a;
        }
      } catch (g2) {
      }
      e = null;
    }
    if (e && "undefined" != typeof e[b2] && (!a || !(a instanceof e[b2]) && (a instanceof e.Location || a instanceof e.Element))) {
      if (n2(a))
        try {
          var f = a.constructor.displayName || a.constructor.name || Object.prototype.toString.call(a);
        } catch (g2) {
          f = "<object could not be stringified>";
        }
      else
        f = void 0 === a ? "undefined" : null === a ? "null" : typeof a;
      Ea3(
        "Argument is not a %s (or a non-Element, non-Location mock); got: %s",
        b2,
        f
      );
    }
  }
  ;
  function ob2(a, b2) {
    this.a = a === pb2 && b2 || "";
    this.b = qb;
  }
  ob2.prototype.sa = true;
  ob2.prototype.ra = function() {
    return this.a;
  };
  ob2.prototype.toString = function() {
    return "Const{" + this.a + "}";
  };
  function rb2(a) {
    if (a instanceof ob2 && a.constructor === ob2 && a.b === qb)
      return a.a;
    Ea3("expected object of type Const, got '" + a + "'");
    return "type_error:Const";
  }
  var qb = {}, pb2 = {}, sb2 = new ob2(pb2, "");
  function tb2(a, b2) {
    this.a = a === ub2 && b2 || "";
    this.b = vb2;
  }
  tb2.prototype.sa = true;
  tb2.prototype.ra = function() {
    return this.a.toString();
  };
  tb2.prototype.toString = function() {
    return "TrustedResourceUrl{" + this.a + "}";
  };
  function wb2(a) {
    if (a instanceof tb2 && a.constructor === tb2 && a.b === vb2)
      return a.a;
    Ea3("expected object of type TrustedResourceUrl, got '" + a + "' of type " + la3(a));
    return "type_error:TrustedResourceUrl";
  }
  function xb2(a, b2) {
    var c = rb2(a);
    if (!yb2.test(c))
      throw Error("Invalid TrustedResourceUrl format: " + c);
    a = c.replace(zb2, function(d, e) {
      if (!Object.prototype.hasOwnProperty.call(b2, e))
        throw Error('Found marker, "' + e + '", in format string, "' + c + '", but no valid label mapping found in args: ' + JSON.stringify(b2));
      d = b2[e];
      return d instanceof ob2 ? rb2(d) : encodeURIComponent(String(d));
    });
    return new tb2(ub2, a);
  }
  var zb2 = /%{(\w+)}/g, yb2 = /^((https:)?\/\/[0-9a-z.:[\]-]+\/|\/[^/\\]|[^:/\\%]+\/|[^:/\\%]*[?#]|about:blank#)/i, vb2 = {}, ub2 = {};
  function Ab2(a, b2) {
    this.a = a === Bb2 && b2 || "";
    this.b = Cb2;
  }
  Ab2.prototype.sa = true;
  Ab2.prototype.ra = function() {
    return this.a.toString();
  };
  Ab2.prototype.toString = function() {
    return "SafeUrl{" + this.a + "}";
  };
  function Db2(a) {
    if (a instanceof Ab2 && a.constructor === Ab2 && a.b === Cb2)
      return a.a;
    Ea3("expected object of type SafeUrl, got '" + a + "' of type " + la3(a));
    return "type_error:SafeUrl";
  }
  var Eb2 = /^(?:(?:https?|mailto|ftp):|[^:/?#]*(?:[/?#]|$))/i;
  function Fb2(a) {
    if (a instanceof Ab2)
      return a;
    a = "object" == typeof a && a.sa ? a.ra() : String(a);
    Eb2.test(a) || (a = "about:invalid#zClosurez");
    return new Ab2(Bb2, a);
  }
  var Cb2 = {}, Bb2 = {};
  function Gb2() {
    this.a = "";
    this.b = Hb2;
  }
  Gb2.prototype.sa = true;
  Gb2.prototype.ra = function() {
    return this.a.toString();
  };
  Gb2.prototype.toString = function() {
    return "SafeHtml{" + this.a + "}";
  };
  function Ib2(a) {
    if (a instanceof Gb2 && a.constructor === Gb2 && a.b === Hb2)
      return a.a;
    Ea3("expected object of type SafeHtml, got '" + a + "' of type " + la3(a));
    return "type_error:SafeHtml";
  }
  var Hb2 = {};
  function Jb2(a) {
    var b2 = new Gb2();
    b2.a = a;
    return b2;
  }
  Jb2("<!DOCTYPE html>");
  var Kb2 = Jb2("");
  Jb2("<br>");
  function Lb2(a) {
    var b2 = new tb2(ub2, rb2(sb2));
    nb2(a, "HTMLIFrameElement");
    a.src = wb2(b2).toString();
  }
  function Mb2(a, b2) {
    nb2(a, "HTMLScriptElement");
    a.src = wb2(b2);
    if (null === ja2)
      b: {
        b2 = l.document;
        if ((b2 = b2.querySelector && b2.querySelector("script[nonce]")) && (b2 = b2.nonce || b2.getAttribute("nonce")) && ia2.test(b2)) {
          ja2 = b2;
          break b;
        }
        ja2 = "";
      }
    b2 = ja2;
    b2 && a.setAttribute("nonce", b2);
  }
  ;
  function Nb2(a, b2) {
    for (var c = a.split("%s"), d = "", e = Array.prototype.slice.call(arguments, 1); e.length && 1 < c.length; )
      d += c.shift() + e.shift();
    return d + c.join("%s");
  }
  function Ob2(a) {
    eb2.test(a) && (-1 != a.indexOf("&") && (a = a.replace(Za2, "&amp;")), -1 != a.indexOf("<") && (a = a.replace($a2, "&lt;")), -1 != a.indexOf(">") && (a = a.replace(ab2, "&gt;")), -1 != a.indexOf('"') && (a = a.replace(bb2, "&quot;")), -1 != a.indexOf("'") && (a = a.replace(cb2, "&#39;")), -1 != a.indexOf("\0") && (a = a.replace(db2, "&#0;")));
    return a;
  }
  ;
  function Pb2(a) {
    Pb2[" "](a);
    return a;
  }
  Pb2[" "] = ka3;
  function Qb2(a, b2) {
    var c = Rb2;
    return Object.prototype.hasOwnProperty.call(c, a) ? c[a] : c[a] = b2(a);
  }
  ;
  var Sb2 = y2("Opera"), Tb2 = y2("Trident") || y2("MSIE"), Ub2 = y2("Edge"), Vb2 = Ub2 || Tb2, Wb2 = y2("Gecko") && !(x3(gb.toLowerCase(), "webkit") && !y2("Edge")) && !(y2("Trident") || y2("MSIE")) && !y2("Edge"), Xb2 = x3(gb.toLowerCase(), "webkit") && !y2("Edge");
  function Yb2() {
    var a = l.document;
    return a ? a.documentMode : void 0;
  }
  var Zb2;
  a: {
    var $b2 = "", ac2 = function() {
      var a = gb;
      if (Wb2)
        return /rv:([^\);]+)(\)|;)/.exec(a);
      if (Ub2)
        return /Edge\/([\d\.]+)/.exec(a);
      if (Tb2)
        return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);
      if (Xb2)
        return /WebKit\/(\S+)/.exec(a);
      if (Sb2)
        return /(?:Version)[ \/]?(\S+)/.exec(a);
    }();
    ac2 && ($b2 = ac2 ? ac2[1] : "");
    if (Tb2) {
      var bc2 = Yb2();
      if (null != bc2 && bc2 > parseFloat($b2)) {
        Zb2 = String(bc2);
        break a;
      }
    }
    Zb2 = $b2;
  }
  var Rb2 = {};
  function cc2(a) {
    return Qb2(a, function() {
      for (var b2 = 0, c = Ya2(String(Zb2)).split("."), d = Ya2(String(a)).split("."), e = Math.max(c.length, d.length), f = 0; 0 == b2 && f < e; f++) {
        var g2 = c[f] || "", h = d[f] || "";
        do {
          g2 = /(\d*)(\D*)(.*)/.exec(g2) || ["", "", "", ""];
          h = /(\d*)(\D*)(.*)/.exec(h) || ["", "", "", ""];
          if (0 == g2[0].length && 0 == h[0].length)
            break;
          b2 = fb2(0 == g2[1].length ? 0 : parseInt(g2[1], 10), 0 == h[1].length ? 0 : parseInt(h[1], 10)) || fb2(0 == g2[2].length, 0 == h[2].length) || fb2(g2[2], h[2]);
          g2 = g2[3];
          h = h[3];
        } while (0 == b2);
      }
      return 0 <= b2;
    });
  }
  var dc2;
  dc2 = l.document && Tb2 ? Yb2() : void 0;
  try {
    new self.OffscreenCanvas(0, 0).getContext("2d");
  } catch (a) {
  }
  var ec2 = !Tb2 || 9 <= Number(dc2);
  function fc2(a) {
    var b2 = document;
    return "string" === typeof a ? b2.getElementById(a) : a;
  }
  function gc2(a, b2) {
    jb2(b2, function(c, d) {
      c && "object" == typeof c && c.sa && (c = c.ra());
      "style" == d ? a.style.cssText = c : "class" == d ? a.className = c : "for" == d ? a.htmlFor = c : hc2.hasOwnProperty(d) ? a.setAttribute(hc2[d], c) : 0 == d.lastIndexOf("aria-", 0) || 0 == d.lastIndexOf("data-", 0) ? a.setAttribute(d, c) : a[d] = c;
    });
  }
  var hc2 = { cellpadding: "cellPadding", cellspacing: "cellSpacing", colspan: "colSpan", frameborder: "frameBorder", height: "height", maxlength: "maxLength", nonce: "nonce", role: "role", rowspan: "rowSpan", type: "type", usemap: "useMap", valign: "vAlign", width: "width" };
  function ic2(a, b2, c) {
    var d = arguments, e = document, f = String(d[0]), g2 = d[1];
    if (!ec2 && g2 && (g2.name || g2.type)) {
      f = ["<", f];
      g2.name && f.push(' name="', Ob2(g2.name), '"');
      if (g2.type) {
        f.push(' type="', Ob2(g2.type), '"');
        var h = {};
        z2(h, g2);
        delete h.type;
        g2 = h;
      }
      f.push(">");
      f = f.join("");
    }
    f = jc2(e, f);
    g2 && ("string" === typeof g2 ? f.className = g2 : Array.isArray(g2) ? f.className = g2.join(" ") : gc2(f, g2));
    2 < d.length && kc2(e, f, d);
    return f;
  }
  function kc2(a, b2, c) {
    function d(g2) {
      g2 && b2.appendChild("string" === typeof g2 ? a.createTextNode(g2) : g2);
    }
    for (var e = 2; e < c.length; e++) {
      var f = c[e];
      !ma2(f) || n2(f) && 0 < f.nodeType ? d(f) : w2(lc2(f) ? Xa2(f) : f, d);
    }
  }
  function jc2(a, b2) {
    b2 = String(b2);
    "application/xhtml+xml" === a.contentType && (b2 = b2.toLowerCase());
    return a.createElement(b2);
  }
  function lc2(a) {
    if (a && "number" == typeof a.length) {
      if (n2(a))
        return "function" == typeof a.item || "string" == typeof a.item;
      if (na3(a))
        return "function" == typeof a.item;
    }
    return false;
  }
  ;
  function mc2(a) {
    l.setTimeout(function() {
      throw a;
    }, 0);
  }
  var nc2;
  function oc2() {
    var a = l.MessageChannel;
    "undefined" === typeof a && "undefined" !== typeof window && window.postMessage && window.addEventListener && !y2("Presto") && (a = function() {
      var e = jc2(document, "IFRAME");
      e.style.display = "none";
      Lb2(e);
      document.documentElement.appendChild(e);
      var f = e.contentWindow;
      e = f.document;
      e.open();
      e.write(Ib2(Kb2));
      e.close();
      var g2 = "callImmediate" + Math.random(), h = "file:" == f.location.protocol ? "*" : f.location.protocol + "//" + f.location.host;
      e = q3(
        function(m) {
          if (("*" == h || m.origin == h) && m.data == g2)
            this.port1.onmessage();
        },
        this
      );
      f.addEventListener("message", e, false);
      this.port1 = {};
      this.port2 = { postMessage: function() {
        f.postMessage(g2, h);
      } };
    });
    if ("undefined" !== typeof a && !y2("Trident") && !y2("MSIE")) {
      var b2 = new a(), c = {}, d = c;
      b2.port1.onmessage = function() {
        if (void 0 !== c.next) {
          c = c.next;
          var e = c.Fb;
          c.Fb = null;
          e();
        }
      };
      return function(e) {
        d.next = { Fb: e };
        d = d.next;
        b2.port2.postMessage(0);
      };
    }
    return function(e) {
      l.setTimeout(e, 0);
    };
  }
  ;
  function pc2(a, b2) {
    qc2 || rc2();
    sc || (qc2(), sc = true);
    La3.add(a, b2);
  }
  var qc2;
  function rc2() {
    if (l.Promise && l.Promise.resolve) {
      var a = l.Promise.resolve(void 0);
      qc2 = function() {
        a.then(tc2);
      };
    } else
      qc2 = function() {
        var b2 = tc2;
        !na3(l.setImmediate) || l.Window && l.Window.prototype && !y2("Edge") && l.Window.prototype.setImmediate == l.setImmediate ? (nc2 || (nc2 = oc2()), nc2(b2)) : l.setImmediate(b2);
      };
  }
  var sc = false, La3 = new Ha2();
  function tc2() {
    for (var a; a = Ka2(); ) {
      try {
        a.a.call(a.b);
      } catch (b2) {
        mc2(b2);
      }
      Ga2(Ja2, a);
    }
    sc = false;
  }
  ;
  function C3(a, b2) {
    this.a = uc2;
    this.i = void 0;
    this.f = this.b = this.c = null;
    this.g = this.h = false;
    if (a != ka3)
      try {
        var c = this;
        a.call(b2, function(d) {
          vc2(c, wc, d);
        }, function(d) {
          if (!(d instanceof xc2))
            try {
              if (d instanceof Error)
                throw d;
              throw Error("Promise rejected.");
            } catch (e) {
            }
          vc2(c, yc2, d);
        });
      } catch (d) {
        vc2(this, yc2, d);
      }
  }
  var uc2 = 0, wc = 2, yc2 = 3;
  function zc2() {
    this.next = this.f = this.b = this.g = this.a = null;
    this.c = false;
  }
  zc2.prototype.reset = function() {
    this.f = this.b = this.g = this.a = null;
    this.c = false;
  };
  var Ac2 = new Fa2(function() {
    return new zc2();
  }, function(a) {
    a.reset();
  });
  function Bc2(a, b2, c) {
    var d = Ac2.get();
    d.g = a;
    d.b = b2;
    d.f = c;
    return d;
  }
  function D3(a) {
    if (a instanceof C3)
      return a;
    var b2 = new C3(ka3);
    vc2(b2, wc, a);
    return b2;
  }
  function E3(a) {
    return new C3(function(b2, c) {
      c(a);
    });
  }
  function Cc2(a, b2, c) {
    Dc2(a, b2, c, null) || pc2(ta3(b2, a));
  }
  function Ec2(a) {
    return new C3(function(b2, c) {
      var d = a.length, e = [];
      if (d)
        for (var f = function(p2, v2) {
          d--;
          e[p2] = v2;
          0 == d && b2(e);
        }, g2 = function(p2) {
          c(p2);
        }, h = 0, m; h < a.length; h++)
          m = a[h], Cc2(m, ta3(f, h), g2);
      else
        b2(e);
    });
  }
  function Fc2(a) {
    return new C3(function(b2) {
      var c = a.length, d = [];
      if (c)
        for (var e = function(h, m, p2) {
          c--;
          d[h] = m ? { Ob: true, value: p2 } : { Ob: false, reason: p2 };
          0 == c && b2(d);
        }, f = 0, g2; f < a.length; f++)
          g2 = a[f], Cc2(g2, ta3(e, f, true), ta3(e, f, false));
      else
        b2(d);
    });
  }
  C3.prototype.then = function(a, b2, c) {
    return Gc2(this, na3(a) ? a : null, na3(b2) ? b2 : null, c);
  };
  C3.prototype.$goog_Thenable = true;
  k3 = C3.prototype;
  k3.na = function(a, b2) {
    a = Bc2(a, a, b2);
    a.c = true;
    Hc2(this, a);
    return this;
  };
  k3.s = function(a, b2) {
    return Gc2(this, null, a, b2);
  };
  k3.cancel = function(a) {
    if (this.a == uc2) {
      var b2 = new xc2(a);
      pc2(function() {
        Ic2(this, b2);
      }, this);
    }
  };
  function Ic2(a, b2) {
    if (a.a == uc2)
      if (a.c) {
        var c = a.c;
        if (c.b) {
          for (var d = 0, e = null, f = null, g2 = c.b; g2 && (g2.c || (d++, g2.a == a && (e = g2), !(e && 1 < d))); g2 = g2.next)
            e || (f = g2);
          e && (c.a == uc2 && 1 == d ? Ic2(c, b2) : (f ? (d = f, d.next == c.f && (c.f = d), d.next = d.next.next) : Jc2(c), Kc2(c, e, yc2, b2)));
        }
        a.c = null;
      } else
        vc2(a, yc2, b2);
  }
  function Hc2(a, b2) {
    a.b || a.a != wc && a.a != yc2 || Lc2(a);
    a.f ? a.f.next = b2 : a.b = b2;
    a.f = b2;
  }
  function Gc2(a, b2, c, d) {
    var e = Bc2(null, null, null);
    e.a = new C3(function(f, g2) {
      e.g = b2 ? function(h) {
        try {
          var m = b2.call(d, h);
          f(m);
        } catch (p2) {
          g2(p2);
        }
      } : f;
      e.b = c ? function(h) {
        try {
          var m = c.call(d, h);
          void 0 === m && h instanceof xc2 ? g2(h) : f(m);
        } catch (p2) {
          g2(p2);
        }
      } : g2;
    });
    e.a.c = a;
    Hc2(a, e);
    return e.a;
  }
  k3.Zc = function(a) {
    this.a = uc2;
    vc2(this, wc, a);
  };
  k3.$c = function(a) {
    this.a = uc2;
    vc2(this, yc2, a);
  };
  function vc2(a, b2, c) {
    a.a == uc2 && (a === c && (b2 = yc2, c = new TypeError("Promise cannot resolve to itself")), a.a = 1, Dc2(c, a.Zc, a.$c, a) || (a.i = c, a.a = b2, a.c = null, Lc2(a), b2 != yc2 || c instanceof xc2 || Mc2(a, c)));
  }
  function Dc2(a, b2, c, d) {
    if (a instanceof C3)
      return Hc2(a, Bc2(b2 || ka3, c || null, d)), true;
    if (Ca2(a))
      return a.then(b2, c, d), true;
    if (n2(a))
      try {
        var e = a.then;
        if (na3(e))
          return Nc2(a, e, b2, c, d), true;
      } catch (f) {
        return c.call(d, f), true;
      }
    return false;
  }
  function Nc2(a, b2, c, d, e) {
    function f(m) {
      h || (h = true, d.call(e, m));
    }
    function g2(m) {
      h || (h = true, c.call(e, m));
    }
    var h = false;
    try {
      b2.call(a, g2, f);
    } catch (m) {
      f(m);
    }
  }
  function Lc2(a) {
    a.h || (a.h = true, pc2(a.fc, a));
  }
  function Jc2(a) {
    var b2 = null;
    a.b && (b2 = a.b, a.b = b2.next, b2.next = null);
    a.b || (a.f = null);
    return b2;
  }
  k3.fc = function() {
    for (var a; a = Jc2(this); )
      Kc2(this, a, this.a, this.i);
    this.h = false;
  };
  function Kc2(a, b2, c, d) {
    if (c == yc2 && b2.b && !b2.c)
      for (; a && a.g; a = a.c)
        a.g = false;
    if (b2.a)
      b2.a.c = null, Oc2(b2, c, d);
    else
      try {
        b2.c ? b2.g.call(b2.f) : Oc2(b2, c, d);
      } catch (e) {
        Pc2.call(null, e);
      }
    Ga2(Ac2, b2);
  }
  function Oc2(a, b2, c) {
    b2 == wc ? a.g.call(a.f, c) : a.b && a.b.call(a.f, c);
  }
  function Mc2(a, b2) {
    a.g = true;
    pc2(function() {
      a.g && Pc2.call(null, b2);
    });
  }
  var Pc2 = mc2;
  function xc2(a) {
    u4.call(this, a);
  }
  r2(xc2, u4);
  xc2.prototype.name = "cancel";
  function Qc2() {
    0 != Rc2 && (Sc2[oa3(this)] = this);
    this.xa = this.xa;
    this.oa = this.oa;
  }
  var Rc2 = 0, Sc2 = {};
  Qc2.prototype.xa = false;
  function Tc2(a) {
    if (!a.xa && (a.xa = true, a.Da(), 0 != Rc2)) {
      var b2 = oa3(a);
      if (0 != Rc2 && a.oa && 0 < a.oa.length)
        throw Error(a + " did not empty its onDisposeCallbacks queue. This probably means it overrode dispose() or disposeInternal() without calling the superclass' method.");
      delete Sc2[b2];
    }
  }
  Qc2.prototype.Da = function() {
    if (this.oa)
      for (; this.oa.length; )
        this.oa.shift()();
  };
  var Uc2 = Object.freeze || function(a) {
    return a;
  };
  var Vc2 = !Tb2 || 9 <= Number(dc2), Wc2 = Tb2 && !cc2("9"), Xc2 = function() {
    if (!l.addEventListener || !Object.defineProperty)
      return false;
    var a = false, b2 = Object.defineProperty({}, "passive", { get: function() {
      a = true;
    } });
    try {
      l.addEventListener("test", ka3, b2), l.removeEventListener("test", ka3, b2);
    } catch (c) {
    }
    return a;
  }();
  function F3(a, b2) {
    this.type = a;
    this.b = this.target = b2;
    this.defaultPrevented = false;
  }
  F3.prototype.preventDefault = function() {
    this.defaultPrevented = true;
  };
  function Yc2(a, b2) {
    F3.call(this, a ? a.type : "");
    this.relatedTarget = this.b = this.target = null;
    this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0;
    this.key = "";
    this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = false;
    this.pointerId = 0;
    this.pointerType = "";
    this.a = null;
    if (a) {
      var c = this.type = a.type, d = a.changedTouches && a.changedTouches.length ? a.changedTouches[0] : null;
      this.target = a.target || a.srcElement;
      this.b = b2;
      if (b2 = a.relatedTarget) {
        if (Wb2) {
          a: {
            try {
              Pb2(b2.nodeName);
              var e = true;
              break a;
            } catch (f) {
            }
            e = false;
          }
          e || (b2 = null);
        }
      } else
        "mouseover" == c ? b2 = a.fromElement : "mouseout" == c && (b2 = a.toElement);
      this.relatedTarget = b2;
      d ? (this.clientX = void 0 !== d.clientX ? d.clientX : d.pageX, this.clientY = void 0 !== d.clientY ? d.clientY : d.pageY, this.screenX = d.screenX || 0, this.screenY = d.screenY || 0) : (this.clientX = void 0 !== a.clientX ? a.clientX : a.pageX, this.clientY = void 0 !== a.clientY ? a.clientY : a.pageY, this.screenX = a.screenX || 0, this.screenY = a.screenY || 0);
      this.button = a.button;
      this.key = a.key || "";
      this.ctrlKey = a.ctrlKey;
      this.altKey = a.altKey;
      this.shiftKey = a.shiftKey;
      this.metaKey = a.metaKey;
      this.pointerId = a.pointerId || 0;
      this.pointerType = "string" === typeof a.pointerType ? a.pointerType : Zc2[a.pointerType] || "";
      this.a = a;
      a.defaultPrevented && this.preventDefault();
    }
  }
  r2(Yc2, F3);
  var Zc2 = Uc2({ 2: "touch", 3: "pen", 4: "mouse" });
  Yc2.prototype.preventDefault = function() {
    Yc2.$a.preventDefault.call(this);
    var a = this.a;
    if (a.preventDefault)
      a.preventDefault();
    else if (a.returnValue = false, Wc2)
      try {
        if (a.ctrlKey || 112 <= a.keyCode && 123 >= a.keyCode)
          a.keyCode = -1;
      } catch (b2) {
      }
  };
  Yc2.prototype.g = function() {
    return this.a;
  };
  var $c2 = "closure_listenable_" + (1e6 * Math.random() | 0), ad2 = 0;
  function bd2(a, b2, c, d, e) {
    this.listener = a;
    this.proxy = null;
    this.src = b2;
    this.type = c;
    this.capture = !!d;
    this.Ua = e;
    this.key = ++ad2;
    this.va = this.Oa = false;
  }
  function cd2(a) {
    a.va = true;
    a.listener = null;
    a.proxy = null;
    a.src = null;
    a.Ua = null;
  }
  ;
  function dd2(a) {
    this.src = a;
    this.a = {};
    this.b = 0;
  }
  dd2.prototype.add = function(a, b2, c, d, e) {
    var f = a.toString();
    a = this.a[f];
    a || (a = this.a[f] = [], this.b++);
    var g2 = ed2(a, b2, d, e);
    -1 < g2 ? (b2 = a[g2], c || (b2.Oa = false)) : (b2 = new bd2(b2, this.src, f, !!d, e), b2.Oa = c, a.push(b2));
    return b2;
  };
  function fd2(a, b2) {
    var c = b2.type;
    c in a.a && Ua2(a.a[c], b2) && (cd2(b2), 0 == a.a[c].length && (delete a.a[c], a.b--));
  }
  function ed2(a, b2, c, d) {
    for (var e = 0; e < a.length; ++e) {
      var f = a[e];
      if (!f.va && f.listener == b2 && f.capture == !!c && f.Ua == d)
        return e;
    }
    return -1;
  }
  ;
  var gd2 = "closure_lm_" + (1e6 * Math.random() | 0), hd2 = {}, id2 = 0;
  function jd2(a, b2, c, d, e) {
    if (d && d.once)
      kd2(a, b2, c, d, e);
    else if (Array.isArray(b2))
      for (var f = 0; f < b2.length; f++)
        jd2(a, b2[f], c, d, e);
    else
      c = ld2(c), a && a[$c2] ? md2(a, b2, c, n2(d) ? !!d.capture : !!d, e) : nd2(a, b2, c, false, d, e);
  }
  function nd2(a, b2, c, d, e, f) {
    if (!b2)
      throw Error("Invalid event type");
    var g2 = n2(e) ? !!e.capture : !!e, h = od2(a);
    h || (a[gd2] = h = new dd2(a));
    c = h.add(b2, c, d, g2, f);
    if (!c.proxy) {
      d = pd2();
      c.proxy = d;
      d.src = a;
      d.listener = c;
      if (a.addEventListener)
        Xc2 || (e = g2), void 0 === e && (e = false), a.addEventListener(b2.toString(), d, e);
      else if (a.attachEvent)
        a.attachEvent(qd2(b2.toString()), d);
      else if (a.addListener && a.removeListener)
        a.addListener(d);
      else
        throw Error("addEventListener and attachEvent are unavailable.");
      id2++;
    }
  }
  function pd2() {
    var a = rd2, b2 = Vc2 ? function(c) {
      return a.call(b2.src, b2.listener, c);
    } : function(c) {
      c = a.call(b2.src, b2.listener, c);
      if (!c)
        return c;
    };
    return b2;
  }
  function kd2(a, b2, c, d, e) {
    if (Array.isArray(b2))
      for (var f = 0; f < b2.length; f++)
        kd2(a, b2[f], c, d, e);
    else
      c = ld2(c), a && a[$c2] ? sd2(a, b2, c, n2(d) ? !!d.capture : !!d, e) : nd2(a, b2, c, true, d, e);
  }
  function G3(a, b2, c, d, e) {
    if (Array.isArray(b2))
      for (var f = 0; f < b2.length; f++)
        G3(a, b2[f], c, d, e);
    else
      (d = n2(d) ? !!d.capture : !!d, c = ld2(c), a && a[$c2]) ? (a = a.v, b2 = String(b2).toString(), b2 in a.a && (f = a.a[b2], c = ed2(f, c, d, e), -1 < c && (cd2(f[c]), Array.prototype.splice.call(f, c, 1), 0 == f.length && (delete a.a[b2], a.b--)))) : a && (a = od2(a)) && (b2 = a.a[b2.toString()], a = -1, b2 && (a = ed2(b2, c, d, e)), (c = -1 < a ? b2[a] : null) && td2(c));
  }
  function td2(a) {
    if ("number" !== typeof a && a && !a.va) {
      var b2 = a.src;
      if (b2 && b2[$c2])
        fd2(b2.v, a);
      else {
        var c = a.type, d = a.proxy;
        b2.removeEventListener ? b2.removeEventListener(c, d, a.capture) : b2.detachEvent ? b2.detachEvent(qd2(c), d) : b2.addListener && b2.removeListener && b2.removeListener(d);
        id2--;
        (c = od2(b2)) ? (fd2(c, a), 0 == c.b && (c.src = null, b2[gd2] = null)) : cd2(a);
      }
    }
  }
  function qd2(a) {
    return a in hd2 ? hd2[a] : hd2[a] = "on" + a;
  }
  function ud2(a, b2, c, d) {
    var e = true;
    if (a = od2(a)) {
      if (b2 = a.a[b2.toString()])
        for (b2 = b2.concat(), a = 0; a < b2.length; a++) {
          var f = b2[a];
          f && f.capture == c && !f.va && (f = vd2(f, d), e = e && false !== f);
        }
    }
    return e;
  }
  function vd2(a, b2) {
    var c = a.listener, d = a.Ua || a.src;
    a.Oa && td2(a);
    return c.call(d, b2);
  }
  function rd2(a, b2) {
    if (a.va)
      return true;
    if (!Vc2) {
      if (!b2)
        a: {
          b2 = ["window", "event"];
          for (var c = l, d = 0; d < b2.length; d++)
            if (c = c[b2[d]], null == c) {
              b2 = null;
              break a;
            }
          b2 = c;
        }
      d = b2;
      b2 = new Yc2(d, this);
      c = true;
      if (!(0 > d.keyCode || void 0 != d.returnValue)) {
        a: {
          var e = false;
          if (0 == d.keyCode)
            try {
              d.keyCode = -1;
              break a;
            } catch (g2) {
              e = true;
            }
          if (e || void 0 == d.returnValue)
            d.returnValue = true;
        }
        d = [];
        for (e = b2.b; e; e = e.parentNode)
          d.push(e);
        a = a.type;
        for (e = d.length - 1; 0 <= e; e--) {
          b2.b = d[e];
          var f = ud2(d[e], a, true, b2);
          c = c && f;
        }
        for (e = 0; e < d.length; e++)
          b2.b = d[e], f = ud2(d[e], a, false, b2), c = c && f;
      }
      return c;
    }
    return vd2(
      a,
      new Yc2(b2, this)
    );
  }
  function od2(a) {
    a = a[gd2];
    return a instanceof dd2 ? a : null;
  }
  var wd2 = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);
  function ld2(a) {
    if (na3(a))
      return a;
    a[wd2] || (a[wd2] = function(b2) {
      return a.handleEvent(b2);
    });
    return a[wd2];
  }
  ;
  function H3() {
    Qc2.call(this);
    this.v = new dd2(this);
    this.$b = this;
    this.fb = null;
  }
  r2(H3, Qc2);
  H3.prototype[$c2] = true;
  H3.prototype.addEventListener = function(a, b2, c, d) {
    jd2(this, a, b2, c, d);
  };
  H3.prototype.removeEventListener = function(a, b2, c, d) {
    G3(this, a, b2, c, d);
  };
  H3.prototype.dispatchEvent = function(a) {
    var b2, c = this.fb;
    if (c)
      for (b2 = []; c; c = c.fb)
        b2.push(c);
    c = this.$b;
    var d = a.type || a;
    if ("string" === typeof a)
      a = new F3(a, c);
    else if (a instanceof F3)
      a.target = a.target || c;
    else {
      var e = a;
      a = new F3(d, c);
      z2(a, e);
    }
    e = true;
    if (b2)
      for (var f = b2.length - 1; 0 <= f; f--) {
        var g2 = a.b = b2[f];
        e = xd2(g2, d, true, a) && e;
      }
    g2 = a.b = c;
    e = xd2(g2, d, true, a) && e;
    e = xd2(g2, d, false, a) && e;
    if (b2)
      for (f = 0; f < b2.length; f++)
        g2 = a.b = b2[f], e = xd2(g2, d, false, a) && e;
    return e;
  };
  H3.prototype.Da = function() {
    H3.$a.Da.call(this);
    if (this.v) {
      var a = this.v, b2 = 0, c;
      for (c in a.a) {
        for (var d = a.a[c], e = 0; e < d.length; e++)
          ++b2, cd2(d[e]);
        delete a.a[c];
        a.b--;
      }
    }
    this.fb = null;
  };
  function md2(a, b2, c, d, e) {
    a.v.add(String(b2), c, false, d, e);
  }
  function sd2(a, b2, c, d, e) {
    a.v.add(String(b2), c, true, d, e);
  }
  function xd2(a, b2, c, d) {
    b2 = a.v.a[String(b2)];
    if (!b2)
      return true;
    b2 = b2.concat();
    for (var e = true, f = 0; f < b2.length; ++f) {
      var g2 = b2[f];
      if (g2 && !g2.va && g2.capture == c) {
        var h = g2.listener, m = g2.Ua || g2.src;
        g2.Oa && fd2(a.v, g2);
        e = false !== h.call(m, d) && e;
      }
    }
    return e && !d.defaultPrevented;
  }
  ;
  function zd2(a, b2, c) {
    if (na3(a))
      c && (a = q3(a, c));
    else if (a && "function" == typeof a.handleEvent)
      a = q3(a.handleEvent, a);
    else
      throw Error("Invalid listener argument");
    return 2147483647 < Number(b2) ? -1 : l.setTimeout(a, b2 || 0);
  }
  function Ad2(a) {
    var b2 = null;
    return new C3(function(c, d) {
      b2 = zd2(function() {
        c(void 0);
      }, a);
      -1 == b2 && d(Error("Failed to schedule timer."));
    }).s(function(c) {
      l.clearTimeout(b2);
      throw c;
    });
  }
  ;
  function Bd2(a) {
    if (a.V && "function" == typeof a.V)
      return a.V();
    if ("string" === typeof a)
      return a.split("");
    if (ma2(a)) {
      for (var b2 = [], c = a.length, d = 0; d < c; d++)
        b2.push(a[d]);
      return b2;
    }
    b2 = [];
    c = 0;
    for (d in a)
      b2[c++] = a[d];
    return b2;
  }
  function Cd2(a) {
    if (a.Y && "function" == typeof a.Y)
      return a.Y();
    if (!a.V || "function" != typeof a.V) {
      if (ma2(a) || "string" === typeof a) {
        var b2 = [];
        a = a.length;
        for (var c = 0; c < a; c++)
          b2.push(c);
        return b2;
      }
      b2 = [];
      c = 0;
      for (var d in a)
        b2[c++] = d;
      return b2;
    }
  }
  function Dd2(a, b2) {
    if (a.forEach && "function" == typeof a.forEach)
      a.forEach(b2, void 0);
    else if (ma2(a) || "string" === typeof a)
      w2(a, b2, void 0);
    else
      for (var c = Cd2(a), d = Bd2(a), e = d.length, f = 0; f < e; f++)
        b2.call(void 0, d[f], c && c[f], a);
  }
  ;
  function Ed2(a, b2) {
    this.b = {};
    this.a = [];
    this.c = 0;
    var c = arguments.length;
    if (1 < c) {
      if (c % 2)
        throw Error("Uneven number of arguments");
      for (var d = 0; d < c; d += 2)
        this.set(arguments[d], arguments[d + 1]);
    } else if (a)
      if (a instanceof Ed2)
        for (c = a.Y(), d = 0; d < c.length; d++)
          this.set(c[d], a.get(c[d]));
      else
        for (d in a)
          this.set(d, a[d]);
  }
  k3 = Ed2.prototype;
  k3.V = function() {
    Fd2(this);
    for (var a = [], b2 = 0; b2 < this.a.length; b2++)
      a.push(this.b[this.a[b2]]);
    return a;
  };
  k3.Y = function() {
    Fd2(this);
    return this.a.concat();
  };
  k3.clear = function() {
    this.b = {};
    this.c = this.a.length = 0;
  };
  function Fd2(a) {
    if (a.c != a.a.length) {
      for (var b2 = 0, c = 0; b2 < a.a.length; ) {
        var d = a.a[b2];
        Gd2(a.b, d) && (a.a[c++] = d);
        b2++;
      }
      a.a.length = c;
    }
    if (a.c != a.a.length) {
      var e = {};
      for (c = b2 = 0; b2 < a.a.length; )
        d = a.a[b2], Gd2(e, d) || (a.a[c++] = d, e[d] = 1), b2++;
      a.a.length = c;
    }
  }
  k3.get = function(a, b2) {
    return Gd2(this.b, a) ? this.b[a] : b2;
  };
  k3.set = function(a, b2) {
    Gd2(this.b, a) || (this.c++, this.a.push(a));
    this.b[a] = b2;
  };
  k3.forEach = function(a, b2) {
    for (var c = this.Y(), d = 0; d < c.length; d++) {
      var e = c[d], f = this.get(e);
      a.call(b2, f, e, this);
    }
  };
  function Gd2(a, b2) {
    return Object.prototype.hasOwnProperty.call(a, b2);
  }
  ;
  var Hd2 = /^(?:([^:/?#.]+):)?(?:\/\/(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/\\#?]|$))?([^?#]+)?(?:\?([^#]*))?(?:#([\s\S]*))?$/;
  function Id2(a, b2) {
    if (a) {
      a = a.split("&");
      for (var c = 0; c < a.length; c++) {
        var d = a[c].indexOf("="), e = null;
        if (0 <= d) {
          var f = a[c].substring(0, d);
          e = a[c].substring(d + 1);
        } else
          f = a[c];
        b2(f, e ? decodeURIComponent(e.replace(/\+/g, " ")) : "");
      }
    }
  }
  ;
  function Jd2(a, b2) {
    this.a = this.l = this.f = "";
    this.g = null;
    this.h = this.c = "";
    this.i = false;
    var c;
    a instanceof Jd2 ? (this.i = void 0 !== b2 ? b2 : a.i, Kd2(this, a.f), this.l = a.l, this.a = a.a, Ld2(this, a.g), this.c = a.c, Md2(this, Nd2(a.b)), this.h = a.h) : a && (c = String(a).match(Hd2)) ? (this.i = !!b2, Kd2(this, c[1] || "", true), this.l = Od2(c[2] || ""), this.a = Od2(c[3] || "", true), Ld2(this, c[4]), this.c = Od2(c[5] || "", true), Md2(this, c[6] || "", true), this.h = Od2(c[7] || "")) : (this.i = !!b2, this.b = new Pd2(null, this.i));
  }
  Jd2.prototype.toString = function() {
    var a = [], b2 = this.f;
    b2 && a.push(Qd(b2, Rd, true), ":");
    var c = this.a;
    if (c || "file" == b2)
      a.push("//"), (b2 = this.l) && a.push(Qd(b2, Rd, true), "@"), a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), c = this.g, null != c && a.push(":", String(c));
    if (c = this.c)
      this.a && "/" != c.charAt(0) && a.push("/"), a.push(Qd(c, "/" == c.charAt(0) ? Sd : Td, true));
    (c = this.b.toString()) && a.push("?", c);
    (c = this.h) && a.push("#", Qd(c, Ud));
    return a.join("");
  };
  Jd2.prototype.resolve = function(a) {
    var b2 = new Jd2(this), c = !!a.f;
    c ? Kd2(b2, a.f) : c = !!a.l;
    c ? b2.l = a.l : c = !!a.a;
    c ? b2.a = a.a : c = null != a.g;
    var d = a.c;
    if (c)
      Ld2(b2, a.g);
    else if (c = !!a.c) {
      if ("/" != d.charAt(0))
        if (this.a && !this.c)
          d = "/" + d;
        else {
          var e = b2.c.lastIndexOf("/");
          -1 != e && (d = b2.c.substr(0, e + 1) + d);
        }
      e = d;
      if (".." == e || "." == e)
        d = "";
      else if (x3(e, "./") || x3(e, "/.")) {
        d = 0 == e.lastIndexOf("/", 0);
        e = e.split("/");
        for (var f = [], g2 = 0; g2 < e.length; ) {
          var h = e[g2++];
          "." == h ? d && g2 == e.length && f.push("") : ".." == h ? ((1 < f.length || 1 == f.length && "" != f[0]) && f.pop(), d && g2 == e.length && f.push("")) : (f.push(h), d = true);
        }
        d = f.join("/");
      } else
        d = e;
    }
    c ? b2.c = d : c = "" !== a.b.toString();
    c ? Md2(b2, Nd2(a.b)) : c = !!a.h;
    c && (b2.h = a.h);
    return b2;
  };
  function Kd2(a, b2, c) {
    a.f = c ? Od2(b2, true) : b2;
    a.f && (a.f = a.f.replace(/:$/, ""));
  }
  function Ld2(a, b2) {
    if (b2) {
      b2 = Number(b2);
      if (isNaN(b2) || 0 > b2)
        throw Error("Bad port number " + b2);
      a.g = b2;
    } else
      a.g = null;
  }
  function Md2(a, b2, c) {
    b2 instanceof Pd2 ? (a.b = b2, Vd(a.b, a.i)) : (c || (b2 = Qd(b2, Wd)), a.b = new Pd2(b2, a.i));
  }
  function I3(a, b2, c) {
    a.b.set(b2, c);
  }
  function Xd(a, b2) {
    return a.b.get(b2);
  }
  function J3(a) {
    return a instanceof Jd2 ? new Jd2(a) : new Jd2(a, void 0);
  }
  function Yd(a, b2, c, d) {
    var e = new Jd2(null, void 0);
    a && Kd2(e, a);
    b2 && (e.a = b2);
    c && Ld2(e, c);
    d && (e.c = d);
    return e;
  }
  function Od2(a, b2) {
    return a ? b2 ? decodeURI(a.replace(/%25/g, "%2525")) : decodeURIComponent(a) : "";
  }
  function Qd(a, b2, c) {
    return "string" === typeof a ? (a = encodeURI(a).replace(b2, Zd), c && (a = a.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), a) : null;
  }
  function Zd(a) {
    a = a.charCodeAt(0);
    return "%" + (a >> 4 & 15).toString(16) + (a & 15).toString(16);
  }
  var Rd = /[#\/\?@]/g, Td = /[#\?:]/g, Sd = /[#\?]/g, Wd = /[#\?@]/g, Ud = /#/g;
  function Pd2(a, b2) {
    this.b = this.a = null;
    this.c = a || null;
    this.f = !!b2;
  }
  function $d(a) {
    a.a || (a.a = new Ed2(), a.b = 0, a.c && Id2(a.c, function(b2, c) {
      a.add(decodeURIComponent(b2.replace(/\+/g, " ")), c);
    }));
  }
  function ae2(a) {
    var b2 = Cd2(a);
    if ("undefined" == typeof b2)
      throw Error("Keys are undefined");
    var c = new Pd2(null, void 0);
    a = Bd2(a);
    for (var d = 0; d < b2.length; d++) {
      var e = b2[d], f = a[d];
      Array.isArray(f) ? be2(c, e, f) : c.add(e, f);
    }
    return c;
  }
  k3 = Pd2.prototype;
  k3.add = function(a, b2) {
    $d(this);
    this.c = null;
    a = ce2(this, a);
    var c = this.a.get(a);
    c || this.a.set(a, c = []);
    c.push(b2);
    this.b += 1;
    return this;
  };
  function de2(a, b2) {
    $d(a);
    b2 = ce2(a, b2);
    Gd2(a.a.b, b2) && (a.c = null, a.b -= a.a.get(b2).length, a = a.a, Gd2(a.b, b2) && (delete a.b[b2], a.c--, a.a.length > 2 * a.c && Fd2(a)));
  }
  k3.clear = function() {
    this.a = this.c = null;
    this.b = 0;
  };
  function ee2(a, b2) {
    $d(a);
    b2 = ce2(a, b2);
    return Gd2(a.a.b, b2);
  }
  k3.forEach = function(a, b2) {
    $d(this);
    this.a.forEach(function(c, d) {
      w2(c, function(e) {
        a.call(b2, e, d, this);
      }, this);
    }, this);
  };
  k3.Y = function() {
    $d(this);
    for (var a = this.a.V(), b2 = this.a.Y(), c = [], d = 0; d < b2.length; d++)
      for (var e = a[d], f = 0; f < e.length; f++)
        c.push(b2[d]);
    return c;
  };
  k3.V = function(a) {
    $d(this);
    var b2 = [];
    if ("string" === typeof a)
      ee2(this, a) && (b2 = Wa2(b2, this.a.get(ce2(this, a))));
    else {
      a = this.a.V();
      for (var c = 0; c < a.length; c++)
        b2 = Wa2(b2, a[c]);
    }
    return b2;
  };
  k3.set = function(a, b2) {
    $d(this);
    this.c = null;
    a = ce2(this, a);
    ee2(this, a) && (this.b -= this.a.get(a).length);
    this.a.set(a, [b2]);
    this.b += 1;
    return this;
  };
  k3.get = function(a, b2) {
    if (!a)
      return b2;
    a = this.V(a);
    return 0 < a.length ? String(a[0]) : b2;
  };
  function be2(a, b2, c) {
    de2(a, b2);
    0 < c.length && (a.c = null, a.a.set(ce2(a, b2), Xa2(c)), a.b += c.length);
  }
  k3.toString = function() {
    if (this.c)
      return this.c;
    if (!this.a)
      return "";
    for (var a = [], b2 = this.a.Y(), c = 0; c < b2.length; c++) {
      var d = b2[c], e = encodeURIComponent(String(d));
      d = this.V(d);
      for (var f = 0; f < d.length; f++) {
        var g2 = e;
        "" !== d[f] && (g2 += "=" + encodeURIComponent(String(d[f])));
        a.push(g2);
      }
    }
    return this.c = a.join("&");
  };
  function Nd2(a) {
    var b2 = new Pd2();
    b2.c = a.c;
    a.a && (b2.a = new Ed2(a.a), b2.b = a.b);
    return b2;
  }
  function ce2(a, b2) {
    b2 = String(b2);
    a.f && (b2 = b2.toLowerCase());
    return b2;
  }
  function Vd(a, b2) {
    b2 && !a.f && ($d(a), a.c = null, a.a.forEach(function(c, d) {
      var e = d.toLowerCase();
      d != e && (de2(this, d), be2(this, e, c));
    }, a));
    a.f = b2;
  }
  ;
  function fe2(a) {
    var b2 = [];
    ge2(new he2(), a, b2);
    return b2.join("");
  }
  function he2() {
  }
  function ge2(a, b2, c) {
    if (null == b2)
      c.push("null");
    else {
      if ("object" == typeof b2) {
        if (Array.isArray(b2)) {
          var d = b2;
          b2 = d.length;
          c.push("[");
          for (var e = "", f = 0; f < b2; f++)
            c.push(e), ge2(a, d[f], c), e = ",";
          c.push("]");
          return;
        }
        if (b2 instanceof String || b2 instanceof Number || b2 instanceof Boolean)
          b2 = b2.valueOf();
        else {
          c.push("{");
          e = "";
          for (d in b2)
            Object.prototype.hasOwnProperty.call(b2, d) && (f = b2[d], "function" != typeof f && (c.push(e), ie2(d, c), c.push(":"), ge2(a, f, c), e = ","));
          c.push("}");
          return;
        }
      }
      switch (typeof b2) {
        case "string":
          ie2(b2, c);
          break;
        case "number":
          c.push(isFinite(b2) && !isNaN(b2) ? String(b2) : "null");
          break;
        case "boolean":
          c.push(String(b2));
          break;
        case "function":
          c.push("null");
          break;
        default:
          throw Error("Unknown type: " + typeof b2);
      }
    }
  }
  var je2 = { '"': '\\"', "\\": "\\\\", "/": "\\/", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\u000b" }, ke2 = /\uffff/.test("￿") ? /[\\"\x00-\x1f\x7f-\uffff]/g : /[\\"\x00-\x1f\x7f-\xff]/g;
  function ie2(a, b2) {
    b2.push('"', a.replace(ke2, function(c) {
      var d = je2[c];
      d || (d = "\\u" + (c.charCodeAt(0) | 65536).toString(16).substr(1), je2[c] = d);
      return d;
    }), '"');
  }
  ;
  function le2() {
    var a = K3();
    return Tb2 && !!dc2 && 11 == dc2 || /Edge\/\d+/.test(a);
  }
  function me2() {
    return l.window && l.window.location.href || self && self.location && self.location.href || "";
  }
  function ne2(a, b2) {
    b2 = b2 || l.window;
    var c = "about:blank";
    a && (c = Db2(Fb2(a)));
    b2.location.href = c;
  }
  function oe2(a, b2) {
    var c = [], d;
    for (d in a)
      d in b2 ? typeof a[d] != typeof b2[d] ? c.push(d) : "object" == typeof a[d] && null != a[d] && null != b2[d] ? 0 < oe2(a[d], b2[d]).length && c.push(d) : a[d] !== b2[d] && c.push(d) : c.push(d);
    for (d in b2)
      d in a || c.push(d);
    return c;
  }
  function pe2() {
    var a = K3();
    a = qe2(a) != re2 ? null : (a = a.match(/\sChrome\/(\d+)/i)) && 2 == a.length ? parseInt(a[1], 10) : null;
    return a && 30 > a ? false : !Tb2 || !dc2 || 9 < dc2;
  }
  function se2(a) {
    a = (a || K3()).toLowerCase();
    return a.match(/android/) || a.match(/webos/) || a.match(/iphone|ipad|ipod/) || a.match(/blackberry/) || a.match(/windows phone/) || a.match(/iemobile/) ? true : false;
  }
  function te2(a) {
    a = a || l.window;
    try {
      a.close();
    } catch (b2) {
    }
  }
  function ue2(a, b2, c) {
    var d = Math.floor(1e9 * Math.random()).toString();
    b2 = b2 || 500;
    c = c || 600;
    var e = (window.screen.availHeight - c) / 2, f = (window.screen.availWidth - b2) / 2;
    b2 = { width: b2, height: c, top: 0 < e ? e : 0, left: 0 < f ? f : 0, location: true, resizable: true, statusbar: true, toolbar: false };
    c = K3().toLowerCase();
    d && (b2.target = d, x3(c, "crios/") && (b2.target = "_blank"));
    qe2(K3()) == ve2 && (a = a || "http://localhost", b2.scrollbars = true);
    c = a || "";
    (a = b2) || (a = {});
    d = window;
    b2 = c instanceof Ab2 ? c : Fb2("undefined" != typeof c.href ? c.href : String(c));
    c = a.target || c.target;
    e = [];
    for (g2 in a)
      switch (g2) {
        case "width":
        case "height":
        case "top":
        case "left":
          e.push(g2 + "=" + a[g2]);
          break;
        case "target":
        case "noopener":
        case "noreferrer":
          break;
        default:
          e.push(g2 + "=" + (a[g2] ? 1 : 0));
      }
    var g2 = e.join(",");
    if ((y2("iPhone") && !y2("iPod") && !y2("iPad") || y2("iPad") || y2("iPod")) && d.navigator && d.navigator.standalone && c && "_self" != c)
      g2 = jc2(document, "A"), nb2(g2, "HTMLAnchorElement"), b2 instanceof Ab2 || b2 instanceof Ab2 || (b2 = "object" == typeof b2 && b2.sa ? b2.ra() : String(b2), Eb2.test(b2) || (b2 = "about:invalid#zClosurez"), b2 = new Ab2(Bb2, b2)), g2.href = Db2(b2), g2.setAttribute("target", c), a.noreferrer && g2.setAttribute("rel", "noreferrer"), a = document.createEvent("MouseEvent"), a.initMouseEvent("click", true, true, d, 1), g2.dispatchEvent(a), g2 = {};
    else if (a.noreferrer) {
      if (g2 = d.open("", c, g2), a = Db2(b2), g2 && (Vb2 && x3(a, ";") && (a = "'" + a.replace(/'/g, "%27") + "'"), g2.opener = null, a = Jb2('<meta name="referrer" content="no-referrer"><meta http-equiv="refresh" content="0; url=' + Ob2(a) + '">'), d = g2.document))
        d.write(Ib2(a)), d.close();
    } else
      (g2 = d.open(Db2(b2), c, g2)) && a.noopener && (g2.opener = null);
    if (g2)
      try {
        g2.focus();
      } catch (h) {
      }
    return g2;
  }
  function we2(a) {
    return new C3(function(b2) {
      function c() {
        Ad2(2e3).then(function() {
          if (!a || a.closed)
            b2();
          else
            return c();
        });
      }
      return c();
    });
  }
  var xe2 = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/, ye2 = /^[^@]+@[^@]+$/;
  function ze2() {
    var a = null;
    return new C3(function(b2) {
      "complete" == l.document.readyState ? b2() : (a = function() {
        b2();
      }, kd2(window, "load", a));
    }).s(function(b2) {
      G3(window, "load", a);
      throw b2;
    });
  }
  function Ae2() {
    return Be2(void 0) ? ze2().then(function() {
      return new C3(function(a, b2) {
        var c = l.document, d = setTimeout(function() {
          b2(Error("Cordova framework is not ready."));
        }, 1e3);
        c.addEventListener("deviceready", function() {
          clearTimeout(d);
          a();
        }, false);
      });
    }) : E3(Error("Cordova must run in an Android or iOS file scheme."));
  }
  function Be2(a) {
    a = a || K3();
    return !("file:" !== Ce2() && "ionic:" !== Ce2() || !a.toLowerCase().match(/iphone|ipad|ipod|android/));
  }
  function De2() {
    var a = l.window;
    try {
      return !(!a || a == a.top);
    } catch (b2) {
      return false;
    }
  }
  function Ee2() {
    return "undefined" !== typeof l.WorkerGlobalScope && "function" === typeof l.importScripts;
  }
  function Fe2() {
    return import_app8.default.INTERNAL.hasOwnProperty("reactNative") ? "ReactNative" : import_app8.default.INTERNAL.hasOwnProperty("node") ? "Node" : Ee2() ? "Worker" : "Browser";
  }
  function Ge2() {
    var a = Fe2();
    return "ReactNative" === a || "Node" === a;
  }
  function He2() {
    for (var a = 50, b2 = []; 0 < a; )
      b2.push("1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".charAt(Math.floor(62 * Math.random()))), a--;
    return b2.join("");
  }
  var ve2 = "Firefox", re2 = "Chrome";
  function qe2(a) {
    var b2 = a.toLowerCase();
    if (x3(b2, "opera/") || x3(b2, "opr/") || x3(b2, "opios/"))
      return "Opera";
    if (x3(b2, "iemobile"))
      return "IEMobile";
    if (x3(b2, "msie") || x3(b2, "trident/"))
      return "IE";
    if (x3(b2, "edge/"))
      return "Edge";
    if (x3(b2, "firefox/"))
      return ve2;
    if (x3(b2, "silk/"))
      return "Silk";
    if (x3(b2, "blackberry"))
      return "Blackberry";
    if (x3(b2, "webos"))
      return "Webos";
    if (!x3(b2, "safari/") || x3(b2, "chrome/") || x3(b2, "crios/") || x3(b2, "android"))
      if (!x3(b2, "chrome/") && !x3(b2, "crios/") || x3(b2, "edge/")) {
        if (x3(b2, "android"))
          return "Android";
        if ((a = a.match(/([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/)) && 2 == a.length)
          return a[1];
      } else
        return re2;
    else
      return "Safari";
    return "Other";
  }
  var Ie2 = { ld: "FirebaseCore-web", nd: "FirebaseUI-web" };
  function Je2(a, b2) {
    b2 = b2 || [];
    var c = [], d = {}, e;
    for (e in Ie2)
      d[Ie2[e]] = true;
    for (e = 0; e < b2.length; e++)
      "undefined" !== typeof d[b2[e]] && (delete d[b2[e]], c.push(b2[e]));
    c.sort();
    b2 = c;
    b2.length || (b2 = ["FirebaseCore-web"]);
    c = Fe2();
    "Browser" === c ? (d = K3(), c = qe2(d)) : "Worker" === c && (d = K3(), c = qe2(d) + "-" + c);
    return c + "/JsCore/" + a + "/" + b2.join(",");
  }
  function K3() {
    return l.navigator && l.navigator.userAgent || "";
  }
  function L3(a, b2) {
    a = a.split(".");
    b2 = b2 || l;
    for (var c = 0; c < a.length && "object" == typeof b2 && null != b2; c++)
      b2 = b2[a[c]];
    c != a.length && (b2 = void 0);
    return b2;
  }
  function Ke2() {
    try {
      var a = l.localStorage, b2 = Le2();
      if (a)
        return a.setItem(b2, "1"), a.removeItem(b2), le2() ? !!l.indexedDB : true;
    } catch (c) {
      return Ee2() && !!l.indexedDB;
    }
    return false;
  }
  function Me2() {
    return (Ne2() || "chrome-extension:" === Ce2() || Be2()) && !Ge2() && Ke2() && !Ee2();
  }
  function Ne2() {
    return "http:" === Ce2() || "https:" === Ce2();
  }
  function Ce2() {
    return l.location && l.location.protocol || null;
  }
  function Oe2(a) {
    a = a || K3();
    return se2(a) || qe2(a) == ve2 ? false : true;
  }
  function Pe2(a) {
    return "undefined" === typeof a ? null : fe2(a);
  }
  function Qe2(a) {
    var b2 = {}, c;
    for (c in a)
      a.hasOwnProperty(c) && null !== a[c] && void 0 !== a[c] && (b2[c] = a[c]);
    return b2;
  }
  function Re2(a) {
    if (null !== a)
      return JSON.parse(a);
  }
  function Le2(a) {
    return a ? a : Math.floor(1e9 * Math.random()).toString();
  }
  function Se2(a) {
    a = a || K3();
    return "Safari" == qe2(a) || a.toLowerCase().match(/iphone|ipad|ipod/) ? false : true;
  }
  function Te2() {
    var a = l.___jsl;
    if (a && a.H) {
      for (var b2 in a.H)
        if (a.H[b2].r = a.H[b2].r || [], a.H[b2].L = a.H[b2].L || [], a.H[b2].r = a.H[b2].L.concat(), a.CP)
          for (var c = 0; c < a.CP.length; c++)
            a.CP[c] = null;
    }
  }
  function Ue2(a, b2) {
    if (a > b2)
      throw Error("Short delay should be less than long delay!");
    this.a = a;
    this.c = b2;
    a = K3();
    b2 = Fe2();
    this.b = se2(a) || "ReactNative" === b2;
  }
  Ue2.prototype.get = function() {
    var a = l.navigator;
    return (a && "boolean" === typeof a.onLine && (Ne2() || "chrome-extension:" === Ce2() || "undefined" !== typeof a.connection) ? a.onLine : 1) ? this.b ? this.c : this.a : Math.min(5e3, this.a);
  };
  function Ve2() {
    var a = l.document;
    return a && "undefined" !== typeof a.visibilityState ? "visible" == a.visibilityState : true;
  }
  function We2() {
    var a = l.document, b2 = null;
    return Ve2() || !a ? D3() : new C3(function(c) {
      b2 = function() {
        Ve2() && (a.removeEventListener("visibilitychange", b2, false), c());
      };
      a.addEventListener("visibilitychange", b2, false);
    }).s(function(c) {
      a.removeEventListener("visibilitychange", b2, false);
      throw c;
    });
  }
  function Xe2(a) {
    "undefined" !== typeof console && "function" === typeof console.warn && console.warn(a);
  }
  function Ye2(a) {
    try {
      var b2 = new Date(parseInt(a, 10));
      if (!isNaN(b2.getTime()) && !/[^0-9]/.test(a))
        return b2.toUTCString();
    } catch (c) {
    }
    return null;
  }
  function Ze2() {
    return !(!L3("fireauth.oauthhelper", l) && !L3("fireauth.iframe", l));
  }
  function $e2() {
    var a = l.navigator;
    return a && a.serviceWorker && a.serviceWorker.controller || null;
  }
  function af() {
    var a = l.navigator;
    return a && a.serviceWorker ? D3().then(function() {
      return a.serviceWorker.ready;
    }).then(function(b2) {
      return b2.active || null;
    }).s(function() {
      return null;
    }) : D3(null);
  }
  ;
  var bf = {};
  function cf(a) {
    bf[a] || (bf[a] = true, Xe2(a));
  }
  ;
  var df;
  try {
    var ef = {};
    Object.defineProperty(ef, "abcd", { configurable: true, enumerable: true, value: 1 });
    Object.defineProperty(ef, "abcd", { configurable: true, enumerable: true, value: 2 });
    df = 2 == ef.abcd;
  } catch (a) {
    df = false;
  }
  function M3(a, b2, c) {
    df ? Object.defineProperty(a, b2, { configurable: true, enumerable: true, value: c }) : a[b2] = c;
  }
  function N3(a, b2) {
    if (b2)
      for (var c in b2)
        b2.hasOwnProperty(c) && M3(a, c, b2[c]);
  }
  function ff(a) {
    var b2 = {};
    N3(b2, a);
    return b2;
  }
  function gf(a) {
    var b2 = {}, c;
    for (c in a)
      a.hasOwnProperty(c) && (b2[c] = a[c]);
    return b2;
  }
  function hf(a, b2) {
    if (!b2 || !b2.length)
      return true;
    if (!a)
      return false;
    for (var c = 0; c < b2.length; c++) {
      var d = a[b2[c]];
      if (void 0 === d || null === d || "" === d)
        return false;
    }
    return true;
  }
  function jf(a) {
    var b2 = a;
    if ("object" == typeof a && null != a) {
      b2 = "length" in a ? [] : {};
      for (var c in a)
        M3(b2, c, jf(a[c]));
    }
    return b2;
  }
  ;
  function kf(a) {
    var b2 = a && (a[lf] ? "phone" : null);
    if (b2 && a && a[mf]) {
      M3(this, "uid", a[mf]);
      M3(this, "displayName", a[nf] || null);
      var c = null;
      a[of3] && (c = new Date(a[of3]).toUTCString());
      M3(this, "enrollmentTime", c);
      M3(this, "factorId", b2);
    } else
      throw new t("internal-error", "Internal assert: invalid MultiFactorInfo object");
  }
  kf.prototype.w = function() {
    return { uid: this.uid, displayName: this.displayName, factorId: this.factorId, enrollmentTime: this.enrollmentTime };
  };
  function pf(a) {
    try {
      var b2 = new qf(a);
    } catch (c) {
      b2 = null;
    }
    return b2;
  }
  var nf = "displayName", of3 = "enrolledAt", mf = "mfaEnrollmentId", lf = "phoneInfo";
  function qf(a) {
    kf.call(this, a);
    M3(this, "phoneNumber", a[lf]);
  }
  r2(qf, kf);
  qf.prototype.w = function() {
    var a = qf.$a.w.call(this);
    a.phoneNumber = this.phoneNumber;
    return a;
  };
  function rf(a) {
    var b2 = {}, c = a[sf], d = a[tf], e = a[uf];
    a = pf(a[vf]);
    if (!e || e != wf && e != xf && !c || e == xf && !d || e == yf && !a)
      throw Error("Invalid checkActionCode response!");
    e == xf ? (b2[zf] = c || null, b2[Af] = c || null, b2[Bf] = d) : (b2[zf] = d || null, b2[Af] = d || null, b2[Bf] = c || null);
    b2[Cf] = a || null;
    M3(this, Df, e);
    M3(this, Ef, jf(b2));
  }
  var yf = "REVERT_SECOND_FACTOR_ADDITION", wf = "EMAIL_SIGNIN", xf = "VERIFY_AND_CHANGE_EMAIL", sf = "email", vf = "mfaInfo", tf = "newEmail", uf = "requestType", Bf = "email", zf = "fromEmail", Cf = "multiFactorInfo", Af = "previousEmail", Ef = "data", Df = "operation";
  function Ff(a) {
    a = J3(a);
    var b2 = Xd(a, Gf) || null, c = Xd(a, Hf) || null, d = Xd(a, If) || null;
    d = d ? Jf[d] || null : null;
    if (!b2 || !c || !d)
      throw new t("argument-error", Gf + ", " + Hf + "and " + If + " are required in a valid action code URL.");
    N3(this, { apiKey: b2, operation: d, code: c, continueUrl: Xd(a, Kf) || null, languageCode: Xd(a, Lf) || null, tenantId: Xd(a, Mf) || null });
  }
  var Gf = "apiKey", Hf = "oobCode", Kf = "continueUrl", Lf = "languageCode", If = "mode", Mf = "tenantId", Jf = { recoverEmail: "RECOVER_EMAIL", resetPassword: "PASSWORD_RESET", revertSecondFactorAddition: yf, signIn: wf, verifyAndChangeEmail: xf, verifyEmail: "VERIFY_EMAIL" };
  function Nf(a) {
    try {
      return new Ff(a);
    } catch (b2) {
      return null;
    }
  }
  ;
  function Of(a) {
    var b2 = a[Pf];
    if ("undefined" === typeof b2)
      throw new t("missing-continue-uri");
    if ("string" !== typeof b2 || "string" === typeof b2 && !b2.length)
      throw new t("invalid-continue-uri");
    this.h = b2;
    this.b = this.a = null;
    this.g = false;
    var c = a[Qf];
    if (c && "object" === typeof c) {
      b2 = c[Rf];
      var d = c[Sf];
      c = c[Tf];
      if ("string" === typeof b2 && b2.length) {
        this.a = b2;
        if ("undefined" !== typeof d && "boolean" !== typeof d)
          throw new t("argument-error", Sf + " property must be a boolean when specified.");
        this.g = !!d;
        if ("undefined" !== typeof c && ("string" !== typeof c || "string" === typeof c && !c.length))
          throw new t("argument-error", Tf + " property must be a non empty string when specified.");
        this.b = c || null;
      } else {
        if ("undefined" !== typeof b2)
          throw new t("argument-error", Rf + " property must be a non empty string when specified.");
        if ("undefined" !== typeof d || "undefined" !== typeof c)
          throw new t("missing-android-pkg-name");
      }
    } else if ("undefined" !== typeof c)
      throw new t("argument-error", Qf + " property must be a non null object when specified.");
    this.f = null;
    if ((b2 = a[Uf]) && "object" === typeof b2)
      if (b2 = b2[Vf], "string" === typeof b2 && b2.length)
        this.f = b2;
      else {
        if ("undefined" !== typeof b2)
          throw new t("argument-error", Vf + " property must be a non empty string when specified.");
      }
    else if ("undefined" !== typeof b2)
      throw new t("argument-error", Uf + " property must be a non null object when specified.");
    b2 = a[Wf];
    if ("undefined" !== typeof b2 && "boolean" !== typeof b2)
      throw new t("argument-error", Wf + " property must be a boolean when specified.");
    this.c = !!b2;
    a = a[Xf];
    if ("undefined" !== typeof a && ("string" !== typeof a || "string" === typeof a && !a.length))
      throw new t("argument-error", Xf + " property must be a non empty string when specified.");
    this.i = a || null;
  }
  var Qf = "android", Xf = "dynamicLinkDomain", Wf = "handleCodeInApp", Uf = "iOS", Pf = "url", Sf = "installApp", Tf = "minimumVersion", Rf = "packageName", Vf = "bundleId";
  function Yf(a) {
    var b2 = {};
    b2.continueUrl = a.h;
    b2.canHandleCodeInApp = a.c;
    if (b2.androidPackageName = a.a)
      b2.androidMinimumVersion = a.b, b2.androidInstallApp = a.g;
    b2.iOSBundleId = a.f;
    b2.dynamicLinkDomain = a.i;
    for (var c in b2)
      null === b2[c] && delete b2[c];
    return b2;
  }
  ;
  function Zf(a) {
    return Pa(a, function(b2) {
      b2 = b2.toString(16);
      return 1 < b2.length ? b2 : "0" + b2;
    }).join("");
  }
  ;
  var $f = null;
  function ag(a) {
    var b2 = "";
    bg(a, function(c) {
      b2 += String.fromCharCode(c);
    });
    return b2;
  }
  function bg(a, b2) {
    function c(m) {
      for (; d < a.length; ) {
        var p2 = a.charAt(d++), v2 = $f[p2];
        if (null != v2)
          return v2;
        if (!/^[\s\xa0]*$/.test(p2))
          throw Error("Unknown base64 encoding at char: " + p2);
      }
      return m;
    }
    cg();
    for (var d = 0; ; ) {
      var e = c(-1), f = c(0), g2 = c(64), h = c(64);
      if (64 === h && -1 === e)
        break;
      b2(e << 2 | f >> 4);
      64 != g2 && (b2(f << 4 & 240 | g2 >> 2), 64 != h && b2(g2 << 6 & 192 | h));
    }
  }
  function cg() {
    if (!$f) {
      $f = {};
      for (var a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), b2 = ["+/=", "+/", "-_=", "-_.", "-_"], c = 0; 5 > c; c++)
        for (var d = a.concat(b2[c].split("")), e = 0; e < d.length; e++) {
          var f = d[e];
          void 0 === $f[f] && ($f[f] = e);
        }
    }
  }
  ;
  function dg(a) {
    var b2 = eg(a);
    if (!(b2 && b2.sub && b2.iss && b2.aud && b2.exp))
      throw Error("Invalid JWT");
    this.g = a;
    this.c = b2.exp;
    this.h = b2.sub;
    ua3();
    this.a = b2.provider_id || b2.firebase && b2.firebase.sign_in_provider || null;
    this.f = b2.firebase && b2.firebase.tenant || null;
    this.b = !!b2.is_anonymous || "anonymous" == this.a;
  }
  dg.prototype.S = function() {
    return this.f;
  };
  dg.prototype.i = function() {
    return this.b;
  };
  dg.prototype.toString = function() {
    return this.g;
  };
  function fg(a) {
    try {
      return new dg(a);
    } catch (b2) {
      return null;
    }
  }
  function eg(a) {
    if (!a)
      return null;
    a = a.split(".");
    if (3 != a.length)
      return null;
    a = a[1];
    for (var b2 = (4 - a.length % 4) % 4, c = 0; c < b2; c++)
      a += ".";
    try {
      return JSON.parse(ag(a));
    } catch (d) {
    }
    return null;
  }
  ;
  var gg = "oauth_consumer_key oauth_nonce oauth_signature oauth_signature_method oauth_timestamp oauth_token oauth_version".split(" "), hg = ["client_id", "response_type", "scope", "redirect_uri", "state"], ig = { md: { Ja: "locale", ua: 700, ta: 600, fa: "facebook.com", Wa: hg }, od: { Ja: null, ua: 500, ta: 750, fa: "github.com", Wa: hg }, pd: { Ja: "hl", ua: 515, ta: 680, fa: "google.com", Wa: hg }, vd: { Ja: "lang", ua: 485, ta: 705, fa: "twitter.com", Wa: gg }, jd: { Ja: "locale", ua: 640, ta: 600, fa: "apple.com", Wa: [] } };
  function jg(a) {
    for (var b2 in ig)
      if (ig[b2].fa == a)
        return ig[b2];
    return null;
  }
  ;
  function kg(a) {
    var b2 = {};
    b2["facebook.com"] = lg;
    b2["google.com"] = mg;
    b2["github.com"] = ng;
    b2["twitter.com"] = og;
    var c = a && a[pg];
    try {
      if (c)
        return b2[c] ? new b2[c](a) : new qg(a);
      if ("undefined" !== typeof a[rg])
        return new sg(a);
    } catch (d) {
    }
    return null;
  }
  var rg = "idToken", pg = "providerId";
  function sg(a) {
    var b2 = a[pg];
    if (!b2 && a[rg]) {
      var c = fg(a[rg]);
      c && c.a && (b2 = c.a);
    }
    if (!b2)
      throw Error("Invalid additional user info!");
    if ("anonymous" == b2 || "custom" == b2)
      b2 = null;
    c = false;
    "undefined" !== typeof a.isNewUser ? c = !!a.isNewUser : "identitytoolkit#SignupNewUserResponse" === a.kind && (c = true);
    M3(this, "providerId", b2);
    M3(this, "isNewUser", c);
  }
  function qg(a) {
    sg.call(this, a);
    a = Re2(a.rawUserInfo || "{}");
    M3(this, "profile", jf(a || {}));
  }
  r2(qg, sg);
  function lg(a) {
    qg.call(this, a);
    if ("facebook.com" != this.providerId)
      throw Error("Invalid provider ID!");
  }
  r2(lg, qg);
  function ng(a) {
    qg.call(this, a);
    if ("github.com" != this.providerId)
      throw Error("Invalid provider ID!");
    M3(this, "username", this.profile && this.profile.login || null);
  }
  r2(ng, qg);
  function mg(a) {
    qg.call(this, a);
    if ("google.com" != this.providerId)
      throw Error("Invalid provider ID!");
  }
  r2(mg, qg);
  function og(a) {
    qg.call(this, a);
    if ("twitter.com" != this.providerId)
      throw Error("Invalid provider ID!");
    M3(this, "username", a.screenName || null);
  }
  r2(og, qg);
  function tg(a) {
    var b2 = J3(a), c = Xd(b2, "link"), d = Xd(J3(c), "link");
    b2 = Xd(b2, "deep_link_id");
    return Xd(J3(b2), "link") || b2 || d || c || a;
  }
  ;
  function ug(a, b2) {
    if (!a && !b2)
      throw new t("internal-error", "Internal assert: no raw session string available");
    if (a && b2)
      throw new t("internal-error", "Internal assert: unable to determine the session type");
    this.a = a || null;
    this.b = b2 || null;
    this.type = this.a ? vg : wg;
  }
  var vg = "enroll", wg = "signin";
  ug.prototype.Ha = function() {
    return this.a ? D3(this.a) : D3(this.b);
  };
  ug.prototype.w = function() {
    return this.type == vg ? { multiFactorSession: { idToken: this.a } } : { multiFactorSession: { pendingCredential: this.b } };
  };
  function xg() {
  }
  xg.prototype.ja = function() {
  };
  xg.prototype.b = function() {
  };
  xg.prototype.c = function() {
  };
  xg.prototype.w = function() {
  };
  function yg(a, b2) {
    return a.then(function(c) {
      if (c[zg]) {
        var d = fg(c[zg]);
        if (!d || b2 != d.h)
          throw new t("user-mismatch");
        return c;
      }
      throw new t("user-mismatch");
    }).s(function(c) {
      throw c && c.code && c.code == va2 + "user-not-found" ? new t("user-mismatch") : c;
    });
  }
  function Ag(a, b2) {
    if (b2)
      this.a = b2;
    else
      throw new t("internal-error", "failed to construct a credential");
    M3(this, "providerId", a);
    M3(this, "signInMethod", a);
  }
  Ag.prototype.ja = function(a) {
    return Bg(a, Cg(this));
  };
  Ag.prototype.b = function(a, b2) {
    var c = Cg(this);
    c.idToken = b2;
    return Dg(a, c);
  };
  Ag.prototype.c = function(a, b2) {
    return yg(Eg(a, Cg(this)), b2);
  };
  function Cg(a) {
    return { pendingToken: a.a, requestUri: "http://localhost" };
  }
  Ag.prototype.w = function() {
    return { providerId: this.providerId, signInMethod: this.signInMethod, pendingToken: this.a };
  };
  function Fg(a) {
    if (a && a.providerId && a.signInMethod && 0 == a.providerId.indexOf("saml.") && a.pendingToken)
      try {
        return new Ag(a.providerId, a.pendingToken);
      } catch (b2) {
      }
    return null;
  }
  function Gg(a, b2, c) {
    this.a = null;
    if (b2.idToken || b2.accessToken)
      b2.idToken && M3(this, "idToken", b2.idToken), b2.accessToken && M3(this, "accessToken", b2.accessToken), b2.nonce && !b2.pendingToken && M3(this, "nonce", b2.nonce), b2.pendingToken && (this.a = b2.pendingToken);
    else if (b2.oauthToken && b2.oauthTokenSecret)
      M3(this, "accessToken", b2.oauthToken), M3(this, "secret", b2.oauthTokenSecret);
    else
      throw new t("internal-error", "failed to construct a credential");
    M3(this, "providerId", a);
    M3(this, "signInMethod", c);
  }
  Gg.prototype.ja = function(a) {
    return Bg(a, Hg(this));
  };
  Gg.prototype.b = function(a, b2) {
    var c = Hg(this);
    c.idToken = b2;
    return Dg(a, c);
  };
  Gg.prototype.c = function(a, b2) {
    var c = Hg(this);
    return yg(Eg(a, c), b2);
  };
  function Hg(a) {
    var b2 = {};
    a.idToken && (b2.id_token = a.idToken);
    a.accessToken && (b2.access_token = a.accessToken);
    a.secret && (b2.oauth_token_secret = a.secret);
    b2.providerId = a.providerId;
    a.nonce && !a.a && (b2.nonce = a.nonce);
    b2 = { postBody: ae2(b2).toString(), requestUri: "http://localhost" };
    a.a && (delete b2.postBody, b2.pendingToken = a.a);
    return b2;
  }
  Gg.prototype.w = function() {
    var a = { providerId: this.providerId, signInMethod: this.signInMethod };
    this.idToken && (a.oauthIdToken = this.idToken);
    this.accessToken && (a.oauthAccessToken = this.accessToken);
    this.secret && (a.oauthTokenSecret = this.secret);
    this.nonce && (a.nonce = this.nonce);
    this.a && (a.pendingToken = this.a);
    return a;
  };
  function Ig(a) {
    if (a && a.providerId && a.signInMethod) {
      var b2 = { idToken: a.oauthIdToken, accessToken: a.oauthTokenSecret ? null : a.oauthAccessToken, oauthTokenSecret: a.oauthTokenSecret, oauthToken: a.oauthTokenSecret && a.oauthAccessToken, nonce: a.nonce, pendingToken: a.pendingToken };
      try {
        return new Gg(a.providerId, b2, a.signInMethod);
      } catch (c) {
      }
    }
    return null;
  }
  function Jg(a, b2) {
    this.Pc = b2 || [];
    N3(this, { providerId: a, isOAuthProvider: true });
    this.Hb = {};
    this.ob = (jg(a) || {}).Ja || null;
    this.nb = null;
  }
  Jg.prototype.Ka = function(a) {
    this.Hb = lb2(a);
    return this;
  };
  function Kg(a) {
    if ("string" !== typeof a || 0 != a.indexOf("saml."))
      throw new t("argument-error", 'SAML provider IDs must be prefixed with "saml."');
    Jg.call(this, a, []);
  }
  r2(Kg, Jg);
  function Lg(a) {
    Jg.call(this, a, hg);
    this.a = [];
  }
  r2(Lg, Jg);
  Lg.prototype.Ca = function(a) {
    Ta2(this.a, a) || this.a.push(a);
    return this;
  };
  Lg.prototype.Pb = function() {
    return Xa2(this.a);
  };
  Lg.prototype.credential = function(a, b2) {
    var c;
    n2(a) ? c = { idToken: a.idToken || null, accessToken: a.accessToken || null, nonce: a.rawNonce || null } : c = { idToken: a || null, accessToken: b2 || null };
    if (!c.idToken && !c.accessToken)
      throw new t("argument-error", "credential failed: must provide the ID token and/or the access token.");
    return new Gg(this.providerId, c, this.providerId);
  };
  function Mg() {
    Lg.call(this, "facebook.com");
  }
  r2(Mg, Lg);
  M3(Mg, "PROVIDER_ID", "facebook.com");
  M3(Mg, "FACEBOOK_SIGN_IN_METHOD", "facebook.com");
  function Ng(a) {
    if (!a)
      throw new t("argument-error", "credential failed: expected 1 argument (the OAuth access token).");
    var b2 = a;
    n2(a) && (b2 = a.accessToken);
    return new Mg().credential({ accessToken: b2 });
  }
  function Og() {
    Lg.call(this, "github.com");
  }
  r2(Og, Lg);
  M3(Og, "PROVIDER_ID", "github.com");
  M3(Og, "GITHUB_SIGN_IN_METHOD", "github.com");
  function Pg(a) {
    if (!a)
      throw new t("argument-error", "credential failed: expected 1 argument (the OAuth access token).");
    var b2 = a;
    n2(a) && (b2 = a.accessToken);
    return new Og().credential({ accessToken: b2 });
  }
  function Qg() {
    Lg.call(this, "google.com");
    this.Ca("profile");
  }
  r2(Qg, Lg);
  M3(Qg, "PROVIDER_ID", "google.com");
  M3(Qg, "GOOGLE_SIGN_IN_METHOD", "google.com");
  function Rg(a, b2) {
    var c = a;
    n2(a) && (c = a.idToken, b2 = a.accessToken);
    return new Qg().credential({ idToken: c, accessToken: b2 });
  }
  function Sg() {
    Jg.call(this, "twitter.com", gg);
  }
  r2(Sg, Jg);
  M3(Sg, "PROVIDER_ID", "twitter.com");
  M3(Sg, "TWITTER_SIGN_IN_METHOD", "twitter.com");
  function Tg(a, b2) {
    var c = a;
    n2(c) || (c = { oauthToken: a, oauthTokenSecret: b2 });
    if (!c.oauthToken || !c.oauthTokenSecret)
      throw new t("argument-error", "credential failed: expected 2 arguments (the OAuth access token and secret).");
    return new Gg("twitter.com", c, "twitter.com");
  }
  function Ug(a, b2, c) {
    this.a = a;
    this.f = b2;
    M3(this, "providerId", "password");
    M3(this, "signInMethod", c === Vg.EMAIL_LINK_SIGN_IN_METHOD ? Vg.EMAIL_LINK_SIGN_IN_METHOD : Vg.EMAIL_PASSWORD_SIGN_IN_METHOD);
  }
  Ug.prototype.ja = function(a) {
    return this.signInMethod == Vg.EMAIL_LINK_SIGN_IN_METHOD ? O3(a, Wg, { email: this.a, oobCode: this.f }) : O3(a, Xg, { email: this.a, password: this.f });
  };
  Ug.prototype.b = function(a, b2) {
    return this.signInMethod == Vg.EMAIL_LINK_SIGN_IN_METHOD ? O3(a, Yg, { idToken: b2, email: this.a, oobCode: this.f }) : O3(a, Zg, { idToken: b2, email: this.a, password: this.f });
  };
  Ug.prototype.c = function(a, b2) {
    return yg(this.ja(a), b2);
  };
  Ug.prototype.w = function() {
    return { email: this.a, password: this.f, signInMethod: this.signInMethod };
  };
  function $g(a) {
    return a && a.email && a.password ? new Ug(a.email, a.password, a.signInMethod) : null;
  }
  function Vg() {
    N3(this, { providerId: "password", isOAuthProvider: false });
  }
  function ah(a, b2) {
    b2 = bh(b2);
    if (!b2)
      throw new t("argument-error", "Invalid email link!");
    return new Ug(a, b2.code, Vg.EMAIL_LINK_SIGN_IN_METHOD);
  }
  function bh(a) {
    a = tg(a);
    return (a = Nf(a)) && a.operation === wf ? a : null;
  }
  N3(Vg, { PROVIDER_ID: "password" });
  N3(Vg, { EMAIL_LINK_SIGN_IN_METHOD: "emailLink" });
  N3(Vg, { EMAIL_PASSWORD_SIGN_IN_METHOD: "password" });
  function ch(a) {
    if (!(a.cb && a.bb || a.La && a.ea))
      throw new t("internal-error");
    this.a = a;
    M3(this, "providerId", "phone");
    this.fa = "phone";
    M3(this, "signInMethod", "phone");
  }
  ch.prototype.ja = function(a) {
    return a.eb(dh(this));
  };
  ch.prototype.b = function(a, b2) {
    var c = dh(this);
    c.idToken = b2;
    return O3(a, eh, c);
  };
  ch.prototype.c = function(a, b2) {
    var c = dh(this);
    c.operation = "REAUTH";
    a = O3(a, fh, c);
    return yg(a, b2);
  };
  ch.prototype.w = function() {
    var a = { providerId: "phone" };
    this.a.cb && (a.verificationId = this.a.cb);
    this.a.bb && (a.verificationCode = this.a.bb);
    this.a.La && (a.temporaryProof = this.a.La);
    this.a.ea && (a.phoneNumber = this.a.ea);
    return a;
  };
  function gh(a) {
    if (a && "phone" === a.providerId && (a.verificationId && a.verificationCode || a.temporaryProof && a.phoneNumber)) {
      var b2 = {};
      w2(["verificationId", "verificationCode", "temporaryProof", "phoneNumber"], function(c) {
        a[c] && (b2[c] = a[c]);
      });
      return new ch(b2);
    }
    return null;
  }
  function dh(a) {
    return a.a.La && a.a.ea ? { temporaryProof: a.a.La, phoneNumber: a.a.ea } : { sessionInfo: a.a.cb, code: a.a.bb };
  }
  function hh(a) {
    try {
      this.a = a || import_app8.default.auth();
    } catch (b2) {
      throw new t("argument-error", "Either an instance of firebase.auth.Auth must be passed as an argument to the firebase.auth.PhoneAuthProvider constructor, or the default firebase App instance must be initialized via firebase.initializeApp().");
    }
    N3(this, { providerId: "phone", isOAuthProvider: false });
  }
  hh.prototype.eb = function(a, b2) {
    var c = this.a.a;
    return D3(b2.verify()).then(function(d) {
      if ("string" !== typeof d)
        throw new t("argument-error", "An implementation of firebase.auth.ApplicationVerifier.prototype.verify() must return a firebase.Promise that resolves with a string.");
      switch (b2.type) {
        case "recaptcha":
          var e = n2(a) ? a.session : null, f = n2(a) ? a.phoneNumber : a, g2;
          e && e.type == vg ? g2 = e.Ha().then(function(h) {
            return ih(c, { idToken: h, phoneEnrollmentInfo: { phoneNumber: f, recaptchaToken: d } });
          }) : e && e.type == wg ? g2 = e.Ha().then(function(h) {
            return jh(
              c,
              { mfaPendingCredential: h, mfaEnrollmentId: a.multiFactorHint && a.multiFactorHint.uid || a.multiFactorUid, phoneSignInInfo: { recaptchaToken: d } }
            );
          }) : g2 = kh(c, { phoneNumber: f, recaptchaToken: d });
          return g2.then(function(h) {
            "function" === typeof b2.reset && b2.reset();
            return h;
          }, function(h) {
            "function" === typeof b2.reset && b2.reset();
            throw h;
          });
        default:
          throw new t("argument-error", 'Only firebase.auth.ApplicationVerifiers with type="recaptcha" are currently supported.');
      }
    });
  };
  function lh(a, b2) {
    if (!a)
      throw new t("missing-verification-id");
    if (!b2)
      throw new t("missing-verification-code");
    return new ch({ cb: a, bb: b2 });
  }
  N3(hh, { PROVIDER_ID: "phone" });
  N3(hh, { PHONE_SIGN_IN_METHOD: "phone" });
  function mh(a) {
    if (a.temporaryProof && a.phoneNumber)
      return new ch({ La: a.temporaryProof, ea: a.phoneNumber });
    var b2 = a && a.providerId;
    if (!b2 || "password" === b2)
      return null;
    var c = a && a.oauthAccessToken, d = a && a.oauthTokenSecret, e = a && a.nonce, f = a && a.oauthIdToken, g2 = a && a.pendingToken;
    try {
      switch (b2) {
        case "google.com":
          return Rg(f, c);
        case "facebook.com":
          return Ng(c);
        case "github.com":
          return Pg(c);
        case "twitter.com":
          return Tg(c, d);
        default:
          return c || d || f || g2 ? g2 ? 0 == b2.indexOf("saml.") ? new Ag(b2, g2) : new Gg(b2, {
            pendingToken: g2,
            idToken: a.oauthIdToken,
            accessToken: a.oauthAccessToken
          }, b2) : new Lg(b2).credential({ idToken: f, accessToken: c, rawNonce: e }) : null;
      }
    } catch (h) {
      return null;
    }
  }
  function nh(a) {
    if (!a.isOAuthProvider)
      throw new t("invalid-oauth-provider");
  }
  ;
  function oh(a, b2, c, d, e, f, g2) {
    this.c = a;
    this.b = b2 || null;
    this.g = c || null;
    this.f = d || null;
    this.i = f || null;
    this.h = g2 || null;
    this.a = e || null;
    if (this.g || this.a) {
      if (this.g && this.a)
        throw new t("invalid-auth-event");
      if (this.g && !this.f)
        throw new t("invalid-auth-event");
    } else
      throw new t("invalid-auth-event");
  }
  oh.prototype.getUid = function() {
    var a = [];
    a.push(this.c);
    this.b && a.push(this.b);
    this.f && a.push(this.f);
    this.h && a.push(this.h);
    return a.join("-");
  };
  oh.prototype.S = function() {
    return this.h;
  };
  oh.prototype.w = function() {
    return { type: this.c, eventId: this.b, urlResponse: this.g, sessionId: this.f, postBody: this.i, tenantId: this.h, error: this.a && this.a.w() };
  };
  function ph(a) {
    a = a || {};
    return a.type ? new oh(a.type, a.eventId, a.urlResponse, a.sessionId, a.error && ya2(a.error), a.postBody, a.tenantId) : null;
  }
  ;
  function qh() {
    this.b = null;
    this.a = [];
  }
  var rh = null;
  function sh(a) {
    var b2 = rh;
    b2.a.push(a);
    b2.b || (b2.b = function(c) {
      for (var d = 0; d < b2.a.length; d++)
        b2.a[d](c);
    }, a = L3("universalLinks.subscribe", l), "function" === typeof a && a(null, b2.b));
  }
  ;
  function th(a) {
    var b2 = "unauthorized-domain", c = void 0, d = J3(a);
    a = d.a;
    d = d.f;
    "chrome-extension" == d ? c = Nb2("This chrome extension ID (chrome-extension://%s) is not authorized to run this operation. Add it to the OAuth redirect domains list in the Firebase console -> Auth section -> Sign in method tab.", a) : "http" == d || "https" == d ? c = Nb2("This domain (%s) is not authorized to run this operation. Add it to the OAuth redirect domains list in the Firebase console -> Auth section -> Sign in method tab.", a) : b2 = "operation-not-supported-in-this-environment";
    t.call(this, b2, c);
  }
  r2(th, t);
  function uh(a, b2, c) {
    t.call(this, a, c);
    a = b2 || {};
    a.Ib && M3(this, "email", a.Ib);
    a.ea && M3(this, "phoneNumber", a.ea);
    a.credential && M3(this, "credential", a.credential);
    a.Yb && M3(this, "tenantId", a.Yb);
  }
  r2(uh, t);
  uh.prototype.w = function() {
    var a = { code: this.code, message: this.message };
    this.email && (a.email = this.email);
    this.phoneNumber && (a.phoneNumber = this.phoneNumber);
    this.tenantId && (a.tenantId = this.tenantId);
    var b2 = this.credential && this.credential.w();
    b2 && z2(a, b2);
    return a;
  };
  uh.prototype.toJSON = function() {
    return this.w();
  };
  function vh(a) {
    if (a.code) {
      var b2 = a.code || "";
      0 == b2.indexOf(va2) && (b2 = b2.substring(va2.length));
      var c = { credential: mh(a), Yb: a.tenantId };
      if (a.email)
        c.Ib = a.email;
      else if (a.phoneNumber)
        c.ea = a.phoneNumber;
      else if (!c.credential)
        return new t(b2, a.message || void 0);
      return new uh(b2, c, a.message);
    }
    return null;
  }
  ;
  function wh() {
  }
  wh.prototype.c = null;
  function xh(a) {
    return a.c || (a.c = a.b());
  }
  ;
  var yh;
  function zh() {
  }
  r2(zh, wh);
  zh.prototype.a = function() {
    var a = Ah(this);
    return a ? new ActiveXObject(a) : new XMLHttpRequest();
  };
  zh.prototype.b = function() {
    var a = {};
    Ah(this) && (a[0] = true, a[1] = true);
    return a;
  };
  function Ah(a) {
    if (!a.f && "undefined" == typeof XMLHttpRequest && "undefined" != typeof ActiveXObject) {
      for (var b2 = ["MSXML2.XMLHTTP.6.0", "MSXML2.XMLHTTP.3.0", "MSXML2.XMLHTTP", "Microsoft.XMLHTTP"], c = 0; c < b2.length; c++) {
        var d = b2[c];
        try {
          return new ActiveXObject(d), a.f = d;
        } catch (e) {
        }
      }
      throw Error("Could not create ActiveXObject. ActiveX might be disabled, or MSXML might not be installed");
    }
    return a.f;
  }
  yh = new zh();
  function Bh() {
  }
  r2(Bh, wh);
  Bh.prototype.a = function() {
    var a = new XMLHttpRequest();
    if ("withCredentials" in a)
      return a;
    if ("undefined" != typeof XDomainRequest)
      return new Ch();
    throw Error("Unsupported browser");
  };
  Bh.prototype.b = function() {
    return {};
  };
  function Ch() {
    this.a = new XDomainRequest();
    this.readyState = 0;
    this.onreadystatechange = null;
    this.responseType = this.responseText = this.response = "";
    this.status = -1;
    this.statusText = "";
    this.a.onload = q3(this.pc, this);
    this.a.onerror = q3(this.Rb, this);
    this.a.onprogress = q3(this.qc, this);
    this.a.ontimeout = q3(this.uc, this);
  }
  k3 = Ch.prototype;
  k3.open = function(a, b2, c) {
    if (null != c && !c)
      throw Error("Only async requests are supported.");
    this.a.open(a, b2);
  };
  k3.send = function(a) {
    if (a)
      if ("string" == typeof a)
        this.a.send(a);
      else
        throw Error("Only string data is supported");
    else
      this.a.send();
  };
  k3.abort = function() {
    this.a.abort();
  };
  k3.setRequestHeader = function() {
  };
  k3.getResponseHeader = function(a) {
    return "content-type" == a.toLowerCase() ? this.a.contentType : "";
  };
  k3.pc = function() {
    this.status = 200;
    this.response = this.responseText = this.a.responseText;
    Dh(this, 4);
  };
  k3.Rb = function() {
    this.status = 500;
    this.response = this.responseText = "";
    Dh(this, 4);
  };
  k3.uc = function() {
    this.Rb();
  };
  k3.qc = function() {
    this.status = 200;
    Dh(this, 1);
  };
  function Dh(a, b2) {
    a.readyState = b2;
    if (a.onreadystatechange)
      a.onreadystatechange();
  }
  k3.getAllResponseHeaders = function() {
    return "content-type: " + this.a.contentType;
  };
  function Eh(a, b2, c) {
    this.reset(a, b2, c, void 0, void 0);
  }
  Eh.prototype.a = null;
  var Fh = 0;
  Eh.prototype.reset = function(a, b2, c, d, e) {
    "number" == typeof e || Fh++;
    d || ua3();
    delete this.a;
  };
  function Gh(a) {
    this.f = a;
    this.b = this.c = this.a = null;
  }
  function Hh(a, b2) {
    this.name = a;
    this.value = b2;
  }
  Hh.prototype.toString = function() {
    return this.name;
  };
  var Ih = new Hh("SEVERE", 1e3), Jh = new Hh("WARNING", 900), Kh = new Hh("CONFIG", 700), Lh = new Hh("FINE", 500);
  function Mh(a) {
    if (a.c)
      return a.c;
    if (a.a)
      return Mh(a.a);
    Ea3("Root logger has no level set.");
    return null;
  }
  Gh.prototype.log = function(a, b2, c) {
    if (a.value >= Mh(this).value)
      for (na3(b2) && (b2 = b2()), a = new Eh(a, String(b2), this.f), c && (a.a = c), c = this; c; )
        c = c.a;
  };
  var Nh = {}, Oh = null;
  function Ph(a) {
    Oh || (Oh = new Gh(""), Nh[""] = Oh, Oh.c = Kh);
    var b2;
    if (!(b2 = Nh[a])) {
      b2 = new Gh(a);
      var c = a.lastIndexOf("."), d = a.substr(c + 1);
      c = Ph(a.substr(0, c));
      c.b || (c.b = {});
      c.b[d] = b2;
      b2.a = c;
      Nh[a] = b2;
    }
    return b2;
  }
  ;
  function Qh(a, b2) {
    a && a.log(Lh, b2, void 0);
  }
  ;
  function Rh(a) {
    this.f = a;
  }
  r2(Rh, wh);
  Rh.prototype.a = function() {
    return new Sh(this.f);
  };
  Rh.prototype.b = /* @__PURE__ */ function(a) {
    return function() {
      return a;
    };
  }({});
  function Sh(a) {
    H3.call(this);
    this.o = a;
    this.readyState = Th;
    this.status = 0;
    this.responseType = this.responseText = this.response = this.statusText = "";
    this.onreadystatechange = null;
    this.i = new Headers();
    this.b = null;
    this.m = "GET";
    this.g = "";
    this.a = false;
    this.h = Ph("goog.net.FetchXmlHttp");
    this.l = this.c = this.f = null;
  }
  r2(Sh, H3);
  var Th = 0;
  k3 = Sh.prototype;
  k3.open = function(a, b2) {
    if (this.readyState != Th)
      throw this.abort(), Error("Error reopening a connection");
    this.m = a;
    this.g = b2;
    this.readyState = 1;
    Uh(this);
  };
  k3.send = function(a) {
    if (1 != this.readyState)
      throw this.abort(), Error("need to call open() first. ");
    this.a = true;
    var b2 = { headers: this.i, method: this.m, credentials: void 0, cache: void 0 };
    a && (b2.body = a);
    this.o.fetch(new Request(this.g, b2)).then(this.tc.bind(this), this.Ta.bind(this));
  };
  k3.abort = function() {
    this.response = this.responseText = "";
    this.i = new Headers();
    this.status = 0;
    this.c && this.c.cancel("Request was aborted.");
    1 <= this.readyState && this.a && 4 != this.readyState && (this.a = false, Vh(this, false));
    this.readyState = Th;
  };
  k3.tc = function(a) {
    this.a && (this.f = a, this.b || (this.b = a.headers, this.readyState = 2, Uh(this)), this.a && (this.readyState = 3, Uh(this), this.a && ("arraybuffer" === this.responseType ? a.arrayBuffer().then(this.rc.bind(this), this.Ta.bind(this)) : "undefined" !== typeof l.ReadableStream && "body" in a ? (this.response = this.responseText = "", this.c = a.body.getReader(), this.l = new TextDecoder(), Wh(this)) : a.text().then(this.sc.bind(this), this.Ta.bind(this)))));
  };
  function Wh(a) {
    a.c.read().then(a.oc.bind(a)).catch(a.Ta.bind(a));
  }
  k3.oc = function(a) {
    if (this.a) {
      var b2 = this.l.decode(a.value ? a.value : new Uint8Array(0), { stream: !a.done });
      b2 && (this.response = this.responseText += b2);
      a.done ? Vh(this, true) : Uh(this);
      3 == this.readyState && Wh(this);
    }
  };
  k3.sc = function(a) {
    this.a && (this.response = this.responseText = a, Vh(this, true));
  };
  k3.rc = function(a) {
    this.a && (this.response = a, Vh(this, true));
  };
  k3.Ta = function(a) {
    var b2 = this.h;
    b2 && b2.log(Jh, "Failed to fetch url " + this.g, a instanceof Error ? a : Error(a));
    this.a && Vh(this, true);
  };
  function Vh(a, b2) {
    b2 && a.f && (a.status = a.f.status, a.statusText = a.f.statusText);
    a.readyState = 4;
    a.f = null;
    a.c = null;
    a.l = null;
    Uh(a);
  }
  k3.setRequestHeader = function(a, b2) {
    this.i.append(a, b2);
  };
  k3.getResponseHeader = function(a) {
    return this.b ? this.b.get(a.toLowerCase()) || "" : ((a = this.h) && a.log(Jh, "Attempting to get response header but no headers have been received for url: " + this.g, void 0), "");
  };
  k3.getAllResponseHeaders = function() {
    if (!this.b) {
      var a = this.h;
      a && a.log(Jh, "Attempting to get all response headers but no headers have been received for url: " + this.g, void 0);
      return "";
    }
    a = [];
    for (var b2 = this.b.entries(), c = b2.next(); !c.done; )
      c = c.value, a.push(c[0] + ": " + c[1]), c = b2.next();
    return a.join("\r\n");
  };
  function Uh(a) {
    a.onreadystatechange && a.onreadystatechange.call(a);
  }
  ;
  function Xh(a) {
    H3.call(this);
    this.headers = new Ed2();
    this.O = a || null;
    this.c = false;
    this.A = this.a = null;
    this.h = this.P = this.l = "";
    this.f = this.N = this.i = this.G = false;
    this.g = 0;
    this.o = null;
    this.m = Yh;
    this.u = this.R = false;
  }
  r2(Xh, H3);
  var Yh = "";
  Xh.prototype.b = Ph("goog.net.XhrIo");
  var Zh = /^https?$/i, $h = ["POST", "PUT"];
  function ai2(a, b2, c, d, e) {
    if (a.a)
      throw Error("[goog.net.XhrIo] Object is active with another request=" + a.l + "; newUri=" + b2);
    c = c ? c.toUpperCase() : "GET";
    a.l = b2;
    a.h = "";
    a.P = c;
    a.G = false;
    a.c = true;
    a.a = a.O ? a.O.a() : yh.a();
    a.A = a.O ? xh(a.O) : xh(yh);
    a.a.onreadystatechange = q3(a.Ub, a);
    try {
      Qh(a.b, bi2(a, "Opening Xhr")), a.N = true, a.a.open(c, String(b2), true), a.N = false;
    } catch (g2) {
      Qh(a.b, bi2(a, "Error opening Xhr: " + g2.message));
      ci2(a, g2);
      return;
    }
    b2 = d || "";
    var f = new Ed2(a.headers);
    e && Dd2(e, function(g2, h) {
      f.set(h, g2);
    });
    e = Ra3(f.Y());
    d = l.FormData && b2 instanceof l.FormData;
    !Ta2($h, c) || e || d || f.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
    f.forEach(function(g2, h) {
      this.a.setRequestHeader(h, g2);
    }, a);
    a.m && (a.a.responseType = a.m);
    "withCredentials" in a.a && a.a.withCredentials !== a.R && (a.a.withCredentials = a.R);
    try {
      di2(a), 0 < a.g && (a.u = ei2(a.a), Qh(a.b, bi2(a, "Will abort after " + a.g + "ms if incomplete, xhr2 " + a.u)), a.u ? (a.a.timeout = a.g, a.a.ontimeout = q3(a.Ma, a)) : a.o = zd2(a.Ma, a.g, a)), Qh(a.b, bi2(a, "Sending request")), a.i = true, a.a.send(b2), a.i = false;
    } catch (g2) {
      Qh(
        a.b,
        bi2(a, "Send error: " + g2.message)
      ), ci2(a, g2);
    }
  }
  function ei2(a) {
    return Tb2 && cc2(9) && "number" === typeof a.timeout && void 0 !== a.ontimeout;
  }
  function Sa3(a) {
    return "content-type" == a.toLowerCase();
  }
  k3 = Xh.prototype;
  k3.Ma = function() {
    "undefined" != typeof ha3 && this.a && (this.h = "Timed out after " + this.g + "ms, aborting", Qh(this.b, bi2(this, this.h)), this.dispatchEvent("timeout"), this.abort(8));
  };
  function ci2(a, b2) {
    a.c = false;
    a.a && (a.f = true, a.a.abort(), a.f = false);
    a.h = b2;
    fi2(a);
    gi2(a);
  }
  function fi2(a) {
    a.G || (a.G = true, a.dispatchEvent("complete"), a.dispatchEvent("error"));
  }
  k3.abort = function() {
    this.a && this.c && (Qh(this.b, bi2(this, "Aborting")), this.c = false, this.f = true, this.a.abort(), this.f = false, this.dispatchEvent("complete"), this.dispatchEvent("abort"), gi2(this));
  };
  k3.Da = function() {
    this.a && (this.c && (this.c = false, this.f = true, this.a.abort(), this.f = false), gi2(this, true));
    Xh.$a.Da.call(this);
  };
  k3.Ub = function() {
    this.xa || (this.N || this.i || this.f ? hi2(this) : this.Ic());
  };
  k3.Ic = function() {
    hi2(this);
  };
  function hi2(a) {
    if (a.c && "undefined" != typeof ha3) {
      if (a.A[1] && 4 == ii2(a) && 2 == ji2(a))
        Qh(a.b, bi2(a, "Local request error detected and ignored"));
      else if (a.i && 4 == ii2(a))
        zd2(a.Ub, 0, a);
      else if (a.dispatchEvent("readystatechange"), 4 == ii2(a)) {
        Qh(a.b, bi2(a, "Request complete"));
        a.c = false;
        try {
          var b2 = ji2(a);
          a:
            switch (b2) {
              case 200:
              case 201:
              case 202:
              case 204:
              case 206:
              case 304:
              case 1223:
                var c = true;
                break a;
              default:
                c = false;
            }
          var d;
          if (!(d = c)) {
            var e;
            if (e = 0 === b2) {
              var f = String(a.l).match(Hd2)[1] || null;
              if (!f && l.self && l.self.location) {
                var g2 = l.self.location.protocol;
                f = g2.substr(0, g2.length - 1);
              }
              e = !Zh.test(f ? f.toLowerCase() : "");
            }
            d = e;
          }
          if (d)
            a.dispatchEvent("complete"), a.dispatchEvent("success");
          else {
            try {
              var h = 2 < ii2(a) ? a.a.statusText : "";
            } catch (m) {
              Qh(a.b, "Can not get status: " + m.message), h = "";
            }
            a.h = h + " [" + ji2(a) + "]";
            fi2(a);
          }
        } finally {
          gi2(a);
        }
      }
    }
  }
  function gi2(a, b2) {
    if (a.a) {
      di2(a);
      var c = a.a, d = a.A[0] ? ka3 : null;
      a.a = null;
      a.A = null;
      b2 || a.dispatchEvent("ready");
      try {
        c.onreadystatechange = d;
      } catch (e) {
        (a = a.b) && a.log(Ih, "Problem encountered resetting onreadystatechange: " + e.message, void 0);
      }
    }
  }
  function di2(a) {
    a.a && a.u && (a.a.ontimeout = null);
    a.o && (l.clearTimeout(a.o), a.o = null);
  }
  function ii2(a) {
    return a.a ? a.a.readyState : 0;
  }
  function ji2(a) {
    try {
      return 2 < ii2(a) ? a.a.status : -1;
    } catch (b2) {
      return -1;
    }
  }
  function ki2(a) {
    try {
      return a.a ? a.a.responseText : "";
    } catch (b2) {
      return Qh(a.b, "Can not get responseText: " + b2.message), "";
    }
  }
  k3.getResponse = function() {
    try {
      if (!this.a)
        return null;
      if ("response" in this.a)
        return this.a.response;
      switch (this.m) {
        case Yh:
        case "text":
          return this.a.responseText;
        case "arraybuffer":
          if ("mozResponseArrayBuffer" in this.a)
            return this.a.mozResponseArrayBuffer;
      }
      var a = this.b;
      a && a.log(Ih, "Response type " + this.m + " is not supported on this browser", void 0);
      return null;
    } catch (b2) {
      return Qh(this.b, "Can not get response: " + b2.message), null;
    }
  };
  function bi2(a, b2) {
    return b2 + " [" + a.P + " " + a.l + " " + ji2(a) + "]";
  }
  ;
  function li2(a) {
    var b2 = mi2;
    this.g = [];
    this.u = b2;
    this.o = a || null;
    this.f = this.a = false;
    this.c = void 0;
    this.m = this.A = this.i = false;
    this.h = 0;
    this.b = null;
    this.l = 0;
  }
  li2.prototype.cancel = function(a) {
    if (this.a)
      this.c instanceof li2 && this.c.cancel();
    else {
      if (this.b) {
        var b2 = this.b;
        delete this.b;
        a ? b2.cancel(a) : (b2.l--, 0 >= b2.l && b2.cancel());
      }
      this.u ? this.u.call(this.o, this) : this.m = true;
      this.a || (a = new ni2(this), oi2(this), pi2(this, false, a));
    }
  };
  li2.prototype.v = function(a, b2) {
    this.i = false;
    pi2(this, a, b2);
  };
  function pi2(a, b2, c) {
    a.a = true;
    a.c = c;
    a.f = !b2;
    qi2(a);
  }
  function oi2(a) {
    if (a.a) {
      if (!a.m)
        throw new ri2(a);
      a.m = false;
    }
  }
  function si2(a, b2) {
    ti2(a, null, b2, void 0);
  }
  function ti2(a, b2, c, d) {
    a.g.push([b2, c, d]);
    a.a && qi2(a);
  }
  li2.prototype.then = function(a, b2, c) {
    var d, e, f = new C3(function(g2, h) {
      d = g2;
      e = h;
    });
    ti2(this, d, function(g2) {
      g2 instanceof ni2 ? f.cancel() : e(g2);
    });
    return f.then(a, b2, c);
  };
  li2.prototype.$goog_Thenable = true;
  function ui2(a) {
    return Qa(a.g, function(b2) {
      return na3(b2[1]);
    });
  }
  function qi2(a) {
    if (a.h && a.a && ui2(a)) {
      var b2 = a.h, c = vi2[b2];
      c && (l.clearTimeout(c.a), delete vi2[b2]);
      a.h = 0;
    }
    a.b && (a.b.l--, delete a.b);
    b2 = a.c;
    for (var d = c = false; a.g.length && !a.i; ) {
      var e = a.g.shift(), f = e[0], g2 = e[1];
      e = e[2];
      if (f = a.f ? g2 : f)
        try {
          var h = f.call(e || a.o, b2);
          void 0 !== h && (a.f = a.f && (h == b2 || h instanceof Error), a.c = b2 = h);
          if (Ca2(b2) || "function" === typeof l.Promise && b2 instanceof l.Promise)
            d = true, a.i = true;
        } catch (m) {
          b2 = m, a.f = true, ui2(a) || (c = true);
        }
    }
    a.c = b2;
    d && (h = q3(a.v, a, true), d = q3(a.v, a, false), b2 instanceof li2 ? (ti2(b2, h, d), b2.A = true) : b2.then(h, d));
    c && (b2 = new wi2(b2), vi2[b2.a] = b2, a.h = b2.a);
  }
  function ri2() {
    u4.call(this);
  }
  r2(ri2, u4);
  ri2.prototype.message = "Deferred has already fired";
  ri2.prototype.name = "AlreadyCalledError";
  function ni2() {
    u4.call(this);
  }
  r2(ni2, u4);
  ni2.prototype.message = "Deferred was canceled";
  ni2.prototype.name = "CanceledError";
  function wi2(a) {
    this.a = l.setTimeout(q3(this.c, this), 0);
    this.b = a;
  }
  wi2.prototype.c = function() {
    delete vi2[this.a];
    throw this.b;
  };
  var vi2 = {};
  function xi2(a) {
    var b2 = {}, c = b2.document || document, d = wb2(a).toString(), e = jc2(document, "SCRIPT"), f = { Vb: e, Ma: void 0 }, g2 = new li2(f), h = null, m = null != b2.timeout ? b2.timeout : 5e3;
    0 < m && (h = window.setTimeout(function() {
      yi2(e, true);
      var p2 = new zi2(Ai2, "Timeout reached for loading script " + d);
      oi2(g2);
      pi2(g2, false, p2);
    }, m), f.Ma = h);
    e.onload = e.onreadystatechange = function() {
      e.readyState && "loaded" != e.readyState && "complete" != e.readyState || (yi2(e, b2.wd || false, h), oi2(g2), pi2(g2, true, null));
    };
    e.onerror = function() {
      yi2(e, true, h);
      var p2 = new zi2(Bi2, "Error while loading script " + d);
      oi2(g2);
      pi2(g2, false, p2);
    };
    f = b2.attributes || {};
    z2(f, { type: "text/javascript", charset: "UTF-8" });
    gc2(e, f);
    Mb2(e, a);
    Ci2(c).appendChild(e);
    return g2;
  }
  function Ci2(a) {
    var b2;
    return (b2 = (a || document).getElementsByTagName("HEAD")) && 0 != b2.length ? b2[0] : a.documentElement;
  }
  function mi2() {
    if (this && this.Vb) {
      var a = this.Vb;
      a && "SCRIPT" == a.tagName && yi2(a, true, this.Ma);
    }
  }
  function yi2(a, b2, c) {
    null != c && l.clearTimeout(c);
    a.onload = ka3;
    a.onerror = ka3;
    a.onreadystatechange = ka3;
    b2 && window.setTimeout(function() {
      a && a.parentNode && a.parentNode.removeChild(a);
    }, 0);
  }
  var Bi2 = 0, Ai2 = 1;
  function zi2(a, b2) {
    var c = "Jsloader error (code #" + a + ")";
    b2 && (c += ": " + b2);
    u4.call(this, c);
    this.code = a;
  }
  r2(zi2, u4);
  function Di2(a) {
    this.f = a;
  }
  r2(Di2, wh);
  Di2.prototype.a = function() {
    return new this.f();
  };
  Di2.prototype.b = function() {
    return {};
  };
  function Ei2(a, b2, c) {
    this.c = a;
    a = b2 || {};
    this.l = a.secureTokenEndpoint || "https://securetoken.googleapis.com/v1/token";
    this.v = a.secureTokenTimeout || Fi2;
    this.g = lb2(a.secureTokenHeaders || Gi2);
    this.h = a.firebaseEndpoint || "https://www.googleapis.com/identitytoolkit/v3/relyingparty/";
    this.i = a.identityPlatformEndpoint || "https://identitytoolkit.googleapis.com/v2/";
    this.m = a.firebaseTimeout || Hi2;
    this.a = lb2(a.firebaseHeaders || Ii2);
    c && (this.a["X-Client-Version"] = c, this.g["X-Client-Version"] = c);
    c = "Node" == Fe2();
    c = l.XMLHttpRequest || c && import_app8.default.INTERNAL.node && import_app8.default.INTERNAL.node.XMLHttpRequest;
    if (!c && !Ee2())
      throw new t("internal-error", "The XMLHttpRequest compatibility library was not found.");
    this.f = void 0;
    Ee2() ? this.f = new Rh(self) : Ge2() ? this.f = new Di2(c) : this.f = new Bh();
    this.b = null;
  }
  var Ji2, zg = "idToken", Fi2 = new Ue2(3e4, 6e4), Gi2 = { "Content-Type": "application/x-www-form-urlencoded" }, Hi2 = new Ue2(3e4, 6e4), Ii2 = { "Content-Type": "application/json" };
  function Ki2(a, b2) {
    b2 ? a.a["X-Firebase-Locale"] = b2 : delete a.a["X-Firebase-Locale"];
  }
  function Li2(a, b2) {
    b2 && (a.l = Mi2("https://securetoken.googleapis.com/v1/token", b2), a.h = Mi2("https://www.googleapis.com/identitytoolkit/v3/relyingparty/", b2), a.i = Mi2("https://identitytoolkit.googleapis.com/v2/", b2));
  }
  function Mi2(a, b2) {
    a = J3(a);
    b2 = J3(b2.url);
    a.c = a.a + a.c;
    Kd2(a, b2.f);
    a.a = b2.a;
    Ld2(a, b2.g);
    return a.toString();
  }
  function Ni2(a, b2) {
    b2 ? (a.a["X-Client-Version"] = b2, a.g["X-Client-Version"] = b2) : (delete a.a["X-Client-Version"], delete a.g["X-Client-Version"]);
  }
  Ei2.prototype.S = function() {
    return this.b;
  };
  function Oi2(a, b2, c, d, e, f, g2) {
    pe2() || Ee2() ? a = q3(a.u, a) : (Ji2 || (Ji2 = new C3(function(h, m) {
      Pi2(h, m);
    })), a = q3(a.o, a));
    a(b2, c, d, e, f, g2);
  }
  Ei2.prototype.u = function(a, b2, c, d, e, f) {
    if (Ee2() && ("undefined" === typeof l.fetch || "undefined" === typeof l.Headers || "undefined" === typeof l.Request))
      throw new t("operation-not-supported-in-this-environment", "fetch, Headers and Request native APIs or equivalent Polyfills must be available to support HTTP requests from a Worker environment.");
    var g2 = new Xh(this.f);
    if (f) {
      g2.g = Math.max(0, f);
      var h = setTimeout(function() {
        g2.dispatchEvent("timeout");
      }, f);
    }
    md2(g2, "complete", function() {
      h && clearTimeout(h);
      var m = null;
      try {
        m = JSON.parse(ki2(this)) || null;
      } catch (p2) {
        m = null;
      }
      b2 && b2(m);
    });
    sd2(g2, "ready", function() {
      h && clearTimeout(h);
      Tc2(this);
    });
    sd2(g2, "timeout", function() {
      h && clearTimeout(h);
      Tc2(this);
      b2 && b2(null);
    });
    ai2(g2, a, c, d, e);
  };
  var Qi2 = new ob2(pb2, "https://apis.google.com/js/client.js?onload=%{onload}"), Ri2 = "__fcb" + Math.floor(1e6 * Math.random()).toString();
  function Pi2(a, b2) {
    if (((window.gapi || {}).client || {}).request)
      a();
    else {
      l[Ri2] = function() {
        ((window.gapi || {}).client || {}).request ? a() : b2(Error("CORS_UNSUPPORTED"));
      };
      var c = xb2(Qi2, { onload: Ri2 });
      si2(xi2(c), function() {
        b2(Error("CORS_UNSUPPORTED"));
      });
    }
  }
  Ei2.prototype.o = function(a, b2, c, d, e) {
    var f = this;
    Ji2.then(function() {
      window.gapi.client.setApiKey(f.c);
      var g2 = window.gapi.auth.getToken();
      window.gapi.auth.setToken(null);
      window.gapi.client.request({ path: a, method: c, body: d, headers: e, authType: "none", callback: function(h) {
        window.gapi.auth.setToken(g2);
        b2 && b2(h);
      } });
    }).s(function(g2) {
      b2 && b2({ error: { message: g2 && g2.message || "CORS_UNSUPPORTED" } });
    });
  };
  function Si2(a, b2) {
    return new C3(function(c, d) {
      "refresh_token" == b2.grant_type && b2.refresh_token || "authorization_code" == b2.grant_type && b2.code ? Oi2(a, a.l + "?key=" + encodeURIComponent(a.c), function(e) {
        e ? e.error ? d(Ti2(e)) : e.access_token && e.refresh_token ? c(e) : d(new t("internal-error")) : d(new t("network-request-failed"));
      }, "POST", ae2(b2).toString(), a.g, a.v.get()) : d(new t("internal-error"));
    });
  }
  function Ui2(a, b2, c, d, e, f, g2) {
    var h = J3(b2 + c);
    I3(h, "key", a.c);
    g2 && I3(h, "cb", ua3().toString());
    var m = "GET" == d;
    if (m)
      for (var p2 in e)
        e.hasOwnProperty(p2) && I3(h, p2, e[p2]);
    return new C3(function(v2, B2) {
      Oi2(a, h.toString(), function(A3) {
        A3 ? A3.error ? B2(Ti2(A3, f || {})) : v2(A3) : B2(new t("network-request-failed"));
      }, d, m ? void 0 : fe2(Qe2(e)), a.a, a.m.get());
    });
  }
  function Vi2(a) {
    a = a.email;
    if ("string" !== typeof a || !ye2.test(a))
      throw new t("invalid-email");
  }
  function Wi2(a) {
    "email" in a && Vi2(a);
  }
  function Xi2(a, b2) {
    return O3(a, Yi2, { identifier: b2, continueUri: Ne2() ? me2() : "http://localhost" }).then(function(c) {
      return c.signinMethods || [];
    });
  }
  function Zi2(a) {
    return O3(a, $i2, {}).then(function(b2) {
      return b2.authorizedDomains || [];
    });
  }
  function P3(a) {
    if (!a[zg]) {
      if (a.mfaPendingCredential)
        throw new t("multi-factor-auth-required", null, lb2(a));
      throw new t("internal-error");
    }
  }
  function aj(a) {
    if (a.phoneNumber || a.temporaryProof) {
      if (!a.phoneNumber || !a.temporaryProof)
        throw new t("internal-error");
    } else {
      if (!a.sessionInfo)
        throw new t("missing-verification-id");
      if (!a.code)
        throw new t("missing-verification-code");
    }
  }
  Ei2.prototype.yb = function() {
    return O3(this, bj, {});
  };
  Ei2.prototype.Ab = function(a, b2) {
    return O3(this, cj, { idToken: a, email: b2 });
  };
  Ei2.prototype.Bb = function(a, b2) {
    return O3(this, Zg, { idToken: a, password: b2 });
  };
  var dj = { displayName: "DISPLAY_NAME", photoUrl: "PHOTO_URL" };
  k3 = Ei2.prototype;
  k3.Cb = function(a, b2) {
    var c = { idToken: a }, d = [];
    jb2(dj, function(e, f) {
      var g2 = b2[f];
      null === g2 ? d.push(e) : f in b2 && (c[f] = g2);
    });
    d.length && (c.deleteAttribute = d);
    return O3(this, cj, c);
  };
  k3.ub = function(a, b2) {
    a = { requestType: "PASSWORD_RESET", email: a };
    z2(a, b2);
    return O3(this, ej, a);
  };
  k3.vb = function(a, b2) {
    a = { requestType: "EMAIL_SIGNIN", email: a };
    z2(a, b2);
    return O3(this, fj, a);
  };
  k3.tb = function(a, b2) {
    a = { requestType: "VERIFY_EMAIL", idToken: a };
    z2(a, b2);
    return O3(this, gj, a);
  };
  k3.Db = function(a, b2, c) {
    a = { requestType: "VERIFY_AND_CHANGE_EMAIL", idToken: a, newEmail: b2 };
    z2(a, c);
    return O3(this, hj, a);
  };
  function kh(a, b2) {
    return O3(a, ij, b2);
  }
  k3.eb = function(a) {
    return O3(this, jj, a);
  };
  function ih(a, b2) {
    return O3(a, kj, b2).then(function(c) {
      return c.phoneSessionInfo.sessionInfo;
    });
  }
  function lj(a) {
    if (!a.phoneVerificationInfo)
      throw new t("internal-error");
    if (!a.phoneVerificationInfo.sessionInfo)
      throw new t("missing-verification-id");
    if (!a.phoneVerificationInfo.code)
      throw new t("missing-verification-code");
  }
  function jh(a, b2) {
    return O3(a, mj, b2).then(function(c) {
      return c.phoneResponseInfo.sessionInfo;
    });
  }
  function nj(a, b2, c) {
    return O3(a, oj, { idToken: b2, deleteProvider: c });
  }
  function pj(a) {
    if (!a.requestUri || !a.sessionId && !a.postBody && !a.pendingToken)
      throw new t("internal-error");
  }
  function qj(a, b2) {
    b2.oauthIdToken && b2.providerId && 0 == b2.providerId.indexOf("oidc.") && !b2.pendingToken && (a.sessionId ? b2.nonce = a.sessionId : a.postBody && (a = new Pd2(a.postBody), ee2(a, "nonce") && (b2.nonce = a.get("nonce"))));
    return b2;
  }
  function rj(a) {
    var b2 = null;
    a.needConfirmation ? (a.code = "account-exists-with-different-credential", b2 = vh(a)) : "FEDERATED_USER_ID_ALREADY_LINKED" == a.errorMessage ? (a.code = "credential-already-in-use", b2 = vh(a)) : "EMAIL_EXISTS" == a.errorMessage ? (a.code = "email-already-in-use", b2 = vh(a)) : a.errorMessage && (b2 = sj(a.errorMessage));
    if (b2)
      throw b2;
    P3(a);
  }
  function Bg(a, b2) {
    b2.returnIdpCredential = true;
    return O3(a, tj, b2);
  }
  function Dg(a, b2) {
    b2.returnIdpCredential = true;
    return O3(a, uj, b2);
  }
  function Eg(a, b2) {
    b2.returnIdpCredential = true;
    b2.autoCreate = false;
    return O3(a, vj, b2);
  }
  function wj(a) {
    if (!a.oobCode)
      throw new t("invalid-action-code");
  }
  k3.mb = function(a, b2) {
    return O3(this, xj, { oobCode: a, newPassword: b2 });
  };
  k3.Qa = function(a) {
    return O3(this, yj, { oobCode: a });
  };
  k3.ib = function(a) {
    return O3(this, zj, { oobCode: a });
  };
  var zj = { endpoint: "setAccountInfo", B: wj, Z: "email", C: true }, yj = { endpoint: "resetPassword", B: wj, F: function(a) {
    var b2 = a.requestType;
    if (!b2 || !a.email && "EMAIL_SIGNIN" != b2 && "VERIFY_AND_CHANGE_EMAIL" != b2)
      throw new t("internal-error");
  }, C: true }, Aj = { endpoint: "signupNewUser", B: function(a) {
    Vi2(a);
    if (!a.password)
      throw new t("weak-password");
  }, F: P3, U: true, C: true }, Yi2 = { endpoint: "createAuthUri", C: true }, Bj = { endpoint: "deleteAccount", M: ["idToken"] }, oj = { endpoint: "setAccountInfo", M: ["idToken", "deleteProvider"], B: function(a) {
    if ("array" != la3(a.deleteProvider))
      throw new t("internal-error");
  } }, Wg = { endpoint: "emailLinkSignin", M: ["email", "oobCode"], B: Vi2, F: P3, U: true, C: true }, Yg = { endpoint: "emailLinkSignin", M: ["idToken", "email", "oobCode"], B: Vi2, F: P3, U: true }, Cj = { endpoint: "accounts/mfaEnrollment:finalize", M: ["idToken", "phoneVerificationInfo"], B: lj, F: P3, C: true, Na: true }, Dj = { endpoint: "accounts/mfaSignIn:finalize", M: ["mfaPendingCredential", "phoneVerificationInfo"], B: lj, F: P3, C: true, Na: true }, Ej = { endpoint: "getAccountInfo" }, fj = {
    endpoint: "getOobConfirmationCode",
    M: ["requestType"],
    B: function(a) {
      if ("EMAIL_SIGNIN" != a.requestType)
        throw new t("internal-error");
      Vi2(a);
    },
    Z: "email",
    C: true
  }, gj = { endpoint: "getOobConfirmationCode", M: ["idToken", "requestType"], B: function(a) {
    if ("VERIFY_EMAIL" != a.requestType)
      throw new t("internal-error");
  }, Z: "email", C: true }, hj = { endpoint: "getOobConfirmationCode", M: ["idToken", "newEmail", "requestType"], B: function(a) {
    if ("VERIFY_AND_CHANGE_EMAIL" != a.requestType)
      throw new t("internal-error");
  }, Z: "email", C: true }, ej = { endpoint: "getOobConfirmationCode", M: ["requestType"], B: function(a) {
    if ("PASSWORD_RESET" != a.requestType)
      throw new t("internal-error");
    Vi2(a);
  }, Z: "email", C: true }, $i2 = { kb: true, endpoint: "getProjectConfig", Tb: "GET" }, Fj = { kb: true, endpoint: "getRecaptchaParam", Tb: "GET", F: function(a) {
    if (!a.recaptchaSiteKey)
      throw new t("internal-error");
  } }, xj = { endpoint: "resetPassword", B: wj, Z: "email", C: true }, ij = { endpoint: "sendVerificationCode", M: ["phoneNumber", "recaptchaToken"], Z: "sessionInfo", C: true }, cj = { endpoint: "setAccountInfo", M: ["idToken"], B: Wi2, U: true }, Zg = { endpoint: "setAccountInfo", M: ["idToken"], B: function(a) {
    Wi2(a);
    if (!a.password)
      throw new t("weak-password");
  }, F: P3, U: true }, bj = { endpoint: "signupNewUser", F: P3, U: true, C: true }, kj = { endpoint: "accounts/mfaEnrollment:start", M: ["idToken", "phoneEnrollmentInfo"], B: function(a) {
    if (!a.phoneEnrollmentInfo)
      throw new t("internal-error");
    if (!a.phoneEnrollmentInfo.phoneNumber)
      throw new t("missing-phone-number");
    if (!a.phoneEnrollmentInfo.recaptchaToken)
      throw new t("missing-app-credential");
  }, F: function(a) {
    if (!a.phoneSessionInfo || !a.phoneSessionInfo.sessionInfo)
      throw new t("internal-error");
  }, C: true, Na: true }, mj = {
    endpoint: "accounts/mfaSignIn:start",
    M: ["mfaPendingCredential", "mfaEnrollmentId", "phoneSignInInfo"],
    B: function(a) {
      if (!a.phoneSignInInfo || !a.phoneSignInInfo.recaptchaToken)
        throw new t("missing-app-credential");
    },
    F: function(a) {
      if (!a.phoneResponseInfo || !a.phoneResponseInfo.sessionInfo)
        throw new t("internal-error");
    },
    C: true,
    Na: true
  }, tj = { endpoint: "verifyAssertion", B: pj, Xa: qj, F: rj, U: true, C: true }, vj = { endpoint: "verifyAssertion", B: pj, Xa: qj, F: function(a) {
    if (a.errorMessage && "USER_NOT_FOUND" == a.errorMessage)
      throw new t("user-not-found");
    if (a.errorMessage)
      throw sj(a.errorMessage);
    P3(a);
  }, U: true, C: true }, uj = { endpoint: "verifyAssertion", B: function(a) {
    pj(a);
    if (!a.idToken)
      throw new t("internal-error");
  }, Xa: qj, F: rj, U: true }, Gj = { endpoint: "verifyCustomToken", B: function(a) {
    if (!a.token)
      throw new t("invalid-custom-token");
  }, F: P3, U: true, C: true }, Xg = { endpoint: "verifyPassword", B: function(a) {
    Vi2(a);
    if (!a.password)
      throw new t("wrong-password");
  }, F: P3, U: true, C: true }, jj = { endpoint: "verifyPhoneNumber", B: aj, F: P3, C: true }, eh = {
    endpoint: "verifyPhoneNumber",
    B: function(a) {
      if (!a.idToken)
        throw new t("internal-error");
      aj(a);
    },
    F: function(a) {
      if (a.temporaryProof)
        throw a.code = "credential-already-in-use", vh(a);
      P3(a);
    }
  }, fh = { Gb: { USER_NOT_FOUND: "user-not-found" }, endpoint: "verifyPhoneNumber", B: aj, F: P3, C: true }, Hj = { endpoint: "accounts/mfaEnrollment:withdraw", M: ["idToken", "mfaEnrollmentId"], F: function(a) {
    if (!!a[zg] ^ !!a.refreshToken)
      throw new t("internal-error");
  }, C: true, Na: true };
  function O3(a, b2, c) {
    if (!hf(c, b2.M))
      return E3(new t("internal-error"));
    var d = !!b2.Na, e = b2.Tb || "POST", f;
    return D3(c).then(b2.B).then(function() {
      b2.U && (c.returnSecureToken = true);
      b2.C && a.b && "undefined" === typeof c.tenantId && (c.tenantId = a.b);
      return d ? Ui2(a, a.i, b2.endpoint, e, c, b2.Gb, b2.kb || false) : Ui2(a, a.h, b2.endpoint, e, c, b2.Gb, b2.kb || false);
    }).then(function(g2) {
      f = g2;
      return b2.Xa ? b2.Xa(c, f) : f;
    }).then(b2.F).then(function() {
      if (!b2.Z)
        return f;
      if (!(b2.Z in f))
        throw new t("internal-error");
      return f[b2.Z];
    });
  }
  function sj(a) {
    return Ti2({ error: { errors: [{ message: a }], code: 400, message: a } });
  }
  function Ti2(a, b2) {
    var c = (a.error && a.error.errors && a.error.errors[0] || {}).reason || "";
    var d = { keyInvalid: "invalid-api-key", ipRefererBlocked: "app-not-authorized" };
    if (c = d[c] ? new t(d[c]) : null)
      return c;
    c = a.error && a.error.message || "";
    d = {
      INVALID_CUSTOM_TOKEN: "invalid-custom-token",
      CREDENTIAL_MISMATCH: "custom-token-mismatch",
      MISSING_CUSTOM_TOKEN: "internal-error",
      INVALID_IDENTIFIER: "invalid-email",
      MISSING_CONTINUE_URI: "internal-error",
      INVALID_EMAIL: "invalid-email",
      INVALID_PASSWORD: "wrong-password",
      USER_DISABLED: "user-disabled",
      MISSING_PASSWORD: "internal-error",
      EMAIL_EXISTS: "email-already-in-use",
      PASSWORD_LOGIN_DISABLED: "operation-not-allowed",
      INVALID_IDP_RESPONSE: "invalid-credential",
      INVALID_PENDING_TOKEN: "invalid-credential",
      FEDERATED_USER_ID_ALREADY_LINKED: "credential-already-in-use",
      MISSING_OR_INVALID_NONCE: "missing-or-invalid-nonce",
      INVALID_MESSAGE_PAYLOAD: "invalid-message-payload",
      INVALID_RECIPIENT_EMAIL: "invalid-recipient-email",
      INVALID_SENDER: "invalid-sender",
      EMAIL_NOT_FOUND: "user-not-found",
      RESET_PASSWORD_EXCEED_LIMIT: "too-many-requests",
      EXPIRED_OOB_CODE: "expired-action-code",
      INVALID_OOB_CODE: "invalid-action-code",
      MISSING_OOB_CODE: "internal-error",
      INVALID_PROVIDER_ID: "invalid-provider-id",
      CREDENTIAL_TOO_OLD_LOGIN_AGAIN: "requires-recent-login",
      INVALID_ID_TOKEN: "invalid-user-token",
      TOKEN_EXPIRED: "user-token-expired",
      USER_NOT_FOUND: "user-token-expired",
      CORS_UNSUPPORTED: "cors-unsupported",
      DYNAMIC_LINK_NOT_ACTIVATED: "dynamic-link-not-activated",
      INVALID_APP_ID: "invalid-app-id",
      TOO_MANY_ATTEMPTS_TRY_LATER: "too-many-requests",
      WEAK_PASSWORD: "weak-password",
      OPERATION_NOT_ALLOWED: "operation-not-allowed",
      USER_CANCELLED: "user-cancelled",
      CAPTCHA_CHECK_FAILED: "captcha-check-failed",
      INVALID_APP_CREDENTIAL: "invalid-app-credential",
      INVALID_CODE: "invalid-verification-code",
      INVALID_PHONE_NUMBER: "invalid-phone-number",
      INVALID_SESSION_INFO: "invalid-verification-id",
      INVALID_TEMPORARY_PROOF: "invalid-credential",
      MISSING_APP_CREDENTIAL: "missing-app-credential",
      MISSING_CODE: "missing-verification-code",
      MISSING_PHONE_NUMBER: "missing-phone-number",
      MISSING_SESSION_INFO: "missing-verification-id",
      QUOTA_EXCEEDED: "quota-exceeded",
      SESSION_EXPIRED: "code-expired",
      REJECTED_CREDENTIAL: "rejected-credential",
      INVALID_CONTINUE_URI: "invalid-continue-uri",
      MISSING_ANDROID_PACKAGE_NAME: "missing-android-pkg-name",
      MISSING_IOS_BUNDLE_ID: "missing-ios-bundle-id",
      UNAUTHORIZED_DOMAIN: "unauthorized-continue-uri",
      INVALID_DYNAMIC_LINK_DOMAIN: "invalid-dynamic-link-domain",
      INVALID_OAUTH_CLIENT_ID: "invalid-oauth-client-id",
      INVALID_CERT_HASH: "invalid-cert-hash",
      UNSUPPORTED_TENANT_OPERATION: "unsupported-tenant-operation",
      INVALID_TENANT_ID: "invalid-tenant-id",
      TENANT_ID_MISMATCH: "tenant-id-mismatch",
      ADMIN_ONLY_OPERATION: "admin-restricted-operation",
      INVALID_MFA_PENDING_CREDENTIAL: "invalid-multi-factor-session",
      MFA_ENROLLMENT_NOT_FOUND: "multi-factor-info-not-found",
      MISSING_MFA_PENDING_CREDENTIAL: "missing-multi-factor-session",
      MISSING_MFA_ENROLLMENT_ID: "missing-multi-factor-info",
      EMAIL_CHANGE_NEEDS_VERIFICATION: "email-change-needs-verification",
      SECOND_FACTOR_EXISTS: "second-factor-already-in-use",
      SECOND_FACTOR_LIMIT_EXCEEDED: "maximum-second-factor-count-exceeded",
      UNSUPPORTED_FIRST_FACTOR: "unsupported-first-factor",
      UNVERIFIED_EMAIL: "unverified-email"
    };
    z2(d, b2 || {});
    b2 = (b2 = c.match(/^[^\s]+\s*:\s*([\s\S]*)$/)) && 1 < b2.length ? b2[1] : void 0;
    for (var e in d)
      if (0 === c.indexOf(e))
        return new t(d[e], b2);
    !b2 && a && (b2 = Pe2(a));
    return new t("internal-error", b2);
  }
  ;
  function Ij(a) {
    this.b = a;
    this.a = null;
    this.qb = Jj(this);
  }
  function Jj(a) {
    return Kj().then(function() {
      return new C3(function(b2, c) {
        L3("gapi.iframes.getContext")().open({ where: document.body, url: a.b, messageHandlersFilter: L3("gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER"), attributes: { style: { position: "absolute", top: "-100px", width: "1px", height: "1px" } }, dontclear: true }, function(d) {
          function e() {
            clearTimeout(f);
            b2();
          }
          a.a = d;
          a.a.restyle({ setHideOnLeave: false });
          var f = setTimeout(function() {
            c(Error("Network Error"));
          }, Lj.get());
          d.ping(e).then(e, function() {
            c(Error("Network Error"));
          });
        });
      });
    });
  }
  function Mj(a, b2) {
    return a.qb.then(function() {
      return new C3(function(c) {
        a.a.send(b2.type, b2, c, L3("gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER"));
      });
    });
  }
  function Nj(a, b2) {
    a.qb.then(function() {
      a.a.register("authEvent", b2, L3("gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER"));
    });
  }
  var Oj = new ob2(pb2, "https://apis.google.com/js/api.js?onload=%{onload}"), Pj = new Ue2(3e4, 6e4), Lj = new Ue2(5e3, 15e3), Qj = null;
  function Kj() {
    return Qj ? Qj : Qj = new C3(function(a, b2) {
      function c() {
        Te2();
        L3("gapi.load")("gapi.iframes", { callback: a, ontimeout: function() {
          Te2();
          b2(Error("Network Error"));
        }, timeout: Pj.get() });
      }
      if (L3("gapi.iframes.Iframe"))
        a();
      else if (L3("gapi.load"))
        c();
      else {
        var d = "__iframefcb" + Math.floor(1e6 * Math.random()).toString();
        l[d] = function() {
          L3("gapi.load") ? c() : b2(Error("Network Error"));
        };
        d = xb2(Oj, { onload: d });
        D3(xi2(d)).s(function() {
          b2(Error("Network Error"));
        });
      }
    }).s(function(a) {
      Qj = null;
      throw a;
    });
  }
  ;
  function Rj(a, b2, c, d) {
    this.l = a;
    this.h = b2;
    this.i = c;
    this.g = d;
    this.f = null;
    this.g ? (a = J3(this.g.url), a = Yd(a.f, a.a, a.g, "/emulator/auth/iframe")) : a = Yd("https", this.l, null, "/__/auth/iframe");
    this.a = a;
    I3(this.a, "apiKey", this.h);
    I3(this.a, "appName", this.i);
    this.b = null;
    this.c = [];
  }
  Rj.prototype.toString = function() {
    this.f ? I3(this.a, "v", this.f) : de2(this.a.b, "v");
    this.b ? I3(this.a, "eid", this.b) : de2(this.a.b, "eid");
    this.c.length ? I3(this.a, "fw", this.c.join(",")) : de2(this.a.b, "fw");
    return this.a.toString();
  };
  function Sj(a, b2, c, d, e, f) {
    this.u = a;
    this.o = b2;
    this.c = c;
    this.v = d;
    this.m = f;
    this.i = this.g = this.l = null;
    this.a = e;
    this.h = this.f = null;
  }
  Sj.prototype.xb = function(a) {
    this.h = a;
    return this;
  };
  Sj.prototype.toString = function() {
    if (this.m) {
      var a = J3(this.m.url);
      a = Yd(a.f, a.a, a.g, "/emulator/auth/handler");
    } else
      a = Yd("https", this.u, null, "/__/auth/handler");
    I3(a, "apiKey", this.o);
    I3(a, "appName", this.c);
    I3(a, "authType", this.v);
    if (this.a.isOAuthProvider) {
      var b2 = this.a;
      try {
        var c = import_app8.default.app(this.c).auth().ka();
      } catch (h) {
        c = null;
      }
      b2.nb = c;
      I3(a, "providerId", this.a.providerId);
      c = this.a;
      b2 = Qe2(c.Hb);
      for (var d in b2)
        b2[d] = b2[d].toString();
      d = c.Pc;
      b2 = lb2(b2);
      for (var e = 0; e < d.length; e++) {
        var f = d[e];
        f in b2 && delete b2[f];
      }
      c.ob && c.nb && !b2[c.ob] && (b2[c.ob] = c.nb);
      kb2(b2) || I3(a, "customParameters", Pe2(b2));
    }
    "function" === typeof this.a.Pb && (c = this.a.Pb(), c.length && I3(a, "scopes", c.join(",")));
    this.l ? I3(a, "redirectUrl", this.l) : de2(a.b, "redirectUrl");
    this.g ? I3(a, "eventId", this.g) : de2(a.b, "eventId");
    this.i ? I3(a, "v", this.i) : de2(a.b, "v");
    if (this.b)
      for (var g2 in this.b)
        this.b.hasOwnProperty(g2) && !Xd(a, g2) && I3(a, g2, this.b[g2]);
    this.h ? I3(a, "tid", this.h) : de2(a.b, "tid");
    this.f ? I3(a, "eid", this.f) : de2(a.b, "eid");
    g2 = Tj(this.c);
    g2.length && I3(a, "fw", g2.join(","));
    return a.toString();
  };
  function Tj(a) {
    try {
      return import_app8.default.app(a).auth().Ga();
    } catch (b2) {
      return [];
    }
  }
  function Uj(a, b2, c, d, e, f) {
    this.o = a;
    this.g = b2;
    this.b = c;
    this.f = f;
    this.c = d || null;
    this.i = e || null;
    this.l = this.u = this.A = null;
    this.h = [];
    this.v = this.a = null;
  }
  function Vj(a) {
    var b2 = me2();
    return Zi2(a).then(function(c) {
      a: {
        var d = J3(b2), e = d.f;
        d = d.a;
        for (var f = 0; f < c.length; f++) {
          var g2 = c[f];
          var h = d;
          var m = e;
          0 == g2.indexOf("chrome-extension://") ? h = J3(g2).a == h && "chrome-extension" == m : "http" != m && "https" != m ? h = false : xe2.test(g2) ? h = h == g2 : (g2 = g2.split(".").join("\\."), h = new RegExp("^(.+\\." + g2 + "|" + g2 + ")$", "i").test(h));
          if (h) {
            c = true;
            break a;
          }
        }
        c = false;
      }
      if (!c)
        throw new th(me2());
    });
  }
  function Wj(a) {
    if (a.v)
      return a.v;
    a.v = ze2().then(function() {
      if (!a.u) {
        var b2 = a.c, c = a.i, d = Tj(a.b), e = new Rj(a.o, a.g, a.b, a.f);
        e.f = b2;
        e.b = c;
        e.c = Xa2(d || []);
        a.u = e.toString();
      }
      a.m = new Ij(a.u);
      Xj(a);
    });
    return a.v;
  }
  k3 = Uj.prototype;
  k3.Nb = function(a, b2, c) {
    var d = new t("popup-closed-by-user"), e = new t("web-storage-unsupported"), f = this, g2 = false;
    return this.la().then(function() {
      Yj(f).then(function(h) {
        h || (a && te2(a), b2(e), g2 = true);
      });
    }).s(function() {
    }).then(function() {
      if (!g2)
        return we2(a);
    }).then(function() {
      if (!g2)
        return Ad2(c).then(function() {
          b2(d);
        });
    });
  };
  k3.Wb = function() {
    var a = K3();
    return !Oe2(a) && !Se2(a);
  };
  k3.Sb = function() {
    return false;
  };
  k3.Lb = function(a, b2, c, d, e, f, g2, h) {
    if (!a)
      return E3(new t("popup-blocked"));
    if (g2 && !Oe2())
      return this.la().s(function(p2) {
        te2(a);
        e(p2);
      }), d(), D3();
    this.a || (this.a = Vj(Zj(this)));
    var m = this;
    return this.a.then(function() {
      var p2 = m.la().s(function(v2) {
        te2(a);
        e(v2);
        throw v2;
      });
      d();
      return p2;
    }).then(function() {
      nh(c);
      if (!g2) {
        var p2 = ak(m.o, m.g, m.b, b2, c, null, f, m.c, void 0, m.i, h, m.f);
        ne2(p2, a);
      }
    }).s(function(p2) {
      "auth/network-request-failed" == p2.code && (m.a = null);
      throw p2;
    });
  };
  function Zj(a) {
    a.l || (a.A = a.c ? Je2(a.c, Tj(a.b)) : null, a.l = new Ei2(a.g, Aa3(a.i), a.A), a.f && Li2(a.l, a.f));
    return a.l;
  }
  k3.Mb = function(a, b2, c, d) {
    this.a || (this.a = Vj(Zj(this)));
    var e = this;
    return this.a.then(function() {
      nh(b2);
      var f = ak(e.o, e.g, e.b, a, b2, me2(), c, e.c, void 0, e.i, d, e.f);
      ne2(f);
    }).s(function(f) {
      "auth/network-request-failed" == f.code && (e.a = null);
      throw f;
    });
  };
  k3.la = function() {
    var a = this;
    return Wj(this).then(function() {
      return a.m.qb;
    }).s(function() {
      a.a = null;
      throw new t("network-request-failed");
    });
  };
  k3.Zb = function() {
    return true;
  };
  function ak(a, b2, c, d, e, f, g2, h, m, p2, v2, B2) {
    a = new Sj(a, b2, c, d, e, B2);
    a.l = f;
    a.g = g2;
    a.i = h;
    a.b = lb2(m || null);
    a.f = p2;
    return a.xb(v2).toString();
  }
  function Xj(a) {
    if (!a.m)
      throw Error("IfcHandler must be initialized!");
    Nj(a.m, function(b2) {
      var c = {};
      if (b2 && b2.authEvent) {
        var d = false;
        b2 = ph(b2.authEvent);
        for (c = 0; c < a.h.length; c++)
          d = a.h[c](b2) || d;
        c = {};
        c.status = d ? "ACK" : "ERROR";
        return D3(c);
      }
      c.status = "ERROR";
      return D3(c);
    });
  }
  function Yj(a) {
    var b2 = { type: "webStorageSupport" };
    return Wj(a).then(function() {
      return Mj(a.m, b2);
    }).then(function(c) {
      if (c && c.length && "undefined" !== typeof c[0].webStorageSupport)
        return c[0].webStorageSupport;
      throw Error();
    });
  }
  k3.Ea = function(a) {
    this.h.push(a);
  };
  k3.Ra = function(a) {
    Va2(this.h, function(b2) {
      return b2 == a;
    });
  };
  function bk(a) {
    this.a = a || import_app8.default.INTERNAL.reactNative && import_app8.default.INTERNAL.reactNative.AsyncStorage;
    if (!this.a)
      throw new t("internal-error", "The React Native compatibility library was not found.");
    this.type = "asyncStorage";
  }
  k3 = bk.prototype;
  k3.get = function(a) {
    return D3(this.a.getItem(a)).then(function(b2) {
      return b2 && Re2(b2);
    });
  };
  k3.set = function(a, b2) {
    return D3(this.a.setItem(a, Pe2(b2)));
  };
  k3.T = function(a) {
    return D3(this.a.removeItem(a));
  };
  k3.ca = function() {
  };
  k3.ia = function() {
  };
  function ck(a) {
    this.b = a;
    this.a = {};
    this.f = q3(this.c, this);
  }
  var dk = [];
  function ek() {
    var a = Ee2() ? self : null;
    w2(dk, function(c) {
      c.b == a && (b2 = c);
    });
    if (!b2) {
      var b2 = new ck(a);
      dk.push(b2);
    }
    return b2;
  }
  ck.prototype.c = function(a) {
    var b2 = a.data.eventType, c = a.data.eventId, d = this.a[b2];
    if (d && 0 < d.length) {
      a.ports[0].postMessage({ status: "ack", eventId: c, eventType: b2, response: null });
      var e = [];
      w2(d, function(f) {
        e.push(D3().then(function() {
          return f(a.origin, a.data.data);
        }));
      });
      Fc2(e).then(function(f) {
        var g2 = [];
        w2(f, function(h) {
          g2.push({ fulfilled: h.Ob, value: h.value, reason: h.reason ? h.reason.message : void 0 });
        });
        w2(g2, function(h) {
          for (var m in h)
            "undefined" === typeof h[m] && delete h[m];
        });
        a.ports[0].postMessage({
          status: "done",
          eventId: c,
          eventType: b2,
          response: g2
        });
      });
    }
  };
  function fk(a, b2, c) {
    kb2(a.a) && a.b.addEventListener("message", a.f);
    "undefined" === typeof a.a[b2] && (a.a[b2] = []);
    a.a[b2].push(c);
  }
  ;
  function gk(a) {
    this.a = a;
  }
  gk.prototype.postMessage = function(a, b2) {
    this.a.postMessage(a, b2);
  };
  function hk(a) {
    this.c = a;
    this.b = false;
    this.a = [];
  }
  function ik(a, b2, c, d) {
    var e, f = c || {}, g2, h, m, p2 = null;
    if (a.b)
      return E3(Error("connection_unavailable"));
    var v2 = d ? 800 : 50, B2 = "undefined" !== typeof MessageChannel ? new MessageChannel() : null;
    return new C3(function(A3, Q3) {
      B2 ? (e = Math.floor(Math.random() * Math.pow(10, 20)).toString(), B2.port1.start(), h = setTimeout(function() {
        Q3(Error("unsupported_event"));
      }, v2), g2 = function(xa3) {
        xa3.data.eventId === e && ("ack" === xa3.data.status ? (clearTimeout(h), m = setTimeout(function() {
          Q3(Error("timeout"));
        }, 3e3)) : "done" === xa3.data.status ? (clearTimeout(m), "undefined" !== typeof xa3.data.response ? A3(xa3.data.response) : Q3(Error("unknown_error"))) : (clearTimeout(h), clearTimeout(m), Q3(Error("invalid_response"))));
      }, p2 = { messageChannel: B2, onMessage: g2 }, a.a.push(p2), B2.port1.addEventListener("message", g2), a.c.postMessage({ eventType: b2, eventId: e, data: f }, [B2.port2])) : Q3(Error("connection_unavailable"));
    }).then(function(A3) {
      jk(a, p2);
      return A3;
    }).s(function(A3) {
      jk(a, p2);
      throw A3;
    });
  }
  function jk(a, b2) {
    if (b2) {
      var c = b2.messageChannel, d = b2.onMessage;
      c && (c.port1.removeEventListener("message", d), c.port1.close());
      Va2(a.a, function(e) {
        return e == b2;
      });
    }
  }
  hk.prototype.close = function() {
    for (; 0 < this.a.length; )
      jk(this, this.a[0]);
    this.b = true;
  };
  function kk() {
    if (!lk())
      throw new t("web-storage-unsupported");
    this.c = {};
    this.a = [];
    this.b = 0;
    this.m = l.indexedDB;
    this.type = "indexedDB";
    this.g = this.l = this.f = this.i = null;
    this.o = false;
    this.h = null;
    var a = this;
    Ee2() && self ? (this.l = ek(), fk(this.l, "keyChanged", function(b2, c) {
      return mk(a).then(function(d) {
        0 < d.length && w2(a.a, function(e) {
          e(d);
        });
        return { keyProcessed: Ta2(d, c.key) };
      });
    }), fk(this.l, "ping", function() {
      return D3(["keyChanged"]);
    })) : af().then(function(b2) {
      if (a.h = b2)
        a.g = new hk(new gk(b2)), ik(a.g, "ping", null, true).then(function(c) {
          c[0].fulfilled && Ta2(c[0].value, "keyChanged") && (a.o = true);
        }).s(function() {
        });
    });
  }
  var nk;
  function ok(a) {
    return new C3(function(b2, c) {
      var d = a.m.deleteDatabase("firebaseLocalStorageDb");
      d.onsuccess = function() {
        b2();
      };
      d.onerror = function(e) {
        c(Error(e.target.error));
      };
    });
  }
  function pk(a) {
    return new C3(function(b2, c) {
      var d = a.m.open("firebaseLocalStorageDb", 1);
      d.onerror = function(e) {
        try {
          e.preventDefault();
        } catch (f) {
        }
        c(Error(e.target.error));
      };
      d.onupgradeneeded = function(e) {
        e = e.target.result;
        try {
          e.createObjectStore("firebaseLocalStorage", { keyPath: "fbase_key" });
        } catch (f) {
          c(f);
        }
      };
      d.onsuccess = function(e) {
        e = e.target.result;
        e.objectStoreNames.contains("firebaseLocalStorage") ? b2(e) : ok(a).then(function() {
          return pk(a);
        }).then(function(f) {
          b2(f);
        }).s(function(f) {
          c(f);
        });
      };
    });
  }
  function qk(a) {
    a.v || (a.v = pk(a));
    return a.v;
  }
  function lk() {
    try {
      return !!l.indexedDB;
    } catch (a) {
      return false;
    }
  }
  function rk(a) {
    return a.objectStore("firebaseLocalStorage");
  }
  function sk(a, b2) {
    return a.transaction(["firebaseLocalStorage"], b2 ? "readwrite" : "readonly");
  }
  function tk(a) {
    return new C3(function(b2, c) {
      a.onsuccess = function(d) {
        d && d.target ? b2(d.target.result) : b2();
      };
      a.onerror = function(d) {
        c(d.target.error);
      };
    });
  }
  k3 = kk.prototype;
  k3.set = function(a, b2) {
    var c = false, d, e = this;
    return qk(this).then(function(f) {
      d = f;
      f = rk(sk(d, true));
      return tk(f.get(a));
    }).then(function(f) {
      var g2 = rk(sk(d, true));
      if (f)
        return f.value = b2, tk(g2.put(f));
      e.b++;
      c = true;
      f = {};
      f.fbase_key = a;
      f.value = b2;
      return tk(g2.add(f));
    }).then(function() {
      e.c[a] = b2;
      return uk(e, a);
    }).na(function() {
      c && e.b--;
    });
  };
  function uk(a, b2) {
    return a.g && a.h && $e2() === a.h ? ik(a.g, "keyChanged", { key: b2 }, a.o).then(function() {
    }).s(function() {
    }) : D3();
  }
  k3.get = function(a) {
    return qk(this).then(function(b2) {
      return tk(rk(sk(b2, false)).get(a));
    }).then(function(b2) {
      return b2 && b2.value;
    });
  };
  k3.T = function(a) {
    var b2 = false, c = this;
    return qk(this).then(function(d) {
      b2 = true;
      c.b++;
      return tk(rk(sk(d, true))["delete"](a));
    }).then(function() {
      delete c.c[a];
      return uk(c, a);
    }).na(function() {
      b2 && c.b--;
    });
  };
  function mk(a) {
    return qk(a).then(function(b2) {
      var c = rk(sk(b2, false));
      return c.getAll ? tk(c.getAll()) : new C3(function(d, e) {
        var f = [], g2 = c.openCursor();
        g2.onsuccess = function(h) {
          (h = h.target.result) ? (f.push(h.value), h["continue"]()) : d(f);
        };
        g2.onerror = function(h) {
          e(h.target.error);
        };
      });
    }).then(function(b2) {
      var c = {}, d = [];
      if (0 == a.b) {
        for (d = 0; d < b2.length; d++)
          c[b2[d].fbase_key] = b2[d].value;
        d = oe2(a.c, c);
        a.c = c;
      }
      return d;
    });
  }
  k3.ca = function(a) {
    0 == this.a.length && vk(this);
    this.a.push(a);
  };
  k3.ia = function(a) {
    Va2(this.a, function(b2) {
      return b2 == a;
    });
    0 == this.a.length && wk(this);
  };
  function vk(a) {
    function b2() {
      a.f = setTimeout(function() {
        a.i = mk(a).then(function(c) {
          0 < c.length && w2(a.a, function(d) {
            d(c);
          });
        }).then(function() {
          b2();
        }).s(function(c) {
          "STOP_EVENT" != c.message && b2();
        });
      }, 800);
    }
    wk(a);
    b2();
  }
  function wk(a) {
    a.i && a.i.cancel("STOP_EVENT");
    a.f && (clearTimeout(a.f), a.f = null);
  }
  ;
  function xk(a) {
    var b2 = this, c = null;
    this.a = [];
    this.type = "indexedDB";
    this.c = a;
    this.b = D3().then(function() {
      if (lk()) {
        var d = Le2(), e = "__sak" + d;
        nk || (nk = new kk());
        c = nk;
        return c.set(e, d).then(function() {
          return c.get(e);
        }).then(function(f) {
          if (f !== d)
            throw Error("indexedDB not supported!");
          return c.T(e);
        }).then(function() {
          return c;
        }).s(function() {
          return b2.c;
        });
      }
      return b2.c;
    }).then(function(d) {
      b2.type = d.type;
      d.ca(function(e) {
        w2(b2.a, function(f) {
          f(e);
        });
      });
      return d;
    });
  }
  k3 = xk.prototype;
  k3.get = function(a) {
    return this.b.then(function(b2) {
      return b2.get(a);
    });
  };
  k3.set = function(a, b2) {
    return this.b.then(function(c) {
      return c.set(a, b2);
    });
  };
  k3.T = function(a) {
    return this.b.then(function(b2) {
      return b2.T(a);
    });
  };
  k3.ca = function(a) {
    this.a.push(a);
  };
  k3.ia = function(a) {
    Va2(this.a, function(b2) {
      return b2 == a;
    });
  };
  function yk() {
    this.a = {};
    this.type = "inMemory";
  }
  k3 = yk.prototype;
  k3.get = function(a) {
    return D3(this.a[a]);
  };
  k3.set = function(a, b2) {
    this.a[a] = b2;
    return D3();
  };
  k3.T = function(a) {
    delete this.a[a];
    return D3();
  };
  k3.ca = function() {
  };
  k3.ia = function() {
  };
  function zk() {
    if (!Ak()) {
      if ("Node" == Fe2())
        throw new t("internal-error", "The LocalStorage compatibility library was not found.");
      throw new t("web-storage-unsupported");
    }
    this.a = Bk() || import_app8.default.INTERNAL.node.localStorage;
    this.type = "localStorage";
  }
  function Bk() {
    try {
      var a = l.localStorage, b2 = Le2();
      a && (a.setItem(b2, "1"), a.removeItem(b2));
      return a;
    } catch (c) {
      return null;
    }
  }
  function Ak() {
    var a = "Node" == Fe2();
    a = Bk() || a && import_app8.default.INTERNAL.node && import_app8.default.INTERNAL.node.localStorage;
    if (!a)
      return false;
    try {
      return a.setItem("__sak", "1"), a.removeItem("__sak"), true;
    } catch (b2) {
      return false;
    }
  }
  k3 = zk.prototype;
  k3.get = function(a) {
    var b2 = this;
    return D3().then(function() {
      var c = b2.a.getItem(a);
      return Re2(c);
    });
  };
  k3.set = function(a, b2) {
    var c = this;
    return D3().then(function() {
      var d = Pe2(b2);
      null === d ? c.T(a) : c.a.setItem(a, d);
    });
  };
  k3.T = function(a) {
    var b2 = this;
    return D3().then(function() {
      b2.a.removeItem(a);
    });
  };
  k3.ca = function(a) {
    l.window && jd2(l.window, "storage", a);
  };
  k3.ia = function(a) {
    l.window && G3(l.window, "storage", a);
  };
  function Ck() {
    this.type = "nullStorage";
  }
  k3 = Ck.prototype;
  k3.get = function() {
    return D3(null);
  };
  k3.set = function() {
    return D3();
  };
  k3.T = function() {
    return D3();
  };
  k3.ca = function() {
  };
  k3.ia = function() {
  };
  function Dk() {
    if (!Ek()) {
      if ("Node" == Fe2())
        throw new t("internal-error", "The SessionStorage compatibility library was not found.");
      throw new t("web-storage-unsupported");
    }
    this.a = Fk() || import_app8.default.INTERNAL.node.sessionStorage;
    this.type = "sessionStorage";
  }
  function Fk() {
    try {
      var a = l.sessionStorage, b2 = Le2();
      a && (a.setItem(b2, "1"), a.removeItem(b2));
      return a;
    } catch (c) {
      return null;
    }
  }
  function Ek() {
    var a = "Node" == Fe2();
    a = Fk() || a && import_app8.default.INTERNAL.node && import_app8.default.INTERNAL.node.sessionStorage;
    if (!a)
      return false;
    try {
      return a.setItem("__sak", "1"), a.removeItem("__sak"), true;
    } catch (b2) {
      return false;
    }
  }
  k3 = Dk.prototype;
  k3.get = function(a) {
    var b2 = this;
    return D3().then(function() {
      var c = b2.a.getItem(a);
      return Re2(c);
    });
  };
  k3.set = function(a, b2) {
    var c = this;
    return D3().then(function() {
      var d = Pe2(b2);
      null === d ? c.T(a) : c.a.setItem(a, d);
    });
  };
  k3.T = function(a) {
    var b2 = this;
    return D3().then(function() {
      b2.a.removeItem(a);
    });
  };
  k3.ca = function() {
  };
  k3.ia = function() {
  };
  function Gk() {
    var a = {};
    a.Browser = Hk;
    a.Node = Ik;
    a.ReactNative = Jk;
    a.Worker = Kk;
    this.a = a[Fe2()];
  }
  var Lk, Hk = { D: zk, ab: Dk }, Ik = { D: zk, ab: Dk }, Jk = { D: bk, ab: Ck }, Kk = { D: zk, ab: Ck };
  var Mk = { qd: "local", NONE: "none", sd: "session" };
  function Nk(a) {
    var b2 = new t("invalid-persistence-type"), c = new t("unsupported-persistence-type");
    a: {
      for (d in Mk)
        if (Mk[d] == a) {
          var d = true;
          break a;
        }
      d = false;
    }
    if (!d || "string" !== typeof a)
      throw b2;
    switch (Fe2()) {
      case "ReactNative":
        if ("session" === a)
          throw c;
        break;
      case "Node":
        if ("none" !== a)
          throw c;
        break;
      case "Worker":
        if ("session" === a || !lk() && "none" !== a)
          throw c;
        break;
      default:
        if (!Ke2() && "none" !== a)
          throw c;
    }
  }
  function Ok() {
    var a = !Se2(K3()) && De2() ? true : false, b2 = Oe2(), c = Ke2();
    this.v = a;
    this.h = b2;
    this.l = c;
    this.a = {};
    Lk || (Lk = new Gk());
    a = Lk;
    try {
      this.g = !le2() && Ze2() || !l.indexedDB ? new a.a.D() : new xk(Ee2() ? new yk() : new a.a.D());
    } catch (d) {
      this.g = new yk(), this.h = true;
    }
    try {
      this.i = new a.a.ab();
    } catch (d) {
      this.i = new yk();
    }
    this.m = new yk();
    this.f = q3(this.Xb, this);
    this.b = {};
  }
  var Pk;
  function Qk() {
    Pk || (Pk = new Ok());
    return Pk;
  }
  function Rk(a, b2) {
    switch (b2) {
      case "session":
        return a.i;
      case "none":
        return a.m;
      default:
        return a.g;
    }
  }
  function Sk(a, b2) {
    return "firebase:" + a.name + (b2 ? ":" + b2 : "");
  }
  function Tk(a, b2, c) {
    var d = Sk(b2, c), e = Rk(a, b2.D);
    return a.get(b2, c).then(function(f) {
      var g2 = null;
      try {
        g2 = Re2(l.localStorage.getItem(d));
      } catch (h) {
      }
      if (g2 && !f)
        return l.localStorage.removeItem(d), a.set(b2, g2, c);
      g2 && f && "localStorage" != e.type && l.localStorage.removeItem(d);
    });
  }
  k3 = Ok.prototype;
  k3.get = function(a, b2) {
    return Rk(this, a.D).get(Sk(a, b2));
  };
  function Uk(a, b2, c) {
    c = Sk(b2, c);
    "local" == b2.D && (a.b[c] = null);
    return Rk(a, b2.D).T(c);
  }
  k3.set = function(a, b2, c) {
    var d = Sk(a, c), e = this, f = Rk(this, a.D);
    return f.set(d, b2).then(function() {
      return f.get(d);
    }).then(function(g2) {
      "local" == a.D && (e.b[d] = g2);
    });
  };
  k3.addListener = function(a, b2, c) {
    a = Sk(a, b2);
    this.l && (this.b[a] = l.localStorage.getItem(a));
    kb2(this.a) && (Rk(this, "local").ca(this.f), this.h || (le2() || !Ze2()) && l.indexedDB || !this.l || Vk(this));
    this.a[a] || (this.a[a] = []);
    this.a[a].push(c);
  };
  k3.removeListener = function(a, b2, c) {
    a = Sk(a, b2);
    this.a[a] && (Va2(this.a[a], function(d) {
      return d == c;
    }), 0 == this.a[a].length && delete this.a[a]);
    kb2(this.a) && (Rk(this, "local").ia(this.f), Wk(this));
  };
  function Vk(a) {
    Wk(a);
    a.c = setInterval(function() {
      for (var b2 in a.a) {
        var c = l.localStorage.getItem(b2), d = a.b[b2];
        c != d && (a.b[b2] = c, c = new Yc2({ type: "storage", key: b2, target: window, oldValue: d, newValue: c, a: true }), a.Xb(c));
      }
    }, 1e3);
  }
  function Wk(a) {
    a.c && (clearInterval(a.c), a.c = null);
  }
  k3.Xb = function(a) {
    if (a && a.g) {
      var b2 = a.a.key;
      if (null == b2)
        for (var c in this.a) {
          var d = this.b[c];
          "undefined" === typeof d && (d = null);
          var e = l.localStorage.getItem(c);
          e !== d && (this.b[c] = e, this.lb(c));
        }
      else if (0 == b2.indexOf("firebase:") && this.a[b2]) {
        "undefined" !== typeof a.a.a ? Rk(this, "local").ia(this.f) : Wk(this);
        if (this.v) {
          if (c = l.localStorage.getItem(b2), d = a.a.newValue, d !== c)
            null !== d ? l.localStorage.setItem(b2, d) : l.localStorage.removeItem(b2);
          else if (this.b[b2] === d && "undefined" === typeof a.a.a)
            return;
        }
        var f = this;
        c = function() {
          if ("undefined" !== typeof a.a.a || f.b[b2] !== l.localStorage.getItem(b2))
            f.b[b2] = l.localStorage.getItem(b2), f.lb(b2);
        };
        Tb2 && dc2 && 10 == dc2 && l.localStorage.getItem(b2) !== a.a.newValue && a.a.newValue !== a.a.oldValue ? setTimeout(c, 10) : c();
      }
    } else
      w2(a, q3(this.lb, this));
  };
  k3.lb = function(a) {
    this.a[a] && w2(this.a[a], function(b2) {
      b2();
    });
  };
  function Xk(a) {
    this.a = a;
    this.b = Qk();
  }
  var Yk = { name: "authEvent", D: "local" };
  function Zk(a) {
    return a.b.get(Yk, a.a).then(function(b2) {
      return ph(b2);
    });
  }
  ;
  function $k() {
    this.a = Qk();
  }
  ;
  function al() {
    this.b = -1;
  }
  ;
  function bl(a, b2) {
    this.b = cl;
    this.f = l.Uint8Array ? new Uint8Array(this.b) : Array(this.b);
    this.g = this.c = 0;
    this.a = [];
    this.i = a;
    this.h = b2;
    this.l = l.Int32Array ? new Int32Array(64) : Array(64);
    void 0 === dl && (l.Int32Array ? dl = new Int32Array(el) : dl = el);
    this.reset();
  }
  var dl;
  r2(bl, al);
  for (var cl = 64, fl = cl - 1, gl = [], hl = 0; hl < fl; hl++)
    gl[hl] = 0;
  var il = Wa2(128, gl);
  bl.prototype.reset = function() {
    this.g = this.c = 0;
    this.a = l.Int32Array ? new Int32Array(this.h) : Xa2(this.h);
  };
  function jl(a) {
    for (var b2 = a.f, c = a.l, d = 0, e = 0; e < b2.length; )
      c[d++] = b2[e] << 24 | b2[e + 1] << 16 | b2[e + 2] << 8 | b2[e + 3], e = 4 * d;
    for (b2 = 16; 64 > b2; b2++) {
      e = c[b2 - 15] | 0;
      d = c[b2 - 2] | 0;
      var f = (c[b2 - 16] | 0) + ((e >>> 7 | e << 25) ^ (e >>> 18 | e << 14) ^ e >>> 3) | 0, g2 = (c[b2 - 7] | 0) + ((d >>> 17 | d << 15) ^ (d >>> 19 | d << 13) ^ d >>> 10) | 0;
      c[b2] = f + g2 | 0;
    }
    d = a.a[0] | 0;
    e = a.a[1] | 0;
    var h = a.a[2] | 0, m = a.a[3] | 0, p2 = a.a[4] | 0, v2 = a.a[5] | 0, B2 = a.a[6] | 0;
    f = a.a[7] | 0;
    for (b2 = 0; 64 > b2; b2++) {
      var A3 = ((d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10)) + (d & e ^ d & h ^ e & h) | 0;
      g2 = p2 & v2 ^ ~p2 & B2;
      f = f + ((p2 >>> 6 | p2 << 26) ^ (p2 >>> 11 | p2 << 21) ^ (p2 >>> 25 | p2 << 7)) | 0;
      g2 = g2 + (dl[b2] | 0) | 0;
      g2 = f + (g2 + (c[b2] | 0) | 0) | 0;
      f = B2;
      B2 = v2;
      v2 = p2;
      p2 = m + g2 | 0;
      m = h;
      h = e;
      e = d;
      d = g2 + A3 | 0;
    }
    a.a[0] = a.a[0] + d | 0;
    a.a[1] = a.a[1] + e | 0;
    a.a[2] = a.a[2] + h | 0;
    a.a[3] = a.a[3] + m | 0;
    a.a[4] = a.a[4] + p2 | 0;
    a.a[5] = a.a[5] + v2 | 0;
    a.a[6] = a.a[6] + B2 | 0;
    a.a[7] = a.a[7] + f | 0;
  }
  function kl(a, b2, c) {
    void 0 === c && (c = b2.length);
    var d = 0, e = a.c;
    if ("string" === typeof b2)
      for (; d < c; )
        a.f[e++] = b2.charCodeAt(d++), e == a.b && (jl(a), e = 0);
    else if (ma2(b2))
      for (; d < c; ) {
        var f = b2[d++];
        if (!("number" == typeof f && 0 <= f && 255 >= f && f == (f | 0)))
          throw Error("message must be a byte array");
        a.f[e++] = f;
        e == a.b && (jl(a), e = 0);
      }
    else
      throw Error("message must be string or array");
    a.c = e;
    a.g += c;
  }
  var el = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  function ll() {
    bl.call(this, 8, ml);
  }
  r2(ll, bl);
  var ml = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225];
  function nl(a, b2, c, d, e, f) {
    this.m = a;
    this.i = b2;
    this.l = c;
    this.v = d || null;
    this.u = e || null;
    this.o = f;
    this.h = b2 + ":" + c;
    this.A = new $k();
    this.g = new Xk(this.h);
    this.f = null;
    this.b = [];
    this.a = this.c = null;
  }
  function ol(a) {
    return new t("invalid-cordova-configuration", a);
  }
  k3 = nl.prototype;
  k3.la = function() {
    return this.Ia ? this.Ia : this.Ia = Ae2().then(function() {
      if ("function" !== typeof L3("universalLinks.subscribe", l))
        throw ol("cordova-universal-links-plugin-fix is not installed");
      if ("undefined" === typeof L3("BuildInfo.packageName", l))
        throw ol("cordova-plugin-buildinfo is not installed");
      if ("function" !== typeof L3("cordova.plugins.browsertab.openUrl", l))
        throw ol("cordova-plugin-browsertab is not installed");
      if ("function" !== typeof L3("cordova.InAppBrowser.open", l))
        throw ol("cordova-plugin-inappbrowser is not installed");
    }, function() {
      throw new t("cordova-not-ready");
    });
  };
  function pl() {
    for (var a = 20, b2 = []; 0 < a; )
      b2.push("1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".charAt(Math.floor(62 * Math.random()))), a--;
    return b2.join("");
  }
  function ql(a) {
    var b2 = new ll();
    kl(b2, a);
    a = [];
    var c = 8 * b2.g;
    56 > b2.c ? kl(b2, il, 56 - b2.c) : kl(b2, il, b2.b - (b2.c - 56));
    for (var d = 63; 56 <= d; d--)
      b2.f[d] = c & 255, c /= 256;
    jl(b2);
    for (d = c = 0; d < b2.i; d++)
      for (var e = 24; 0 <= e; e -= 8)
        a[c++] = b2.a[d] >> e & 255;
    return Zf(a);
  }
  k3.Nb = function(a, b2) {
    b2(new t("operation-not-supported-in-this-environment"));
    return D3();
  };
  k3.Lb = function() {
    return E3(new t("operation-not-supported-in-this-environment"));
  };
  k3.Zb = function() {
    return false;
  };
  k3.Wb = function() {
    return true;
  };
  k3.Sb = function() {
    return true;
  };
  k3.Mb = function(a, b2, c, d) {
    if (this.c)
      return E3(new t("redirect-operation-pending"));
    var e = this, f = l.document, g2 = null, h = null, m = null, p2 = null;
    return this.c = D3().then(function() {
      nh(b2);
      return rl(e);
    }).then(function() {
      return sl(e, a, b2, c, d);
    }).then(function() {
      return new C3(function(v2, B2) {
        h = function() {
          var A3 = L3("cordova.plugins.browsertab.close", l);
          v2();
          "function" === typeof A3 && A3();
          e.a && "function" === typeof e.a.close && (e.a.close(), e.a = null);
          return false;
        };
        e.Ea(h);
        m = function() {
          g2 || (g2 = Ad2(2e3).then(function() {
            B2(new t("redirect-cancelled-by-user"));
          }));
        };
        p2 = function() {
          Ve2() && m();
        };
        f.addEventListener("resume", m, false);
        K3().toLowerCase().match(/android/) || f.addEventListener("visibilitychange", p2, false);
      }).s(function(v2) {
        return tl(e).then(function() {
          throw v2;
        });
      });
    }).na(function() {
      m && f.removeEventListener("resume", m, false);
      p2 && f.removeEventListener("visibilitychange", p2, false);
      g2 && g2.cancel();
      h && e.Ra(h);
      e.c = null;
    });
  };
  function sl(a, b2, c, d, e) {
    var f = pl(), g2 = new oh(b2, d, null, f, new t("no-auth-event"), null, e), h = L3("BuildInfo.packageName", l);
    if ("string" !== typeof h)
      throw new t("invalid-cordova-configuration");
    var m = L3("BuildInfo.displayName", l), p2 = {};
    if (K3().toLowerCase().match(/iphone|ipad|ipod/))
      p2.ibi = h;
    else if (K3().toLowerCase().match(/android/))
      p2.apn = h;
    else
      return E3(new t("operation-not-supported-in-this-environment"));
    m && (p2.appDisplayName = m);
    f = ql(f);
    p2.sessionId = f;
    var v2 = ak(a.m, a.i, a.l, b2, c, null, d, a.v, p2, a.u, e, a.o);
    return a.la().then(function() {
      var B2 = a.h;
      return a.A.a.set(Yk, g2.w(), B2);
    }).then(function() {
      var B2 = L3("cordova.plugins.browsertab.isAvailable", l);
      if ("function" !== typeof B2)
        throw new t("invalid-cordova-configuration");
      var A3 = null;
      B2(function(Q3) {
        if (Q3) {
          A3 = L3("cordova.plugins.browsertab.openUrl", l);
          if ("function" !== typeof A3)
            throw new t("invalid-cordova-configuration");
          A3(v2);
        } else {
          A3 = L3("cordova.InAppBrowser.open", l);
          if ("function" !== typeof A3)
            throw new t("invalid-cordova-configuration");
          Q3 = K3();
          a.a = A3(v2, Q3.match(/(iPad|iPhone|iPod).*OS 7_\d/i) || Q3.match(/(iPad|iPhone|iPod).*OS 8_\d/i) ? "_blank" : "_system", "location=yes");
        }
      });
    });
  }
  function ul(a, b2) {
    for (var c = 0; c < a.b.length; c++)
      try {
        a.b[c](b2);
      } catch (d) {
      }
  }
  function rl(a) {
    a.f || (a.f = a.la().then(function() {
      return new C3(function(b2) {
        function c(d) {
          b2(d);
          a.Ra(c);
          return false;
        }
        a.Ea(c);
        vl(a);
      });
    }));
    return a.f;
  }
  function tl(a) {
    var b2 = null;
    return Zk(a.g).then(function(c) {
      b2 = c;
      c = a.g;
      return Uk(c.b, Yk, c.a);
    }).then(function() {
      return b2;
    });
  }
  function vl(a) {
    function b2(g2) {
      d = true;
      e && e.cancel();
      tl(a).then(function(h) {
        var m = c;
        if (h && g2 && g2.url) {
          var p2 = null;
          m = tg(g2.url);
          -1 != m.indexOf("/__/auth/callback") && (p2 = J3(m), p2 = Re2(Xd(p2, "firebaseError") || null), p2 = (p2 = "object" === typeof p2 ? ya2(p2) : null) ? new oh(h.c, h.b, null, null, p2, null, h.S()) : new oh(h.c, h.b, m, h.f, null, null, h.S()));
          m = p2 || c;
        }
        ul(a, m);
      });
    }
    var c = new oh("unknown", null, null, null, new t("no-auth-event")), d = false, e = Ad2(500).then(function() {
      return tl(a).then(function() {
        d || ul(a, c);
      });
    }), f = l.handleOpenURL;
    l.handleOpenURL = function(g2) {
      0 == g2.toLowerCase().indexOf(L3("BuildInfo.packageName", l).toLowerCase() + "://") && b2({ url: g2 });
      if ("function" === typeof f)
        try {
          f(g2);
        } catch (h) {
          console.error(h);
        }
    };
    rh || (rh = new qh());
    sh(b2);
  }
  k3.Ea = function(a) {
    this.b.push(a);
    rl(this).s(function(b2) {
      "auth/invalid-cordova-configuration" === b2.code && (b2 = new oh("unknown", null, null, null, new t("no-auth-event")), a(b2));
    });
  };
  k3.Ra = function(a) {
    Va2(this.b, function(b2) {
      return b2 == a;
    });
  };
  function wl(a) {
    this.a = a;
    this.b = Qk();
  }
  var xl = { name: "pendingRedirect", D: "session" };
  function yl(a) {
    return a.b.set(xl, "pending", a.a);
  }
  function zl(a) {
    return Uk(a.b, xl, a.a);
  }
  function Al(a) {
    return a.b.get(xl, a.a).then(function(b2) {
      return "pending" == b2;
    });
  }
  ;
  function Bl(a, b2, c, d) {
    this.i = {};
    this.u = 0;
    this.O = a;
    this.m = b2;
    this.v = c;
    this.G = d;
    this.h = [];
    this.f = false;
    this.l = q3(this.o, this);
    this.b = new Cl();
    this.A = new Dl();
    this.g = new wl(El(this.m, this.v));
    this.c = {};
    this.c.unknown = this.b;
    this.c.signInViaRedirect = this.b;
    this.c.linkViaRedirect = this.b;
    this.c.reauthViaRedirect = this.b;
    this.c.signInViaPopup = this.A;
    this.c.linkViaPopup = this.A;
    this.c.reauthViaPopup = this.A;
    this.a = Fl(this.O, this.m, this.v, Ba2, this.G);
  }
  function Fl(a, b2, c, d, e) {
    var f = import_app8.default.SDK_VERSION || null;
    return Be2() ? new nl(a, b2, c, f, d, e) : new Uj(a, b2, c, f, d, e);
  }
  Bl.prototype.reset = function() {
    this.f = false;
    this.a.Ra(this.l);
    this.a = Fl(this.O, this.m, this.v, null, this.G);
    this.i = {};
  };
  function Gl(a) {
    a.f || (a.f = true, a.a.Ea(a.l));
    var b2 = a.a;
    return a.a.la().s(function(c) {
      a.a == b2 && a.reset();
      throw c;
    });
  }
  function Hl(a) {
    a.a.Wb() && Gl(a).s(function(b2) {
      var c = new oh("unknown", null, null, null, new t("operation-not-supported-in-this-environment"));
      Il(b2) && a.o(c);
    });
    a.a.Sb() || Jl(a.b);
  }
  function Kl(a, b2) {
    Ta2(a.h, b2) || a.h.push(b2);
    a.f || Al(a.g).then(function(c) {
      c ? zl(a.g).then(function() {
        Gl(a).s(function(d) {
          var e = new oh("unknown", null, null, null, new t("operation-not-supported-in-this-environment"));
          Il(d) && a.o(e);
        });
      }) : Hl(a);
    }).s(function() {
      Hl(a);
    });
  }
  function Ll(a, b2) {
    Va2(a.h, function(c) {
      return c == b2;
    });
  }
  Bl.prototype.o = function(a) {
    if (!a)
      throw new t("invalid-auth-event");
    6e5 <= ua3() - this.u && (this.i = {}, this.u = 0);
    if (a && a.getUid() && this.i.hasOwnProperty(a.getUid()))
      return false;
    for (var b2 = false, c = 0; c < this.h.length; c++) {
      var d = this.h[c];
      if (d.Eb(a.c, a.b)) {
        if (b2 = this.c[a.c])
          b2.h(a, d), a && (a.f || a.b) && (this.i[a.getUid()] = true, this.u = ua3());
        b2 = true;
        break;
      }
    }
    Jl(this.b);
    return b2;
  };
  var Ml = new Ue2(2e3, 1e4), Nl = new Ue2(3e4, 6e4);
  Bl.prototype.qa = function() {
    return this.b.qa();
  };
  function Ol(a, b2, c, d, e, f, g2) {
    return a.a.Lb(b2, c, d, function() {
      a.f || (a.f = true, a.a.Ea(a.l));
    }, function() {
      a.reset();
    }, e, f, g2);
  }
  function Il(a) {
    return a && "auth/cordova-not-ready" == a.code ? true : false;
  }
  function Pl(a, b2, c, d, e) {
    var f;
    return yl(a.g).then(function() {
      return a.a.Mb(b2, c, d, e).s(function(g2) {
        if (Il(g2))
          throw new t("operation-not-supported-in-this-environment");
        f = g2;
        return zl(a.g).then(function() {
          throw f;
        });
      }).then(function() {
        return a.a.Zb() ? new C3(function() {
        }) : zl(a.g).then(function() {
          return a.qa();
        }).then(function() {
        }).s(function() {
        });
      });
    });
  }
  function Ql(a, b2, c, d, e) {
    return a.a.Nb(d, function(f) {
      b2.ma(c, null, f, e);
    }, Ml.get());
  }
  var Rl = {};
  function El(a, b2, c) {
    a = a + ":" + b2;
    c && (a = a + ":" + c.url);
    return a;
  }
  function Sl(a, b2, c, d) {
    var e = El(b2, c, d);
    Rl[e] || (Rl[e] = new Bl(a, b2, c, d));
    return Rl[e];
  }
  function Cl() {
    this.b = null;
    this.f = [];
    this.c = [];
    this.a = null;
    this.i = this.g = false;
  }
  Cl.prototype.reset = function() {
    this.b = null;
    this.a && (this.a.cancel(), this.a = null);
  };
  Cl.prototype.h = function(a, b2) {
    if (a) {
      this.reset();
      this.g = true;
      var c = a.c, d = a.b, e = a.a && "auth/web-storage-unsupported" == a.a.code, f = a.a && "auth/operation-not-supported-in-this-environment" == a.a.code;
      this.i = !(!e && !f);
      "unknown" != c || e || f ? a.a ? (Tl(this, true, null, a.a), D3()) : b2.Fa(c, d) ? Ul(this, a, b2) : E3(new t("invalid-auth-event")) : (Tl(this, false, null, null), D3());
    } else
      E3(new t("invalid-auth-event"));
  };
  function Jl(a) {
    a.g || (a.g = true, Tl(a, false, null, null));
  }
  function Vl(a) {
    a.g && !a.i && Tl(a, false, null, null);
  }
  function Ul(a, b2, c) {
    c = c.Fa(b2.c, b2.b);
    var d = b2.g, e = b2.f, f = b2.i, g2 = b2.S(), h = !!b2.c.match(/Redirect$/);
    c(d, e, g2, f).then(function(m) {
      Tl(a, h, m, null);
    }).s(function(m) {
      Tl(a, h, null, m);
    });
  }
  function Wl(a, b2) {
    a.b = function() {
      return E3(b2);
    };
    if (a.c.length)
      for (var c = 0; c < a.c.length; c++)
        a.c[c](b2);
  }
  function Xl(a, b2) {
    a.b = function() {
      return D3(b2);
    };
    if (a.f.length)
      for (var c = 0; c < a.f.length; c++)
        a.f[c](b2);
  }
  function Tl(a, b2, c, d) {
    b2 ? d ? Wl(a, d) : Xl(a, c) : Xl(a, { user: null });
    a.f = [];
    a.c = [];
  }
  Cl.prototype.qa = function() {
    var a = this;
    return new C3(function(b2, c) {
      a.b ? a.b().then(b2, c) : (a.f.push(b2), a.c.push(c), Yl(a));
    });
  };
  function Yl(a) {
    var b2 = new t("timeout");
    a.a && a.a.cancel();
    a.a = Ad2(Nl.get()).then(function() {
      a.b || (a.g = true, Tl(a, true, null, b2));
    });
  }
  function Dl() {
  }
  Dl.prototype.h = function(a, b2) {
    if (a) {
      var c = a.c, d = a.b;
      a.a ? (b2.ma(a.c, null, a.a, a.b), D3()) : b2.Fa(c, d) ? Zl(a, b2) : E3(new t("invalid-auth-event"));
    } else
      E3(new t("invalid-auth-event"));
  };
  function Zl(a, b2) {
    var c = a.b, d = a.c;
    b2.Fa(d, c)(a.g, a.f, a.S(), a.i).then(function(e) {
      b2.ma(d, e, null, c);
    }).s(function(e) {
      b2.ma(d, null, e, c);
    });
  }
  ;
  function $l() {
    this.hb = false;
    Object.defineProperty(this, "appVerificationDisabled", { get: function() {
      return this.hb;
    }, set: function(a) {
      this.hb = a;
    }, enumerable: false });
  }
  ;
  function am(a, b2) {
    this.a = b2;
    M3(this, "verificationId", a);
  }
  am.prototype.confirm = function(a) {
    a = lh(this.verificationId, a);
    return this.a(a);
  };
  function bm(a, b2, c, d) {
    return new hh(a).eb(b2, c).then(function(e) {
      return new am(e, d);
    });
  }
  ;
  function cm(a) {
    var b2 = eg(a);
    if (!(b2 && b2.exp && b2.auth_time && b2.iat))
      throw new t("internal-error", "An internal error occurred. The token obtained by Firebase appears to be malformed. Please retry the operation.");
    N3(this, { token: a, expirationTime: Ye2(1e3 * b2.exp), authTime: Ye2(1e3 * b2.auth_time), issuedAtTime: Ye2(1e3 * b2.iat), signInProvider: b2.firebase && b2.firebase.sign_in_provider ? b2.firebase.sign_in_provider : null, signInSecondFactor: b2.firebase && b2.firebase.sign_in_second_factor ? b2.firebase.sign_in_second_factor : null, claims: b2 });
  }
  ;
  function dm(a, b2, c) {
    var d = b2 && b2[em];
    if (!d)
      throw new t("argument-error", "Internal assert: Invalid MultiFactorResolver");
    this.a = a;
    this.f = lb2(b2);
    this.g = c;
    this.c = new ug(null, d);
    this.b = [];
    var e = this;
    w2(b2[fm] || [], function(f) {
      (f = pf(f)) && e.b.push(f);
    });
    M3(this, "auth", this.a);
    M3(this, "session", this.c);
    M3(this, "hints", this.b);
  }
  var fm = "mfaInfo", em = "mfaPendingCredential";
  dm.prototype.Qc = function(a) {
    var b2 = this;
    return a.rb(this.a.a, this.c).then(function(c) {
      var d = lb2(b2.f);
      delete d[fm];
      delete d[em];
      z2(d, c);
      return b2.g(d);
    });
  };
  function gm(a, b2, c, d) {
    t.call(this, "multi-factor-auth-required", d, b2);
    this.b = new dm(a, b2, c);
    M3(this, "resolver", this.b);
  }
  r2(gm, t);
  function hm(a, b2, c) {
    if (a && n2(a.serverResponse) && "auth/multi-factor-auth-required" === a.code)
      try {
        return new gm(b2, a.serverResponse, c, a.message);
      } catch (d) {
      }
    return null;
  }
  ;
  function im() {
  }
  im.prototype.rb = function(a, b2, c) {
    return b2.type == vg ? jm(this, a, b2, c) : km(this, a, b2);
  };
  function jm(a, b2, c, d) {
    return c.Ha().then(function(e) {
      e = { idToken: e };
      "undefined" !== typeof d && (e.displayName = d);
      z2(e, { phoneVerificationInfo: dh(a.a) });
      return O3(b2, Cj, e);
    });
  }
  function km(a, b2, c) {
    return c.Ha().then(function(d) {
      d = { mfaPendingCredential: d };
      z2(d, { phoneVerificationInfo: dh(a.a) });
      return O3(b2, Dj, d);
    });
  }
  function lm(a) {
    M3(this, "factorId", a.fa);
    this.a = a;
  }
  r2(lm, im);
  function mm(a) {
    lm.call(this, a);
    if (this.a.fa != hh.PROVIDER_ID)
      throw new t("argument-error", "firebase.auth.PhoneMultiFactorAssertion requires a valid firebase.auth.PhoneAuthCredential");
  }
  r2(mm, lm);
  function nm(a, b2) {
    F3.call(this, a);
    for (var c in b2)
      this[c] = b2[c];
  }
  r2(nm, F3);
  function om(a, b2) {
    this.a = a;
    this.b = [];
    this.c = q3(this.xc, this);
    jd2(this.a, "userReloaded", this.c);
    var c = [];
    b2 && b2.multiFactor && b2.multiFactor.enrolledFactors && w2(b2.multiFactor.enrolledFactors, function(d) {
      var e = null, f = {};
      if (d) {
        d.uid && (f[mf] = d.uid);
        d.displayName && (f[nf] = d.displayName);
        d.enrollmentTime && (f[of3] = new Date(d.enrollmentTime).toISOString());
        d.phoneNumber && (f[lf] = d.phoneNumber);
        try {
          e = new qf(f);
        } catch (g2) {
        }
        d = e;
      } else
        d = null;
      d && c.push(d);
    });
    pm(this, c);
  }
  function qm(a) {
    var b2 = [];
    w2(a.mfaInfo || [], function(c) {
      (c = pf(c)) && b2.push(c);
    });
    return b2;
  }
  k3 = om.prototype;
  k3.xc = function(a) {
    pm(this, qm(a.gd));
  };
  function pm(a, b2) {
    a.b = b2;
    M3(a, "enrolledFactors", b2);
  }
  k3.Qb = function() {
    return this.a.I().then(function(a) {
      return new ug(a, null);
    });
  };
  k3.ec = function(a, b2) {
    var c = this, d = this.a.a;
    return this.Qb().then(function(e) {
      return a.rb(d, e, b2);
    }).then(function(e) {
      rm(c.a, e);
      return c.a.reload();
    });
  };
  k3.ad = function(a) {
    var b2 = this, c = "string" === typeof a ? a : a.uid, d = this.a.a;
    return this.a.I().then(function(e) {
      return O3(d, Hj, { idToken: e, mfaEnrollmentId: c });
    }).then(function(e) {
      var f = Oa2(b2.b, function(g2) {
        return g2.uid != c;
      });
      pm(b2, f);
      rm(b2.a, e);
      return b2.a.reload().s(function(g2) {
        if ("auth/user-token-expired" != g2.code)
          throw g2;
      });
    });
  };
  k3.w = function() {
    return { multiFactor: { enrolledFactors: Pa(this.b, function(a) {
      return a.w();
    }) } };
  };
  function sm(a, b2, c) {
    this.h = a;
    this.i = b2;
    this.g = c;
    this.c = 3e4;
    this.f = 96e4;
    this.b = null;
    this.a = this.c;
    if (this.f < this.c)
      throw Error("Proactive refresh lower bound greater than upper bound!");
  }
  sm.prototype.start = function() {
    this.a = this.c;
    tm(this, true);
  };
  function um(a, b2) {
    if (b2)
      return a.a = a.c, a.g();
    b2 = a.a;
    a.a *= 2;
    a.a > a.f && (a.a = a.f);
    return b2;
  }
  function tm(a, b2) {
    a.stop();
    a.b = Ad2(um(a, b2)).then(function() {
      return We2();
    }).then(function() {
      return a.h();
    }).then(function() {
      tm(a, true);
    }).s(function(c) {
      a.i(c) && tm(a, false);
    });
  }
  sm.prototype.stop = function() {
    this.b && (this.b.cancel(), this.b = null);
  };
  function vm(a) {
    this.c = a;
    this.b = this.a = null;
  }
  vm.prototype.w = function() {
    return { apiKey: this.c.c, refreshToken: this.a, accessToken: this.b && this.b.toString(), expirationTime: wm(this) };
  };
  function wm(a) {
    return a.b && 1e3 * a.b.c || 0;
  }
  function xm(a, b2) {
    var c = b2.refreshToken;
    a.b = fg(b2[zg] || "");
    a.a = c;
  }
  function ym(a, b2) {
    a.b = b2.b;
    a.a = b2.a;
  }
  function zm(a, b2) {
    return Si2(a.c, b2).then(function(c) {
      a.b = fg(c.access_token);
      a.a = c.refresh_token;
      return { accessToken: a.b.toString(), refreshToken: a.a };
    }).s(function(c) {
      "auth/user-token-expired" == c.code && (a.a = null);
      throw c;
    });
  }
  vm.prototype.getToken = function(a) {
    a = !!a;
    return this.b && !this.a ? E3(new t("user-token-expired")) : a || !this.b || ua3() > wm(this) - 3e4 ? this.a ? zm(this, { grant_type: "refresh_token", refresh_token: this.a }) : D3(null) : D3({ accessToken: this.b.toString(), refreshToken: this.a });
  };
  function Am(a, b2) {
    this.a = a || null;
    this.b = b2 || null;
    N3(this, { lastSignInTime: Ye2(b2 || null), creationTime: Ye2(a || null) });
  }
  function Bm(a) {
    return new Am(a.a, a.b);
  }
  Am.prototype.w = function() {
    return { lastLoginAt: this.b, createdAt: this.a };
  };
  function Cm(a, b2, c, d, e, f) {
    N3(this, { uid: a, displayName: d || null, photoURL: e || null, email: c || null, phoneNumber: f || null, providerId: b2 });
  }
  function Dm(a, b2, c) {
    this.G = [];
    this.l = a.apiKey;
    this.m = a.appName;
    this.o = a.authDomain || null;
    var d = import_app8.default.SDK_VERSION ? Je2(import_app8.default.SDK_VERSION) : null;
    this.a = new Ei2(this.l, Aa3(Ba2), d);
    a.emulatorConfig && Li2(this.a, a.emulatorConfig);
    this.b = new vm(this.a);
    Em(this, b2[zg]);
    xm(this.b, b2);
    M3(this, "refreshToken", this.b.a);
    Fm(this, c || {});
    H3.call(this);
    this.P = false;
    this.o && Me2() && (this.i = Sl(this.o, this.l, this.m));
    this.R = [];
    this.f = null;
    this.u = Gm(this);
    this.$ = q3(this.gb, this);
    var e = this;
    this.pa = null;
    this.Ba = function(f) {
      e.wa(f.h);
    };
    this.ba = null;
    this.za = function(f) {
      Li2(e.a, f.c);
    };
    this.W = null;
    this.X = [];
    this.Aa = function(f) {
      Hm(e, f.f);
    };
    this.aa = null;
    this.N = new om(this, c);
    M3(this, "multiFactor", this.N);
  }
  r2(Dm, H3);
  Dm.prototype.wa = function(a) {
    this.pa = a;
    Ki2(this.a, a);
  };
  Dm.prototype.ka = function() {
    return this.pa;
  };
  function Im(a, b2) {
    a.ba && G3(a.ba, "languageCodeChanged", a.Ba);
    (a.ba = b2) && jd2(b2, "languageCodeChanged", a.Ba);
  }
  function Jm(a, b2) {
    a.W && G3(a.W, "emulatorConfigChanged", a.za);
    (a.W = b2) && jd2(b2, "emulatorConfigChanged", a.za);
  }
  function Hm(a, b2) {
    a.X = b2;
    Ni2(a.a, import_app8.default.SDK_VERSION ? Je2(import_app8.default.SDK_VERSION, a.X) : null);
  }
  Dm.prototype.Ga = function() {
    return Xa2(this.X);
  };
  function Km(a, b2) {
    a.aa && G3(a.aa, "frameworkChanged", a.Aa);
    (a.aa = b2) && jd2(b2, "frameworkChanged", a.Aa);
  }
  Dm.prototype.gb = function() {
    this.u.b && (this.u.stop(), this.u.start());
  };
  function Lm(a) {
    try {
      return import_app8.default.app(a.m).auth();
    } catch (b2) {
      throw new t("internal-error", "No firebase.auth.Auth instance is available for the Firebase App '" + a.m + "'!");
    }
  }
  function Gm(a) {
    return new sm(function() {
      return a.I(true);
    }, function(b2) {
      return b2 && "auth/network-request-failed" == b2.code ? true : false;
    }, function() {
      var b2 = wm(a.b) - ua3() - 3e5;
      return 0 < b2 ? b2 : 0;
    });
  }
  function Mm(a) {
    a.A || a.u.b || (a.u.start(), G3(a, "tokenChanged", a.$), jd2(a, "tokenChanged", a.$));
  }
  function Nm(a) {
    G3(a, "tokenChanged", a.$);
    a.u.stop();
  }
  function Em(a, b2) {
    a.ya = b2;
    M3(a, "_lat", b2);
  }
  function Om(a, b2) {
    Va2(a.R, function(c) {
      return c == b2;
    });
  }
  function Pm(a) {
    for (var b2 = [], c = 0; c < a.R.length; c++)
      b2.push(a.R[c](a));
    return Fc2(b2).then(function() {
      return a;
    });
  }
  function Qm(a) {
    a.i && !a.P && (a.P = true, Kl(a.i, a));
  }
  function Fm(a, b2) {
    N3(a, { uid: b2.uid, displayName: b2.displayName || null, photoURL: b2.photoURL || null, email: b2.email || null, emailVerified: b2.emailVerified || false, phoneNumber: b2.phoneNumber || null, isAnonymous: b2.isAnonymous || false, tenantId: b2.tenantId || null, metadata: new Am(b2.createdAt, b2.lastLoginAt), providerData: [] });
    a.a.b = a.tenantId;
  }
  M3(Dm.prototype, "providerId", "firebase");
  function Rm() {
  }
  function Sm(a) {
    return D3().then(function() {
      if (a.A)
        throw new t("app-deleted");
    });
  }
  function Tm(a) {
    return Pa(a.providerData, function(b2) {
      return b2.providerId;
    });
  }
  function Um(a, b2) {
    b2 && (Vm(a, b2.providerId), a.providerData.push(b2));
  }
  function Vm(a, b2) {
    Va2(a.providerData, function(c) {
      return c.providerId == b2;
    });
  }
  function Wm(a, b2, c) {
    ("uid" != b2 || c) && a.hasOwnProperty(b2) && M3(a, b2, c);
  }
  function Xm(a, b2) {
    a != b2 && (N3(a, { uid: b2.uid, displayName: b2.displayName, photoURL: b2.photoURL, email: b2.email, emailVerified: b2.emailVerified, phoneNumber: b2.phoneNumber, isAnonymous: b2.isAnonymous, tenantId: b2.tenantId, providerData: [] }), b2.metadata ? M3(a, "metadata", Bm(b2.metadata)) : M3(a, "metadata", new Am()), w2(b2.providerData, function(c) {
      Um(a, c);
    }), ym(a.b, b2.b), M3(a, "refreshToken", a.b.a), pm(a.N, b2.N.b));
  }
  k3 = Dm.prototype;
  k3.reload = function() {
    var a = this;
    return R3(this, Sm(this).then(function() {
      return Ym(a).then(function() {
        return Pm(a);
      }).then(Rm);
    }));
  };
  function Ym(a) {
    return a.I().then(function(b2) {
      var c = a.isAnonymous;
      return Zm(a, b2).then(function() {
        c || Wm(a, "isAnonymous", false);
        return b2;
      });
    });
  }
  k3.nc = function(a) {
    return this.I(a).then(function(b2) {
      return new cm(b2);
    });
  };
  k3.I = function(a) {
    var b2 = this;
    return R3(this, Sm(this).then(function() {
      return b2.b.getToken(a);
    }).then(function(c) {
      if (!c)
        throw new t("internal-error");
      c.accessToken != b2.ya && (Em(b2, c.accessToken), b2.dispatchEvent(new nm("tokenChanged")));
      Wm(b2, "refreshToken", c.refreshToken);
      return c.accessToken;
    }));
  };
  function rm(a, b2) {
    b2[zg] && a.ya != b2[zg] && (xm(a.b, b2), a.dispatchEvent(new nm("tokenChanged")), Em(a, b2[zg]), Wm(a, "refreshToken", a.b.a));
  }
  function Zm(a, b2) {
    return O3(a.a, Ej, { idToken: b2 }).then(q3(a.Jc, a));
  }
  k3.Jc = function(a) {
    a = a.users;
    if (!a || !a.length)
      throw new t("internal-error");
    a = a[0];
    Fm(this, { uid: a.localId, displayName: a.displayName, photoURL: a.photoUrl, email: a.email, emailVerified: !!a.emailVerified, phoneNumber: a.phoneNumber, lastLoginAt: a.lastLoginAt, createdAt: a.createdAt, tenantId: a.tenantId });
    for (var b2 = $m(a), c = 0; c < b2.length; c++)
      Um(this, b2[c]);
    Wm(this, "isAnonymous", !(this.email && a.passwordHash) && !(this.providerData && this.providerData.length));
    this.dispatchEvent(new nm("userReloaded", { gd: a }));
  };
  function $m(a) {
    return (a = a.providerUserInfo) && a.length ? Pa(a, function(b2) {
      return new Cm(b2.rawId, b2.providerId, b2.email, b2.displayName, b2.photoUrl, b2.phoneNumber);
    }) : [];
  }
  k3.Kc = function(a) {
    cf("firebase.User.prototype.reauthenticateAndRetrieveDataWithCredential is deprecated. Please use firebase.User.prototype.reauthenticateWithCredential instead.");
    return this.sb(a);
  };
  k3.sb = function(a) {
    var b2 = this, c = null;
    return R3(this, a.c(this.a, this.uid).then(function(d) {
      rm(b2, d);
      c = an2(b2, d, "reauthenticate");
      b2.f = null;
      return b2.reload();
    }).then(function() {
      return c;
    }), true);
  };
  function bn2(a, b2) {
    return Ym(a).then(function() {
      if (Ta2(Tm(a), b2))
        return Pm(a).then(function() {
          throw new t("provider-already-linked");
        });
    });
  }
  k3.Bc = function(a) {
    cf("firebase.User.prototype.linkAndRetrieveDataWithCredential is deprecated. Please use firebase.User.prototype.linkWithCredential instead.");
    return this.pb(a);
  };
  k3.pb = function(a) {
    var b2 = this, c = null;
    return R3(this, bn2(this, a.providerId).then(function() {
      return b2.I();
    }).then(function(d) {
      return a.b(b2.a, d);
    }).then(function(d) {
      c = an2(b2, d, "link");
      return cn2(b2, d);
    }).then(function() {
      return c;
    }));
  };
  k3.Cc = function(a, b2) {
    var c = this;
    return R3(this, bn2(this, "phone").then(function() {
      return bm(Lm(c), a, b2, q3(c.pb, c));
    }));
  };
  k3.Lc = function(a, b2) {
    var c = this;
    return R3(this, D3().then(function() {
      return bm(Lm(c), a, b2, q3(c.sb, c));
    }), true);
  };
  function an2(a, b2, c) {
    var d = mh(b2);
    b2 = kg(b2);
    return ff({ user: a, credential: d, additionalUserInfo: b2, operationType: c });
  }
  function cn2(a, b2) {
    rm(a, b2);
    return a.reload().then(function() {
      return a;
    });
  }
  k3.Ab = function(a) {
    var b2 = this;
    return R3(this, this.I().then(function(c) {
      return b2.a.Ab(c, a);
    }).then(function(c) {
      rm(b2, c);
      return b2.reload();
    }));
  };
  k3.dd = function(a) {
    var b2 = this;
    return R3(this, this.I().then(function(c) {
      return a.b(b2.a, c);
    }).then(function(c) {
      rm(b2, c);
      return b2.reload();
    }));
  };
  k3.Bb = function(a) {
    var b2 = this;
    return R3(this, this.I().then(function(c) {
      return b2.a.Bb(c, a);
    }).then(function(c) {
      rm(b2, c);
      return b2.reload();
    }));
  };
  k3.Cb = function(a) {
    if (void 0 === a.displayName && void 0 === a.photoURL)
      return Sm(this);
    var b2 = this;
    return R3(this, this.I().then(function(c) {
      return b2.a.Cb(c, { displayName: a.displayName, photoUrl: a.photoURL });
    }).then(function(c) {
      rm(b2, c);
      Wm(b2, "displayName", c.displayName || null);
      Wm(b2, "photoURL", c.photoUrl || null);
      w2(b2.providerData, function(d) {
        "password" === d.providerId && (M3(d, "displayName", b2.displayName), M3(d, "photoURL", b2.photoURL));
      });
      return Pm(b2);
    }).then(Rm));
  };
  k3.bd = function(a) {
    var b2 = this;
    return R3(this, Ym(this).then(function(c) {
      return Ta2(Tm(b2), a) ? nj(b2.a, c, [a]).then(function(d) {
        var e = {};
        w2(d.providerUserInfo || [], function(f) {
          e[f.providerId] = true;
        });
        w2(Tm(b2), function(f) {
          e[f] || Vm(b2, f);
        });
        e[hh.PROVIDER_ID] || M3(b2, "phoneNumber", null);
        return Pm(b2);
      }) : Pm(b2).then(function() {
        throw new t("no-such-provider");
      });
    }));
  };
  k3.delete = function() {
    var a = this;
    return R3(this, this.I().then(function(b2) {
      return O3(a.a, Bj, { idToken: b2 });
    }).then(function() {
      a.dispatchEvent(new nm("userDeleted"));
    })).then(function() {
      for (var b2 = 0; b2 < a.G.length; b2++)
        a.G[b2].cancel("app-deleted");
      Im(a, null);
      Jm(a, null);
      Km(a, null);
      a.G = [];
      a.A = true;
      Nm(a);
      M3(a, "refreshToken", null);
      a.i && Ll(a.i, a);
    });
  };
  k3.Eb = function(a, b2) {
    return "linkViaPopup" == a && (this.h || null) == b2 && this.g || "reauthViaPopup" == a && (this.h || null) == b2 && this.g || "linkViaRedirect" == a && (this.ga || null) == b2 || "reauthViaRedirect" == a && (this.ga || null) == b2 ? true : false;
  };
  k3.ma = function(a, b2, c, d) {
    "linkViaPopup" != a && "reauthViaPopup" != a || d != (this.h || null) || (c && this.O ? this.O(c) : b2 && !c && this.g && this.g(b2), this.c && (this.c.cancel(), this.c = null), delete this.g, delete this.O);
  };
  k3.Fa = function(a, b2) {
    return "linkViaPopup" == a && b2 == (this.h || null) ? q3(this.Jb, this) : "reauthViaPopup" == a && b2 == (this.h || null) ? q3(this.Kb, this) : "linkViaRedirect" == a && (this.ga || null) == b2 ? q3(this.Jb, this) : "reauthViaRedirect" == a && (this.ga || null) == b2 ? q3(this.Kb, this) : null;
  };
  k3.Dc = function(a) {
    var b2 = this;
    return dn2(this, "linkViaPopup", a, function() {
      return bn2(b2, a.providerId).then(function() {
        return Pm(b2);
      });
    }, false);
  };
  k3.Mc = function(a) {
    return dn2(this, "reauthViaPopup", a, function() {
      return D3();
    }, true);
  };
  function dn2(a, b2, c, d, e) {
    if (!Me2())
      return E3(new t("operation-not-supported-in-this-environment"));
    if (a.f && !e)
      return E3(a.f);
    var f = jg(c.providerId), g2 = Le2(a.uid + ":::"), h = null;
    (!Oe2() || De2()) && a.o && c.isOAuthProvider && (h = ak(a.o, a.l, a.m, b2, c, null, g2, import_app8.default.SDK_VERSION || null, null, null, a.tenantId));
    var m = ue2(h, f && f.ua, f && f.ta);
    d = d().then(function() {
      en3(a);
      if (!e)
        return a.I().then(function() {
        });
    }).then(function() {
      return Ol(a.i, m, b2, c, g2, !!h, a.tenantId);
    }).then(function() {
      return new C3(function(p2, v2) {
        a.ma(
          b2,
          null,
          new t("cancelled-popup-request"),
          a.h || null
        );
        a.g = p2;
        a.O = v2;
        a.h = g2;
        a.c = Ql(a.i, a, b2, m, g2);
      });
    }).then(function(p2) {
      m && te2(m);
      return p2 ? ff(p2) : null;
    }).s(function(p2) {
      m && te2(m);
      throw p2;
    });
    return R3(a, d, e);
  }
  k3.Ec = function(a) {
    var b2 = this;
    return fn2(this, "linkViaRedirect", a, function() {
      return bn2(b2, a.providerId);
    }, false);
  };
  k3.Nc = function(a) {
    return fn2(this, "reauthViaRedirect", a, function() {
      return D3();
    }, true);
  };
  function fn2(a, b2, c, d, e) {
    if (!Me2())
      return E3(new t("operation-not-supported-in-this-environment"));
    if (a.f && !e)
      return E3(a.f);
    var f = null, g2 = Le2(a.uid + ":::");
    d = d().then(function() {
      en3(a);
      if (!e)
        return a.I().then(function() {
        });
    }).then(function() {
      a.ga = g2;
      return Pm(a);
    }).then(function(h) {
      a.ha && (h = a.ha, h = h.b.set(gn2, a.w(), h.a));
      return h;
    }).then(function() {
      return Pl(a.i, b2, c, g2, a.tenantId);
    }).s(function(h) {
      f = h;
      if (a.ha)
        return hn2(a.ha);
      throw f;
    }).then(function() {
      if (f)
        throw f;
    });
    return R3(a, d, e);
  }
  function en3(a) {
    if (!a.i || !a.P) {
      if (a.i && !a.P)
        throw new t("internal-error");
      throw new t("auth-domain-config-required");
    }
  }
  k3.Jb = function(a, b2, c, d) {
    var e = this;
    this.c && (this.c.cancel(), this.c = null);
    var f = null;
    c = this.I().then(function(g2) {
      return Dg(e.a, { requestUri: a, postBody: d, sessionId: b2, idToken: g2 });
    }).then(function(g2) {
      f = an2(e, g2, "link");
      return cn2(e, g2);
    }).then(function() {
      return f;
    });
    return R3(this, c);
  };
  k3.Kb = function(a, b2, c, d) {
    var e = this;
    this.c && (this.c.cancel(), this.c = null);
    var f = null, g2 = D3().then(function() {
      return yg(Eg(e.a, { requestUri: a, sessionId: b2, postBody: d, tenantId: c }), e.uid);
    }).then(function(h) {
      f = an2(e, h, "reauthenticate");
      rm(e, h);
      e.f = null;
      return e.reload();
    }).then(function() {
      return f;
    });
    return R3(this, g2, true);
  };
  k3.tb = function(a) {
    var b2 = this, c = null;
    return R3(this, this.I().then(function(d) {
      c = d;
      return "undefined" === typeof a || kb2(a) ? {} : Yf(new Of(a));
    }).then(function(d) {
      return b2.a.tb(c, d);
    }).then(function(d) {
      if (b2.email != d)
        return b2.reload();
    }).then(function() {
    }));
  };
  k3.Db = function(a, b2) {
    var c = this, d = null;
    return R3(this, this.I().then(function(e) {
      d = e;
      return "undefined" === typeof b2 || kb2(b2) ? {} : Yf(new Of(b2));
    }).then(function(e) {
      return c.a.Db(d, a, e);
    }).then(function(e) {
      if (c.email != e)
        return c.reload();
    }).then(function() {
    }));
  };
  function R3(a, b2, c) {
    var d = jn2(a, b2, c);
    a.G.push(d);
    d.na(function() {
      Ua2(a.G, d);
    });
    return d.s(function(e) {
      var f = null;
      e && "auth/multi-factor-auth-required" === e.code && (f = hm(e.w(), Lm(a), q3(a.ic, a)));
      throw f || e;
    });
  }
  k3.ic = function(a) {
    var b2 = null, c = this;
    a = yg(D3(a), c.uid).then(function(d) {
      b2 = an2(c, d, "reauthenticate");
      rm(c, d);
      c.f = null;
      return c.reload();
    }).then(function() {
      return b2;
    });
    return R3(this, a, true);
  };
  function jn2(a, b2, c) {
    return a.f && !c ? (b2.cancel(), E3(a.f)) : b2.s(function(d) {
      !d || "auth/user-disabled" != d.code && "auth/user-token-expired" != d.code || (a.f || a.dispatchEvent(new nm("userInvalidated")), a.f = d);
      throw d;
    });
  }
  k3.toJSON = function() {
    return this.w();
  };
  k3.w = function() {
    var a = { uid: this.uid, displayName: this.displayName, photoURL: this.photoURL, email: this.email, emailVerified: this.emailVerified, phoneNumber: this.phoneNumber, isAnonymous: this.isAnonymous, tenantId: this.tenantId, providerData: [], apiKey: this.l, appName: this.m, authDomain: this.o, stsTokenManager: this.b.w(), redirectEventId: this.ga || null };
    this.metadata && z2(a, this.metadata.w());
    w2(this.providerData, function(b2) {
      a.providerData.push(gf(b2));
    });
    z2(a, this.N.w());
    return a;
  };
  function kn2(a) {
    if (!a.apiKey)
      return null;
    var b2 = { apiKey: a.apiKey, authDomain: a.authDomain, appName: a.appName, emulatorConfig: a.emulatorConfig }, c = {};
    if (a.stsTokenManager && a.stsTokenManager.accessToken)
      c[zg] = a.stsTokenManager.accessToken, c.refreshToken = a.stsTokenManager.refreshToken || null;
    else
      return null;
    var d = new Dm(b2, c, a);
    a.providerData && w2(a.providerData, function(e) {
      e && Um(d, ff(e));
    });
    a.redirectEventId && (d.ga = a.redirectEventId);
    return d;
  }
  function ln2(a, b2, c, d) {
    var e = new Dm(a, b2);
    c && (e.ha = c);
    d && Hm(e, d);
    return e.reload().then(function() {
      return e;
    });
  }
  function mn2(a, b2, c, d) {
    var e = a.b, f = {};
    f[zg] = e.b && e.b.toString();
    f.refreshToken = e.a;
    b2 = new Dm(b2 || { apiKey: a.l, authDomain: a.o, appName: a.m }, f);
    c && (b2.ha = c);
    d && Hm(b2, d);
    Xm(b2, a);
    return b2;
  }
  ;
  function nn2(a) {
    this.a = a;
    this.b = Qk();
  }
  var gn2 = { name: "redirectUser", D: "session" };
  function hn2(a) {
    return Uk(a.b, gn2, a.a);
  }
  function on2(a, b2) {
    return a.b.get(gn2, a.a).then(function(c) {
      c && b2 && (c.authDomain = b2);
      return kn2(c || {});
    });
  }
  ;
  function pn2(a) {
    this.a = a;
    this.b = Qk();
    this.c = null;
    this.f = qn2(this);
    this.b.addListener(rn2("local"), this.a, q3(this.g, this));
  }
  pn2.prototype.g = function() {
    var a = this, b2 = rn2("local");
    sn2(this, function() {
      return D3().then(function() {
        return a.c && "local" != a.c.D ? a.b.get(b2, a.a) : null;
      }).then(function(c) {
        if (c)
          return tn2(a, "local").then(function() {
            a.c = b2;
          });
      });
    });
  };
  function tn2(a, b2) {
    var c = [], d;
    for (d in Mk)
      Mk[d] !== b2 && c.push(Uk(a.b, rn2(Mk[d]), a.a));
    c.push(Uk(a.b, un2, a.a));
    return Ec2(c);
  }
  function qn2(a) {
    var b2 = rn2("local"), c = rn2("session"), d = rn2("none");
    return Tk(a.b, b2, a.a).then(function() {
      return a.b.get(c, a.a);
    }).then(function(e) {
      return e ? c : a.b.get(d, a.a).then(function(f) {
        return f ? d : a.b.get(b2, a.a).then(function(g2) {
          return g2 ? b2 : a.b.get(un2, a.a).then(function(h) {
            return h ? rn2(h) : b2;
          });
        });
      });
    }).then(function(e) {
      a.c = e;
      return tn2(a, e.D);
    }).s(function() {
      a.c || (a.c = b2);
    });
  }
  var un2 = { name: "persistence", D: "session" };
  function rn2(a) {
    return { name: "authUser", D: a };
  }
  pn2.prototype.wb = function(a) {
    var b2 = null, c = this;
    Nk(a);
    return sn2(this, function() {
      return a != c.c.D ? c.b.get(c.c, c.a).then(function(d) {
        b2 = d;
        return tn2(c, a);
      }).then(function() {
        c.c = rn2(a);
        if (b2)
          return c.b.set(c.c, b2, c.a);
      }) : D3();
    });
  };
  function vn2(a) {
    return sn2(a, function() {
      return a.b.set(un2, a.c.D, a.a);
    });
  }
  function wn2(a, b2) {
    return sn2(a, function() {
      return a.b.set(a.c, b2.w(), a.a);
    });
  }
  function xn2(a) {
    return sn2(a, function() {
      return Uk(a.b, a.c, a.a);
    });
  }
  function yn2(a, b2, c) {
    return sn2(a, function() {
      return a.b.get(a.c, a.a).then(function(d) {
        d && b2 && (d.authDomain = b2);
        d && c && (d.emulatorConfig = c);
        return kn2(d || {});
      });
    });
  }
  function sn2(a, b2) {
    a.f = a.f.then(b2, b2);
    return a.f;
  }
  ;
  function zn2(a) {
    this.m = false;
    M3(this, "settings", new $l());
    M3(this, "app", a);
    if (S3(this).options && S3(this).options.apiKey)
      a = import_app8.default.SDK_VERSION ? Je2(import_app8.default.SDK_VERSION) : null, this.a = new Ei2(S3(this).options && S3(this).options.apiKey, Aa3(Ba2), a);
    else
      throw new t("invalid-api-key");
    this.R = [];
    this.u = [];
    this.P = [];
    this.ac = import_app8.default.INTERNAL.createSubscribe(q3(this.yc, this));
    this.X = void 0;
    this.bc = import_app8.default.INTERNAL.createSubscribe(q3(this.zc, this));
    An2(this, null);
    this.l = new pn2(S3(this).options.apiKey + ":" + S3(this).name);
    this.G = new nn2(S3(this).options.apiKey + ":" + S3(this).name);
    this.$ = T3(this, Bn2(this));
    this.i = T3(this, Cn2(this));
    this.ba = false;
    this.pa = q3(this.Yc, this);
    this.Ba = q3(this.da, this);
    this.ya = q3(this.kc, this);
    this.za = q3(this.vc, this);
    this.Aa = q3(this.wc, this);
    this.b = null;
    Dn2(this);
    this.INTERNAL = {};
    this.INTERNAL["delete"] = q3(this.delete, this);
    this.INTERNAL.logFramework = q3(this.Fc, this);
    this.A = 0;
    H3.call(this);
    En2(this);
    this.N = [];
    this.f = null;
  }
  r2(zn2, H3);
  function Fn2(a) {
    F3.call(this, "languageCodeChanged");
    this.h = a;
  }
  r2(Fn2, F3);
  function Gn2(a) {
    F3.call(this, "emulatorConfigChanged");
    this.c = a;
  }
  r2(Gn2, F3);
  function Hn2(a) {
    F3.call(this, "frameworkChanged");
    this.f = a;
  }
  r2(Hn2, F3);
  k3 = zn2.prototype;
  k3.wb = function(a) {
    a = this.l.wb(a);
    return T3(this, a);
  };
  k3.wa = function(a) {
    this.aa === a || this.m || (this.aa = a, Ki2(this.a, this.aa), this.dispatchEvent(new Fn2(this.ka())));
  };
  k3.ka = function() {
    return this.aa;
  };
  k3.ed = function() {
    var a = l.navigator;
    this.wa(a ? a.languages && a.languages[0] || a.language || a.userLanguage || null : null);
  };
  k3.fd = function(a) {
    if (!this.f) {
      if (!/^https?:\/\//.test(a))
        throw new t("argument-error", "Emulator URL must start with a valid scheme (http:// or https://).");
      In2();
      this.f = { url: a };
      this.settings.hb = true;
      Li2(this.a, this.f);
      this.dispatchEvent(new Gn2(this.f));
    }
  };
  function In2() {
    Xe2("WARNING: You are using the Auth Emulator, which is intended for local testing only.  Do not use with production credentials.");
    l.document && ze2().then(function() {
      var a = l.document.createElement("div");
      a.innerText = "Running in emulator mode. Do not use with production credentials.";
      a.style.position = "fixed";
      a.style.width = "100%";
      a.style.backgroundColor = "#ffffff";
      a.style.border = ".1em solid #000000";
      a.style.color = "#ff0000";
      a.style.bottom = "0px";
      a.style.left = "0px";
      a.style.margin = "0px";
      a.style.zIndex = 1e4;
      a.style.textAlign = "center";
      a.classList.add("firebase-emulator-warning");
      l.document.body.appendChild(a);
    });
  }
  k3.Fc = function(a) {
    this.N.push(a);
    Ni2(this.a, import_app8.default.SDK_VERSION ? Je2(import_app8.default.SDK_VERSION, this.N) : null);
    this.dispatchEvent(new Hn2(this.N));
  };
  k3.Ga = function() {
    return Xa2(this.N);
  };
  k3.xb = function(a) {
    this.W === a || this.m || (this.W = a, this.a.b = this.W);
  };
  k3.S = function() {
    return this.W;
  };
  function En2(a) {
    Object.defineProperty(a, "lc", { get: function() {
      return this.ka();
    }, set: function(b2) {
      this.wa(b2);
    }, enumerable: false });
    a.aa = null;
    Object.defineProperty(a, "ti", { get: function() {
      return this.S();
    }, set: function(b2) {
      this.xb(b2);
    }, enumerable: false });
    a.W = null;
  }
  k3.toJSON = function() {
    return { apiKey: S3(this).options.apiKey, authDomain: S3(this).options.authDomain, appName: S3(this).name, currentUser: U3(this) && U3(this).w() };
  };
  function Jn2(a) {
    return a.gb || E3(new t("auth-domain-config-required"));
  }
  function Dn2(a) {
    var b2 = S3(a).options.authDomain, c = S3(a).options.apiKey;
    b2 && Me2() && (a.gb = a.$.then(function() {
      if (!a.m) {
        a.b = Sl(b2, c, S3(a).name, a.f);
        Kl(a.b, a);
        U3(a) && Qm(U3(a));
        if (a.o) {
          Qm(a.o);
          var d = a.o;
          d.wa(a.ka());
          Im(d, a);
          d = a.o;
          Hm(d, a.N);
          Km(d, a);
          d = a.o;
          Li2(d.a, a.f);
          Jm(d, a);
          a.o = null;
        }
        return a.b;
      }
    }));
  }
  k3.Eb = function(a, b2) {
    switch (a) {
      case "unknown":
      case "signInViaRedirect":
        return true;
      case "signInViaPopup":
        return this.h == b2 && !!this.g;
      default:
        return false;
    }
  };
  k3.ma = function(a, b2, c, d) {
    "signInViaPopup" == a && this.h == d && (c && this.O ? this.O(c) : b2 && !c && this.g && this.g(b2), this.c && (this.c.cancel(), this.c = null), delete this.g, delete this.O);
  };
  k3.Fa = function(a, b2) {
    return "signInViaRedirect" == a || "signInViaPopup" == a && this.h == b2 && this.g ? q3(this.hc, this) : null;
  };
  k3.hc = function(a, b2, c, d) {
    var e = this, f = { requestUri: a, postBody: d, sessionId: b2, tenantId: c };
    this.c && (this.c.cancel(), this.c = null);
    return e.$.then(function() {
      return Kn2(e, Bg(e.a, f));
    });
  };
  k3.Wc = function(a) {
    if (!Me2())
      return E3(new t("operation-not-supported-in-this-environment"));
    var b2 = this, c = jg(a.providerId), d = Le2(), e = null;
    (!Oe2() || De2()) && S3(this).options.authDomain && a.isOAuthProvider && (e = ak(S3(this).options.authDomain, S3(this).options.apiKey, S3(this).name, "signInViaPopup", a, null, d, import_app8.default.SDK_VERSION || null, null, null, this.S(), this.f));
    var f = ue2(e, c && c.ua, c && c.ta);
    c = Jn2(this).then(function(g2) {
      return Ol(g2, f, "signInViaPopup", a, d, !!e, b2.S());
    }).then(function() {
      return new C3(function(g2, h) {
        b2.ma(
          "signInViaPopup",
          null,
          new t("cancelled-popup-request"),
          b2.h
        );
        b2.g = g2;
        b2.O = h;
        b2.h = d;
        b2.c = Ql(b2.b, b2, "signInViaPopup", f, d);
      });
    }).then(function(g2) {
      f && te2(f);
      return g2 ? ff(g2) : null;
    }).s(function(g2) {
      f && te2(f);
      throw g2;
    });
    return T3(this, c);
  };
  k3.Xc = function(a) {
    if (!Me2())
      return E3(new t("operation-not-supported-in-this-environment"));
    var b2 = this, c = Jn2(this).then(function() {
      return vn2(b2.l);
    }).then(function() {
      return Pl(b2.b, "signInViaRedirect", a, void 0, b2.S());
    });
    return T3(this, c);
  };
  function Ln2(a) {
    if (!Me2())
      return E3(new t("operation-not-supported-in-this-environment"));
    var b2 = Jn2(a).then(function() {
      return a.b.qa();
    }).then(function(c) {
      return c ? ff(c) : null;
    });
    return T3(a, b2);
  }
  k3.qa = function() {
    var a = this;
    return Ln2(this).then(function(b2) {
      a.b && Vl(a.b.b);
      return b2;
    }).s(function(b2) {
      a.b && Vl(a.b.b);
      throw b2;
    });
  };
  k3.cd = function(a) {
    if (!a)
      return E3(new t("null-user"));
    if (this.W != a.tenantId)
      return E3(new t("tenant-id-mismatch"));
    var b2 = this, c = {};
    c.apiKey = S3(this).options.apiKey;
    c.authDomain = S3(this).options.authDomain;
    c.appName = S3(this).name;
    var d = mn2(a, c, b2.G, b2.Ga());
    return T3(this, this.i.then(function() {
      if (S3(b2).options.apiKey != a.l)
        return d.reload();
    }).then(function() {
      if (U3(b2) && a.uid == U3(b2).uid)
        return Xm(U3(b2), a), b2.da(a);
      An2(b2, d);
      Qm(d);
      return b2.da(d);
    }).then(function() {
      Mn2(b2);
    }));
  };
  function Nn2(a, b2) {
    var c = {};
    c.apiKey = S3(a).options.apiKey;
    c.authDomain = S3(a).options.authDomain;
    c.appName = S3(a).name;
    a.f && (c.emulatorConfig = a.f);
    return a.$.then(function() {
      return ln2(c, b2, a.G, a.Ga());
    }).then(function(d) {
      if (U3(a) && d.uid == U3(a).uid)
        return Xm(U3(a), d), a.da(d);
      An2(a, d);
      Qm(d);
      return a.da(d);
    }).then(function() {
      Mn2(a);
    });
  }
  function An2(a, b2) {
    U3(a) && (Om(U3(a), a.Ba), G3(U3(a), "tokenChanged", a.ya), G3(U3(a), "userDeleted", a.za), G3(U3(a), "userInvalidated", a.Aa), Nm(U3(a)));
    b2 && (b2.R.push(a.Ba), jd2(b2, "tokenChanged", a.ya), jd2(b2, "userDeleted", a.za), jd2(b2, "userInvalidated", a.Aa), 0 < a.A && Mm(b2));
    M3(a, "currentUser", b2);
    b2 && (b2.wa(a.ka()), Im(b2, a), Hm(b2, a.N), Km(b2, a), Li2(b2.a, a.f), Jm(b2, a));
  }
  k3.zb = function() {
    var a = this, b2 = this.i.then(function() {
      a.b && Vl(a.b.b);
      if (!U3(a))
        return D3();
      An2(a, null);
      return xn2(a.l).then(function() {
        Mn2(a);
      });
    });
    return T3(this, b2);
  };
  function On2(a) {
    var b2 = on2(a.G, S3(a).options.authDomain).then(function(c) {
      if (a.o = c)
        c.ha = a.G;
      return hn2(a.G);
    });
    return T3(a, b2);
  }
  function Bn2(a) {
    var b2 = S3(a).options.authDomain, c = On2(a).then(function() {
      return yn2(a.l, b2, a.f);
    }).then(function(d) {
      return d ? (d.ha = a.G, a.o && (a.o.ga || null) == (d.ga || null) ? d : d.reload().then(function() {
        return wn2(a.l, d).then(function() {
          return d;
        });
      }).s(function(e) {
        return "auth/network-request-failed" == e.code ? d : xn2(a.l);
      })) : null;
    }).then(function(d) {
      An2(a, d || null);
    });
    return T3(a, c);
  }
  function Cn2(a) {
    return a.$.then(function() {
      return Ln2(a);
    }).s(function() {
    }).then(function() {
      if (!a.m)
        return a.pa();
    }).s(function() {
    }).then(function() {
      if (!a.m) {
        a.ba = true;
        var b2 = a.l;
        b2.b.addListener(rn2("local"), b2.a, a.pa);
      }
    });
  }
  k3.Yc = function() {
    var a = this;
    return yn2(this.l, S3(this).options.authDomain).then(function(b2) {
      if (!a.m) {
        var c;
        if (c = U3(a) && b2) {
          c = U3(a).uid;
          var d = b2.uid;
          c = void 0 === c || null === c || "" === c || void 0 === d || null === d || "" === d ? false : c == d;
        }
        if (c)
          return Xm(U3(a), b2), U3(a).I();
        if (U3(a) || b2)
          An2(a, b2), b2 && (Qm(b2), b2.ha = a.G), a.b && Kl(a.b, a), Mn2(a);
      }
    });
  };
  k3.da = function(a) {
    return wn2(this.l, a);
  };
  k3.kc = function() {
    Mn2(this);
    this.da(U3(this));
  };
  k3.vc = function() {
    this.zb();
  };
  k3.wc = function() {
    this.zb();
  };
  function Kn2(a, b2) {
    var c = null, d = null;
    return T3(a, b2.then(function(e) {
      c = mh(e);
      d = kg(e);
      return Nn2(a, e);
    }, function(e) {
      var f = null;
      e && "auth/multi-factor-auth-required" === e.code && (f = hm(e.w(), a, q3(a.jc, a)));
      throw f || e;
    }).then(function() {
      return ff({ user: U3(a), credential: c, additionalUserInfo: d, operationType: "signIn" });
    }));
  }
  k3.jc = function(a) {
    var b2 = this;
    return this.i.then(function() {
      return Kn2(b2, D3(a));
    });
  };
  k3.yc = function(a) {
    var b2 = this;
    this.addAuthTokenListener(function() {
      a.next(U3(b2));
    });
  };
  k3.zc = function(a) {
    var b2 = this;
    Pn2(this, function() {
      a.next(U3(b2));
    });
  };
  k3.Hc = function(a, b2, c) {
    var d = this;
    this.ba && Promise.resolve().then(function() {
      "function" === typeof a ? a(U3(d)) : "function" === typeof a.next && a.next(U3(d));
    });
    return this.ac(a, b2, c);
  };
  k3.Gc = function(a, b2, c) {
    var d = this;
    this.ba && Promise.resolve().then(function() {
      d.X = d.getUid();
      "function" === typeof a ? a(U3(d)) : "function" === typeof a.next && a.next(U3(d));
    });
    return this.bc(a, b2, c);
  };
  k3.mc = function(a) {
    var b2 = this, c = this.i.then(function() {
      return U3(b2) ? U3(b2).I(a).then(function(d) {
        return { accessToken: d };
      }) : null;
    });
    return T3(this, c);
  };
  k3.Sc = function(a) {
    var b2 = this;
    return this.i.then(function() {
      return Kn2(b2, O3(b2.a, Gj, { token: a }));
    }).then(function(c) {
      var d = c.user;
      Wm(d, "isAnonymous", false);
      b2.da(d);
      return c;
    });
  };
  k3.Tc = function(a, b2) {
    var c = this;
    return this.i.then(function() {
      return Kn2(c, O3(c.a, Xg, { email: a, password: b2 }));
    });
  };
  k3.dc = function(a, b2) {
    var c = this;
    return this.i.then(function() {
      return Kn2(c, O3(c.a, Aj, { email: a, password: b2 }));
    });
  };
  k3.Za = function(a) {
    var b2 = this;
    return this.i.then(function() {
      return Kn2(b2, a.ja(b2.a));
    });
  };
  k3.Rc = function(a) {
    cf("firebase.auth.Auth.prototype.signInAndRetrieveDataWithCredential is deprecated. Please use firebase.auth.Auth.prototype.signInWithCredential instead.");
    return this.Za(a);
  };
  k3.yb = function() {
    var a = this;
    return this.i.then(function() {
      var b2 = U3(a);
      if (b2 && b2.isAnonymous) {
        var c = ff({ providerId: null, isNewUser: false });
        return ff({ user: b2, credential: null, additionalUserInfo: c, operationType: "signIn" });
      }
      return Kn2(a, a.a.yb()).then(function(d) {
        var e = d.user;
        Wm(e, "isAnonymous", true);
        a.da(e);
        return d;
      });
    });
  };
  function S3(a) {
    return a.app;
  }
  function U3(a) {
    return a.currentUser;
  }
  k3.getUid = function() {
    return U3(this) && U3(this).uid || null;
  };
  function Qn2(a) {
    return U3(a) && U3(a)._lat || null;
  }
  function Mn2(a) {
    if (a.ba) {
      for (var b2 = 0; b2 < a.u.length; b2++)
        if (a.u[b2])
          a.u[b2](Qn2(a));
      if (a.X !== a.getUid() && a.P.length) {
        for (a.X = a.getUid(), b2 = 0; b2 < a.P.length; b2++)
          if (a.P[b2])
            a.P[b2](Qn2(a));
      }
    }
  }
  k3.cc = function(a) {
    this.addAuthTokenListener(a);
    this.A++;
    0 < this.A && U3(this) && Mm(U3(this));
  };
  k3.Oc = function(a) {
    var b2 = this;
    w2(this.u, function(c) {
      c == a && b2.A--;
    });
    0 > this.A && (this.A = 0);
    0 == this.A && U3(this) && Nm(U3(this));
    this.removeAuthTokenListener(a);
  };
  k3.addAuthTokenListener = function(a) {
    var b2 = this;
    this.u.push(a);
    T3(this, this.i.then(function() {
      b2.m || Ta2(b2.u, a) && a(Qn2(b2));
    }));
  };
  k3.removeAuthTokenListener = function(a) {
    Va2(this.u, function(b2) {
      return b2 == a;
    });
  };
  function Pn2(a, b2) {
    a.P.push(b2);
    T3(a, a.i.then(function() {
      !a.m && Ta2(a.P, b2) && a.X !== a.getUid() && (a.X = a.getUid(), b2(Qn2(a)));
    }));
  }
  k3.delete = function() {
    this.m = true;
    for (var a = 0; a < this.R.length; a++)
      this.R[a].cancel("app-deleted");
    this.R = [];
    this.l && (a = this.l, a.b.removeListener(rn2("local"), a.a, this.pa));
    this.b && (Ll(this.b, this), Vl(this.b.b));
    return Promise.resolve();
  };
  function T3(a, b2) {
    a.R.push(b2);
    b2.na(function() {
      Ua2(a.R, b2);
    });
    return b2;
  }
  k3.gc = function(a) {
    return T3(this, Xi2(this.a, a));
  };
  k3.Ac = function(a) {
    return !!bh(a);
  };
  k3.vb = function(a, b2) {
    var c = this;
    return T3(this, D3().then(function() {
      var d = new Of(b2);
      if (!d.c)
        throw new t("argument-error", Wf + " must be true when sending sign in link to email");
      return Yf(d);
    }).then(function(d) {
      return c.a.vb(a, d);
    }).then(function() {
    }));
  };
  k3.hd = function(a) {
    return this.Qa(a).then(function(b2) {
      return b2.data.email;
    });
  };
  k3.mb = function(a, b2) {
    return T3(this, this.a.mb(a, b2).then(function() {
    }));
  };
  k3.Qa = function(a) {
    return T3(this, this.a.Qa(a).then(function(b2) {
      return new rf(b2);
    }));
  };
  k3.ib = function(a) {
    return T3(this, this.a.ib(a).then(function() {
    }));
  };
  k3.ub = function(a, b2) {
    var c = this;
    return T3(this, D3().then(function() {
      return "undefined" === typeof b2 || kb2(b2) ? {} : Yf(new Of(b2));
    }).then(function(d) {
      return c.a.ub(a, d);
    }).then(function() {
    }));
  };
  k3.Vc = function(a, b2) {
    return T3(this, bm(this, a, b2, q3(this.Za, this)));
  };
  k3.Uc = function(a, b2) {
    var c = this;
    return T3(this, D3().then(function() {
      var d = b2 || me2(), e = ah(a, d);
      d = bh(d);
      if (!d)
        throw new t("argument-error", "Invalid email link!");
      if (d.tenantId !== c.S())
        throw new t("tenant-id-mismatch");
      return c.Za(e);
    }));
  };
  function Rn2() {
  }
  Rn2.prototype.render = function() {
  };
  Rn2.prototype.reset = function() {
  };
  Rn2.prototype.getResponse = function() {
  };
  Rn2.prototype.execute = function() {
  };
  function Sn2() {
    this.a = {};
    this.b = 1e12;
  }
  var Tn2 = null;
  Sn2.prototype.render = function(a, b2) {
    this.a[this.b.toString()] = new Un2(a, b2);
    return this.b++;
  };
  Sn2.prototype.reset = function(a) {
    var b2 = Vn2(this, a);
    a = Wn2(a);
    b2 && a && (b2.delete(), delete this.a[a]);
  };
  Sn2.prototype.getResponse = function(a) {
    return (a = Vn2(this, a)) ? a.getResponse() : null;
  };
  Sn2.prototype.execute = function(a) {
    (a = Vn2(this, a)) && a.execute();
  };
  function Vn2(a, b2) {
    return (b2 = Wn2(b2)) ? a.a[b2] || null : null;
  }
  function Wn2(a) {
    return (a = "undefined" === typeof a ? 1e12 : a) ? a.toString() : null;
  }
  function Un2(a, b2) {
    this.g = false;
    this.c = b2;
    this.a = this.b = null;
    this.h = "invisible" !== this.c.size;
    this.f = fc2(a);
    var c = this;
    this.i = function() {
      c.execute();
    };
    this.h ? this.execute() : jd2(this.f, "click", this.i);
  }
  Un2.prototype.getResponse = function() {
    Xn2(this);
    return this.b;
  };
  Un2.prototype.execute = function() {
    Xn2(this);
    var a = this;
    this.a || (this.a = setTimeout(function() {
      a.b = He2();
      var b2 = a.c.callback, c = a.c["expired-callback"];
      if (b2)
        try {
          b2(a.b);
        } catch (d) {
        }
      a.a = setTimeout(function() {
        a.a = null;
        a.b = null;
        if (c)
          try {
            c();
          } catch (d) {
          }
        a.h && a.execute();
      }, 6e4);
    }, 500));
  };
  Un2.prototype.delete = function() {
    Xn2(this);
    this.g = true;
    clearTimeout(this.a);
    this.a = null;
    G3(this.f, "click", this.i);
  };
  function Xn2(a) {
    if (a.g)
      throw Error("reCAPTCHA mock was already deleted!");
  }
  ;
  function Yn2() {
  }
  M3(Yn2, "FACTOR_ID", "phone");
  function Zn2() {
  }
  Zn2.prototype.g = function() {
    Tn2 || (Tn2 = new Sn2());
    return D3(Tn2);
  };
  Zn2.prototype.c = function() {
  };
  var $n2 = null;
  function ao2() {
    this.b = l.grecaptcha ? Infinity : 0;
    this.f = null;
    this.a = "__rcb" + Math.floor(1e6 * Math.random()).toString();
  }
  var bo2 = new ob2(pb2, "https://www.google.com/recaptcha/api.js?onload=%{onload}&render=explicit&hl=%{hl}"), co2 = new Ue2(3e4, 6e4);
  ao2.prototype.g = function(a) {
    var b2 = this;
    return new C3(function(c, d) {
      var e = setTimeout(function() {
        d(new t("network-request-failed"));
      }, co2.get());
      if (!l.grecaptcha || a !== b2.f && !b2.b) {
        l[b2.a] = function() {
          if (l.grecaptcha) {
            b2.f = a;
            var g2 = l.grecaptcha.render;
            l.grecaptcha.render = function(h, m) {
              h = g2(h, m);
              b2.b++;
              return h;
            };
            clearTimeout(e);
            c(l.grecaptcha);
          } else
            clearTimeout(e), d(new t("internal-error"));
          delete l[b2.a];
        };
        var f = xb2(bo2, { onload: b2.a, hl: a || "" });
        D3(xi2(f)).s(function() {
          clearTimeout(e);
          d(new t("internal-error", "Unable to load external reCAPTCHA dependencies!"));
        });
      } else
        clearTimeout(e), c(l.grecaptcha);
    });
  };
  ao2.prototype.c = function() {
    this.b--;
  };
  var eo2 = null;
  function fo2(a, b2, c, d, e, f, g2) {
    M3(this, "type", "recaptcha");
    this.c = this.f = null;
    this.A = false;
    this.m = b2;
    this.g = null;
    g2 ? ($n2 || ($n2 = new Zn2()), g2 = $n2) : (eo2 || (eo2 = new ao2()), g2 = eo2);
    this.v = g2;
    this.a = c || { theme: "light", type: "image" };
    this.h = [];
    if (this.a[go2])
      throw new t("argument-error", "sitekey should not be provided for reCAPTCHA as one is automatically provisioned for the current project.");
    this.i = "invisible" === this.a[ho2];
    if (!l.document)
      throw new t("operation-not-supported-in-this-environment", "RecaptchaVerifier is only supported in a browser HTTP/HTTPS environment with DOM support.");
    if (!fc2(b2) || !this.i && fc2(b2).hasChildNodes())
      throw new t("argument-error", "reCAPTCHA container is either not found or already contains inner elements!");
    this.o = new Ei2(a, f || null, e || null);
    this.u = d || function() {
      return null;
    };
    var h = this;
    this.l = [];
    var m = this.a[io2];
    this.a[io2] = function(v2) {
      jo2(h, v2);
      if ("function" === typeof m)
        m(v2);
      else if ("string" === typeof m) {
        var B2 = L3(m, l);
        "function" === typeof B2 && B2(v2);
      }
    };
    var p2 = this.a[ko2];
    this.a[ko2] = function() {
      jo2(h, null);
      if ("function" === typeof p2)
        p2();
      else if ("string" === typeof p2) {
        var v2 = L3(p2, l);
        "function" === typeof v2 && v2();
      }
    };
  }
  var io2 = "callback", ko2 = "expired-callback", go2 = "sitekey", ho2 = "size";
  function jo2(a, b2) {
    for (var c = 0; c < a.l.length; c++)
      try {
        a.l[c](b2);
      } catch (d) {
      }
  }
  function lo2(a, b2) {
    Va2(a.l, function(c) {
      return c == b2;
    });
  }
  function mo2(a, b2) {
    a.h.push(b2);
    b2.na(function() {
      Ua2(a.h, b2);
    });
    return b2;
  }
  k3 = fo2.prototype;
  k3.Ia = function() {
    var a = this;
    return this.f ? this.f : this.f = mo2(this, D3().then(function() {
      if (Ne2() && !Ee2())
        return ze2();
      throw new t("operation-not-supported-in-this-environment", "RecaptchaVerifier is only supported in a browser HTTP/HTTPS environment.");
    }).then(function() {
      return a.v.g(a.u());
    }).then(function(b2) {
      a.g = b2;
      return O3(a.o, Fj, {});
    }).then(function(b2) {
      a.a[go2] = b2.recaptchaSiteKey;
    }).s(function(b2) {
      a.f = null;
      throw b2;
    }));
  };
  k3.render = function() {
    no2(this);
    var a = this;
    return mo2(this, this.Ia().then(function() {
      if (null === a.c) {
        var b2 = a.m;
        if (!a.i) {
          var c = fc2(b2);
          b2 = ic2("DIV");
          c.appendChild(b2);
        }
        a.c = a.g.render(b2, a.a);
      }
      return a.c;
    }));
  };
  k3.verify = function() {
    no2(this);
    var a = this;
    return mo2(this, this.render().then(function(b2) {
      return new C3(function(c) {
        var d = a.g.getResponse(b2);
        if (d)
          c(d);
        else {
          var e = function(f) {
            f && (lo2(a, e), c(f));
          };
          a.l.push(e);
          a.i && a.g.execute(a.c);
        }
      });
    }));
  };
  k3.reset = function() {
    no2(this);
    null !== this.c && this.g.reset(this.c);
  };
  function no2(a) {
    if (a.A)
      throw new t("internal-error", "RecaptchaVerifier instance has been destroyed.");
  }
  k3.clear = function() {
    no2(this);
    this.A = true;
    this.v.c();
    for (var a = 0; a < this.h.length; a++)
      this.h[a].cancel("RecaptchaVerifier instance has been destroyed.");
    if (!this.i) {
      a = fc2(this.m);
      for (var b2; b2 = a.firstChild; )
        a.removeChild(b2);
    }
  };
  function oo2(a, b2, c) {
    var d = false;
    try {
      this.b = c || import_app8.default.app();
    } catch (g2) {
      throw new t("argument-error", "No firebase.app.App instance is currently initialized.");
    }
    if (this.b.options && this.b.options.apiKey)
      c = this.b.options.apiKey;
    else
      throw new t("invalid-api-key");
    var e = this, f = null;
    try {
      f = this.b.auth().Ga();
    } catch (g2) {
    }
    try {
      d = this.b.auth().settings.appVerificationDisabledForTesting;
    } catch (g2) {
    }
    f = import_app8.default.SDK_VERSION ? Je2(import_app8.default.SDK_VERSION, f) : null;
    fo2.call(this, c, a, b2, function() {
      try {
        var g2 = e.b.auth().ka();
      } catch (h) {
        g2 = null;
      }
      return g2;
    }, f, Aa3(Ba2), d);
  }
  r2(oo2, fo2);
  function po2(a, b2, c, d) {
    a: {
      c = Array.prototype.slice.call(c);
      var e = 0;
      for (var f = false, g2 = 0; g2 < b2.length; g2++)
        if (b2[g2].optional)
          f = true;
        else {
          if (f)
            throw new t("internal-error", "Argument validator encountered a required argument after an optional argument.");
          e++;
        }
      f = b2.length;
      if (c.length < e || f < c.length)
        d = "Expected " + (e == f ? 1 == e ? "1 argument" : e + " arguments" : e + "-" + f + " arguments") + " but got " + c.length + ".";
      else {
        for (e = 0; e < c.length; e++)
          if (f = b2[e].optional && void 0 === c[e], !b2[e].K(c[e]) && !f) {
            b2 = b2[e];
            if (0 > e || e >= qo2.length)
              throw new t(
                "internal-error",
                "Argument validator received an unsupported number of arguments."
              );
            c = qo2[e];
            d = (d ? "" : c + " argument ") + (b2.name ? '"' + b2.name + '" ' : "") + "must be " + b2.J + ".";
            break a;
          }
        d = null;
      }
    }
    if (d)
      throw new t("argument-error", a + " failed: " + d);
  }
  var qo2 = "First Second Third Fourth Fifth Sixth Seventh Eighth Ninth".split(" ");
  function V3(a, b2) {
    return { name: a || "", J: "a valid string", optional: !!b2, K: function(c) {
      return "string" === typeof c;
    } };
  }
  function ro2(a, b2) {
    return { name: a || "", J: "a boolean", optional: !!b2, K: function(c) {
      return "boolean" === typeof c;
    } };
  }
  function W3(a, b2) {
    return { name: a || "", J: "a valid object", optional: !!b2, K: n2 };
  }
  function so2(a, b2) {
    return { name: a || "", J: "a function", optional: !!b2, K: function(c) {
      return "function" === typeof c;
    } };
  }
  function to2(a, b2) {
    return { name: a || "", J: "null", optional: !!b2, K: function(c) {
      return null === c;
    } };
  }
  function uo2() {
    return { name: "", J: "an HTML element", optional: false, K: function(a) {
      return !!(a && a instanceof Element);
    } };
  }
  function vo2() {
    return { name: "auth", J: "an instance of Firebase Auth", optional: true, K: function(a) {
      return !!(a && a instanceof zn2);
    } };
  }
  function wo2() {
    return { name: "app", J: "an instance of Firebase App", optional: true, K: function(a) {
      return !!(a && a instanceof import_app8.default.app.App);
    } };
  }
  function xo2(a) {
    return { name: a ? a + "Credential" : "credential", J: a ? "a valid " + a + " credential" : "a valid credential", optional: false, K: function(b2) {
      if (!b2)
        return false;
      var c = !a || b2.providerId === a;
      return !(!b2.ja || !c);
    } };
  }
  function yo2() {
    return { name: "multiFactorAssertion", J: "a valid multiFactorAssertion", optional: false, K: function(a) {
      return a ? !!a.rb : false;
    } };
  }
  function zo2() {
    return { name: "authProvider", J: "a valid Auth provider", optional: false, K: function(a) {
      return !!(a && a.providerId && a.hasOwnProperty && a.hasOwnProperty("isOAuthProvider"));
    } };
  }
  function Ao2(a, b2) {
    return n2(a) && "string" === typeof a.type && a.type === b2 && "function" === typeof a.Ha;
  }
  function Bo2(a) {
    return n2(a) && "string" === typeof a.uid;
  }
  function Co2() {
    return { name: "applicationVerifier", J: "an implementation of firebase.auth.ApplicationVerifier", optional: false, K: function(a) {
      return !(!a || "string" !== typeof a.type || "function" !== typeof a.verify);
    } };
  }
  function X3(a, b2, c, d) {
    return { name: c || "", J: a.J + " or " + b2.J, optional: !!d, K: function(e) {
      return a.K(e) || b2.K(e);
    } };
  }
  ;
  function Y3(a, b2) {
    for (var c in b2) {
      var d = b2[c].name;
      a[d] = Do2(d, a[c], b2[c].j);
    }
  }
  function Eo2(a, b2) {
    for (var c in b2) {
      var d = b2[c].name;
      d !== c && Object.defineProperty(a, d, { get: ta3(function(e) {
        return this[e];
      }, c), set: ta3(function(e, f, g2, h) {
        po2(e, [g2], [h], true);
        this[f] = h;
      }, d, c, b2[c].jb), enumerable: true });
    }
  }
  function Z3(a, b2, c, d) {
    a[b2] = Do2(b2, c, d);
  }
  function Do2(a, b2, c) {
    function d() {
      var g2 = Array.prototype.slice.call(arguments);
      po2(e, c, g2);
      return b2.apply(this, g2);
    }
    if (!c)
      return b2;
    var e = Fo2(a), f;
    for (f in b2)
      d[f] = b2[f];
    for (f in b2.prototype)
      d.prototype[f] = b2.prototype[f];
    return d;
  }
  function Fo2(a) {
    a = a.split(".");
    return a[a.length - 1];
  }
  ;
  Y3(zn2.prototype, {
    ib: { name: "applyActionCode", j: [V3("code")] },
    Qa: { name: "checkActionCode", j: [V3("code")] },
    mb: { name: "confirmPasswordReset", j: [V3("code"), V3("newPassword")] },
    dc: { name: "createUserWithEmailAndPassword", j: [V3("email"), V3("password")] },
    gc: { name: "fetchSignInMethodsForEmail", j: [V3("email")] },
    qa: { name: "getRedirectResult", j: [] },
    Ac: { name: "isSignInWithEmailLink", j: [V3("emailLink")] },
    Gc: { name: "onAuthStateChanged", j: [X3(W3(), so2(), "nextOrObserver"), so2("opt_error", true), so2("opt_completed", true)] },
    Hc: {
      name: "onIdTokenChanged",
      j: [X3(W3(), so2(), "nextOrObserver"), so2("opt_error", true), so2("opt_completed", true)]
    },
    ub: { name: "sendPasswordResetEmail", j: [V3("email"), X3(W3("opt_actionCodeSettings", true), to2(null, true), "opt_actionCodeSettings", true)] },
    vb: { name: "sendSignInLinkToEmail", j: [V3("email"), W3("actionCodeSettings")] },
    wb: { name: "setPersistence", j: [V3("persistence")] },
    Rc: { name: "signInAndRetrieveDataWithCredential", j: [xo2()] },
    yb: { name: "signInAnonymously", j: [] },
    Za: { name: "signInWithCredential", j: [xo2()] },
    Sc: { name: "signInWithCustomToken", j: [V3("token")] },
    Tc: { name: "signInWithEmailAndPassword", j: [V3("email"), V3("password")] },
    Uc: { name: "signInWithEmailLink", j: [V3("email"), V3("emailLink", true)] },
    Vc: { name: "signInWithPhoneNumber", j: [V3("phoneNumber"), Co2()] },
    Wc: { name: "signInWithPopup", j: [zo2()] },
    Xc: { name: "signInWithRedirect", j: [zo2()] },
    cd: { name: "updateCurrentUser", j: [X3(/* @__PURE__ */ function(a) {
      return { name: "user", J: "an instance of Firebase User", optional: !!a, K: function(b2) {
        return !!(b2 && b2 instanceof Dm);
      } };
    }(), to2(), "user")] },
    zb: { name: "signOut", j: [] },
    toJSON: { name: "toJSON", j: [V3(
      null,
      true
    )] },
    ed: { name: "useDeviceLanguage", j: [] },
    fd: { name: "useEmulator", j: [V3("url")] },
    hd: { name: "verifyPasswordResetCode", j: [V3("code")] }
  });
  Eo2(zn2.prototype, { lc: { name: "languageCode", jb: X3(V3(), to2(), "languageCode") }, ti: { name: "tenantId", jb: X3(V3(), to2(), "tenantId") } });
  zn2.Persistence = Mk;
  zn2.Persistence.LOCAL = "local";
  zn2.Persistence.SESSION = "session";
  zn2.Persistence.NONE = "none";
  Y3(Dm.prototype, {
    "delete": { name: "delete", j: [] },
    nc: { name: "getIdTokenResult", j: [ro2("opt_forceRefresh", true)] },
    I: { name: "getIdToken", j: [ro2("opt_forceRefresh", true)] },
    Bc: { name: "linkAndRetrieveDataWithCredential", j: [xo2()] },
    pb: { name: "linkWithCredential", j: [xo2()] },
    Cc: { name: "linkWithPhoneNumber", j: [V3("phoneNumber"), Co2()] },
    Dc: { name: "linkWithPopup", j: [zo2()] },
    Ec: { name: "linkWithRedirect", j: [zo2()] },
    Kc: { name: "reauthenticateAndRetrieveDataWithCredential", j: [xo2()] },
    sb: { name: "reauthenticateWithCredential", j: [xo2()] },
    Lc: {
      name: "reauthenticateWithPhoneNumber",
      j: [V3("phoneNumber"), Co2()]
    },
    Mc: { name: "reauthenticateWithPopup", j: [zo2()] },
    Nc: { name: "reauthenticateWithRedirect", j: [zo2()] },
    reload: { name: "reload", j: [] },
    tb: { name: "sendEmailVerification", j: [X3(W3("opt_actionCodeSettings", true), to2(null, true), "opt_actionCodeSettings", true)] },
    toJSON: { name: "toJSON", j: [V3(null, true)] },
    bd: { name: "unlink", j: [V3("provider")] },
    Ab: { name: "updateEmail", j: [V3("email")] },
    Bb: { name: "updatePassword", j: [V3("password")] },
    dd: { name: "updatePhoneNumber", j: [xo2("phone")] },
    Cb: { name: "updateProfile", j: [W3("profile")] },
    Db: { name: "verifyBeforeUpdateEmail", j: [V3("email"), X3(W3("opt_actionCodeSettings", true), to2(null, true), "opt_actionCodeSettings", true)] }
  });
  Y3(Sn2.prototype, { execute: { name: "execute" }, render: { name: "render" }, reset: { name: "reset" }, getResponse: { name: "getResponse" } });
  Y3(Rn2.prototype, { execute: { name: "execute" }, render: { name: "render" }, reset: { name: "reset" }, getResponse: { name: "getResponse" } });
  Y3(C3.prototype, { na: { name: "finally" }, s: { name: "catch" }, then: { name: "then" } });
  Eo2($l.prototype, { appVerificationDisabled: { name: "appVerificationDisabledForTesting", jb: ro2("appVerificationDisabledForTesting") } });
  Y3(am.prototype, { confirm: { name: "confirm", j: [V3("verificationCode")] } });
  Z3(xg, "fromJSON", function(a) {
    a = "string" === typeof a ? JSON.parse(a) : a;
    for (var b2, c = [Ig, $g, gh, Fg], d = 0; d < c.length; d++)
      if (b2 = c[d](a))
        return b2;
    return null;
  }, [X3(V3(), W3(), "json")]);
  Z3(Vg, "credential", function(a, b2) {
    return new Ug(a, b2);
  }, [V3("email"), V3("password")]);
  Y3(Ug.prototype, { w: { name: "toJSON", j: [V3(null, true)] } });
  Y3(Mg.prototype, { Ca: { name: "addScope", j: [V3("scope")] }, Ka: { name: "setCustomParameters", j: [W3("customOAuthParameters")] } });
  Z3(Mg, "credential", Ng, [X3(V3(), W3(), "token")]);
  Z3(Vg, "credentialWithLink", ah, [V3("email"), V3("emailLink")]);
  Y3(Og.prototype, { Ca: { name: "addScope", j: [V3("scope")] }, Ka: { name: "setCustomParameters", j: [W3("customOAuthParameters")] } });
  Z3(Og, "credential", Pg, [X3(V3(), W3(), "token")]);
  Y3(Qg.prototype, { Ca: { name: "addScope", j: [V3("scope")] }, Ka: { name: "setCustomParameters", j: [W3("customOAuthParameters")] } });
  Z3(Qg, "credential", Rg, [X3(V3(), X3(W3(), to2()), "idToken"), X3(V3(), to2(), "accessToken", true)]);
  Y3(Sg.prototype, { Ka: { name: "setCustomParameters", j: [W3("customOAuthParameters")] } });
  Z3(Sg, "credential", Tg, [X3(V3(), W3(), "token"), V3("secret", true)]);
  Y3(Lg.prototype, { Ca: { name: "addScope", j: [V3("scope")] }, credential: { name: "credential", j: [X3(V3(), X3(W3(), to2()), "optionsOrIdToken"), X3(V3(), to2(), "accessToken", true)] }, Ka: { name: "setCustomParameters", j: [W3("customOAuthParameters")] } });
  Y3(Gg.prototype, { w: { name: "toJSON", j: [V3(null, true)] } });
  Y3(Ag.prototype, { w: { name: "toJSON", j: [V3(null, true)] } });
  Z3(hh, "credential", lh, [V3("verificationId"), V3("verificationCode")]);
  Y3(hh.prototype, { eb: { name: "verifyPhoneNumber", j: [X3(V3(), /* @__PURE__ */ function(a, b2) {
    return { name: a || "phoneInfoOptions", J: "valid phone info options", optional: !!b2, K: function(c) {
      return c ? c.session && c.phoneNumber ? Ao2(c.session, vg) && "string" === typeof c.phoneNumber : c.session && c.multiFactorHint ? Ao2(c.session, wg) && Bo2(c.multiFactorHint) : c.session && c.multiFactorUid ? Ao2(c.session, wg) && "string" === typeof c.multiFactorUid : c.phoneNumber ? "string" === typeof c.phoneNumber : false : false;
    } };
  }(), "phoneInfoOptions"), Co2()] } });
  Y3(ch.prototype, { w: { name: "toJSON", j: [V3(null, true)] } });
  Y3(t.prototype, { toJSON: { name: "toJSON", j: [V3(null, true)] } });
  Y3(uh.prototype, { toJSON: { name: "toJSON", j: [V3(null, true)] } });
  Y3(th.prototype, { toJSON: { name: "toJSON", j: [V3(null, true)] } });
  Y3(gm.prototype, { toJSON: { name: "toJSON", j: [V3(null, true)] } });
  Y3(dm.prototype, { Qc: { name: "resolveSignIn", j: [yo2()] } });
  Y3(om.prototype, { Qb: { name: "getSession", j: [] }, ec: { name: "enroll", j: [yo2(), V3("displayName", true)] }, ad: { name: "unenroll", j: [X3({ name: "multiFactorInfo", J: "a valid multiFactorInfo", optional: false, K: Bo2 }, V3(), "multiFactorInfoIdentifier")] } });
  Y3(oo2.prototype, { clear: { name: "clear", j: [] }, render: { name: "render", j: [] }, verify: { name: "verify", j: [] } });
  Z3(Ff, "parseLink", Nf, [V3("link")]);
  Z3(Yn2, "assertion", function(a) {
    return new mm(a);
  }, [xo2("phone")]);
  (function() {
    if ("undefined" !== typeof import_app8.default && import_app8.default.INTERNAL && import_app8.default.INTERNAL.registerComponent) {
      var a = { ActionCodeInfo: { Operation: { EMAIL_SIGNIN: wf, PASSWORD_RESET: "PASSWORD_RESET", RECOVER_EMAIL: "RECOVER_EMAIL", REVERT_SECOND_FACTOR_ADDITION: yf, VERIFY_AND_CHANGE_EMAIL: xf, VERIFY_EMAIL: "VERIFY_EMAIL" } }, Auth: zn2, AuthCredential: xg, Error: t };
      Z3(a, "EmailAuthProvider", Vg, []);
      Z3(a, "FacebookAuthProvider", Mg, []);
      Z3(a, "GithubAuthProvider", Og, []);
      Z3(a, "GoogleAuthProvider", Qg, []);
      Z3(a, "TwitterAuthProvider", Sg, []);
      Z3(a, "OAuthProvider", Lg, [V3("providerId")]);
      Z3(a, "SAMLAuthProvider", Kg, [V3("providerId")]);
      Z3(a, "PhoneAuthProvider", hh, [vo2()]);
      Z3(a, "RecaptchaVerifier", oo2, [X3(V3(), uo2(), "recaptchaContainer"), W3("recaptchaParameters", true), wo2()]);
      Z3(a, "ActionCodeURL", Ff, []);
      Z3(a, "PhoneMultiFactorGenerator", Yn2, []);
      import_app8.default.INTERNAL.registerComponent({ name: "auth", instanceFactory: function(b2) {
        b2 = b2.getProvider("app").getImmediate();
        return new zn2(b2);
      }, multipleInstances: false, serviceProps: a, instantiationMode: "LAZY", type: "PUBLIC" });
      import_app8.default.INTERNAL.registerComponent({
        name: "auth-internal",
        instanceFactory: function(b2) {
          b2 = b2.getProvider("auth").getImmediate();
          return { getUid: q3(b2.getUid, b2), getToken: q3(b2.mc, b2), addAuthTokenListener: q3(b2.cc, b2), removeAuthTokenListener: q3(b2.Oc, b2) };
        },
        multipleInstances: false,
        instantiationMode: "LAZY",
        type: "PRIVATE"
      });
      import_app8.default.registerVersion("@firebase/auth", "0.15.0");
      import_app8.default.INTERNAL.extendNamespace({ User: Dm });
    } else
      throw Error("Cannot find the firebase namespace; be sure to include firebase-app.js before this library.");
  })();
}).apply(typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});

// node_modules/ng-fire-admin/node_modules/@angular/fire/auth/auth.module.js
var __decorate8 = function(decorators, target, key, desc) {
  var c = arguments.length, r2 = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d = decorators[i2])
        r2 = (c < 3 ? d(r2) : c > 3 ? d(target, key, r2) : d(target, key)) || r2;
  return c > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var AngularFireAuthModule = function() {
  function AngularFireAuthModule2() {
  }
  AngularFireAuthModule2 = __decorate8([
    NgModule({
      providers: [AngularFireAuth]
    })
  ], AngularFireAuthModule2);
  return AngularFireAuthModule2;
}();

// node_modules/angular-datatables/node_modules/tslib/tslib.es6.js
var extendStatics3 = function(d, b2) {
  extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
    d2.__proto__ = b3;
  } || function(d2, b3) {
    for (var p2 in b3)
      if (b3.hasOwnProperty(p2))
        d2[p2] = b3[p2];
  };
  return extendStatics3(d, b2);
};
function __extends3(d, b2) {
  extendStatics3(d, b2);
  function __() {
    this.constructor = d;
  }
  d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/util/isFunction.js
function isFunction2(x3) {
  return typeof x3 === "function";
}

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/config.js
var _enable_super_gross_mode_that_will_cause_bad_things = false;
var config = {
  Promise: void 0,
  set useDeprecatedSynchronousErrorHandling(value) {
    if (value) {
      var error = new Error();
      console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + error.stack);
    } else if (_enable_super_gross_mode_that_will_cause_bad_things) {
      console.log("RxJS: Back to a better error behavior. Thank you. <3");
    }
    _enable_super_gross_mode_that_will_cause_bad_things = value;
  },
  get useDeprecatedSynchronousErrorHandling() {
    return _enable_super_gross_mode_that_will_cause_bad_things;
  }
};

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/util/hostReportError.js
function hostReportError(err) {
  setTimeout(function() {
    throw err;
  });
}

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/Observer.js
var empty = {
  closed: true,
  next: function(value) {
  },
  error: function(err) {
    if (config.useDeprecatedSynchronousErrorHandling) {
      throw err;
    } else {
      hostReportError(err);
    }
  },
  complete: function() {
  }
};

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/util/isArray.js
var isArray = Array.isArray || function(x3) {
  return x3 && typeof x3.length === "number";
};

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/util/isObject.js
function isObject2(x3) {
  return x3 !== null && typeof x3 === "object";
}

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/util/UnsubscriptionError.js
function UnsubscriptionErrorImpl(errors) {
  Error.call(this);
  this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i2) {
    return i2 + 1 + ") " + err.toString();
  }).join("\n  ") : "";
  this.name = "UnsubscriptionError";
  this.errors = errors;
  return this;
}
UnsubscriptionErrorImpl.prototype = Object.create(Error.prototype);
var UnsubscriptionError = UnsubscriptionErrorImpl;

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/Subscription.js
var Subscription2 = function() {
  function Subscription3(unsubscribe) {
    this.closed = false;
    this._parent = null;
    this._parents = null;
    this._subscriptions = null;
    if (unsubscribe) {
      this._unsubscribe = unsubscribe;
    }
  }
  Subscription3.prototype.unsubscribe = function() {
    var hasErrors = false;
    var errors;
    if (this.closed) {
      return;
    }
    var _a3 = this, _parent = _a3._parent, _parents = _a3._parents, _unsubscribe = _a3._unsubscribe, _subscriptions = _a3._subscriptions;
    this.closed = true;
    this._parent = null;
    this._parents = null;
    this._subscriptions = null;
    var index = -1;
    var len = _parents ? _parents.length : 0;
    while (_parent) {
      _parent.remove(this);
      _parent = ++index < len && _parents[index] || null;
    }
    if (isFunction2(_unsubscribe)) {
      try {
        _unsubscribe.call(this);
      } catch (e) {
        hasErrors = true;
        errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
      }
    }
    if (isArray(_subscriptions)) {
      index = -1;
      len = _subscriptions.length;
      while (++index < len) {
        var sub = _subscriptions[index];
        if (isObject2(sub)) {
          try {
            sub.unsubscribe();
          } catch (e) {
            hasErrors = true;
            errors = errors || [];
            if (e instanceof UnsubscriptionError) {
              errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
            } else {
              errors.push(e);
            }
          }
        }
      }
    }
    if (hasErrors) {
      throw new UnsubscriptionError(errors);
    }
  };
  Subscription3.prototype.add = function(teardown) {
    var subscription = teardown;
    switch (typeof teardown) {
      case "function":
        subscription = new Subscription3(teardown);
      case "object":
        if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== "function") {
          return subscription;
        } else if (this.closed) {
          subscription.unsubscribe();
          return subscription;
        } else if (!(subscription instanceof Subscription3)) {
          var tmp = subscription;
          subscription = new Subscription3();
          subscription._subscriptions = [tmp];
        }
        break;
      default: {
        if (!teardown) {
          return Subscription3.EMPTY;
        }
        throw new Error("unrecognized teardown " + teardown + " added to Subscription.");
      }
    }
    if (subscription._addParent(this)) {
      var subscriptions = this._subscriptions;
      if (subscriptions) {
        subscriptions.push(subscription);
      } else {
        this._subscriptions = [subscription];
      }
    }
    return subscription;
  };
  Subscription3.prototype.remove = function(subscription) {
    var subscriptions = this._subscriptions;
    if (subscriptions) {
      var subscriptionIndex = subscriptions.indexOf(subscription);
      if (subscriptionIndex !== -1) {
        subscriptions.splice(subscriptionIndex, 1);
      }
    }
  };
  Subscription3.prototype._addParent = function(parent2) {
    var _a3 = this, _parent = _a3._parent, _parents = _a3._parents;
    if (_parent === parent2) {
      return false;
    } else if (!_parent) {
      this._parent = parent2;
      return true;
    } else if (!_parents) {
      this._parents = [parent2];
      return true;
    } else if (_parents.indexOf(parent2) === -1) {
      _parents.push(parent2);
      return true;
    }
    return false;
  };
  Subscription3.EMPTY = function(empty3) {
    empty3.closed = true;
    return empty3;
  }(new Subscription3());
  return Subscription3;
}();
function flattenUnsubscriptionErrors(errors) {
  return errors.reduce(function(errs, err) {
    return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);
  }, []);
}

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js
var rxSubscriber = typeof Symbol === "function" ? Symbol("rxSubscriber") : "@@rxSubscriber_" + Math.random();

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/Subscriber.js
var Subscriber = function(_super) {
  __extends3(Subscriber2, _super);
  function Subscriber2(destinationOrNext, error, complete) {
    var _this = _super.call(this) || this;
    _this.syncErrorValue = null;
    _this.syncErrorThrown = false;
    _this.syncErrorThrowable = false;
    _this.isStopped = false;
    switch (arguments.length) {
      case 0:
        _this.destination = empty;
        break;
      case 1:
        if (!destinationOrNext) {
          _this.destination = empty;
          break;
        }
        if (typeof destinationOrNext === "object") {
          if (destinationOrNext instanceof Subscriber2) {
            _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
            _this.destination = destinationOrNext;
            destinationOrNext.add(_this);
          } else {
            _this.syncErrorThrowable = true;
            _this.destination = new SafeSubscriber(_this, destinationOrNext);
          }
          break;
        }
      default:
        _this.syncErrorThrowable = true;
        _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
        break;
    }
    return _this;
  }
  Subscriber2.prototype[rxSubscriber] = function() {
    return this;
  };
  Subscriber2.create = function(next, error, complete) {
    var subscriber = new Subscriber2(next, error, complete);
    subscriber.syncErrorThrowable = false;
    return subscriber;
  };
  Subscriber2.prototype.next = function(value) {
    if (!this.isStopped) {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (!this.isStopped) {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (this.closed) {
      return;
    }
    this.isStopped = true;
    _super.prototype.unsubscribe.call(this);
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    this.destination.error(err);
    this.unsubscribe();
  };
  Subscriber2.prototype._complete = function() {
    this.destination.complete();
    this.unsubscribe();
  };
  Subscriber2.prototype._unsubscribeAndRecycle = function() {
    var _a3 = this, _parent = _a3._parent, _parents = _a3._parents;
    this._parent = null;
    this._parents = null;
    this.unsubscribe();
    this.closed = false;
    this.isStopped = false;
    this._parent = _parent;
    this._parents = _parents;
    return this;
  };
  return Subscriber2;
}(Subscription2);
var SafeSubscriber = function(_super) {
  __extends3(SafeSubscriber2, _super);
  function SafeSubscriber2(_parentSubscriber, observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    _this._parentSubscriber = _parentSubscriber;
    var next;
    var context = _this;
    if (isFunction2(observerOrNext)) {
      next = observerOrNext;
    } else if (observerOrNext) {
      next = observerOrNext.next;
      error = observerOrNext.error;
      complete = observerOrNext.complete;
      if (observerOrNext !== empty) {
        context = Object.create(observerOrNext);
        if (isFunction2(context.unsubscribe)) {
          _this.add(context.unsubscribe.bind(context));
        }
        context.unsubscribe = _this.unsubscribe.bind(_this);
      }
    }
    _this._context = context;
    _this._next = next;
    _this._error = error;
    _this._complete = complete;
    return _this;
  }
  SafeSubscriber2.prototype.next = function(value) {
    if (!this.isStopped && this._next) {
      var _parentSubscriber = this._parentSubscriber;
      if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
        this.__tryOrUnsub(this._next, value);
      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
        this.unsubscribe();
      }
    }
  };
  SafeSubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var _parentSubscriber = this._parentSubscriber;
      var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;
      if (this._error) {
        if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
          this.__tryOrUnsub(this._error, err);
          this.unsubscribe();
        } else {
          this.__tryOrSetError(_parentSubscriber, this._error, err);
          this.unsubscribe();
        }
      } else if (!_parentSubscriber.syncErrorThrowable) {
        this.unsubscribe();
        if (useDeprecatedSynchronousErrorHandling) {
          throw err;
        }
        hostReportError(err);
      } else {
        if (useDeprecatedSynchronousErrorHandling) {
          _parentSubscriber.syncErrorValue = err;
          _parentSubscriber.syncErrorThrown = true;
        } else {
          hostReportError(err);
        }
        this.unsubscribe();
      }
    }
  };
  SafeSubscriber2.prototype.complete = function() {
    var _this = this;
    if (!this.isStopped) {
      var _parentSubscriber = this._parentSubscriber;
      if (this._complete) {
        var wrappedComplete = function() {
          return _this._complete.call(_this._context);
        };
        if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
          this.__tryOrUnsub(wrappedComplete);
          this.unsubscribe();
        } else {
          this.__tryOrSetError(_parentSubscriber, wrappedComplete);
          this.unsubscribe();
        }
      } else {
        this.unsubscribe();
      }
    }
  };
  SafeSubscriber2.prototype.__tryOrUnsub = function(fn2, value) {
    try {
      fn2.call(this._context, value);
    } catch (err) {
      this.unsubscribe();
      if (config.useDeprecatedSynchronousErrorHandling) {
        throw err;
      } else {
        hostReportError(err);
      }
    }
  };
  SafeSubscriber2.prototype.__tryOrSetError = function(parent2, fn2, value) {
    if (!config.useDeprecatedSynchronousErrorHandling) {
      throw new Error("bad call");
    }
    try {
      fn2.call(this._context, value);
    } catch (err) {
      if (config.useDeprecatedSynchronousErrorHandling) {
        parent2.syncErrorValue = err;
        parent2.syncErrorThrown = true;
        return true;
      } else {
        hostReportError(err);
        return true;
      }
    }
    return false;
  };
  SafeSubscriber2.prototype._unsubscribe = function() {
    var _parentSubscriber = this._parentSubscriber;
    this._context = null;
    this._parentSubscriber = null;
    _parentSubscriber.unsubscribe();
  };
  return SafeSubscriber2;
}(Subscriber);

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/util/canReportError.js
function canReportError(observer) {
  while (observer) {
    var _a3 = observer, closed_1 = _a3.closed, destination = _a3.destination, isStopped = _a3.isStopped;
    if (closed_1 || isStopped) {
      return false;
    } else if (destination && destination instanceof Subscriber) {
      observer = destination;
    } else {
      observer = null;
    }
  }
  return true;
}

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/util/toSubscriber.js
function toSubscriber(nextOrObserver, error, complete) {
  if (nextOrObserver) {
    if (nextOrObserver instanceof Subscriber) {
      return nextOrObserver;
    }
    if (nextOrObserver[rxSubscriber]) {
      return nextOrObserver[rxSubscriber]();
    }
  }
  if (!nextOrObserver && !error && !complete) {
    return new Subscriber(empty);
  }
  return new Subscriber(nextOrObserver, error, complete);
}

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/symbol/observable.js
var observable = typeof Symbol === "function" && Symbol.observable || "@@observable";

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/util/noop.js
function noop3() {
}

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/util/pipe.js
function pipeFromArray(fns) {
  if (!fns) {
    return noop3;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn2) {
      return fn2(prev);
    }, input);
  };
}

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/Observable.js
var Observable2 = function() {
  function Observable3(subscribe) {
    this._isScalar = false;
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable3.prototype.lift = function(operator) {
    var observable2 = new Observable3();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable3.prototype.subscribe = function(observerOrNext, error, complete) {
    var operator = this.operator;
    var sink = toSubscriber(observerOrNext, error, complete);
    if (operator) {
      sink.add(operator.call(sink, this.source));
    } else {
      sink.add(this.source || config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
    }
    if (config.useDeprecatedSynchronousErrorHandling) {
      if (sink.syncErrorThrowable) {
        sink.syncErrorThrowable = false;
        if (sink.syncErrorThrown) {
          throw sink.syncErrorValue;
        }
      }
    }
    return sink;
  };
  Observable3.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      if (config.useDeprecatedSynchronousErrorHandling) {
        sink.syncErrorThrown = true;
        sink.syncErrorValue = err;
      }
      if (canReportError(sink)) {
        sink.error(err);
      } else {
        console.warn(err);
      }
    }
  };
  Observable3.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve2, reject) {
      var subscription;
      subscription = _this.subscribe(function(value) {
        try {
          next(value);
        } catch (err) {
          reject(err);
          if (subscription) {
            subscription.unsubscribe();
          }
        }
      }, reject, resolve2);
    });
  };
  Observable3.prototype._subscribe = function(subscriber) {
    var source = this.source;
    return source && source.subscribe(subscriber);
  };
  Observable3.prototype[observable] = function() {
    return this;
  };
  Observable3.prototype.pipe = function() {
    var operations = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      operations[_i2] = arguments[_i2];
    }
    if (operations.length === 0) {
      return this;
    }
    return pipeFromArray(operations)(this);
  };
  Observable3.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve2, reject) {
      var value;
      _this.subscribe(function(x3) {
        return value = x3;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve2(value);
      });
    });
  };
  Observable3.create = function(subscribe) {
    return new Observable3(subscribe);
  };
  return Observable3;
}();
function getPromiseCtor(promiseCtor) {
  if (!promiseCtor) {
    promiseCtor = config.Promise || Promise;
  }
  if (!promiseCtor) {
    throw new Error("no Promise impl found");
  }
  return promiseCtor;
}

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js
function ObjectUnsubscribedErrorImpl() {
  Error.call(this);
  this.message = "object unsubscribed";
  this.name = "ObjectUnsubscribedError";
  return this;
}
ObjectUnsubscribedErrorImpl.prototype = Object.create(Error.prototype);
var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/SubjectSubscription.js
var SubjectSubscription = function(_super) {
  __extends3(SubjectSubscription2, _super);
  function SubjectSubscription2(subject, subscriber) {
    var _this = _super.call(this) || this;
    _this.subject = subject;
    _this.subscriber = subscriber;
    _this.closed = false;
    return _this;
  }
  SubjectSubscription2.prototype.unsubscribe = function() {
    if (this.closed) {
      return;
    }
    this.closed = true;
    var subject = this.subject;
    var observers = subject.observers;
    this.subject = null;
    if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
      return;
    }
    var subscriberIndex = observers.indexOf(this.subscriber);
    if (subscriberIndex !== -1) {
      observers.splice(subscriberIndex, 1);
    }
  };
  return SubjectSubscription2;
}(Subscription2);

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/Subject.js
var SubjectSubscriber = function(_super) {
  __extends3(SubjectSubscriber2, _super);
  function SubjectSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    return _this;
  }
  return SubjectSubscriber2;
}(Subscriber);
var Subject2 = function(_super) {
  __extends3(Subject3, _super);
  function Subject3() {
    var _this = _super.call(this) || this;
    _this.observers = [];
    _this.closed = false;
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject3.prototype[rxSubscriber] = function() {
    return new SubjectSubscriber(this);
  };
  Subject3.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject3.prototype.next = function(value) {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
    if (!this.isStopped) {
      var observers = this.observers;
      var len = observers.length;
      var copy = observers.slice();
      for (var i2 = 0; i2 < len; i2++) {
        copy[i2].next(value);
      }
    }
  };
  Subject3.prototype.error = function(err) {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
    this.hasError = true;
    this.thrownError = err;
    this.isStopped = true;
    var observers = this.observers;
    var len = observers.length;
    var copy = observers.slice();
    for (var i2 = 0; i2 < len; i2++) {
      copy[i2].error(err);
    }
    this.observers.length = 0;
  };
  Subject3.prototype.complete = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
    this.isStopped = true;
    var observers = this.observers;
    var len = observers.length;
    var copy = observers.slice();
    for (var i2 = 0; i2 < len; i2++) {
      copy[i2].complete();
    }
    this.observers.length = 0;
  };
  Subject3.prototype.unsubscribe = function() {
    this.isStopped = true;
    this.closed = true;
    this.observers = null;
  };
  Subject3.prototype._trySubscribe = function(subscriber) {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else {
      return _super.prototype._trySubscribe.call(this, subscriber);
    }
  };
  Subject3.prototype._subscribe = function(subscriber) {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else if (this.hasError) {
      subscriber.error(this.thrownError);
      return Subscription2.EMPTY;
    } else if (this.isStopped) {
      subscriber.complete();
      return Subscription2.EMPTY;
    } else {
      this.observers.push(subscriber);
      return new SubjectSubscription(this, subscriber);
    }
  };
  Subject3.prototype.asObservable = function() {
    var observable2 = new Observable2();
    observable2.source = this;
    return observable2;
  };
  Subject3.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject3;
}(Observable2);
var AnonymousSubject = function(_super) {
  __extends3(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var destination = this.destination;
    if (destination && destination.next) {
      destination.next(value);
    }
  };
  AnonymousSubject2.prototype.error = function(err) {
    var destination = this.destination;
    if (destination && destination.error) {
      this.destination.error(err);
    }
  };
  AnonymousSubject2.prototype.complete = function() {
    var destination = this.destination;
    if (destination && destination.complete) {
      this.destination.complete();
    }
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var source = this.source;
    if (source) {
      return this.source.subscribe(subscriber);
    } else {
      return Subscription2.EMPTY;
    }
  };
  return AnonymousSubject2;
}(Subject2);

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/operators/refCount.js
function refCount() {
  return function refCountOperatorFunction(source) {
    return source.lift(new RefCountOperator(source));
  };
}
var RefCountOperator = function() {
  function RefCountOperator3(connectable) {
    this.connectable = connectable;
  }
  RefCountOperator3.prototype.call = function(subscriber, source) {
    var connectable = this.connectable;
    connectable._refCount++;
    var refCounter = new RefCountSubscriber(subscriber, connectable);
    var subscription = source.subscribe(refCounter);
    if (!refCounter.closed) {
      refCounter.connection = connectable.connect();
    }
    return subscription;
  };
  return RefCountOperator3;
}();
var RefCountSubscriber = function(_super) {
  __extends3(RefCountSubscriber3, _super);
  function RefCountSubscriber3(destination, connectable) {
    var _this = _super.call(this, destination) || this;
    _this.connectable = connectable;
    return _this;
  }
  RefCountSubscriber3.prototype._unsubscribe = function() {
    var connectable = this.connectable;
    if (!connectable) {
      this.connection = null;
      return;
    }
    this.connectable = null;
    var refCount2 = connectable._refCount;
    if (refCount2 <= 0) {
      this.connection = null;
      return;
    }
    connectable._refCount = refCount2 - 1;
    if (refCount2 > 1) {
      this.connection = null;
      return;
    }
    var connection = this.connection;
    var sharedConnection = connectable._connection;
    this.connection = null;
    if (sharedConnection && (!connection || sharedConnection === connection)) {
      sharedConnection.unsubscribe();
    }
  };
  return RefCountSubscriber3;
}(Subscriber);

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/observable/ConnectableObservable.js
var ConnectableObservable = function(_super) {
  __extends3(ConnectableObservable2, _super);
  function ConnectableObservable2(source, subjectFactory) {
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.subjectFactory = subjectFactory;
    _this._refCount = 0;
    _this._isComplete = false;
    return _this;
  }
  ConnectableObservable2.prototype._subscribe = function(subscriber) {
    return this.getSubject().subscribe(subscriber);
  };
  ConnectableObservable2.prototype.getSubject = function() {
    var subject = this._subject;
    if (!subject || subject.isStopped) {
      this._subject = this.subjectFactory();
    }
    return this._subject;
  };
  ConnectableObservable2.prototype.connect = function() {
    var connection = this._connection;
    if (!connection) {
      this._isComplete = false;
      connection = this._connection = new Subscription2();
      connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));
      if (connection.closed) {
        this._connection = null;
        connection = Subscription2.EMPTY;
      } else {
        this._connection = connection;
      }
    }
    return connection;
  };
  ConnectableObservable2.prototype.refCount = function() {
    return refCount()(this);
  };
  return ConnectableObservable2;
}(Observable2);
var connectableProto = ConnectableObservable.prototype;
var connectableObservableDescriptor = {
  operator: { value: null },
  _refCount: { value: 0, writable: true },
  _subject: { value: null, writable: true },
  _connection: { value: null, writable: true },
  _subscribe: { value: connectableProto._subscribe },
  _isComplete: { value: connectableProto._isComplete, writable: true },
  getSubject: { value: connectableProto.getSubject },
  connect: { value: connectableProto.connect },
  refCount: { value: connectableProto.refCount }
};
var ConnectableSubscriber = function(_super) {
  __extends3(ConnectableSubscriber2, _super);
  function ConnectableSubscriber2(destination, connectable) {
    var _this = _super.call(this, destination) || this;
    _this.connectable = connectable;
    return _this;
  }
  ConnectableSubscriber2.prototype._error = function(err) {
    this._unsubscribe();
    _super.prototype._error.call(this, err);
  };
  ConnectableSubscriber2.prototype._complete = function() {
    this.connectable._isComplete = true;
    this._unsubscribe();
    _super.prototype._complete.call(this);
  };
  ConnectableSubscriber2.prototype._unsubscribe = function() {
    var connectable = this.connectable;
    if (connectable) {
      this.connectable = null;
      var connection = connectable._connection;
      connectable._refCount = 0;
      connectable._subject = null;
      connectable._connection = null;
      if (connection) {
        connection.unsubscribe();
      }
    }
  };
  return ConnectableSubscriber2;
}(SubjectSubscriber);
var RefCountOperator2 = function() {
  function RefCountOperator3(connectable) {
    this.connectable = connectable;
  }
  RefCountOperator3.prototype.call = function(subscriber, source) {
    var connectable = this.connectable;
    connectable._refCount++;
    var refCounter = new RefCountSubscriber2(subscriber, connectable);
    var subscription = source.subscribe(refCounter);
    if (!refCounter.closed) {
      refCounter.connection = connectable.connect();
    }
    return subscription;
  };
  return RefCountOperator3;
}();
var RefCountSubscriber2 = function(_super) {
  __extends3(RefCountSubscriber3, _super);
  function RefCountSubscriber3(destination, connectable) {
    var _this = _super.call(this, destination) || this;
    _this.connectable = connectable;
    return _this;
  }
  RefCountSubscriber3.prototype._unsubscribe = function() {
    var connectable = this.connectable;
    if (!connectable) {
      this.connection = null;
      return;
    }
    this.connectable = null;
    var refCount2 = connectable._refCount;
    if (refCount2 <= 0) {
      this.connection = null;
      return;
    }
    connectable._refCount = refCount2 - 1;
    if (refCount2 > 1) {
      this.connection = null;
      return;
    }
    var connection = this.connection;
    var sharedConnection = connectable._connection;
    this.connection = null;
    if (sharedConnection && (!connection || sharedConnection === connection)) {
      sharedConnection.unsubscribe();
    }
  };
  return RefCountSubscriber3;
}(Subscriber);

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/operators/groupBy.js
var GroupByOperator = function() {
  function GroupByOperator2(keySelector, elementSelector, durationSelector, subjectSelector) {
    this.keySelector = keySelector;
    this.elementSelector = elementSelector;
    this.durationSelector = durationSelector;
    this.subjectSelector = subjectSelector;
  }
  GroupByOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
  };
  return GroupByOperator2;
}();
var GroupBySubscriber = function(_super) {
  __extends3(GroupBySubscriber2, _super);
  function GroupBySubscriber2(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
    var _this = _super.call(this, destination) || this;
    _this.keySelector = keySelector;
    _this.elementSelector = elementSelector;
    _this.durationSelector = durationSelector;
    _this.subjectSelector = subjectSelector;
    _this.groups = null;
    _this.attemptedToUnsubscribe = false;
    _this.count = 0;
    return _this;
  }
  GroupBySubscriber2.prototype._next = function(value) {
    var key;
    try {
      key = this.keySelector(value);
    } catch (err) {
      this.error(err);
      return;
    }
    this._group(value, key);
  };
  GroupBySubscriber2.prototype._group = function(value, key) {
    var groups = this.groups;
    if (!groups) {
      groups = this.groups = /* @__PURE__ */ new Map();
    }
    var group = groups.get(key);
    var element;
    if (this.elementSelector) {
      try {
        element = this.elementSelector(value);
      } catch (err) {
        this.error(err);
      }
    } else {
      element = value;
    }
    if (!group) {
      group = this.subjectSelector ? this.subjectSelector() : new Subject2();
      groups.set(key, group);
      var groupedObservable = new GroupedObservable(key, group, this);
      this.destination.next(groupedObservable);
      if (this.durationSelector) {
        var duration = void 0;
        try {
          duration = this.durationSelector(new GroupedObservable(key, group));
        } catch (err) {
          this.error(err);
          return;
        }
        this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
      }
    }
    if (!group.closed) {
      group.next(element);
    }
  };
  GroupBySubscriber2.prototype._error = function(err) {
    var groups = this.groups;
    if (groups) {
      groups.forEach(function(group, key) {
        group.error(err);
      });
      groups.clear();
    }
    this.destination.error(err);
  };
  GroupBySubscriber2.prototype._complete = function() {
    var groups = this.groups;
    if (groups) {
      groups.forEach(function(group, key) {
        group.complete();
      });
      groups.clear();
    }
    this.destination.complete();
  };
  GroupBySubscriber2.prototype.removeGroup = function(key) {
    this.groups.delete(key);
  };
  GroupBySubscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.attemptedToUnsubscribe = true;
      if (this.count === 0) {
        _super.prototype.unsubscribe.call(this);
      }
    }
  };
  return GroupBySubscriber2;
}(Subscriber);
var GroupDurationSubscriber = function(_super) {
  __extends3(GroupDurationSubscriber2, _super);
  function GroupDurationSubscriber2(key, group, parent2) {
    var _this = _super.call(this, group) || this;
    _this.key = key;
    _this.group = group;
    _this.parent = parent2;
    return _this;
  }
  GroupDurationSubscriber2.prototype._next = function(value) {
    this.complete();
  };
  GroupDurationSubscriber2.prototype._unsubscribe = function() {
    var _a3 = this, parent2 = _a3.parent, key = _a3.key;
    this.key = this.parent = null;
    if (parent2) {
      parent2.removeGroup(key);
    }
  };
  return GroupDurationSubscriber2;
}(Subscriber);
var GroupedObservable = function(_super) {
  __extends3(GroupedObservable2, _super);
  function GroupedObservable2(key, groupSubject, refCountSubscription) {
    var _this = _super.call(this) || this;
    _this.key = key;
    _this.groupSubject = groupSubject;
    _this.refCountSubscription = refCountSubscription;
    return _this;
  }
  GroupedObservable2.prototype._subscribe = function(subscriber) {
    var subscription = new Subscription2();
    var _a3 = this, refCountSubscription = _a3.refCountSubscription, groupSubject = _a3.groupSubject;
    if (refCountSubscription && !refCountSubscription.closed) {
      subscription.add(new InnerRefCountSubscription(refCountSubscription));
    }
    subscription.add(groupSubject.subscribe(subscriber));
    return subscription;
  };
  return GroupedObservable2;
}(Observable2);
var InnerRefCountSubscription = function(_super) {
  __extends3(InnerRefCountSubscription2, _super);
  function InnerRefCountSubscription2(parent2) {
    var _this = _super.call(this) || this;
    _this.parent = parent2;
    parent2.count++;
    return _this;
  }
  InnerRefCountSubscription2.prototype.unsubscribe = function() {
    var parent2 = this.parent;
    if (!parent2.closed && !this.closed) {
      _super.prototype.unsubscribe.call(this);
      parent2.count -= 1;
      if (parent2.count === 0 && parent2.attemptedToUnsubscribe) {
        parent2.unsubscribe();
      }
    }
  };
  return InnerRefCountSubscription2;
}(Subscription2);

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/BehaviorSubject.js
var BehaviorSubject = function(_super) {
  __extends3(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: true,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    if (subscription && !subscription.closed) {
      subscriber.next(this._value);
    }
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    if (this.hasError) {
      throw this.thrownError;
    } else if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else {
      return this._value;
    }
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
}(Subject2);

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/scheduler/Action.js
var Action = function(_super) {
  __extends3(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    return this;
  };
  return Action2;
}(Subscription2);

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js
var AsyncAction = function(_super) {
  __extends3(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state;
    var id2 = this.id;
    var scheduler = this.scheduler;
    if (id2 != null) {
      this.id = this.recycleAsyncId(scheduler, id2, delay);
    }
    this.pending = true;
    this.delay = delay;
    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, id2, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    return setInterval(scheduler.flush.bind(scheduler, this), delay);
  };
  AsyncAction2.prototype.recycleAsyncId = function(scheduler, id2, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    if (delay !== null && this.delay === delay && this.pending === false) {
      return id2;
    }
    clearInterval(id2);
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state, delay) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state, delay);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state, delay) {
    var errored = false;
    var errorValue = void 0;
    try {
      this.work(state);
    } catch (e) {
      errored = true;
      errorValue = !!e && e || new Error(e);
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype._unsubscribe = function() {
    var id2 = this.id;
    var scheduler = this.scheduler;
    var actions = scheduler.actions;
    var index = actions.indexOf(this);
    this.work = null;
    this.state = null;
    this.pending = false;
    this.scheduler = null;
    if (index !== -1) {
      actions.splice(index, 1);
    }
    if (id2 != null) {
      this.id = this.recycleAsyncId(scheduler, id2, null);
    }
    this.delay = null;
  };
  return AsyncAction2;
}(Action);

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/scheduler/QueueAction.js
var QueueAction = function(_super) {
  __extends3(QueueAction2, _super);
  function QueueAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  QueueAction2.prototype.schedule = function(state, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    if (delay > 0) {
      return _super.prototype.schedule.call(this, state, delay);
    }
    this.delay = delay;
    this.state = state;
    this.scheduler.flush(this);
    return this;
  };
  QueueAction2.prototype.execute = function(state, delay) {
    return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);
  };
  QueueAction2.prototype.requestAsyncId = function(scheduler, id2, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay);
    }
    return scheduler.flush(this);
  };
  return QueueAction2;
}(AsyncAction);

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/Scheduler.js
var Scheduler = function() {
  function Scheduler2(SchedulerAction, now2) {
    if (now2 === void 0) {
      now2 = Scheduler2.now;
    }
    this.SchedulerAction = SchedulerAction;
    this.now = now2;
  }
  Scheduler2.prototype.schedule = function(work, delay, state) {
    if (delay === void 0) {
      delay = 0;
    }
    return new this.SchedulerAction(this, work).schedule(state, delay);
  };
  Scheduler2.now = function() {
    return Date.now();
  };
  return Scheduler2;
}();

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js
var AsyncScheduler = function(_super) {
  __extends3(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now2) {
    if (now2 === void 0) {
      now2 = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, function() {
      if (AsyncScheduler2.delegate && AsyncScheduler2.delegate !== _this) {
        return AsyncScheduler2.delegate.now();
      } else {
        return now2();
      }
    }) || this;
    _this.actions = [];
    _this.active = false;
    _this.scheduled = void 0;
    return _this;
  }
  AsyncScheduler2.prototype.schedule = function(work, delay, state) {
    if (delay === void 0) {
      delay = 0;
    }
    if (AsyncScheduler2.delegate && AsyncScheduler2.delegate !== this) {
      return AsyncScheduler2.delegate.schedule(work, delay, state);
    } else {
      return _super.prototype.schedule.call(this, work, delay, state);
    }
  };
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this.active) {
      actions.push(action);
      return;
    }
    var error;
    this.active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this.active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
}(Scheduler);

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/scheduler/QueueScheduler.js
var QueueScheduler = function(_super) {
  __extends3(QueueScheduler2, _super);
  function QueueScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return QueueScheduler2;
}(AsyncScheduler);

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/scheduler/queue.js
var queue = new QueueScheduler(QueueAction);

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/observable/empty.js
var EMPTY = new Observable2(function(subscriber) {
  return subscriber.complete();
});
function empty2(scheduler) {
  return scheduler ? emptyScheduled(scheduler) : EMPTY;
}
function emptyScheduled(scheduler) {
  return new Observable2(function(subscriber) {
    return scheduler.schedule(function() {
      return subscriber.complete();
    });
  });
}

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/util/isScheduler.js
function isScheduler(value) {
  return value && typeof value.schedule === "function";
}

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/util/subscribeToArray.js
var subscribeToArray = function(array) {
  return function(subscriber) {
    for (var i2 = 0, len = array.length; i2 < len && !subscriber.closed; i2++) {
      subscriber.next(array[i2]);
    }
    if (!subscriber.closed) {
      subscriber.complete();
    }
  };
};

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/observable/fromArray.js
function fromArray(input, scheduler) {
  if (!scheduler) {
    return new Observable2(subscribeToArray(input));
  } else {
    return new Observable2(function(subscriber) {
      var sub = new Subscription2();
      var i2 = 0;
      sub.add(scheduler.schedule(function() {
        if (i2 === input.length) {
          subscriber.complete();
          return;
        }
        subscriber.next(input[i2++]);
        if (!subscriber.closed) {
          sub.add(this.schedule());
        }
      }));
      return sub;
    });
  }
}

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/observable/scalar.js
function scalar(value) {
  var result = new Observable2(function(subscriber) {
    subscriber.next(value);
    subscriber.complete();
  });
  result._isScalar = true;
  result.value = value;
  return result;
}

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/observable/of.js
function of2() {
  var args = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    args[_i2] = arguments[_i2];
  }
  var scheduler = args[args.length - 1];
  if (isScheduler(scheduler)) {
    args.pop();
  } else {
    scheduler = void 0;
  }
  switch (args.length) {
    case 0:
      return empty2(scheduler);
    case 1:
      return scheduler ? fromArray(args, scheduler) : scalar(args[0]);
    default:
      return fromArray(args, scheduler);
  }
}

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/observable/throwError.js
function throwError(error, scheduler) {
  if (!scheduler) {
    return new Observable2(function(subscriber) {
      return subscriber.error(error);
    });
  } else {
    return new Observable2(function(subscriber) {
      return scheduler.schedule(dispatch, 0, { error, subscriber });
    });
  }
}
function dispatch(_a3) {
  var error = _a3.error, subscriber = _a3.subscriber;
  subscriber.error(error);
}

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/Notification.js
var NotificationKind;
(function(NotificationKind2) {
  NotificationKind2["NEXT"] = "N";
  NotificationKind2["ERROR"] = "E";
  NotificationKind2["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
var Notification = function() {
  function Notification2(kind, value, error) {
    this.kind = kind;
    this.value = value;
    this.error = error;
    this.hasValue = kind === "N";
  }
  Notification2.prototype.observe = function(observer) {
    switch (this.kind) {
      case "N":
        return observer.next && observer.next(this.value);
      case "E":
        return observer.error && observer.error(this.error);
      case "C":
        return observer.complete && observer.complete();
    }
  };
  Notification2.prototype.do = function(next, error, complete) {
    var kind = this.kind;
    switch (kind) {
      case "N":
        return next && next(this.value);
      case "E":
        return error && error(this.error);
      case "C":
        return complete && complete();
    }
  };
  Notification2.prototype.accept = function(nextOrObserver, error, complete) {
    if (nextOrObserver && typeof nextOrObserver.next === "function") {
      return this.observe(nextOrObserver);
    } else {
      return this.do(nextOrObserver, error, complete);
    }
  };
  Notification2.prototype.toObservable = function() {
    var kind = this.kind;
    switch (kind) {
      case "N":
        return of2(this.value);
      case "E":
        return throwError(this.error);
      case "C":
        return empty2();
    }
    throw new Error("unexpected notification kind value");
  };
  Notification2.createNext = function(value) {
    if (typeof value !== "undefined") {
      return new Notification2("N", value);
    }
    return Notification2.undefinedValueNotification;
  };
  Notification2.createError = function(err) {
    return new Notification2("E", void 0, err);
  };
  Notification2.createComplete = function() {
    return Notification2.completeNotification;
  };
  Notification2.completeNotification = new Notification2("C");
  Notification2.undefinedValueNotification = new Notification2("N", void 0);
  return Notification2;
}();

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/operators/observeOn.js
var ObserveOnOperator = function() {
  function ObserveOnOperator2(scheduler, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    this.scheduler = scheduler;
    this.delay = delay;
  }
  ObserveOnOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
  };
  return ObserveOnOperator2;
}();
var ObserveOnSubscriber = function(_super) {
  __extends3(ObserveOnSubscriber2, _super);
  function ObserveOnSubscriber2(destination, scheduler, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    var _this = _super.call(this, destination) || this;
    _this.scheduler = scheduler;
    _this.delay = delay;
    return _this;
  }
  ObserveOnSubscriber2.dispatch = function(arg) {
    var notification = arg.notification, destination = arg.destination;
    notification.observe(destination);
    this.unsubscribe();
  };
  ObserveOnSubscriber2.prototype.scheduleMessage = function(notification) {
    var destination = this.destination;
    destination.add(this.scheduler.schedule(ObserveOnSubscriber2.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
  };
  ObserveOnSubscriber2.prototype._next = function(value) {
    this.scheduleMessage(Notification.createNext(value));
  };
  ObserveOnSubscriber2.prototype._error = function(err) {
    this.scheduleMessage(Notification.createError(err));
    this.unsubscribe();
  };
  ObserveOnSubscriber2.prototype._complete = function() {
    this.scheduleMessage(Notification.createComplete());
    this.unsubscribe();
  };
  return ObserveOnSubscriber2;
}(Subscriber);
var ObserveOnMessage = /* @__PURE__ */ function() {
  function ObserveOnMessage2(notification, destination) {
    this.notification = notification;
    this.destination = destination;
  }
  return ObserveOnMessage2;
}();

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/ReplaySubject.js
var ReplaySubject = function(_super) {
  __extends3(ReplaySubject2, _super);
  function ReplaySubject2(bufferSize, windowTime, scheduler) {
    if (bufferSize === void 0) {
      bufferSize = Number.POSITIVE_INFINITY;
    }
    if (windowTime === void 0) {
      windowTime = Number.POSITIVE_INFINITY;
    }
    var _this = _super.call(this) || this;
    _this.scheduler = scheduler;
    _this._events = [];
    _this._infiniteTimeWindow = false;
    _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
    _this._windowTime = windowTime < 1 ? 1 : windowTime;
    if (windowTime === Number.POSITIVE_INFINITY) {
      _this._infiniteTimeWindow = true;
      _this.next = _this.nextInfiniteTimeWindow;
    } else {
      _this.next = _this.nextTimeWindow;
    }
    return _this;
  }
  ReplaySubject2.prototype.nextInfiniteTimeWindow = function(value) {
    var _events = this._events;
    _events.push(value);
    if (_events.length > this._bufferSize) {
      _events.shift();
    }
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype.nextTimeWindow = function(value) {
    this._events.push(new ReplayEvent(this._getNow(), value));
    this._trimBufferThenGetEvents();
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    var _infiniteTimeWindow = this._infiniteTimeWindow;
    var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
    var scheduler = this.scheduler;
    var len = _events.length;
    var subscription;
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else if (this.isStopped || this.hasError) {
      subscription = Subscription2.EMPTY;
    } else {
      this.observers.push(subscriber);
      subscription = new SubjectSubscription(this, subscriber);
    }
    if (scheduler) {
      subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));
    }
    if (_infiniteTimeWindow) {
      for (var i2 = 0; i2 < len && !subscriber.closed; i2++) {
        subscriber.next(_events[i2]);
      }
    } else {
      for (var i2 = 0; i2 < len && !subscriber.closed; i2++) {
        subscriber.next(_events[i2].value);
      }
    }
    if (this.hasError) {
      subscriber.error(this.thrownError);
    } else if (this.isStopped) {
      subscriber.complete();
    }
    return subscription;
  };
  ReplaySubject2.prototype._getNow = function() {
    return (this.scheduler || queue).now();
  };
  ReplaySubject2.prototype._trimBufferThenGetEvents = function() {
    var now2 = this._getNow();
    var _bufferSize = this._bufferSize;
    var _windowTime = this._windowTime;
    var _events = this._events;
    var eventsCount = _events.length;
    var spliceCount = 0;
    while (spliceCount < eventsCount) {
      if (now2 - _events[spliceCount].time < _windowTime) {
        break;
      }
      spliceCount++;
    }
    if (eventsCount > _bufferSize) {
      spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
    }
    if (spliceCount > 0) {
      _events.splice(0, spliceCount);
    }
    return _events;
  };
  return ReplaySubject2;
}(Subject2);
var ReplayEvent = /* @__PURE__ */ function() {
  function ReplayEvent2(time, value) {
    this.time = time;
    this.value = value;
  }
  return ReplayEvent2;
}();

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/AsyncSubject.js
var AsyncSubject = function(_super) {
  __extends3(AsyncSubject2, _super);
  function AsyncSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.value = null;
    _this.hasNext = false;
    _this.hasCompleted = false;
    return _this;
  }
  AsyncSubject2.prototype._subscribe = function(subscriber) {
    if (this.hasError) {
      subscriber.error(this.thrownError);
      return Subscription2.EMPTY;
    } else if (this.hasCompleted && this.hasNext) {
      subscriber.next(this.value);
      subscriber.complete();
      return Subscription2.EMPTY;
    }
    return _super.prototype._subscribe.call(this, subscriber);
  };
  AsyncSubject2.prototype.next = function(value) {
    if (!this.hasCompleted) {
      this.value = value;
      this.hasNext = true;
    }
  };
  AsyncSubject2.prototype.error = function(error) {
    if (!this.hasCompleted) {
      _super.prototype.error.call(this, error);
    }
  };
  AsyncSubject2.prototype.complete = function() {
    this.hasCompleted = true;
    if (this.hasNext) {
      _super.prototype.next.call(this, this.value);
    }
    _super.prototype.complete.call(this);
  };
  return AsyncSubject2;
}(Subject2);

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/util/Immediate.js
var nextHandle = 1;
var tasksByHandle = {};
function runIfPresent(handle) {
  var cb2 = tasksByHandle[handle];
  if (cb2) {
    cb2();
  }
}
var Immediate = {
  setImmediate: function(cb2) {
    var handle = nextHandle++;
    tasksByHandle[handle] = cb2;
    Promise.resolve().then(function() {
      return runIfPresent(handle);
    });
    return handle;
  },
  clearImmediate: function(handle) {
    delete tasksByHandle[handle];
  }
};

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/scheduler/AsapAction.js
var AsapAction = function(_super) {
  __extends3(AsapAction2, _super);
  function AsapAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AsapAction2.prototype.requestAsyncId = function(scheduler, id2, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    if (delay !== null && delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay);
    }
    scheduler.actions.push(this);
    return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
  };
  AsapAction2.prototype.recycleAsyncId = function(scheduler, id2, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id2, delay);
    }
    if (scheduler.actions.length === 0) {
      Immediate.clearImmediate(id2);
      scheduler.scheduled = void 0;
    }
    return void 0;
  };
  return AsapAction2;
}(AsyncAction);

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/scheduler/AsapScheduler.js
var AsapScheduler = function(_super) {
  __extends3(AsapScheduler2, _super);
  function AsapScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AsapScheduler2.prototype.flush = function(action) {
    this.active = true;
    this.scheduled = void 0;
    var actions = this.actions;
    var error;
    var index = -1;
    var count = actions.length;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (++index < count && (action = actions.shift()));
    this.active = false;
    if (error) {
      while (++index < count && (action = actions.shift())) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsapScheduler2;
}(AsyncScheduler);

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/scheduler/asap.js
var asap = new AsapScheduler(AsapAction);

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/scheduler/async.js
var async2 = new AsyncScheduler(AsyncAction);

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameAction.js
var AnimationFrameAction = function(_super) {
  __extends3(AnimationFrameAction2, _super);
  function AnimationFrameAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id2, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    if (delay !== null && delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay);
    }
    scheduler.actions.push(this);
    return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function() {
      return scheduler.flush(null);
    }));
  };
  AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id2, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id2, delay);
    }
    if (scheduler.actions.length === 0) {
      cancelAnimationFrame(id2);
      scheduler.scheduled = void 0;
    }
    return void 0;
  };
  return AnimationFrameAction2;
}(AsyncAction);

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameScheduler.js
var AnimationFrameScheduler = function(_super) {
  __extends3(AnimationFrameScheduler2, _super);
  function AnimationFrameScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AnimationFrameScheduler2.prototype.flush = function(action) {
    this.active = true;
    this.scheduled = void 0;
    var actions = this.actions;
    var error;
    var index = -1;
    var count = actions.length;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (++index < count && (action = actions.shift()));
    this.active = false;
    if (error) {
      while (++index < count && (action = actions.shift())) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AnimationFrameScheduler2;
}(AsyncScheduler);

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/scheduler/animationFrame.js
var animationFrame = new AnimationFrameScheduler(AnimationFrameAction);

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/scheduler/VirtualTimeScheduler.js
var VirtualTimeScheduler = function(_super) {
  __extends3(VirtualTimeScheduler2, _super);
  function VirtualTimeScheduler2(SchedulerAction, maxFrames) {
    if (SchedulerAction === void 0) {
      SchedulerAction = VirtualAction;
    }
    if (maxFrames === void 0) {
      maxFrames = Number.POSITIVE_INFINITY;
    }
    var _this = _super.call(this, SchedulerAction, function() {
      return _this.frame;
    }) || this;
    _this.maxFrames = maxFrames;
    _this.frame = 0;
    _this.index = -1;
    return _this;
  }
  VirtualTimeScheduler2.prototype.flush = function() {
    var _a3 = this, actions = _a3.actions, maxFrames = _a3.maxFrames;
    var error, action;
    while ((action = actions[0]) && action.delay <= maxFrames) {
      actions.shift();
      this.frame = action.delay;
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    }
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  VirtualTimeScheduler2.frameTimeFactor = 10;
  return VirtualTimeScheduler2;
}(AsyncScheduler);
var VirtualAction = function(_super) {
  __extends3(VirtualAction2, _super);
  function VirtualAction2(scheduler, work, index) {
    if (index === void 0) {
      index = scheduler.index += 1;
    }
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.index = index;
    _this.active = true;
    _this.index = scheduler.index = index;
    return _this;
  }
  VirtualAction2.prototype.schedule = function(state, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    if (!this.id) {
      return _super.prototype.schedule.call(this, state, delay);
    }
    this.active = false;
    var action = new VirtualAction2(this.scheduler, this.work);
    this.add(action);
    return action.schedule(state, delay);
  };
  VirtualAction2.prototype.requestAsyncId = function(scheduler, id2, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    this.delay = scheduler.frame + delay;
    var actions = scheduler.actions;
    actions.push(this);
    actions.sort(VirtualAction2.sortActions);
    return true;
  };
  VirtualAction2.prototype.recycleAsyncId = function(scheduler, id2, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    return void 0;
  };
  VirtualAction2.prototype._execute = function(state, delay) {
    if (this.active === true) {
      return _super.prototype._execute.call(this, state, delay);
    }
  };
  VirtualAction2.sortActions = function(a, b2) {
    if (a.delay === b2.delay) {
      if (a.index === b2.index) {
        return 0;
      } else if (a.index > b2.index) {
        return 1;
      } else {
        return -1;
      }
    } else if (a.delay > b2.delay) {
      return 1;
    } else {
      return -1;
    }
  };
  return VirtualAction2;
}(AsyncAction);

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js
function ArgumentOutOfRangeErrorImpl() {
  Error.call(this);
  this.message = "argument out of range";
  this.name = "ArgumentOutOfRangeError";
  return this;
}
ArgumentOutOfRangeErrorImpl.prototype = Object.create(Error.prototype);

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/util/EmptyError.js
function EmptyErrorImpl() {
  Error.call(this);
  this.message = "no elements in sequence";
  this.name = "EmptyError";
  return this;
}
EmptyErrorImpl.prototype = Object.create(Error.prototype);

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/util/TimeoutError.js
function TimeoutErrorImpl() {
  Error.call(this);
  this.message = "Timeout has occurred";
  this.name = "TimeoutError";
  return this;
}
TimeoutErrorImpl.prototype = Object.create(Error.prototype);

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/operators/map.js
var MapOperator = function() {
  function MapOperator2(project, thisArg) {
    this.project = project;
    this.thisArg = thisArg;
  }
  MapOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
  };
  return MapOperator2;
}();
var MapSubscriber = function(_super) {
  __extends3(MapSubscriber2, _super);
  function MapSubscriber2(destination, project, thisArg) {
    var _this = _super.call(this, destination) || this;
    _this.project = project;
    _this.count = 0;
    _this.thisArg = thisArg || _this;
    return _this;
  }
  MapSubscriber2.prototype._next = function(value) {
    var result;
    try {
      result = this.project.call(this.thisArg, value, this.count++);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  };
  return MapSubscriber2;
}(Subscriber);

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/OuterSubscriber.js
var OuterSubscriber = function(_super) {
  __extends3(OuterSubscriber2, _super);
  function OuterSubscriber2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  OuterSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.destination.next(innerValue);
  };
  OuterSubscriber2.prototype.notifyError = function(error, innerSub) {
    this.destination.error(error);
  };
  OuterSubscriber2.prototype.notifyComplete = function(innerSub) {
    this.destination.complete();
  };
  return OuterSubscriber2;
}(Subscriber);

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/InnerSubscriber.js
var InnerSubscriber = function(_super) {
  __extends3(InnerSubscriber2, _super);
  function InnerSubscriber2(parent2, outerValue, outerIndex) {
    var _this = _super.call(this) || this;
    _this.parent = parent2;
    _this.outerValue = outerValue;
    _this.outerIndex = outerIndex;
    _this.index = 0;
    return _this;
  }
  InnerSubscriber2.prototype._next = function(value) {
    this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
  };
  InnerSubscriber2.prototype._error = function(error) {
    this.parent.notifyError(error, this);
    this.unsubscribe();
  };
  InnerSubscriber2.prototype._complete = function() {
    this.parent.notifyComplete(this);
    this.unsubscribe();
  };
  return InnerSubscriber2;
}(Subscriber);

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/util/subscribeToPromise.js
var subscribeToPromise = function(promise) {
  return function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, hostReportError);
    return subscriber;
  };
};

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/util/subscribeToIterable.js
var subscribeToIterable = function(iterable) {
  return function(subscriber) {
    var iterator2 = iterable[iterator]();
    do {
      var item = iterator2.next();
      if (item.done) {
        subscriber.complete();
        break;
      }
      subscriber.next(item.value);
      if (subscriber.closed) {
        break;
      }
    } while (true);
    if (typeof iterator2.return === "function") {
      subscriber.add(function() {
        if (iterator2.return) {
          iterator2.return();
        }
      });
    }
    return subscriber;
  };
};

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/util/subscribeToObservable.js
var subscribeToObservable = function(obj) {
  return function(subscriber) {
    var obs = obj[observable]();
    if (typeof obs.subscribe !== "function") {
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    } else {
      return obs.subscribe(subscriber);
    }
  };
};

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/util/isArrayLike.js
var isArrayLike = function(x3) {
  return x3 && typeof x3.length === "number" && typeof x3 !== "function";
};

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/util/isPromise.js
function isPromise(value) {
  return !!value && typeof value.subscribe !== "function" && typeof value.then === "function";
}

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/util/subscribeTo.js
var subscribeTo = function(result) {
  if (result instanceof Observable2) {
    return function(subscriber) {
      if (result._isScalar) {
        subscriber.next(result.value);
        subscriber.complete();
        return void 0;
      } else {
        return result.subscribe(subscriber);
      }
    };
  } else if (!!result && typeof result[observable] === "function") {
    return subscribeToObservable(result);
  } else if (isArrayLike(result)) {
    return subscribeToArray(result);
  } else if (isPromise(result)) {
    return subscribeToPromise(result);
  } else if (!!result && typeof result[iterator] === "function") {
    return subscribeToIterable(result);
  } else {
    var value = isObject2(result) ? "an invalid object" : "'" + result + "'";
    var msg = "You provided " + value + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.";
    throw new TypeError(msg);
  }
};

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/util/subscribeToResult.js
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, destination) {
  if (destination === void 0) {
    destination = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);
  }
  if (destination.closed) {
    return;
  }
  return subscribeTo(result)(destination);
}

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/observable/combineLatest.js
var NONE = {};
var CombineLatestOperator = function() {
  function CombineLatestOperator2(resultSelector) {
    this.resultSelector = resultSelector;
  }
  CombineLatestOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
  };
  return CombineLatestOperator2;
}();
var CombineLatestSubscriber = function(_super) {
  __extends3(CombineLatestSubscriber2, _super);
  function CombineLatestSubscriber2(destination, resultSelector) {
    var _this = _super.call(this, destination) || this;
    _this.resultSelector = resultSelector;
    _this.active = 0;
    _this.values = [];
    _this.observables = [];
    return _this;
  }
  CombineLatestSubscriber2.prototype._next = function(observable2) {
    this.values.push(NONE);
    this.observables.push(observable2);
  };
  CombineLatestSubscriber2.prototype._complete = function() {
    var observables = this.observables;
    var len = observables.length;
    if (len === 0) {
      this.destination.complete();
    } else {
      this.active = len;
      this.toRespond = len;
      for (var i2 = 0; i2 < len; i2++) {
        var observable2 = observables[i2];
        this.add(subscribeToResult(this, observable2, observable2, i2));
      }
    }
  };
  CombineLatestSubscriber2.prototype.notifyComplete = function(unused) {
    if ((this.active -= 1) === 0) {
      this.destination.complete();
    }
  };
  CombineLatestSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    var values = this.values;
    var oldVal = values[outerIndex];
    var toRespond = !this.toRespond ? 0 : oldVal === NONE ? --this.toRespond : this.toRespond;
    values[outerIndex] = innerValue;
    if (toRespond === 0) {
      if (this.resultSelector) {
        this._tryResultSelector(values);
      } else {
        this.destination.next(values.slice());
      }
    }
  };
  CombineLatestSubscriber2.prototype._tryResultSelector = function(values) {
    var result;
    try {
      result = this.resultSelector.apply(this, values);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  };
  return CombineLatestSubscriber2;
}(OuterSubscriber);

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/operators/mergeMap.js
var MergeMapOperator = function() {
  function MergeMapOperator2(project, concurrent) {
    if (concurrent === void 0) {
      concurrent = Number.POSITIVE_INFINITY;
    }
    this.project = project;
    this.concurrent = concurrent;
  }
  MergeMapOperator2.prototype.call = function(observer, source) {
    return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
  };
  return MergeMapOperator2;
}();
var MergeMapSubscriber = function(_super) {
  __extends3(MergeMapSubscriber2, _super);
  function MergeMapSubscriber2(destination, project, concurrent) {
    if (concurrent === void 0) {
      concurrent = Number.POSITIVE_INFINITY;
    }
    var _this = _super.call(this, destination) || this;
    _this.project = project;
    _this.concurrent = concurrent;
    _this.hasCompleted = false;
    _this.buffer = [];
    _this.active = 0;
    _this.index = 0;
    return _this;
  }
  MergeMapSubscriber2.prototype._next = function(value) {
    if (this.active < this.concurrent) {
      this._tryNext(value);
    } else {
      this.buffer.push(value);
    }
  };
  MergeMapSubscriber2.prototype._tryNext = function(value) {
    var result;
    var index = this.index++;
    try {
      result = this.project(value, index);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.active++;
    this._innerSub(result, value, index);
  };
  MergeMapSubscriber2.prototype._innerSub = function(ish, value, index) {
    var innerSubscriber = new InnerSubscriber(this, void 0, void 0);
    var destination = this.destination;
    destination.add(innerSubscriber);
    subscribeToResult(this, ish, value, index, innerSubscriber);
  };
  MergeMapSubscriber2.prototype._complete = function() {
    this.hasCompleted = true;
    if (this.active === 0 && this.buffer.length === 0) {
      this.destination.complete();
    }
    this.unsubscribe();
  };
  MergeMapSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.destination.next(innerValue);
  };
  MergeMapSubscriber2.prototype.notifyComplete = function(innerSub) {
    var buffer = this.buffer;
    this.remove(innerSub);
    this.active--;
    if (buffer.length > 0) {
      this._next(buffer.shift());
    } else if (this.active === 0 && this.hasCompleted) {
      this.destination.complete();
    }
  };
  return MergeMapSubscriber2;
}(OuterSubscriber);

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/observable/forkJoin.js
var ForkJoinSubscriber = function(_super) {
  __extends3(ForkJoinSubscriber2, _super);
  function ForkJoinSubscriber2(destination, sources) {
    var _this = _super.call(this, destination) || this;
    _this.sources = sources;
    _this.completed = 0;
    _this.haveValues = 0;
    var len = sources.length;
    _this.values = new Array(len);
    for (var i2 = 0; i2 < len; i2++) {
      var source = sources[i2];
      var innerSubscription = subscribeToResult(_this, source, null, i2);
      if (innerSubscription) {
        _this.add(innerSubscription);
      }
    }
    return _this;
  }
  ForkJoinSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.values[outerIndex] = innerValue;
    if (!innerSub._hasValue) {
      innerSub._hasValue = true;
      this.haveValues++;
    }
  };
  ForkJoinSubscriber2.prototype.notifyComplete = function(innerSub) {
    var _a3 = this, destination = _a3.destination, haveValues = _a3.haveValues, values = _a3.values;
    var len = values.length;
    if (!innerSub._hasValue) {
      destination.complete();
      return;
    }
    this.completed++;
    if (this.completed !== len) {
      return;
    }
    if (haveValues === len) {
      destination.next(values);
    }
    destination.complete();
  };
  return ForkJoinSubscriber2;
}(OuterSubscriber);

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/observable/never.js
var NEVER = new Observable2(noop3);

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/observable/race.js
var RaceOperator = function() {
  function RaceOperator2() {
  }
  RaceOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new RaceSubscriber(subscriber));
  };
  return RaceOperator2;
}();
var RaceSubscriber = function(_super) {
  __extends3(RaceSubscriber2, _super);
  function RaceSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.hasFirst = false;
    _this.observables = [];
    _this.subscriptions = [];
    return _this;
  }
  RaceSubscriber2.prototype._next = function(observable2) {
    this.observables.push(observable2);
  };
  RaceSubscriber2.prototype._complete = function() {
    var observables = this.observables;
    var len = observables.length;
    if (len === 0) {
      this.destination.complete();
    } else {
      for (var i2 = 0; i2 < len && !this.hasFirst; i2++) {
        var observable2 = observables[i2];
        var subscription = subscribeToResult(this, observable2, observable2, i2);
        if (this.subscriptions) {
          this.subscriptions.push(subscription);
        }
        this.add(subscription);
      }
      this.observables = null;
    }
  };
  RaceSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    if (!this.hasFirst) {
      this.hasFirst = true;
      for (var i2 = 0; i2 < this.subscriptions.length; i2++) {
        if (i2 !== outerIndex) {
          var subscription = this.subscriptions[i2];
          subscription.unsubscribe();
          this.remove(subscription);
        }
      }
      this.subscriptions = null;
    }
    this.destination.next(innerValue);
  };
  return RaceSubscriber2;
}(OuterSubscriber);

// node_modules/angular-datatables/node_modules/rxjs/_esm5/internal/observable/zip.js
var ZipOperator = function() {
  function ZipOperator2(resultSelector) {
    this.resultSelector = resultSelector;
  }
  ZipOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
  };
  return ZipOperator2;
}();
var ZipSubscriber = function(_super) {
  __extends3(ZipSubscriber2, _super);
  function ZipSubscriber2(destination, resultSelector, values) {
    if (values === void 0) {
      values = /* @__PURE__ */ Object.create(null);
    }
    var _this = _super.call(this, destination) || this;
    _this.iterators = [];
    _this.active = 0;
    _this.resultSelector = typeof resultSelector === "function" ? resultSelector : null;
    _this.values = values;
    return _this;
  }
  ZipSubscriber2.prototype._next = function(value) {
    var iterators = this.iterators;
    if (isArray(value)) {
      iterators.push(new StaticArrayIterator(value));
    } else if (typeof value[iterator] === "function") {
      iterators.push(new StaticIterator(value[iterator]()));
    } else {
      iterators.push(new ZipBufferIterator(this.destination, this, value));
    }
  };
  ZipSubscriber2.prototype._complete = function() {
    var iterators = this.iterators;
    var len = iterators.length;
    this.unsubscribe();
    if (len === 0) {
      this.destination.complete();
      return;
    }
    this.active = len;
    for (var i2 = 0; i2 < len; i2++) {
      var iterator2 = iterators[i2];
      if (iterator2.stillUnsubscribed) {
        var destination = this.destination;
        destination.add(iterator2.subscribe(iterator2, i2));
      } else {
        this.active--;
      }
    }
  };
  ZipSubscriber2.prototype.notifyInactive = function() {
    this.active--;
    if (this.active === 0) {
      this.destination.complete();
    }
  };
  ZipSubscriber2.prototype.checkIterators = function() {
    var iterators = this.iterators;
    var len = iterators.length;
    var destination = this.destination;
    for (var i2 = 0; i2 < len; i2++) {
      var iterator2 = iterators[i2];
      if (typeof iterator2.hasValue === "function" && !iterator2.hasValue()) {
        return;
      }
    }
    var shouldComplete = false;
    var args = [];
    for (var i2 = 0; i2 < len; i2++) {
      var iterator2 = iterators[i2];
      var result = iterator2.next();
      if (iterator2.hasCompleted()) {
        shouldComplete = true;
      }
      if (result.done) {
        destination.complete();
        return;
      }
      args.push(result.value);
    }
    if (this.resultSelector) {
      this._tryresultSelector(args);
    } else {
      destination.next(args);
    }
    if (shouldComplete) {
      destination.complete();
    }
  };
  ZipSubscriber2.prototype._tryresultSelector = function(args) {
    var result;
    try {
      result = this.resultSelector.apply(this, args);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  };
  return ZipSubscriber2;
}(Subscriber);
var StaticIterator = function() {
  function StaticIterator2(iterator2) {
    this.iterator = iterator2;
    this.nextResult = iterator2.next();
  }
  StaticIterator2.prototype.hasValue = function() {
    return true;
  };
  StaticIterator2.prototype.next = function() {
    var result = this.nextResult;
    this.nextResult = this.iterator.next();
    return result;
  };
  StaticIterator2.prototype.hasCompleted = function() {
    var nextResult = this.nextResult;
    return nextResult && nextResult.done;
  };
  return StaticIterator2;
}();
var StaticArrayIterator = function() {
  function StaticArrayIterator2(array) {
    this.array = array;
    this.index = 0;
    this.length = 0;
    this.length = array.length;
  }
  StaticArrayIterator2.prototype[iterator] = function() {
    return this;
  };
  StaticArrayIterator2.prototype.next = function(value) {
    var i2 = this.index++;
    var array = this.array;
    return i2 < this.length ? { value: array[i2], done: false } : { value: null, done: true };
  };
  StaticArrayIterator2.prototype.hasValue = function() {
    return this.array.length > this.index;
  };
  StaticArrayIterator2.prototype.hasCompleted = function() {
    return this.array.length === this.index;
  };
  return StaticArrayIterator2;
}();
var ZipBufferIterator = function(_super) {
  __extends3(ZipBufferIterator2, _super);
  function ZipBufferIterator2(destination, parent2, observable2) {
    var _this = _super.call(this, destination) || this;
    _this.parent = parent2;
    _this.observable = observable2;
    _this.stillUnsubscribed = true;
    _this.buffer = [];
    _this.isComplete = false;
    return _this;
  }
  ZipBufferIterator2.prototype[iterator] = function() {
    return this;
  };
  ZipBufferIterator2.prototype.next = function() {
    var buffer = this.buffer;
    if (buffer.length === 0 && this.isComplete) {
      return { value: null, done: true };
    } else {
      return { value: buffer.shift(), done: false };
    }
  };
  ZipBufferIterator2.prototype.hasValue = function() {
    return this.buffer.length > 0;
  };
  ZipBufferIterator2.prototype.hasCompleted = function() {
    return this.buffer.length === 0 && this.isComplete;
  };
  ZipBufferIterator2.prototype.notifyComplete = function() {
    if (this.buffer.length > 0) {
      this.isComplete = true;
      this.parent.notifyInactive();
    } else {
      this.destination.complete();
    }
  };
  ZipBufferIterator2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.buffer.push(innerValue);
    this.parent.checkIterators();
  };
  ZipBufferIterator2.prototype.subscribe = function(value, index) {
    return subscribeToResult(this, this.observable, this, index);
  };
  return ZipBufferIterator2;
}(OuterSubscriber);

// node_modules/angular-datatables/src/angular-datatables.directive.js
var __decorate9 = function(decorators, target, key, desc) {
  var c = arguments.length, r2 = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d = decorators[i2])
        r2 = (c < 3 ? d(r2) : c > 3 ? d(target, key, r2) : d(target, key)) || r2;
  return c > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata6 = function(k3, v2) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k3, v2);
};
var DataTableDirective = (
  /** @class */
  function() {
    function DataTableDirective2(el) {
      this.el = el;
      this.dtOptions = {};
    }
    DataTableDirective2.prototype.ngOnInit = function() {
      var _this = this;
      if (this.dtTrigger) {
        this.dtTrigger.subscribe(function() {
          _this.displayTable();
        });
      } else {
        this.displayTable();
      }
    };
    DataTableDirective2.prototype.ngOnDestroy = function() {
      if (this.dtTrigger) {
        this.dtTrigger.unsubscribe();
      }
      if (this.dt) {
        this.dt.destroy(true);
      }
    };
    DataTableDirective2.prototype.displayTable = function() {
      var _this = this;
      this.dtInstance = new Promise(function(resolve2, reject) {
        Promise.resolve(_this.dtOptions).then(function(dtOptions) {
          setTimeout(function() {
            _this.dt = $(_this.el.nativeElement).DataTable(dtOptions);
            resolve2(_this.dt);
          });
        });
      });
    };
    __decorate9([
      Input(),
      __metadata6("design:type", Object)
    ], DataTableDirective2.prototype, "dtOptions", void 0);
    __decorate9([
      Input(),
      __metadata6("design:type", Subject2)
    ], DataTableDirective2.prototype, "dtTrigger", void 0);
    DataTableDirective2 = __decorate9([
      Directive({
        selector: "[datatable]"
      }),
      __metadata6("design:paramtypes", [ElementRef])
    ], DataTableDirective2);
    return DataTableDirective2;
  }()
);

// node_modules/angular-datatables/src/angular-datatables.module.js
var __decorate10 = function(decorators, target, key, desc) {
  var c = arguments.length, r2 = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d = decorators[i2])
        r2 = (c < 3 ? d(r2) : c > 3 ? d(target, key, r2) : d(target, key)) || r2;
  return c > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var DataTablesModule = (
  /** @class */
  function() {
    function DataTablesModule2() {
    }
    DataTablesModule_1 = DataTablesModule2;
    DataTablesModule2.forRoot = function() {
      return {
        ngModule: DataTablesModule_1
      };
    };
    var DataTablesModule_1;
    DataTablesModule2 = DataTablesModule_1 = __decorate10([
      NgModule({
        imports: [CommonModule],
        declarations: [DataTableDirective],
        exports: [DataTableDirective]
      })
    ], DataTablesModule2);
    return DataTablesModule2;
  }()
);

// node_modules/ng-fire-admin/fesm5/ng-fire-admin.js
var import_bootstrap = __toESM(require_bootstrap());

// node_modules/@angular/common/locales/fr.mjs
var u2 = void 0;
function plural(val) {
  const n2 = val, i2 = Math.floor(Math.abs(val)), v2 = val.toString().replace(/^[^.]*\.?/, "").length, e = parseInt(val.toString().replace(/^[^e]*(e([-+]?\d+))?/, "$2")) || 0;
  if (i2 === 0 || i2 === 1)
    return 1;
  if (e === 0 && (!(i2 === 0) && (i2 % 1e6 === 0 && v2 === 0)) || !(e >= 0 && e <= 5))
    return 4;
  return 5;
}
var fr_default = ["fr", [["AM", "PM"], u2, u2], u2, [["D", "L", "M", "M", "J", "V", "S"], ["dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam."], ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"], ["di", "lu", "ma", "me", "je", "ve", "sa"]], u2, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc."], ["janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre"]], u2, [["av. J.-C.", "ap. J.-C."], u2, ["avant Jésus-Christ", "après Jésus-Christ"]], 1, [6, 0], ["dd/MM/y", "d MMM y", "d MMMM y", "EEEE d MMMM y"], ["HH:mm", "HH:mm:ss", "HH:mm:ss z", "HH:mm:ss zzzz"], ["{1} {0}", "{1}, {0}", "{1} 'à' {0}", u2], [",", " ", ";", "%", "+", "-", "E", "×", "‰", "∞", "NaN", ":"], ["#,##0.###", "#,##0 %", "#,##0.00 ¤", "#E0"], "EUR", "€", "euro", { "ARS": ["$AR", "$"], "AUD": ["$AU", "$"], "BEF": ["FB"], "BMD": ["$BM", "$"], "BND": ["$BN", "$"], "BYN": [u2, "р."], "BZD": ["$BZ", "$"], "CAD": ["$CA", "$"], "CLP": ["$CL", "$"], "CNY": [u2, "¥"], "COP": ["$CO", "$"], "CYP": ["£CY"], "EGP": [u2, "£E"], "FJD": ["$FJ", "$"], "FKP": ["£FK", "£"], "FRF": ["F"], "GBP": ["£GB", "£"], "GIP": ["£GI", "£"], "HKD": [u2, "$"], "IEP": ["£IE"], "ILP": ["£IL"], "ITL": ["₤IT"], "JPY": [u2, "¥"], "KMF": [u2, "FC"], "LBP": ["£LB", "£L"], "MTP": ["£MT"], "MXN": ["$MX", "$"], "NAD": ["$NA", "$"], "NIO": [u2, "$C"], "NZD": ["$NZ", "$"], "PHP": [u2, "₱"], "RHD": ["$RH"], "RON": [u2, "L"], "RWF": [u2, "FR"], "SBD": ["$SB", "$"], "SGD": ["$SG", "$"], "SRD": ["$SR", "$"], "TOP": [u2, "$T"], "TTD": ["$TT", "$"], "TWD": [u2, "NT$"], "USD": ["$US", "$"], "UYU": ["$UY", "$"], "WST": ["$WS"], "XCD": [u2, "$"], "XPF": ["FCFP"], "ZMW": [u2, "Kw"] }, "ltr", plural];

// node_modules/@angular/common/locales/ar.mjs
var u3 = void 0;
function plural2(val) {
  const n2 = val;
  if (n2 === 0)
    return 0;
  if (n2 === 1)
    return 1;
  if (n2 === 2)
    return 2;
  if (n2 % 100 === Math.floor(n2 % 100) && (n2 % 100 >= 3 && n2 % 100 <= 10))
    return 3;
  if (n2 % 100 === Math.floor(n2 % 100) && (n2 % 100 >= 11 && n2 % 100 <= 99))
    return 4;
  return 5;
}
var ar_default = ["ar", [["ص", "م"], u3, u3], [["ص", "م"], u3, ["صباحًا", "مساءً"]], [["ح", "ن", "ث", "ر", "خ", "ج", "س"], ["الأحد", "الاثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت"], u3, ["أحد", "إثنين", "ثلاثاء", "أربعاء", "خميس", "جمعة", "سبت"]], u3, [["ي", "ف", "م", "أ", "و", "ن", "ل", "غ", "س", "ك", "ب", "د"], ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"], u3], u3, [["ق.م", "م"], u3, ["قبل الميلاد", "ميلادي"]], 6, [5, 6], ["d‏/M‏/y", "dd‏/MM‏/y", "d MMMM y", "EEEE، d MMMM y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", u3, "{1} في {0}", u3], [".", ",", ";", "‎%‎", "‎+", "‎-", "E", "×", "‰", "∞", "ليس رقمًا", ":"], ["#,##0.###", "#,##0%", "¤ #,##0.00", "#E0"], "EGP", "ج.م.‏", "جنيه مصري", { "AED": ["د.إ.‏"], "ARS": [u3, "AR$"], "AUD": ["AU$"], "BBD": [u3, "BB$"], "BHD": ["د.ب.‏"], "BMD": [u3, "BM$"], "BND": [u3, "BN$"], "BSD": [u3, "BS$"], "BYN": [u3, "р."], "BZD": [u3, "BZ$"], "CAD": ["CA$"], "CLP": [u3, "CL$"], "CNY": ["CN¥"], "COP": [u3, "CO$"], "CUP": [u3, "CU$"], "DOP": [u3, "DO$"], "DZD": ["د.ج.‏"], "EGP": ["ج.م.‏", "E£"], "FJD": [u3, "FJ$"], "GBP": ["UK£"], "GYD": [u3, "GY$"], "HKD": ["HK$"], "IQD": ["د.ع.‏"], "IRR": ["ر.إ."], "JMD": [u3, "JM$"], "JOD": ["د.أ.‏"], "JPY": ["JP¥"], "KWD": ["د.ك.‏"], "KYD": [u3, "KY$"], "LBP": ["ل.ل.‏", "L£"], "LRD": [u3, "$LR"], "LYD": ["د.ل.‏"], "MAD": ["د.م.‏"], "MRU": ["أ.م."], "MXN": ["MX$"], "NZD": ["NZ$"], "OMR": ["ر.ع.‏"], "PHP": [u3, "₱"], "QAR": ["ر.ق.‏"], "SAR": ["ر.س.‏"], "SBD": [u3, "SB$"], "SDD": ["د.س.‏"], "SDG": ["ج.س."], "SRD": [u3, "SR$"], "SYP": ["ل.س.‏", "£"], "THB": ["฿"], "TND": ["د.ت.‏"], "TTD": [u3, "TT$"], "TWD": ["NT$"], "USD": ["US$"], "UYU": [u3, "UY$"], "YER": ["ر.ي.‏"] }, "rtl", plural2];

// node_modules/ng-fire-admin/fesm5/ng-fire-admin.js
var FireAdminService = (
  /** @class */
  function() {
    function FireAdminService2(firebaseConfig) {
      this.firebaseConfig = firebaseConfig;
    }
    FireAdminService2.getFirebaseConfig = /**
    * @param {?} self
    * @return {?}
    */
    function(self2) {
      return self2.firebaseConfig;
    };
    FireAdminService2.decorators = [
      { type: Injectable, args: [{
        providedIn: "root"
      }] }
    ];
    FireAdminService2.ctorParameters = function() {
      return [
        { type: void 0, decorators: [{ type: Inject, args: [FirebaseOptionsToken] }] }
      ];
    };
    FireAdminService2.ngInjectableDef = ɵɵdefineInjectable({ factory: function FireAdminService_Factory() {
      return new FireAdminService2(ɵɵinject(FirebaseOptionsToken));
    }, token: FireAdminService2, providedIn: "root" });
    return FireAdminService2;
  }()
);
if (false) {
  FireAdminService.prototype.firebaseConfig;
}
var LocalStorageService = (
  /** @class */
  function() {
    function LocalStorageService2() {
    }
    LocalStorageService2.prototype.get = /**
    * @param {?} key
    * @return {?}
    */
    function(key) {
      var value = localStorage.getItem(key);
      var finalValue;
      try {
        finalValue = JSON.parse(value);
      } catch (error) {
        finalValue = value;
      }
      return finalValue;
    };
    LocalStorageService2.prototype.set = /**
    * @param {?} key
    * @param {?} value
    * @return {?}
    */
    function(key, value) {
      var finalValue;
      try {
        finalValue = JSON.stringify(value);
      } catch (error) {
        finalValue = value;
      }
      localStorage.setItem(key, finalValue);
    };
    LocalStorageService2.decorators = [
      { type: Injectable }
    ];
    LocalStorageService2.ctorParameters = function() {
      return [];
    };
    return LocalStorageService2;
  }()
);
var AlertService = (
  /** @class */
  function() {
    function AlertService2(localStorage2) {
      this.localStorage = localStorage2;
      this.message = null;
      this.type = "primary";
      this.icon = null;
      this.isPersistent = false;
      this.timeoutHandle = null;
      var alert = this.localStorage.get("flash_alert");
      if (alert) {
        this.set(alert.message, alert.type);
        this.localStorage.set("flash_alert", null);
        if (alert.timeout) {
          this.clearAfterTimeout(alert.timeout);
        }
      }
    }
    AlertService2.prototype.set = /**
    * @private
    * @param {?} message
    * @param {?} type
    * @param {?=} isFlashAlert
    * @param {?=} timeout
    * @param {?=} isPersistent
    * @return {?}
    */
    function(message, type, isFlashAlert, timeout, isPersistent) {
      if (isFlashAlert === void 0) {
        isFlashAlert = false;
      }
      if (timeout === void 0) {
        timeout = null;
      }
      if (isPersistent === void 0) {
        isPersistent = false;
      }
      if (isFlashAlert) {
        this.localStorage.set("flash_alert", {
          message,
          type,
          timeout
        });
      } else {
        this.message = message;
        this.type = type;
        switch (this.type) {
          case "primary":
            this.icon = "info";
            break;
          case "success":
            this.icon = "check";
            break;
          case "warning":
            this.icon = "exclamation";
            break;
          case "danger":
            this.icon = "ban";
            break;
          default:
            this.icon = null;
        }
        if (timeout) {
          this.clearAfterTimeout(timeout);
        }
        this.isPersistent = isPersistent;
      }
    };
    AlertService2.prototype.clearAfterTimeout = /**
    * @private
    * @param {?} timeout
    * @return {?}
    */
    function(timeout) {
      var _this = this;
      if (this.timeoutHandle) {
        clearTimeout(this.timeoutHandle);
      }
      this.timeoutHandle = setTimeout(
        /**
        * @return {?}
        */
        function() {
          return _this.clear();
        },
        timeout
      );
    };
    AlertService2.prototype.clear = /**
    * @param {?=} clearFlashAlert
    * @return {?}
    */
    function(clearFlashAlert) {
      if (clearFlashAlert === void 0) {
        clearFlashAlert = false;
      }
      this.message = null;
      if (clearFlashAlert) {
        this.localStorage.set("flash_alert", null);
      }
    };
    AlertService2.prototype.info = /**
    * @param {?} message
    * @param {?=} isFlashAlert
    * @param {?=} timeout
    * @param {?=} isPersistent
    * @return {?}
    */
    function(message, isFlashAlert, timeout, isPersistent) {
      if (isFlashAlert === void 0) {
        isFlashAlert = false;
      }
      if (timeout === void 0) {
        timeout = null;
      }
      if (isPersistent === void 0) {
        isPersistent = false;
      }
      this.set(message, "primary", isFlashAlert, timeout, isPersistent);
    };
    AlertService2.prototype.success = /**
    * @param {?} message
    * @param {?=} isFlashAlert
    * @param {?=} timeout
    * @param {?=} isPersistent
    * @return {?}
    */
    function(message, isFlashAlert, timeout, isPersistent) {
      if (isFlashAlert === void 0) {
        isFlashAlert = false;
      }
      if (timeout === void 0) {
        timeout = null;
      }
      if (isPersistent === void 0) {
        isPersistent = false;
      }
      this.set(message, "success", isFlashAlert, timeout, isPersistent);
    };
    AlertService2.prototype.error = /**
    * @param {?} message
    * @param {?=} isFlashAlert
    * @param {?=} timeout
    * @param {?=} isPersistent
    * @return {?}
    */
    function(message, isFlashAlert, timeout, isPersistent) {
      if (isFlashAlert === void 0) {
        isFlashAlert = false;
      }
      if (timeout === void 0) {
        timeout = null;
      }
      if (isPersistent === void 0) {
        isPersistent = false;
      }
      this.set(message, "danger", isFlashAlert, timeout, isPersistent);
    };
    AlertService2.prototype.warning = /**
    * @param {?} message
    * @param {?=} isFlashAlert
    * @param {?=} timeout
    * @param {?=} isPersistent
    * @return {?}
    */
    function(message, isFlashAlert, timeout, isPersistent) {
      if (isFlashAlert === void 0) {
        isFlashAlert = false;
      }
      if (timeout === void 0) {
        timeout = null;
      }
      if (isPersistent === void 0) {
        isPersistent = false;
      }
      this.set(message, "warning", isFlashAlert, timeout, isPersistent);
    };
    AlertService2.decorators = [
      { type: Injectable }
    ];
    AlertService2.ctorParameters = function() {
      return [
        { type: LocalStorageService }
      ];
    };
    return AlertService2;
  }()
);
if (false) {
  AlertService.prototype.message;
  AlertService.prototype.type;
  AlertService.prototype.icon;
  AlertService.prototype.isPersistent;
  AlertService.prototype.timeoutHandle;
  AlertService.prototype.localStorage;
}
var UserRole = {
  Administrator: "admin",
  Editor: "editor",
  // Author = 'author',
  // Contributor = 'contributor',
  Guest: "guest"
};
if (false) {
  User.prototype.id;
  User.prototype.firstName;
  User.prototype.lastName;
  User.prototype.email;
  User.prototype.password;
  User.prototype.birthDate;
  User.prototype.role;
  User.prototype.bio;
  User.prototype.avatar;
  User.prototype.createdAt;
  User.prototype.updatedAt;
  User.prototype.createdBy;
  User.prototype.creator;
  User.prototype.updatedBy;
}
var SettingsService = (
  /** @class */
  function() {
    function SettingsService2(localStorage2) {
      this.localStorage = localStorage2;
      var settings = this.localStorage.get("settings");
      var defaults = this.getDefaults();
      this.set(__assign({}, defaults, settings));
    }
    SettingsService2.prototype.getDefaults = /**
    * @private
    * @return {?}
    */
    function() {
      return {
        language: "en",
        sidebarStyle: "expanded",
        supportedLanguages: [
          {
            label: "English",
            key: "en",
            isActive: true,
            isRemovable: false
          },
          {
            label: "French",
            key: "fr",
            isActive: true,
            isRemovable: false
          },
          {
            label: "Arabic",
            key: "ar",
            isActive: true,
            isRemovable: false
          }
        ]
      };
    };
    SettingsService2.prototype.set = /**
    * @private
    * @param {?} settings
    * @return {?}
    */
    function(settings) {
      this.language = settings.language;
      this.sidebarStyle = settings.sidebarStyle;
      this.supportedLanguages = settings.supportedLanguages;
    };
    SettingsService2.prototype.save = /**
    * @return {?}
    */
    function() {
      this.localStorage.set("settings", {
        language: this.language,
        sidebarStyle: this.sidebarStyle,
        supportedLanguages: this.supportedLanguages
      });
    };
    SettingsService2.prototype.reset = /**
    * @return {?}
    */
    function() {
      var defaults = this.getDefaults();
      this.set(defaults);
    };
    SettingsService2.prototype.supportedLanguageExists = /**
    * @param {?} label
    * @param {?} key
    * @return {?}
    */
    function(label, key) {
      return this.supportedLanguages.find(
        /**
        * @param {?} lang
        * @return {?}
        */
        function(lang) {
          return lang.label.toLocaleLowerCase() == label.toLocaleLowerCase();
        }
      ) || this.supportedLanguages.find(
        /**
        * @param {?} lang
        * @return {?}
        */
        function(lang) {
          return lang.key.toLocaleLowerCase() == key.toLocaleLowerCase();
        }
      );
    };
    SettingsService2.prototype.getActiveSupportedLanguages = /**
    * @return {?}
    */
    function() {
      return this.supportedLanguages.filter(
        /**
        * @param {?} lang
        * @return {?}
        */
        function(lang) {
          return lang.isActive;
        }
      );
    };
    SettingsService2.decorators = [
      { type: Injectable }
    ];
    SettingsService2.ctorParameters = function() {
      return [
        { type: LocalStorageService }
      ];
    };
    return SettingsService2;
  }()
);
if (false) {
  SettingsService.prototype.language;
  SettingsService.prototype.sidebarStyle;
  SettingsService.prototype.supportedLanguages;
  SettingsService.prototype.localStorage;
}
var en2 = {
  // Login page
  "SignInToYourAccount": "Sign In to Your Account",
  "EmailAddress": "Email address",
  "EnterEmail": "Enter email",
  "Password": "Password",
  "RememberMe": "Remember me",
  "SignIn": "Sign In",
  "ForgotYourPassword": "Forgot your password?",
  // Register page
  "WelcomeToFireAdmin": "Welcome To FireAdmin",
  "RepeatPassword": "Repeat Password",
  "CreateAccount": "Create Account",
  // Sidebar
  "Dashboard": "Dashboard",
  "Pages": "Pages",
  "List": "List",
  "Add": "Add",
  "Posts": "Posts",
  "Categories": "Categories",
  "Translations": "Translations",
  "Comments": "Comments",
  "Menus": "Menus",
  "Media": "Media",
  "Users": "Users",
  // Navbar
  "AddPost": "Add post",
  "Profile": "Profile",
  "Settings": "Settings",
  "Logout": "Logout",
  // Dashboard
  "PostsByStatus": "Posts By Status",
  // Pages: Add
  "AddNewPage": "Add New Page",
  "PageTitle": "Page Title",
  "PageSlug": "Slug",
  "PageLanguage": "Language",
  "PageBlock": "Block",
  "PageBlocks": "Blocks",
  "AddPage": "Add Page",
  "AddBlock": "Add Block",
  "BlockName": "Name",
  "BlockType": "Type",
  "BlockContent": "Content",
  "RemoveBlock": "Remove",
  "CollapseBlock": "Collapse",
  "PageAdded": "Page successfully added!",
  "PageSlugAlreadyExists": "Page slug already exists! Choose another one.",
  // Pages: Block types
  "Text": "Text",
  "HTML": "HTML",
  "JSON": "JSON",
  // Pages: Edit
  "EditPage": "Edit Page",
  "PageSaved": "Page successfully saved!",
  // Pages: Translate
  "TranslatePage": "Translate Page",
  // Pages: List
  "PageCreatedAt": "Creation date",
  "PageUpdatedAt": "Last Modification date",
  "PageAuthor": "Author",
  "DeletePage": "Delete Page",
  "ConfirmDeletePage": "Please confirm deleting page <b>${title}</b> ?",
  "PageDeleted": "Page <b>${title}</b> has been deleted!",
  // Posts: Add
  "AddNewPost": "Add New Post",
  "PostTitle": "Post Title",
  "PostContent": "Post Content",
  "Actions": "Actions",
  "PostLanguage": "Language",
  "PostStatus": "Status",
  "PostDate": "Date",
  "PostImage": "Image",
  "PostSlug": "Slug",
  "SaveDraft": "Save Draft",
  "Publish": "Publish",
  "MoveToTrash": "Move To Trash",
  "PostAdded": "Post successfully added!",
  "PostSlugAlreadyExists": "Post slug already exists! Choose another one.",
  // Posts: Status
  "Draft": "Draft",
  "Published": "Published",
  "Trash": "Trash",
  // Posts: List
  "PostCreatedAt": "Creation date",
  "PostUpdatedAt": "Last Modification date",
  "PostAuthor": "Author",
  "Translate": "Translate",
  "DeletePost": "Delete Post",
  "ConfirmDeletePost": "Please confirm deleting post <b>${title}</b> ?",
  "PostDeleted": "Post <b>${title}</b> has been deleted!",
  // Posts: Edit
  "EditPost": "Edit Post",
  "PostSaved": "Post successfully saved!",
  // Posts: Translate
  "TranslatePost": "Translate Post",
  // Languages
  "All": "All",
  "English": "English",
  "French": "French",
  "Arabic": "Arabic",
  // Settings
  "General": "General",
  "Internationalization": "Internationalization",
  "Language": "Language",
  "SidebarStyle": "Sidebar style",
  "Expanded": "Expanded",
  "Collapsed": "Collapsed",
  "HeaderBar": "Header bar",
  "SaveChanges": "Save Changes",
  "SettingsSaved": "Settings successfully saved!",
  "SupportedLanguages": "Supported languages",
  "Key": "Key",
  "Remove": "Remove",
  "Cancel": "Cancel",
  // Categories
  "NewCategory": "New Category",
  "CategoryLabel": "Label",
  "CategorySlug": "Slug",
  "CategoryLanguage": "Language",
  "AddCategory": "Add Category",
  "CategoryAdded": "Category successfully added!",
  "DeleteCategory": "Delete Category",
  "ConfirmDeleteCategory": "Please confirm deleting category <b>${label}</b> ?",
  "CategoryDeleted": "Category <b>${label}</b> has been deleted!",
  "EditCategory": "Edit Category",
  "CategorySaved": "Category <b>${label}</b> has been saved!",
  // Lists
  "Edit": "Edit",
  "Delete": "Delete",
  "Save": "Save",
  // Users: Add
  "AddNewUser": "Add New User",
  "AddUser": "Add User",
  "NewUser": "New User",
  "FirstName": "First Name",
  "LastName": "Last Name",
  "Email": "Email",
  "BirthDate": "Birth Date",
  "Role": "Role",
  "Bio": "Bio",
  "BioPlaceholder": "I'm a design focused engineer.",
  "ProfilePicture": "Profile Picture",
  "UploadImage": "Upload Image",
  "UserAdded": "User successfully added!",
  // Users: Edit
  "EditUser": "Edit User",
  "UserDetails": "User Details",
  "UpdateUser": "Update User",
  "UserUpdated": "User successfully updated!",
  // Users: Profile
  "UserProfile": "User Profile",
  "LatestPosts": "Latest Posts",
  "FullList": "Full List",
  // Users: List
  "UserName": "User name",
  "CreatedAt": "Creation date",
  "UpdatedAt": "Last modification date",
  "CreatedBy": "Created by",
  "DeleteUser": "Delete User",
  "ConfirmDeleteUser": "Please confirm deleting user <b>${name}</b> ?",
  "UserDeleted": "User <b>${name}</b> has been deleted!",
  // Users: Roles
  "Administrator": "Administrator",
  "Editor": "Editor",
  "Author": "Author",
  "Contributor": "Contributor",
  "Guest": "Guest",
  // Translations
  "NewTranslation": "New Translation",
  "TranslationKey": "Key",
  "TranslationValue": "Value",
  "TranslationLanguage": "Language",
  "AddTranslation": "Add Translation",
  "TranslationAdded": "Translation successfully added!",
  "DeleteTranslation": "Delete Translation",
  "ConfirmDeleteTranslation": "Please confirm deleting translation <b>${key}</b> ?",
  "TranslationDeleted": "Translation <b>${key}</b> has been deleted!",
  "EditTranslation": "Edit Translation",
  "TranslationSaved": "Translation <b>${key}</b> has been saved!",
  "TranslationKeyAlreadyExists": "Translation key <b>${key}</b> already exists for language <b>${lang}</b>.",
  "TranslationsTooltip": 'Translations can be used with <a href="http://www.ngx-translate.com/" target="_blank">ngx-translate</a> library, for any repetitive text (on header/footer or breadcrumb) that needs to be translated.',
  // Error messages
  "GuestsAreNotAllowedToPerformChanges": "Guest users are not allowed to perform changes."
};
var fr2 = {
  // Login page
  "SignInToYourAccount": "Veuillez vous connecter à votre compte",
  "EmailAddress": "Adresse mail",
  "EnterEmail": "Entrez votre e-mail",
  "Password": "Mot de passe",
  "RememberMe": "Se souvenir de moi",
  "SignIn": "Se connecter",
  "ForgotYourPassword": "Mot de passe oublié?",
  // Register page
  "WelcomeToFireAdmin": "Bienvenue dans FireAdmin",
  "RepeatPassword": "Répéter le mot de passe",
  "CreateAccount": "Créer un compte",
  // Sidebar
  "Dashboard": "Tableau de bord",
  "Pages": "Pages",
  "List": "Liste",
  "Add": "Ajouter",
  "Posts": "Articles",
  "Categories": "Catégories",
  "Translations": "Traductions",
  "Comments": "Commentaires",
  "Menus": "Menus",
  "Media": "Médias",
  "Users": "Utilisateurs",
  // Navbar
  "AddPost": "Ajouter un article",
  "Profile": "Profil",
  "Settings": "Réglages",
  "Logout": "Se déconnecter",
  // Dashboard
  "PostsByStatus": "Articles par statut",
  // Pages: Add
  "AddNewPage": "Ajouter une nouvelle page",
  "PageTitle": "Titre de la page",
  "PageSlug": "Slug",
  "PageLanguage": "Langue",
  "PageBlock": "Bloc",
  "PageBlocks": "Blocs",
  "AddPage": "Ajouter la page",
  "AddBlock": "Ajouter un bloc",
  "BlockName": "Nom",
  "BlockType": "Type",
  "BlockContent": "Contenu",
  "RemoveBlock": "Retirer",
  "CollapseBlock": "Ranger",
  "PageAdded": "Page ajoutée avec succès!",
  "PageSlugAlreadyExists": "Le slug de la page existe déjà! Veuillez en choisir un autre.",
  // Pages: Block types
  "Text": "Text",
  "HTML": "HTML",
  "JSON": "JSON",
  // Pages: Edit
  "EditPage": "Modifier la page",
  "PageSaved": "Page enregistrée avec succès!",
  // Pages: Translate
  "TranslatePage": "Traduire la page",
  // Pages: List
  "PageCreatedAt": "Date de création",
  "PageUpdatedAt": "Date de la dernière modification",
  "PageAuthor": "Auteur",
  "DeletePage": "Supprimer la page",
  "ConfirmDeletePage": "Veuillez confirmer la suppression de la page <b>${title}</b> ?",
  "PageDeleted": "Page <b>${title}</b> supprimée!",
  // Posts: Add
  "AddNewPost": "Ajouter un nouvel article",
  "PostTitle": "Titre de l'article",
  "PostContent": "Contenu de l'article",
  "Actions": "Actions",
  "PostLanguage": "Langue",
  "PostStatus": "Statut",
  "PostDate": "Date",
  "PostImage": "Image",
  "PostSlug": "Slug",
  "SaveDraft": "Enregistrer le brouillon",
  "Publish": "Publier",
  "MoveToTrash": "Mettre à la corbeille",
  "PostAdded": "Article ajouté avec succès!",
  "PostSlugAlreadyExists": "Le slug de l'article existe déjà! Veuillez en choisir un autre.",
  // Posts: Status
  "Draft": "Brouillon",
  "Published": "Publié",
  "Trash": "Corbeille",
  // Posts: List
  "PostCreatedAt": "Date de création",
  "PostUpdatedAt": "Date de la dernière modification",
  "PostAuthor": "Auteur",
  "Translate": "Traduire",
  "DeletePost": "Supprimer l'article",
  "ConfirmDeletePost": "Veuillez confirmer la suppression de l'article <b>${title}</b> ?",
  "PostDeleted": "Article <b>${title}</b> supprimé!",
  // Posts: Edit
  "EditPost": "Modifier l'article",
  "PostSaved": "Article enregistré avec succès!",
  // Posts: Translate
  "TranslatePost": "Traduire l'article",
  // Languages
  "All": "Tout",
  "English": "Anglais",
  "French": "Français",
  "Arabic": "Arabe",
  // Settings
  "General": "Général",
  "Internationalization": "Internationalisation",
  "Language": "Langue",
  "SidebarStyle": "Style de barre latérale",
  "Expanded": "Étendu",
  "Collapsed": "Rangé",
  "HeaderBar": "Barre d'en-tête",
  "SaveChanges": "Sauvegarder les modifications",
  "SettingsSaved": "Paramètres enregistrés avec succès!",
  "SupportedLanguages": "Langues prises en charge",
  "Key": "Clé",
  "Remove": "Supprimer",
  "Cancel": "Annuler",
  // Categories
  "NewCategory": "Nouvelle catégorie",
  "CategoryLabel": "Libellé",
  "CategorySlug": "Slug",
  "CategoryLanguage": "Langue",
  "AddCategory": "Ajouter une catégorie",
  "CategoryAdded": "Catégorie ajoutée avec succès!",
  "DeleteCategory": "Supprimer la catégorie",
  "ConfirmDeleteCategory": "Veuillez confirmer la suppression de la catégorie <b>${label}</b> ?",
  "CategoryDeleted": "Catégorie <b>${label}</b> supprimée!",
  "EditCategory": "Modifier la catégorie",
  "CategorySaved": "Catégorie <b>${label}</b> enregistrée!",
  // Lists
  "Edit": "Modifier",
  "Delete": "Supprimer",
  "Save": "Enregistrer",
  // Users: Add
  "AddNewUser": "Ajouter un nouvel utilisateur",
  "AddUser": "Ajouter un utilisateur",
  "NewUser": "Nouvel utilisateur",
  "FirstName": "Prénom",
  "LastName": "Nom de famille",
  "Email": "Email",
  "BirthDate": "Date de naissance",
  "Role": "Rôle",
  "Bio": "Bio",
  "BioPlaceholder": "Je suis un ingénieur spécialisé dans la conception.",
  "ProfilePicture": "Photo de profil",
  "UploadImage": "Télécharger une image",
  "UserAdded": "Utilisateur ajouté avec succès!",
  // Users: Edit
  "EditUser": "Modifier l'utilisateur",
  "UserDetails": "Détails de l'utilisateur",
  "UpdateUser": "Mettre à jour l'utilisateur",
  "UserUpdated": "Utilisateur mis à jour avec succès!",
  // Users: Profile
  "UserProfile": "Profil de l'utilisateur",
  "LatestPosts": "Derniers articles",
  "FullList": "Liste complète",
  // Users: List
  "UserName": "Nom d'utilisateur",
  "CreatedAt": "Date de création",
  "UpdatedAt": "Date de la dernière modification",
  "CreatedBy": "Créé par",
  "DeleteUser": "Supprimer l'utilisateur",
  "ConfirmDeleteUser": "Veuillez confirmer la suppression de l'utilisateur <b>${name}</b> ?",
  "UserDeleted": "Utilisateur <b>${name}</b> supprimé!",
  // Users: Roles
  "Administrator": "Administrateur",
  "Editor": "Éditeur",
  "Author": "Auteur",
  "Contributor": "Contributeur",
  "Guest": "Invité",
  // Translations
  "NewTranslation": "Nouvelle traduction",
  "TranslationKey": "Clé",
  "TranslationValue": "Valeur",
  "TranslationLanguage": "Langue",
  "AddTranslation": "Ajouter une traduction",
  "TranslationAdded": "Traduction ajoutée avec succès!",
  "DeleteTranslation": "Supprimer la traduction",
  "ConfirmDeleteTranslation": "Veuillez confirmer la suppression de la traduction <b>${key}</b> ?",
  "TranslationDeleted": "Traduction <b>${key}</b> supprimée!",
  "EditTranslation": "Modifier la traduction",
  "TranslationSaved": "Traduction <b>${key}</b> enregistrée!",
  "TranslationKeyAlreadyExists": "La clé de traduction <b>${key}</b> existe déjà pour la langue <b>${lang}</b>.",
  "TranslationsTooltip": `Les traductions peuvent être utilisées avec la bibiliothèque <a href="http://www.ngx-translate.com/" target="_blank">ngx-translate</a>, pour tout texte répétitif (en-tête, pied de page ou fil d'Ariane) à traduire.`,
  // Error messages
  "GuestsAreNotAllowedToPerformChanges": "Les invités ne sont pas autorisés à effectuer des modifications."
};
var I18nService = (
  /** @class */
  function() {
    function I18nService2(settings) {
      this.settings = settings;
      this.lang = "en";
      this.translations = {
        "en": en2,
        "fr": fr2
      };
      if (this.settings.language) {
        this.setLanguage(this.settings.language);
      }
    }
    I18nService2.prototype.setLanguage = /**
    * @param {?} lang
    * @return {?}
    */
    function(lang) {
      this.lang = lang;
    };
    I18nService2.prototype.getCurrentLanguage = /**
    * @return {?}
    */
    function() {
      return this.lang;
    };
    I18nService2.prototype.get = /**
    * @param {?} key
    * @param {?=} substitutions
    * @return {?}
    */
    function(key, substitutions) {
      return this.translations[this.lang][key] ? this.replace(this.translations[this.lang][key], substitutions) : key;
    };
    I18nService2.prototype.replace = /**
    * @private
    * @param {?} translation
    * @param {?=} substitutions
    * @return {?}
    */
    function(translation, substitutions) {
      var result = translation;
      if (substitutions) {
        Object.keys(substitutions).forEach(
          /**
          * @param {?} key
          * @return {?}
          */
          function(key) {
            result = result.replace(new RegExp("\\$\\{" + key + "\\}", "gi"), substitutions[key]);
          }
        );
      }
      return result;
    };
    I18nService2.decorators = [
      { type: Injectable }
    ];
    I18nService2.ctorParameters = function() {
      return [
        { type: SettingsService }
      ];
    };
    return I18nService2;
  }()
);
if (false) {
  I18nService.prototype.lang;
  I18nService.prototype.translations;
  I18nService.prototype.settings;
}
var DatabaseService = (
  /** @class */
  function() {
    function DatabaseService2(db2, i18n) {
      this.db = db2;
      this.i18n = i18n;
      this._currentUser = null;
    }
    DatabaseService2.prototype.setCurrentUser = /**
    * Set current user service instance
    *
    * @param {?} instance
    * @return {?}
    */
    function(instance) {
      this._currentUser = instance;
    };
    Object.defineProperty(DatabaseService2.prototype, "currentUser", {
      /**
       * Return current user data
       */
      get: (
        /**
        * Return current user data
        * @return {?}
        */
        function() {
          return this._currentUser.data || null;
        }
      ),
      enumerable: true,
      configurable: true
    });
    DatabaseService2.prototype.afterUserRoleCheck = /**
    * Check user role before perfoming an action/promise
    *
    * @private
    * @param {?} promiseFn
    * @return {?}
    */
    function(promiseFn) {
      var _this = this;
      return new Promise(
        /**
        * @param {?} resolve
        * @param {?} reject
        * @return {?}
        */
        function(resolve2, reject) {
          if (!_this._currentUser || _this._currentUser.isGuest()) {
            reject({ message: _this.i18n.get("GuestsAreNotAllowedToPerformChanges") });
          } else {
            promiseFn().then(
              /**
              * @param {?=} value
              * @return {?}
              */
              function(value) {
                resolve2(value);
              }
            ).catch(
              /**
              * @param {?} error
              * @return {?}
              */
              function(error) {
                reject(error);
              }
            );
          }
        }
      );
    };
    DatabaseService2.prototype.collectionExists = /**
    * Check if collection exists
    *
    * @param {?} path
    * @return {?}
    */
    function(path) {
      return __awaiter(this, void 0, void 0, function() {
        var query;
        return __generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              return [4, this.db.collection(path).get().toPromise().catch(
                /**
                * @param {?} error
                * @return {?}
                */
                function(error) {
                  console.log(error);
                }
              )];
            case 1:
              query = _a3.sent();
              return [2, query ? !!query.size : false];
          }
        });
      });
    };
    DatabaseService2.prototype.addCollection = /**
    * Add collection
    *
    * @param {?} path
    * @param {?} data
    * @return {?}
    */
    function(path, data) {
      var _this = this;
      return this.afterUserRoleCheck(
        /**
        * @return {?}
        */
        function() {
          return _this.db.collection(path).add(data);
        }
      );
    };
    DatabaseService2.prototype.getCollectionRef = /**
    * Get collection ref
    *
    * @param {?} path
    * @param {?=} queryFn
    * @return {?}
    */
    function(path, queryFn) {
      return this.db.collection(path, queryFn);
    };
    DatabaseService2.prototype.getCollection = /**
    * Get collection
    *
    * known issue on several subscriptions: https://github.com/angular/angularfire/issues/1405
    *
    * @param {?} path
    * @param {?=} queryFn
    * @return {?}
    */
    function(path, queryFn) {
      return this.getCollectionRef(path, queryFn).snapshotChanges().pipe(map(
        /**
        * @param {?} changes
        * @return {?}
        */
        function(changes) {
          var docs = [];
          changes.forEach(
            /**
            * @param {?} __0
            * @return {?}
            */
            function(_a3) {
              var doc = _a3.payload.doc;
              docs.push(__assign(
                { id: doc.id },
                /** @type {?} */
                doc.data()
              ));
            }
          );
          return docs;
        }
      ));
    };
    DatabaseService2.prototype.addDocument = /**
    * Add document
    *
    * @param {?} collectionPath
    * @param {?} data
    * @param {?=} documentPath
    * @return {?}
    */
    function(collectionPath, data, documentPath) {
      var _this = this;
      if (documentPath && documentPath.length) {
        return this.afterUserRoleCheck(
          /**
          * @return {?}
          */
          function() {
            return _this.setDocument(collectionPath, documentPath, data);
          }
        );
      } else {
        return this.afterUserRoleCheck(
          /**
          * @return {?}
          */
          function() {
            return _this.addCollection(collectionPath, data);
          }
        );
      }
    };
    DatabaseService2.prototype.setDocument = /**
    * Set document
    *
    * @param {?} collectionPath
    * @param {?} documentPath
    * @param {?} data
    * @param {?=} merge
    * @return {?}
    */
    function(collectionPath, documentPath, data, merge3) {
      var _this = this;
      if (merge3 === void 0) {
        merge3 = true;
      }
      return this.afterUserRoleCheck(
        /**
        * @return {?}
        */
        function() {
          return _this.db.collection(collectionPath).doc(documentPath).set(data, { merge: merge3 });
        }
      );
    };
    DatabaseService2.prototype.updateDocument = /**
    * Update document
    *
    * @param {?} collectionPath
    * @param {?} documentPath
    * @param {?} data
    * @return {?}
    */
    function(collectionPath, documentPath, data) {
      var _this = this;
      return this.afterUserRoleCheck(
        /**
        * @return {?}
        */
        function() {
          return _this.db.collection(collectionPath).doc(documentPath).update(data);
        }
      );
    };
    DatabaseService2.prototype.getDocumentRef = /**
    * Get document ref
    *
    * @param {?} collectionPath
    * @param {?} documentPath
    * @return {?}
    */
    function(collectionPath, documentPath) {
      return this.db.collection(collectionPath).doc(documentPath);
    };
    DatabaseService2.prototype.getDocument = /**
    * Get document
    *
    * @param {?} collectionPath
    * @param {?} documentPath
    * @return {?}
    */
    function(collectionPath, documentPath) {
      return this.getDocumentRef(collectionPath, documentPath).valueChanges();
    };
    DatabaseService2.prototype.deleteDocument = /**
    * Delete document
    *
    * @param {?} collectionPath
    * @param {?} documentPath
    * @return {?}
    */
    function(collectionPath, documentPath) {
      var _this = this;
      return this.afterUserRoleCheck(
        /**
        * @return {?}
        */
        function() {
          return _this.db.collection(collectionPath).doc(documentPath).delete();
        }
      );
    };
    DatabaseService2.prototype.getDocumentsDataAsPromise = /**
    * Get documents data as a promise
    *
    * @param {?} collectionPath
    * @param {?=} queryFn
    * @return {?}
    */
    function(collectionPath, queryFn) {
      return __awaiter(this, void 0, void 0, function() {
        var ref;
        return __generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              return [4, this.getCollectionRef(collectionPath, queryFn).get().toPromise().catch(
                /**
                * @param {?} error
                * @return {?}
                */
                function(error) {
                  console.log(error);
                }
              )];
            case 1:
              ref = _a3.sent();
              return [2, ref ? ref.docs : []];
          }
        });
      });
    };
    DatabaseService2.prototype.getDocumentsCount = /**
    * Get documents count
    *
    * @param {?} collectionPath
    * @param {?=} queryFn
    * @return {?}
    */
    function(collectionPath, queryFn) {
      return __awaiter(this, void 0, void 0, function() {
        var docs;
        return __generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              return [4, this.getDocumentsDataAsPromise(collectionPath, queryFn)];
            case 1:
              docs = _a3.sent();
              return [2, docs.length];
          }
        });
      });
    };
    DatabaseService2.decorators = [
      { type: Injectable }
    ];
    DatabaseService2.ctorParameters = function() {
      return [
        { type: AngularFirestore },
        { type: I18nService }
      ];
    };
    return DatabaseService2;
  }()
);
if (false) {
  DatabaseService.prototype._currentUser;
  DatabaseService.prototype.db;
  DatabaseService.prototype.i18n;
}
function slugify(str) {
  var a = "àáâäæãåāăąçćčđďèéêëēėęěğǵḧîïíīįìłḿñńǹňôöòóœøōõőṕŕřßśšşșťțûüùúūǘůűųẃẍÿýžźż·/_,:;";
  var b2 = "aaaaaaaaaacccddeeeeeeeegghiiiiiilmnnnnoooooooooprrsssssttuuuuuuuuuwxyyzzz------";
  var p2 = new RegExp(a.split("").join("|"), "g");
  return str.toString().toLowerCase().replace(/\s+/g, "-").replace(
    p2,
    /**
    * @param {?} c
    * @return {?}
    */
    function(c) {
      return b2.charAt(a.indexOf(c));
    }
  ).replace(/&/g, "-and-").replace(/[^\u0600-\u06FF\w\-]+/g, "").replace(/\-\-+/g, "-").replace(/^-+/, "").replace(/-+$/, "");
}
function now() {
  return !Date.now ? +/* @__PURE__ */ new Date() : Date.now();
}
function guid() {
  return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
}
var isFile = (
  /**
  * @param {?} input
  * @return {?}
  */
  function(input) {
    return "File" in window && input instanceof File;
  }
);
function resolve(obj) {
  var path = [];
  for (var _i2 = 1; _i2 < arguments.length; _i2++) {
    path[_i2 - 1] = arguments[_i2];
  }
  var current = obj;
  while (path.length) {
    if (typeof current !== "object")
      return void 0;
    current = current[path.shift()];
  }
  return (
    /** @type {?} */
    current
  );
}
var StorageService2 = (
  /** @class */
  function() {
    function StorageService3(storage) {
      this.storage = storage;
    }
    StorageService3.prototype.get = /**
    * @param {?} path
    * @return {?}
    */
    function(path) {
      return this.storage.ref(path);
    };
    StorageService3.prototype.upload = /**
    * @param {?} path
    * @param {?} file
    * @return {?}
    */
    function(path, file) {
      return this.get(path).put(file);
    };
    StorageService3.prototype.delete = /**
    * @param {?} path
    * @return {?}
    */
    function(path) {
      return this.get(path).delete();
    };
    StorageService3.decorators = [
      { type: Injectable }
    ];
    StorageService3.ctorParameters = function() {
      return [
        { type: AngularFireStorage }
      ];
    };
    return StorageService3;
  }()
);
if (false) {
  StorageService2.prototype.storage;
}
var FirebaseUserService = (
  /** @class */
  function() {
    function FirebaseUserService2(fas) {
      this.fas = fas;
      var config2 = FireAdminService.getFirebaseConfig(this.fas);
      this.app = initializeApp(config2, "FirebaseUserApp");
    }
    FirebaseUserService2.prototype.create = /**
    * @param {?} email
    * @param {?} password
    * @return {?}
    */
    function(email, password) {
      var _this = this;
      return new Promise(
        /**
        * @param {?} resolve
        * @param {?} reject
        * @return {?}
        */
        function(resolve2, reject) {
          _this.app.auth().createUserWithEmailAndPassword(email, password).then(
            /**
            * @param {?} userCredential
            * @return {?}
            */
            function(userCredential) {
              _this.app.auth().signOut();
              resolve2(userCredential.user.uid);
            }
          ).catch(
            /**
            * @param {?} error
            * @return {?}
            */
            function(error) {
              reject(error);
            }
          );
        }
      );
    };
    FirebaseUserService2.prototype.register = /**
    * @param {?} user
    * @return {?}
    */
    function(user) {
      var _this = this;
      return new Promise(
        /**
        * @param {?} resolve
        * @param {?} reject
        * @return {?}
        */
        function(resolve2, reject) {
          _this.app.auth().createUserWithEmailAndPassword(user.email, user.password).then(
            /**
            * @param {?} userCredential
            * @return {?}
            */
            function(userCredential) {
              _this.app.firestore().collection("users").doc(userCredential.user.uid).set(user).then(
                /**
                * @return {?}
                */
                function() {
                  _this.app.firestore().collection("config").doc("registration").set({ enabled: false }, { merge: true }).then(
                    /**
                    * @return {?}
                    */
                    function() {
                      _this.app.auth().signOut();
                      resolve2(userCredential.user.uid);
                    }
                  ).catch(
                    /**
                    * @param {?} error
                    * @return {?}
                    */
                    function(error) {
                      _this.app.auth().signOut();
                      reject(error);
                    }
                  );
                }
              ).catch(
                /**
                * @param {?} error
                * @return {?}
                */
                function(error) {
                  _this.app.auth().signOut();
                  reject(error);
                }
              );
            }
          ).catch(
            /**
            * @param {?} error
            * @return {?}
            */
            function(error) {
              reject(error);
            }
          );
        }
      );
    };
    FirebaseUserService2.prototype.updateEmail = /**
    * @param {?} email
    * @param {?} password
    * @param {?} newEmail
    * @return {?}
    */
    function(email, password, newEmail) {
      var _this = this;
      return new Promise(
        /**
        * @param {?} resolve
        * @param {?} reject
        * @return {?}
        */
        function(resolve2, reject) {
          _this.app.auth().signInWithEmailAndPassword(email, password).then(
            /**
            * @return {?}
            */
            function() {
              _this.app.auth().currentUser.updateEmail(newEmail).then(
                /**
                * @return {?}
                */
                function() {
                  resolve2();
                }
              ).catch(
                /**
                * @param {?} error
                * @return {?}
                */
                function(error) {
                  reject(error);
                }
              ).finally(
                /**
                * @return {?}
                */
                function() {
                  _this.app.auth().signOut();
                }
              );
            }
          ).catch(
            /**
            * @param {?} error
            * @return {?}
            */
            function(error) {
              reject(error);
            }
          );
        }
      );
    };
    FirebaseUserService2.prototype.updatePassword = /**
    * @param {?} email
    * @param {?} password
    * @param {?} newPassword
    * @return {?}
    */
    function(email, password, newPassword) {
      var _this = this;
      return new Promise(
        /**
        * @param {?} resolve
        * @param {?} reject
        * @return {?}
        */
        function(resolve2, reject) {
          _this.app.auth().signInWithEmailAndPassword(email, password).then(
            /**
            * @return {?}
            */
            function() {
              _this.app.auth().currentUser.updatePassword(newPassword).then(
                /**
                * @return {?}
                */
                function() {
                  resolve2();
                }
              ).catch(
                /**
                * @param {?} error
                * @return {?}
                */
                function(error) {
                  reject(error);
                }
              ).finally(
                /**
                * @return {?}
                */
                function() {
                  _this.app.auth().signOut();
                }
              );
            }
          ).catch(
            /**
            * @param {?} error
            * @return {?}
            */
            function(error) {
              reject(error);
            }
          );
        }
      );
    };
    FirebaseUserService2.prototype.delete = /**
    * @param {?} email
    * @param {?} password
    * @return {?}
    */
    function(email, password) {
      var _this = this;
      return new Promise(
        /**
        * @param {?} resolve
        * @param {?} reject
        * @return {?}
        */
        function(resolve2, reject) {
          _this.app.auth().signInWithEmailAndPassword(email, password).then(
            /**
            * @return {?}
            */
            function() {
              _this.app.auth().currentUser.delete().then(
                /**
                * @return {?}
                */
                function() {
                  resolve2();
                }
              ).catch(
                /**
                * @param {?} error
                * @return {?}
                */
                function(error) {
                  reject(error);
                }
              ).finally(
                /**
                * @return {?}
                */
                function() {
                  _this.app.auth().signOut();
                }
              );
            }
          ).catch(
            /**
            * @param {?} error
            * @return {?}
            */
            function(error) {
              reject(error);
            }
          );
        }
      );
    };
    FirebaseUserService2.decorators = [
      { type: Injectable }
    ];
    FirebaseUserService2.ctorParameters = function() {
      return [
        { type: FireAdminService }
      ];
    };
    return FirebaseUserService2;
  }()
);
if (false) {
  FirebaseUserService.prototype.app;
  FirebaseUserService.prototype.fas;
}
function getLogo() {
  return "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSI0MHB0IiBoZWlnaHQ9IjQwcHQiIHZpZXdCb3g9IjAgMCA0MCA0MCIgdmVyc2lvbj0iMS4xIj48ZyBpZD0ic3VyZmFjZTc1NjY3NjYiPjxwYXRoIHN0eWxlPSIgc3Ryb2tlOm5vbmU7ZmlsbC1ydWxlOm5vbnplcm87ZmlsbDpyZ2IoMCUsNDguMjM1Mjk0JSwxMDAlKTtmaWxsLW9wYWNpdHk6MTsiIGQ9Ik0gMjAgNDAgQyA4Ljk1MzEyNSA0MCAwIDMxLjA0Njg3NSAwIDIwIEMgMCA4Ljk1MzEyNSA4Ljk1MzEyNSAwIDIwIDAgQyAzMS4wNDY4NzUgMCA0MCA4Ljk1MzEyNSA0MCAyMCBDIDQwIDMxLjA0Njg3NSAzMS4wNDY4NzUgNDAgMjAgNDAgWiBNIDIwIDQwICIvPjxwYXRoIHN0eWxlPSIgc3Ryb2tlOm5vbmU7ZmlsbC1ydWxlOm5vbnplcm87ZmlsbDpyZ2IoODQuMzEzNzI1JSw4NC4zMTM3MjUlLDg0LjMxMzcyNSUpO2ZpbGwtb3BhY2l0eToxOyIgZD0iTSAxMS4zMzIwMzEgMjcuMDQyOTY5IEwgMTkuNTg1OTM4IDExLjU3MDMxMiBDIDE5Ljc1NzgxMiAxMS4yNDIxODggMjAuMjMwNDY5IDExLjI1IDIwLjM5NDUzMSAxMS41ODIwMzEgTCAyMy4yNSAxNy4yOTI5NjkgWiBNIDExLjMzMjAzMSAyNy4wNDI5NjkgIi8+PHBhdGggc3R5bGU9IiBzdHJva2U6bm9uZTtmaWxsLXJ1bGU6bm9uemVybztmaWxsOnJnYig5Ni4wNzg0MzElLDk2LjA3ODQzMSUsOTYuMDc4NDMxJSk7ZmlsbC1vcGFjaXR5OjE7IiBkPSJNIDExLjMzMjAzMSAyNy4wMzkwNjIgTCAxNC4zMzU5MzggOC41MTE3MTkgQyAxNC40MTQwNjIgOC4wMjczNDQgMTUuMDY2NDA2IDcuOTIxODc1IDE1LjI5Mjk2OSA4LjM1OTM3NSBMIDIxLjA4MjAzMSAxOS40NTMxMjUgWiBNIDExLjMzMjAzMSAyNy4wMzkwNjIgIi8+PHBhdGggc3R5bGU9IiBzdHJva2U6bm9uZTtmaWxsLXJ1bGU6bm9uemVybztmaWxsOnJnYig4NC4zMTM3MjUlLDg0LjMxMzcyNSUsODQuMzEzNzI1JSk7ZmlsbC1vcGFjaXR5OjE7IiBkPSJNIDExLjMzNTkzOCAyNy4wMzUxNTYgTCAxMS40NDUzMTIgMjYuOTQ5MjE5IEwgMjAuOTQxNDA2IDE5LjE3OTY4OCBMIDE4LjI2MTcxOSAxNC4wNDY4NzUgWiBNIDExLjMzNTkzOCAyNy4wMzUxNTYgIi8+PHBhdGggc3R5bGU9IiBzdHJva2U6bm9uZTtmaWxsLXJ1bGU6bm9uemVybztmaWxsOnJnYig5Ni4wNzg0MzElLDk2LjA3ODQzMSUsOTYuMDc4NDMxJSk7ZmlsbC1vcGFjaXR5OjE7IiBkPSJNIDExLjMzMjAzMSAyNy4wNDI5NjkgTCAyNS43NzczNDQgMTMuMTEzMjgxIEMgMjYuMDgyMDMxIDEyLjgyMDMxMiAyNi41ODU5MzggMTIuOTkyMTg4IDI2LjY0ODQzOCAxMy40MTAxNTYgTCAyOC42Njc5NjkgMjcuMDQyOTY5IEwgMjAuNTQyOTY5IDMxLjc3NzM0NCBDIDIwLjIxMDkzOCAzMS45NjA5MzggMTkuODA4NTk0IDMxLjk2MDkzOCAxOS40ODA0NjkgMzEuNzc3MzQ0IFogTSAxMS4zMzIwMzEgMjcuMDQyOTY5ICIvPjwvZz48L3N2Zz4=";
}
function getDefaultAvatar() {
  return "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/2wCEAAUDBAQEAwUEBAQFBQUGBwwIBwcHBw8LCwkMEQ8SEhEPERETFhwXExQaFRERGCEYGh0dHx8fExciJCIeJBweHx4BBQUFBwYHDggIDh4UERQeHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHv/AABEIAIAAgAMBIgACEQEDEQH/xAClAAADAQEAAgMAAAAAAAAAAAAFBgcECAIDAAEJEAABAwMCAwUFBQUFCAMAAAABAgMEAAURBiESMUEHE1FhcRQiMoGRCKGxwdEjUmJyghUkM0KSFiZTY3N00uGiwvABAAMBAQEBAQAAAAAAAAAAAAMEBQYCAQAHEQABBAEDAgMHAwUAAAAAAAABAAIDEQQFEiExQRMiUQZhcYGRobHB4fAjJDLR8f/aAAwDAQACEQMRAD8AjbagAAltrA8Ac1tjuKBJ7prPoaFtlfGNjW+MHOLO9Zh/RauMWjEV1RwA2jbyNEo7JcxxcfydUPyoZCSvbY0dgtqx1x60jK5PxRrXDtrS1BRQ4Tnn3pP4imW1xnG0gIzt4gGhcNIbTxrVwhO/EVbCqBpPQ+p702h9DDdohq+GRObKnFjxQxsceayB5GgRwzZL9sQtGyJYcdm6U0stuiSHffDPEEndfDsPU8hXtU/p2M5wzLzZWXc7pEtKlD5JJp4kdnuiLQyiXrC5meUDZd6nJbZH8rIKWx9DXsg637J7f/d7XdrNhJ4cW+IVpB8Mtox99WY9E2i5XrOS6oHuqJqV4N107kd1f4RCRk8TqgMf1JFHYjcCaniiSoskkc2Xkr/A0Vk9o3Z0lxMeVqCG2VkDheZWkfPKcAetfabl2Z3T/Cu2mXVeKXm21D57GiHRmEWx9/z5pCSYE+dpB/nwQh+27Y4cetDpNvxnKedOpsIUwH7Rc1LZO4DixIaUPJWcj5GsL8N1J7uUx3LnQg8SF/yn8jg0u/HmxuXCx6oVNd/iUgzYPDn3aCzIxB5DNUG4wQlJ4sADxpVu0cozkczSr57NBetYSk2a0pOTjG1C5AUNyTR64ICSrJGfWgkvh395P1rsHhNxsIU6j215RPuMbf8ANP6UYttkkun3URtueXT+lbbTDU+vCcfP8KJ6bemMXGdEnQkoa2MZYHMdfur6V5oq7AwE0vGFYZe3uwvm6v8A8aOQbFOBz3cDH/VX/wCNEIGcg8P3Vn1vqxrSNhM7u0uylEpisq5LXzyf4RzPjsOtIRCTJlETB1VKTZjRGV56JpF20R2XWZnUetnWnropJXBtrA7xwnopKTyP8asAdN6jHaL9qDXOonHI9gKNMW9WQExlcclY/idI2/pA9ajOsL3dL5d3rjdZjsuU+oqcdcOST0HkB0A2FBmzhXieZPhWvx4WwR7GLGZMjsiQvfyfwmeXqC4zpHtNxkuzJKzkuSHFOLPqpRJo1YLnLygpkKQlJznJwPl1pGYcGeIjPQCjFtlPoWDukjlnnXj2Fy+jeGdFWozkWbG7x6Q64+Rgl4jPqE7AfOvEW1mSw8FPA8Y4AVL6n1pHhzHuAFclaU5+Foc/Un8a0m8vuvNOBfC2hWEgAbk9POpj8R4PlKsxZjC2iE22Ny/6fPtmnL3PgvtIDixGkFPGAckcPI7bjINVnQPb9ILybRriE1JAIR7fFQEqUOilt8j8sVAWLjKakhRcUF8fduYPPCv0r36kVHXKUvjLRSAUrSOnIjHXxFGikmjdtceEtPBDI3c0UQu0ZDCb5BbuVjvEZ23up9wiOHMHqCSQQfIjIpbutjuWDm5N48oiR+dQHsz7RbzpJ9EmKtUuGFJEqPklEhvOD/KrHI9D5ZrqVuTBvNpj3K3Oh6LKaDrSsYPCehHQjkR4ip2bCGESMFX1HvSJ3xmh0+AUrudlmgKzP2/7dIpan22UnjzOUepwyj9KrN5hHgJGx8aQ7o2QtY4hkdKFG8ojHuckFSJEO1okwI3tboUApvvOAgdT8qORCl094tHBn4QDk8t6FF+NDtqpEnIbA3OfpWvT81uXFS8yQtBxk5zmuMgktulpMNotMUHiCxnh4euVYxSv206L1LcQ1dY8Bx21RYaVd7xDA4vfWcfMfSmmI4kDwGPGrDq/u19is9bacqNlUR4Z7qq3stEx+Q/eO1fU/sovtnlyY2PFs7u/T91+dd+jKafSPEnH0/8AVBQrYJPXc0XvMl1/ui6QSgkcsdKD4O5zxZ8qtvYGmlGjeX8rXGfDaFKIHEcAeQrZFnKHXFB8rUdsfpWqG2tTgG+eeelcEUuyLTTBkd4MqOwTkit1jYcmXOGyrAStYOw2AzvQRt1LTPADkc1eJo1p2e4z3rzSR3ykFttStg2DsT60NwFWiR2HAFE1lPeynzjg75SsgZOMn8q8bg4HmveI7wNgnH+Unp+NaWWorVoUsSkLdKhxYHLnv5mhkZASpTGM+7vk9cZoAZZtNSvLG/FbrCpaYr3Dxpyk4xsR866j+zDcXrhomZb5BWpUR1LiCrmErByPqn76i3YlCbX2iWGDcIiFtSElZQsbHIJTt9a6m0/Z2rLqu7NxI6WWHorSyAPdB4j+RouVgf2j5T1Hb6KS7UGunGOB2u0A1lbZMtLjKHVISrqDyqcxNOv2ZDiHZ70lKiThYzirRfnG0JUSRsKQr2oOtKUgisy13CtxvfsDa4UGvD7NxtSoLftIJOcezqxRrR/ststDcYtTVvAe9iMvGc5PrWeC4M4wSaOxXSlI559a8mk8u2uFoMePm7XuTcU7H2S4beEVdU66a605A7HRAus1MeTJtDiW2HcpWvdbeMc85TUzEhfDnK/H4qza6tQvGjFSCylyVYnHHHBjKhFdCSpQ/kWAT4Baj0NVPZx/hZBNdvv2/Cle1eG3KxGtcehv9D+VzBcSVS0pyCgnGAeVMGjNOi6tPOrGACQgUG1E023JT3KTwcWQeh9KdeyqTwtK35LIq1MSo2DG10m1C5WjQv3OJbLqV5UpScgj0ryTpof2o1FjrIQ4pKPM52qxx4UeYCpSEgkZzSvPjEalYhxEZcC0nKRsBQ3PpiptwAZPitd47M7bChREtuOBbrfEtZ3wfKlmLocm+I7uUTbwkFauP9oCAcp4cbnPyq8XSO6xdWostn9mtpHdlSdicb4+potG01bEJ75TSC4dzkA//jXcL2kHhc5eA5rqP2XO12tcu3RWnZDLbZI4ApI+IeOPSh1lQl24IQvbjXw5OwAJ/Sq922W9MlqKGOFpmK0469nbbYAfjUh081IlyyUDidBAShIydzgV5Ey3UEhl3Hw7hWuzS4CO1vTbsQthDTLaVFOwBAV+tXS0Xtcu+XuSxFflto7hgd0U+7gKUc5I8q4vKpEO6pUw662+lWUlJwoEHBwa6y7BYT6ezz26YnvXLhLW+lTmSShICAfmQqjazmEYb2kcn/YUnAwWDIbJd0KRHUEua82pLdnlgnqVNj/7VNLn/tC2iSg2vhaWfdzIQCkfXnVhuaEJB/YI2/hNJ18UgNOENpyAdgmsSxwPQLWMftFAKA21K18I4HN/JNHGIrx5NqPmSkflSomW7ao/tio0l2OFAHYqUM9BjanBqVHUyCw24UFII4neFQyM4I6GjysNWqUMgHC1QLeuRK7lSVjCeMhKs58BsOuD9D60Oftfao5qGTddFX2zNsvOFbceW6hKkA7FOFpweo54I9a+k3ty23VOG28SUpbbDyuNvj4gE8figFQWU9eAA7ZFO1smsTXoj8F/D85xfcOuqyTHaJ76bJPmQrhSMYAPgM6PTYomwNI78k/ZQtSnkkme0npwPpf3/RSe+dj3a5eCtZ0HplxTnxG2T2mUnr8Ad4R8gBWO1djnbXZEKEXs0ecBOdpra9/k5XRNu1nDg6fdvMhsmL3y2YhzwuSuDmoIPwpG2Tk4KgN96Axe3W6NTf2cC3oj8OUoUFKJHjnIPyxVPIGM0Dz3aHpOiatqBc7GjADe5IHPoPVSgaY7foowjsxljAx7rfH+DlYYWne2y2XYXMdl16U+FcRPsjigT8s12po3WVr1ExHaYlR/bVxkvraac4k7jcAnGSORHSmKbcEW23yZ8pxSI8ZlbzqgM4SlJUTj0FciBjm8chS8jUc7CyPBnaWvC42e1H21TJTSrv2TXN7u0gpDcB9o5A55wfnXtRr/ALQ2SoSOyq7oCR+5IB+9qumW9fTpM2V7JCaTEYiTX0qcUSpzuW462yRtwhXfKBG/w86ZtM6jRdXXYkhoMTG1LHAlRIWlAbCljwHEvGPKvPCa0dER2pZMhtzj9lw9qnUmrL9bnYb/AGcX+MHfiUht1RIzy3aoFpWDqK1yH329BaofddHCFCKvKBvy9yv0YkyI8WOuTKfbYZbGVuOLCUpHiSdhQ2+alsFjgRp11u0WLGkrShh1bmUuFXLGM5HXPIDc11FbHWwcpeeUzD+qbXC+ndP6gmanjTrn2d61kx2SMsRoZaKgOhUpJxnyFdj6ReDmj7Y47Yjp1KWy0zbnj7zDadkg5A6b/OiurdVxNP3Oy251lb0i7y/Z2kpUBwjICl788cSdhuc+VeWoWY01xEd0hTiElfCF4UEk4zt0ztU/VGmSBzn/AM5XuK9gfsHZL16lQEe6p9gKPIZGT8qnN51BZHbk5bUTmFSRzb6073C0REFXdslJOxVxHJ+dTu6aPsse6O3KPECJC/iWCcms3G1vNhWW+GOhUOjv4YLYlBCTgHBxW+IiOgYMlGcb70ChvryMpQfMoH6UWaeyOIst/wChP6UWRqqwn3rzv7DUq1PojusGSlPGyFEDKhuBnpnl86UdKavT3c2I3JLEs28xe5cOFYDgUpI8cgGmKbNQEkBptXkG0/pSqdOW/V10nsyI64UhlhJYfaSAXFlXUclJAB8DuN6taXBkMaS5h2HuVM1SWCRwDXgvHZVCxap4dR2NchpLke12fvo7ZHuqWltxzJHm4cn0r1WiTZZGh8yY7ffS7kEFwIBWhCEcauE/xKWn/TUiOne0TTklt+2uLuTLCFIQlJ48IOcpKFb9TyzzoSNZ3u021Fsn21bTrb/eguhTfNPCRwkeAT9KpSRtc00Of+LzQ9RbhZ0ck97B1r58/Ugq+aNvTmmtZhdocXNbjSAY6nUlPeAjABT0JBI511brJiTP0VfIcNlTkqTbZDTTQIyVqaUAn1ya/Oay9pwhy25b1nMh1DiV47/CVgEHhO2Ry6eNXm0/bJTxJFy0KcH4jHuGT9FI/Ou8VjmghyY9vtUxNTlx5cLzFoO41R7UO3v6eqsMFsMx7+OIZZtlwZx4HLTf4tYps7P40h3VFwuYbV7En2thLm2C57YsFI8wG0/UVFrV9qbQFzkuGdpGcwFsKS+tYbXxIznhPiMnNEpP2udEsLcRDsF1eSCSCChAUc86YMbiOFi2ym+QVa+1LTE3Vmno8C3XUW2QxMalIcU13iF8GfdUkEZG+fUCg947KbJeLVpeBc581abCpS/2Kg2mTxkFaVpwcJJA2HIbZqG3P7YqFIxa9FHPQyJpP3JT+dJGovtTdpN6zEtLMC0qc91IiMFx0+QKuLf0FfMbIyiDVIzpnSR+E7lt3XvXaOqntPW9ti/X4wGEW3jcZlyQkdwVJwSgnkSNttzUe0d2iI1r2sS7haWF/wBkNRRAaccBTxICi4p09BlQAAO+K52jaa7Vu0LU1qb1lKvMVietXdSrohzu0gDJIRzHTGwBPWus9BaRsWi9MNWO2Av8J7x955I7x5zG6j0HgANgPrU/UWOZDW0kFMYU8LZXbiCaPF+oq/kiVzfZIV+3aP8AWKTb0+0eId62P6xTDdExk8WGWk+iBSdeUsAqIabBx+4Kz7Y+Oic3BcwRZKVEhBJ4edF4TTjw95XCn0ofAjf3NLp+LJzRKI4UpHLFfoOjaJC0B8osqFqutSm2RGgtS4iS0pKUnJHxHmaxWN9Nl1C3KkpPszg7p7AyUDOQrzwefzoxHWjmojYVnfjpmpdcwOBOQnbn51rpsKKePYAsvj6jJFJvJVks1ghXOK1KYW2tLiQpDrZ4krH50ZToWLJa7ufbGZbZ/ebC049DUK0rfNRaUkFVmljuCriXGeTxtKPjjofMYqw6S7a7ctKGb/aJUB3YF2P+2b+myh99RZNPkiFtZaem1F7+WuWtzsJ7Nbkcy9Kw0KVuS2ktH/4kVhf+y52VyCS3EusUn/gz1YHyVmqZZtbaTugHseoLe4o/5FuhtX0Vg0zRXWHQFNrbWD1QoH8KkT20+ZlfJLxT5D3cSH6qFw/spdnLTiymfqIpUjh4TLRtuDn4PKt7H2W+zBo5cF9fBO4XPxn/AEpFXJkt5OR4V8efYbGVrbSPFRA/GkjJzQVZjZS2y9Sq1fZ57I4AH+6iZavGVKdd+4qx91PVg0hpbTiALJp61WzhGAY0RCFf6gM/fW16+21sEe2MqPgg8R+6k/WutlwmA1b0pDzmffXuUjxA8fWiRQTTPDWhCnzcXHbckln0HK9XaRNjLvNsjJUDIYUXCRzSCRgH6Zr5NnqGcK9KmrtyW7cUTHlqW53gLiick77mmC53AIClpV7uMg1Ty4PCYyPrQKzcOa6aZ83TkfTsiEy65JDpB/i/Wl25zEK4hvWOdP4iCCMEZFYVyEvIzj3h51lc7FDPOwfFbbTM4zeR55UPt8oGH3ByCVg+vjWxp4JXg490ZNLsZ3g9nUFc3SD9/wD6og7J7vvVnOePGM7nyreYztrVCyWbiir0xwlMZn/FdOD5DqaLtrS0wlkKCUJ5nNK9qXh1x5agV9VeB8K2e1FxQzuCevWqMExvcUhNBZDR2TC2tDhKh8q96EpI6HbrQWHJPCpStve2rYzI2+Laqcc4pISxEHhFGkJOApsK9d63QyGiC0FNkfuEihLMjIArYzJ880Y5Iqki9jkyxJs1RSn2qRy5F5WPxpltbClJC3lqVkf5lZpPtLqS4lRINMqJyUM+7gDHSomdl1w1CEDndU1IltRGDkhIAzzpFv8AeDNmLcKts4G/IVlv9+K0eztuHB+LeltconJKgd6Rx2bbe7qjCC+EeivqedCQCoZGT86KKmEJXFWo8TXwnPNPSglmeLDBdVkcdfLitayl1ojvEDIOdlDwqZmT+I/aqUEG0WvpE1Soq05HEytSDk+FecOQlTwO3vJOD133oAiUDImkZSlXC4M9Mp3+8V74biVIZSvBCgApJpDLi3scPVVsB5imaV//2Q==";
}
function getEmptyImage() {
  return "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAASABIAAD/4QBMRXhpZgAATU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAlKADAAQAAAABAAAAoAAAAAD/7QA4UGhvdG9zaG9wIDMuMAA4QklNBAQAAAAAAAA4QklNBCUAAAAAABDUHYzZjwCyBOmACZjs+EJ+/8AAEQgAoACUAwEiAAIRAQMRAf/EAB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXETIjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/bAEMAAQEBAQEBAgEBAgMCAgIDBAMDAwMEBQQEBAQEBQYFBQUFBQUGBgYGBgYGBgcHBwcHBwgICAgICQkJCQkJCQkJCf/bAEMBAQEBAgICBAICBAkGBQYJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCf/dAAQACv/aAAwDAQACEQMRAD8A/v4ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/9D+/iiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/0f7+KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/S/v4ooooAKKKKACiiigDHv/EGj6ZJ5N7OEf8AugFiPqADis//AITPw1/z8/8Ajj//ABNeG3E8lzO9xMcs5LEn1NQ11KgjmddnvH/CZ+Gv+fn/AMcf/wCJo/4TPw1/z8/+OP8A/E14PRR7FC9sz3j/AITPw1/z8/8Ajj//ABNH/CZ+Gv8An5/8cf8A+Jrweij2KD2zPpKw1Ow1SMy2EokA646j6g8ir1eG+CJ5IvEMUaHCyBlYeoCk/wAxXuVYVIWdjenO6uFFFFQWFFFFABRRRQB//9P+/iiiigAooooAKKKKAPl+iiivQPPCiiigAooooA6jwZ/yMtt/wP8A9AaveK8H8Gf8jLbf8D/9AaveK5a+51UNgooorE2CiiigAooooA//1P7+KKKKACiiigAooooA+X6UAsQqjJNJXpvgjw5vI1q9Xgf6pT3P97/D8/Su6UrK5wxjd2PNpYZYJWhnUo6nBB4INSWtrPe3KWtsu53OAK9e8YeGv7ThOo2S/wCkRjkD+NR/UdvyqTwf4c/sq2+3Xa/6RKOh/gX0+p7/AJVHtVa5p7F3scn4g8GnS9NjvLQmQxjE3/xQ9h0/ya4Gvp9lV1KuMg8EGvCvFXh9tFvPMhGbeU5Q+h7qfp29qVKpfRjq07aob4M/5GW2/wCB/wDoDV7xXg/gz/kZbb/gf/oDV7xWdfcuhsFFFFYmwUUUUAFFFFAH/9X+/iiiigAooooAKKKKAPme3aKG5V7qMyIp+ZM7c47ZwcV6MvxGVFCJY4AGABJ0H/fNa2reBLPULprq1lMBc5YbdwyeuORisv8A4Vv/ANPv/kP/AOyrpc4Pc5lCa2D/AIWR/wBOX/kT/wCxo/4WR/05f+RP/saP+Fb/APT7/wCQ/wD7Kj/hW/8A0+/+Q/8A7Kl+7H+8D/hZH/Tl/wCRP/sao6l44t9Usnsrmxyrjr5nIPYj5e1Xv+Fb/wDT7/5D/wDsqP8AhW//AE+/+Q//ALKhOmDVQ5jwWCfEluR23/8AoDV7vXL6B4Ws9CZp1YyzMMbiMYHsK6is6sk3oaUotLUKKKKzNAooooAKKKKAP//W/v4ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/9f+/iiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/0P7+KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/Z";
}
function getLoadingImage() {
  return "data:image/gif;base64,R0lGODlhhwCHAPUAAP////v7+/f39/Pz8+/v7+vr6+fn5+Pj49/f39vb29fX19LS0s7OzsrKysbGxsLCwr6+vrq6ura2trKysq6urqqqqqampqKiop6enpqampaWlpKSko6OjoqKioaGhn19fXl5eXFxcW1tbWlpaWVlZWFhYV1dXVlZWVVVVVFRUUlJSYKCgnV1dU1NTUVFRUFBQT09PTk5OTU1NS0tLSgoKDExMRwcHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgArACwAAAAAhwCHAAAG/0CAcEgsGo/IpHLJbDqf0Kh0Sq1ar9isdsvter/gsHhMLpvP6LR6zW673/C4fE6v2+/4vH7P7/v/gIGCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp6ipqqusra6vdwYJAgABGyYHQgcKAbBJARYhCLUduAACGyADvkQFCwRCFykPxCe5BiMiywECvbANIxNCDCQaAQEeKLkNJxi9AQPLsAUfJQoABCEhBOgpBgAYVFCDN4AWKwKzxqHw0A1DhwIBIlwYEADDh1wCCBg8ttHUghAYaNlK0QBAAQQdAxw48K6bkIzyThHIgCIkAAQWFjTh9pKARv9VAgJqkOfNyQADBTqOQigvKIh7UeAlHSJAqacFIj4wEKISmpSqXAkMgCiKwAQRJTQMu8KNgAGXpApYGGHBatSxdkUhSFCUioCCpA5QkIDyS0axnxZ8yAqCQoEtAQwYQIDAa6cABRRQ+JAhwRYBKwv2/QQv7xRuo5kxs4AhAwYMDVJXOUqZ8qfFJEiMoCCbCsIFDIJ/IlCg+FQu51CrXg5ggAIIEHJlwVzcNCYDFTh8ACkdC2YFDBJU/oRgwwYICixroa3gn6fSQ+D1fsIz/vxNCy48sN6EAGX+mqg0AQgebHXFAAgw0ABZemnAgQSP1XIfE5gt0ABLohzgwFoAKDDvQXf0JcDLS0hNyIkCHmgQIRQBJBDBiKos0IEGGB2gHhIBINbiAwsA2IkBHHAgHQMY3KMcEeccs8AC8rjIoSkFOOBeARhcAI0CPeLzT4s9BoBABGuBtqIqAUDAgWcBUEABRQ9YsAwDjjUHgQMxuXLABRHQQkAFEpwjgQbQHDCBZwAc8ACMrhjQgFf56RQRBtAMEMED71BmYineBMDABbk8Co0AEOTJHJIFJBRAm14dgMClo7bq6quwxirrrLTWauutuOaq66689urrr8AGK+ywxBZr7LHIJqvsssw26+yz0EYr7bTUVmvttdhmqy0ZQQAAIfkEBQoAGgAsLwAuACgAKAAABv9AjXBILBoAQoyGICQgitCodHhiajYqq4Y07RIHGoEw4loIscwBi5h4eqEI09AQUmo4WY2CaCBt3lBgGgdhGiBiHC9MEzFmGh8wDIBhB0gaCVdCFR9CD0MbI0wKMH9CBYRThBVEKntiUwMhJwVCDCkZXQIWQkhMmF4EGRBCCy8tblMAu3aTRA8qJ0dRAgSWlqjNQisltFMsHMgEr9kaBloBUAIPXBfS5FIDWkUT78lvBQb1UOhQEQ3V+t68esLCgwYJggJGOYcsn0I+BbpBsfawYsUIFTJScGRRAz8hDoWE6DhETIMhAFKqJFmEIksvAQxIkliRUEICEoSM0EDzISqIfOU0YHBg4CNJAgXcrBRi9CWfChE6hixCIMKKUhYRKEhYBAJXi9iaKJB4wIG8bGG9HODAjNwBT4CeXGDiMhuCukUwZOimYILSLif5EZoaaIEVXRTEhHuDt4sDC6gkRHXKk4iACcM0OLgwziEBjtnkGaCA6vGrBidNEa6XwcrmVw4oDzn5qmeXIAAh+QQFCgAAACwvAC4AKAAoAAAG/0CAcEgsGomGo3JZHC1FzOjR4ZRalaxIFFGqXJkcViHqGnZaie94OLoIJx4hwyLEsIiZLyA+tJSuIHpDJF6ChQANACZWEX+CQw0wehF8jwAhRAVJRCt5lksCFiqVch8gFASfRAIQJjErB1iHqg4nI4mqVwULRw+5UgMOFg8FHCIcHL6/RBMjJCkuFEMPGnTLQxosFwcD197fzBLi4EIDBOcEHaYgpN4HCfBp5PO/BAoK9EQPFxwrs9fvzAmx8A+cgAEG1uSTIsHBMgFRHGywIC9XgAMGEBypcAGXNwEGukVh8EmhkFRLCliQ9omXFQMWJgxBqceAyygTWApRJgUekUybSxJAfCNBSAGNAIYKQVpAgUKaVhZEWPPA5YKiABJoEbIAqJ4JHh+QBMBAJgACPAEgiPUI3xCHcswCUOD1V4JDZYd0JYd0LoRMV4IAACH5BAUKAAEALC8ALgAoACgAAAb/wIBwSCwWhhNRcclsNkFDC2mIgTqvRERRIZQOO6vhAev8OISFTqU7FbImQ9CFzLx0hquN8GIanoYbKHRMBh9rARAaSF1EgkRHVxsRQxRKdB4jRCQWWBIiEEMRY3QNQyiWZCFwg0ULLZlOA0UbkKxCd1cIGIe2ZBQBekUeGqC9VyocTQ8cxcbGBM6sDAnRtqUYHBoXpdVLDyx/MEUWENDdRB4nZrXnse3VDA8QEA5a70IIGRwb/BYc/xnO3AvAIEUMGDBcDFzIsCEFDAxkCWlA4YKGBxLfdUCYAkS5CBEWBADA0MCDDyYUNRxEgIHIdgIyLmFAQdS7AgLMPXoggcvCbwEAZAYYNcSnsQE6AwjAMuFBtAEG2F2RwC0aAQNJlTkVYmBB1iYHDAwZgEBoEQFEAzioKjWAAbFCDpgdhOBlgKoIGMTVi89erwEPqAlZ4DNBVbs529LxSyABpAR8h/qN2W4SPoEBEvhtmJfIXCZBAAAh+QQFCgAAACwvAC4AKAAoAAAG/0CAcEgkDoqeonLJXD6Sw9DQwmlam4sVIjrUdK5gQ4aoiXCFHjO6Al5SNEfABjMUCR+kIcbUZnYkUwJFE1VCI2x9ABYPRCtWBEMcH4lCDlB3fYBCCiV9DR1qlEN8iQ6IonKTTQYUE6hLkEVjRAkZF69NIilNDbe4RAwjIL/EQwrFlBRjFAvIRSslJy20ms5CHCWX1tvcDQ0ODNwABr4AGRQXFxgW4gAn7fDbBgfc1UMLDxEVDdwaRA4AHgCMN6QcwYOVRJxSkiDCwGIHWMAowc8Ig4fWHqRQQacJgS2vLJQTQMFekQHgcGmg4Q8MAQfNfmGQsSEOlopC6LUhEAuAhjYZBmHROgZggE0mRyXgDJPAmIElTYc8fUVUCAKQRRDYFHA00dScTAqIM7A0nBADYuMZqBogURAAIfkEBQoAAAAsLwAuACgAKAAABv9AgHBILBIhHKNyyRw2NENJUiiBNq/CAtEKmEwBFwwWa1kMKQ+hN4tpDDWSsRFCGV7qXY+w8TkIKyByShZpAAwQc2JCLIIABRFmQg5cBE0YHUQgEVcMF5ECkVgQCkMfHVpXCxZujZlcY5utQhYblUwODrJYEiIWRhKjukoNHiMZSwoQDMJFH1/M0AAGAtFNCrEPEhEQCNVEDR0sJSZFDqTeQhksr+jt6AgL8Qqo7RUAGccOEvsP5+4uKlygcEfQna12vogcaNDgQQJ3GFQAMMGBwYAECroVFKIhxEZBAg4YqLYszhIDCxIcjHYCQKghBxKMbLdgxEAiAqgRGSAMzxFqaxplXQCgCIsCP40EMJgJoMUYBEEB8MRSgEQgIRhS2BN0ACmAAEYqaOBpIUYsWQQG6DQwtQDSDDEeAiCRgl4jBEwLzHS7R0UsBi2OyZoqJGcWpAVGXAWgLRoBf3yFgCixMpoAwgC8NpQTBAAh+QQFCgAxACwvAC4AKAAoAAAG/8CYcEgsEhsWo3LJHC6SQggRcmlalQloTDqUaK/MCFEcJX4tXDDR8RhSuJCNcCEXSjYGtRGyMCIaQg5aHGRqgE6FVhUZRB5XCBNECGoMekUTfZZDCB4cegqHmjETGE0DC5lCAKJKDx9GBg4OrEt9IBRLk7RGHRq7v0MHwGAPCjENDw6pw0QrISISQwYLuswxFisYy9bc1gcIB3ndQhcV5gwPEA8M1cwIIiknJyXj9fbMEglFCgkNwt0oUIjwJQSBuHu37ilc8qpJO2ArUiwpcIBAPRO4mAj4ldHOLCYHWcFQI6DiryRVrBAICSDAlQEizLjQVKBAlA0WERgbVSoGhTeZwwSwGGGRQ4sBQl4QoceKgMUYBkisEMJBxdN6DlCQ2WB1SZtfGWDoqnp13IMKG2NoaPF0W5MgACH5BAUKAAAALC8ALgAoACgAAAb/QIBwSCwWJ8akckmUDBlIYQPCrCojBCGjMnxQrcxB4zBcLLTRQUQxjDjARsVZGGkIHZbhpbuHFwUMRAlJEUIFGA9+AAkIQwl2QgJMEhREGJBMDmSGfo0ABhh5VgcOnopCBhmiYAcKkqcAD5VEA0UGB6+wSwwZhUUKCAW6ShW9SgYJm8NDFqvLz9Bgj0IJcgDC0UMKFhkdHV8ABMHZQxQbE4Pk6utZQ7XrTkITCGYL4+sfIiIkIev+/+reFClwoECCduQohGDxYUiBAgj9nfkG0I+Ad9A2gDMigEDEZx1CrEgyAKO6DyziKVnQQZmiCCqtNHiBwsAwFXAewDixaYHNUn8IWqTYFAHFxiUgiqDwpQRBBWwEWpCo5aDPTyMniDyYAwaDCkxDNKAQcqHFkBAjdAVtGE5EhyRjh4yYpQgBBmwATCgJ4WFdnyQrRKxjEDMrrCAAIfkEBQoALQAsLwAuACgAKAAABv/AlnBILBITD6NyyRweGkNFZJhgNK/KglWoSAoXDiw2URgaEFwidMhYiI0I9DfBhQwjAyFDQngbDQdCB2UtBXIJay0Rbn4FhC2ATQFDDmFCBRKMTAUKj3liCkQUU1gEdH5GExKNj6gtDF5MA32uYhaWQwODn7VwE7dKAAStvUIGEhIGV7zFQrRFBALNqAEFBwcGzNNDEhQYGIkCBtLbRBAWpOXq60oE7trqDhDzdnGD7EMZHysdHvj/6xJMuBBoHQMHyoxxMKGihgg56iKs+KBhQoIFJUhYBCgkQgaOfhKA4KAO3BIDHWKgSDcNwweSRTC+yPCsHIIN/o5UgNhiQ7FnB7FaNNiy5MSIYhBGUHijIgQxLAhoRWCxFAuJRyWINvGAYQiEEEH/FDkh4kqFjiISuaqAYsgKFkK6DjEx5AOIZjBbsNAgJEOKISUsKfjQy4CFIQuODjnh1ic7tkT+CumwAqQQEr2CAAAh+QQFCgAAACwvAC4AKAAoAAAG/0CAcEgsFhnGpHKpRCCHCaZUqRgiiInFdHpYPgHRrbRQIHaFjuGDmBa7ido3syz+AiDbKzGQJ0bWWwZ0ckJ/hIcKdoeLCRJJBAKLSg8RikQDkkUObZmSBxcSg51UYCgvJicZBKNEDxIVFloCCxsnIWGsABIOZ0WRucCLG8PDEcGYQw4tLzAwLhvBABcdHAAZ0di5FdlDq9wAHB0Txt9WABblYhqjCOhL68AWGhd6RS3YGBmA6VskmSHkpDAoMWIUHiksihTktg9ACRBCGFAwAmGCkDVxAFiSYoLIByEWFk4c0qHDoo5DVhApMUSEuUUj1QjB4BLAAGhDNhJSMQQDSgoA8IBVGVIhIaEgACH5BAUKACQALC8ALgAoACgAAAb/QJJwSCwSCwmjcskcEpJCA9FwaFqX1ehiWEBcrwOigKAdHqTCQvZLHISFh0KUURYiFGwSAS0UyPUBQgN/B15CC2tXCiMbbWwIhnoNkUscNhpDAG9WBWSHdFcbNB15RQQMoEoDiRomlKV4TA0oI1tRpUwHD7GCFS4vG4m4RwyTSgQbLR7DRgULC55LCrbM1dZKfyQlKkIW10YGDQ0PEUUl30YLDdToTQDt1RdEDvBDCgzPCydEGfVCEhcCVvBHEF6VCQQXZCORYYQQEP4cVMAAwcGBBCFCkBBWj4EEdgW/YGgngZeSFCXofRsQ4UIFPnYcFqRAIdVGCUQSeGPWwIhJYiMorDngoNIKHo1CoJQaygYpiQcf2Lgc4qBDzyYRorFYRkJBOT1rvjZoZM3pBg5CKEAkIYHFkAyYmIUYKYQsCQsi4KygpqGoNQ9Xdw4ZaO/bhLzdEJO4ELfeVRITotoBySQIACH5BAUKAAAALC8ALgAoACgAAAb/QIBwSCQaEMQDMVBsOp9CDaowVA4H0CxxsBhOVIzqUEDVahWti/Aw2oiFA8K4bN6GUgbhSIQFJIQEVkJ5dU0KKh1CGSSEQwWNf4VDGUMeMF1+Wo1+m04ZMkMGGWF1AkMISGYWNW6SRQmRhSSuRoJOCyUgsbRQBAqpQxIpvFqonZMAHMRNBcDLz0IV0IUFVCMxJCPTTrALDYIXIx/bRAm/5Ojp6lqmRCUtLSotFuoEDhL4Eev75BD66Qp2AbAQooSKFeoUSKCwANMKD/wGKXAQUdIGadsaOCtygQQIUtMcRIDgZAUJCuoKRGjQ5EE6TEJQZRGhjNgCeoVGaJDjig4DWgwgn+TxwLNBojoU/gFgkEGBFoqVNAxxwITIAqgLKA1JYEtLhA5WMGiNUPNBTQAVMPICoRatEApHAWyIZKCtK6UIOGCScJbCBHUQWHgZJ2QCTnTOIrQSIhBKEAA7";
}
var UsersService = (
  /** @class */
  function() {
    function UsersService2(db2, storage, firebaseUser) {
      var _this = this;
      this.db = db2;
      this.storage = storage;
      this.firebaseUser = firebaseUser;
      this.allRoles = {};
      this.imagesCache = {};
      this.fullNameCache = {};
      Object.keys(UserRole).forEach(
        /**
        * @param {?} key
        * @return {?}
        */
        function(key) {
          _this.allRoles[UserRole[key]] = key;
        }
      );
    }
    UsersService2.prototype.getAllRoles = /**
    * @return {?}
    */
    function() {
      return this.allRoles;
    };
    UsersService2.prototype.add = /**
    * @param {?} data
    * @return {?}
    */
    function(data) {
      var _this = this;
      var user = {
        firstName: data.firstName,
        lastName: data.lastName,
        email: data.email,
        password: data.password,
        // ToDo: add encryption for password (do not use hashing, since we need plain password on update/delete @see FirebaseUserService)
        birthDate: data.birthDate,
        role: data.role,
        bio: data.bio,
        avatar: null,
        createdAt: now(),
        // timestamp
        updatedAt: null,
        createdBy: this.db.currentUser.id,
        updatedBy: null
      };
      return new Promise(
        /**
        * @param {?} resolve
        * @param {?} reject
        * @return {?}
        */
        function(resolve2, reject) {
          _this.firebaseUser.create(data.email, data.password).then(
            /**
            * @param {?} uid
            * @return {?}
            */
            function(uid) {
              _this.uploadImageAfter(_this.db.addDocument("users", user, uid), user, data).then(
                /**
                * @return {?}
                */
                function() {
                  resolve2();
                }
              ).catch(
                /**
                * @param {?} error
                * @return {?}
                */
                function(error) {
                  reject(error);
                }
              );
            }
          ).catch(
            /**
            * @param {?} error
            * @return {?}
            */
            function(error) {
              reject(error);
            }
          );
        }
      );
    };
    UsersService2.prototype.register = /**
    * @param {?} data
    * @return {?}
    */
    function(data) {
      var _this = this;
      var user = {
        firstName: data.firstName,
        lastName: data.lastName,
        email: data.email,
        password: data.password,
        // ToDo: add encryption for password (do not use hashing, since we need plain password on update/delete @see FirebaseUserService)
        birthDate: data.birthDate,
        role: data.role,
        bio: data.bio,
        avatar: null,
        createdAt: now(),
        // timestamp
        updatedAt: null,
        createdBy: null,
        updatedBy: null
      };
      return new Promise(
        /**
        * @param {?} resolve
        * @param {?} reject
        * @return {?}
        */
        function(resolve2, reject) {
          _this.firebaseUser.register(user).then(
            /**
            * @return {?}
            */
            function() {
              resolve2();
            }
          ).catch(
            /**
            * @param {?} error
            * @return {?}
            */
            function(error) {
              reject(error);
            }
          );
        }
      );
    };
    UsersService2.prototype.uploadImageAfter = /**
    * @private
    * @param {?} promise
    * @param {?} user
    * @param {?} data
    * @return {?}
    */
    function(promise, user, data) {
      var _this = this;
      return new Promise(
        /**
        * @param {?} resolve
        * @param {?} reject
        * @return {?}
        */
        function(resolve2, reject) {
          promise.then(
            /**
            * @param {?} doc
            * @return {?}
            */
            function(doc) {
              if (data.avatar && isFile(data.avatar)) {
                var id_1 = doc ? doc.id : data.id;
                var imageFile = (
                  /** @type {?} */
                  data.avatar
                );
                var imageName = guid() + "." + imageFile.name.split(".").pop();
                var imagePath_1 = "users/" + id_1 + "/" + imageName;
                _this.storage.upload(imagePath_1, imageFile).then(
                  /**
                  * @return {?}
                  */
                  function() {
                    user.avatar = imagePath_1;
                    var savePromise = doc ? doc.set(user) : _this.db.setDocument("users", id_1, user);
                    savePromise.finally(
                      /**
                      * @return {?}
                      */
                      function() {
                        resolve2();
                      }
                    );
                  }
                ).catch(
                  /**
                  * @param {?} error
                  * @return {?}
                  */
                  function(error) {
                    reject(error);
                  }
                );
              } else {
                resolve2();
              }
            }
          ).catch(
            /**
            * @param {?} error
            * @return {?}
            */
            function(error) {
              reject(error);
            }
          );
        }
      );
    };
    UsersService2.prototype.get = /**
    * @param {?} id
    * @return {?}
    */
    function(id2) {
      return this.db.getDocument("users", id2).pipe(map(
        /**
        * @param {?} user
        * @return {?}
        */
        function(user) {
          user.id = id2;
          return user;
        }
      ));
    };
    UsersService2.prototype.getFullName = /**
    * @param {?} id
    * @return {?}
    */
    function(id2) {
      var _this = this;
      if (this.fullNameCache[id2]) {
        return of(this.fullNameCache[id2]);
      } else {
        return this.get(id2).pipe(map(
          /**
          * @param {?} user
          * @return {?}
          */
          function(user) {
            var fullName = user.firstName + " " + user.lastName;
            _this.fullNameCache[id2] = fullName;
            return fullName;
          }
        ));
      }
    };
    UsersService2.prototype.getAll = /**
    * @return {?}
    */
    function() {
      return this.db.getCollection("users");
    };
    UsersService2.prototype.getWhere = /**
    * @param {?} field
    * @param {?} operator
    * @param {?} value
    * @return {?}
    */
    function(field, operator, value) {
      return this.getWhereFn(
        /**
        * @param {?} ref
        * @return {?}
        */
        function(ref) {
          return ref.where(field, operator, value);
        }
      );
    };
    UsersService2.prototype.getWhereFn = /**
    * @param {?} queryFn
    * @return {?}
    */
    function(queryFn) {
      return this.db.getCollection("users", queryFn);
    };
    UsersService2.prototype.getAvatarUrl = /**
    * @param {?} imagePath
    * @return {?}
    */
    function(imagePath) {
      var _this = this;
      if (imagePath) {
        if (this.imagesCache[imagePath]) {
          return of(this.imagesCache[imagePath]);
        } else {
          return merge(of(getLoadingImage()), this.storage.get(imagePath).getDownloadURL().pipe(map(
            /**
            * @param {?} imageUrl
            * @return {?}
            */
            function(imageUrl) {
              _this.imagesCache[imagePath] = imageUrl;
              return imageUrl;
            }
          )));
        }
      } else {
        return of(getDefaultAvatar());
      }
    };
    UsersService2.prototype.updateEmail = /**
    * @private
    * @param {?} email
    * @param {?} password
    * @param {?} newEmail
    * @return {?}
    */
    function(email, password, newEmail) {
      var _this = this;
      return new Promise(
        /**
        * @param {?} resolve
        * @param {?} reject
        * @return {?}
        */
        function(resolve2, reject) {
          if (newEmail !== email) {
            _this.firebaseUser.updateEmail(email, password, newEmail).then(
              /**
              * @return {?}
              */
              function() {
                resolve2();
              }
            ).catch(
              /**
              * @param {?} error
              * @return {?}
              */
              function(error) {
                reject(error);
              }
            );
          } else {
            resolve2();
          }
        }
      );
    };
    UsersService2.prototype.updatePassword = /**
    * @private
    * @param {?} email
    * @param {?} password
    * @param {?} newPassword
    * @return {?}
    */
    function(email, password, newPassword) {
      var _this = this;
      return new Promise(
        /**
        * @param {?} resolve
        * @param {?} reject
        * @return {?}
        */
        function(resolve2, reject) {
          if (newPassword !== password) {
            _this.firebaseUser.updatePassword(email, password, newPassword).then(
              /**
              * @return {?}
              */
              function() {
                resolve2();
              }
            ).catch(
              /**
              * @param {?} error
              * @return {?}
              */
              function(error) {
                reject(error);
              }
            );
          } else {
            resolve2();
          }
        }
      );
    };
    UsersService2.prototype.edit = /**
    * @param {?} id
    * @param {?} data
    * @param {?} oldData
    * @return {?}
    */
    function(id2, data, oldData) {
      var _this = this;
      var user = {
        firstName: data.firstName,
        lastName: data.lastName,
        email: data.email,
        password: data.password,
        birthDate: data.birthDate,
        role: data.role,
        bio: data.bio,
        updatedAt: now(),
        updatedBy: this.db.currentUser.id
      };
      if (
        /*data.avatar !== undefined && */
        data.avatar === null
      ) {
        user.avatar = null;
      }
      return new Promise(
        /**
        * @param {?} resolve
        * @param {?} reject
        * @return {?}
        */
        function(resolve2, reject) {
          _this.updateEmail(oldData.email, oldData.password, data.email).then(
            /**
            * @return {?}
            */
            function() {
              _this.updatePassword(data.email, oldData.password, data.password).then(
                /**
                * @return {?}
                */
                function() {
                  _this.uploadImageAfter(_this.db.setDocument("users", id2, user), user, __assign({}, data, { id: id2 })).then(
                    /**
                    * @return {?}
                    */
                    function() {
                      resolve2();
                    }
                  ).catch(
                    /**
                    * @param {?} error
                    * @return {?}
                    */
                    function(error) {
                      reject(error);
                    }
                  );
                }
              ).catch(
                /**
                * @param {?} error
                * @return {?}
                */
                function(error) {
                  reject(error);
                }
              );
            }
          ).catch(
            /**
            * @param {?} error
            * @return {?}
            */
            function(error) {
              reject(error);
            }
          );
        }
      );
    };
    UsersService2.prototype.deleteImage = /**
    * @private
    * @param {?} imagePath
    * @return {?}
    */
    function(imagePath) {
      var _this = this;
      return new Promise(
        /**
        * @param {?} resolve
        * @param {?} reject
        * @return {?}
        */
        function(resolve2, reject) {
          if (imagePath) {
            _this.storage.delete(imagePath).toPromise().then(
              /**
              * @return {?}
              */
              function() {
                resolve2();
              }
            ).catch(
              /**
              * @param {?} error
              * @return {?}
              */
              function(error) {
                reject(error);
              }
            );
          } else {
            resolve2();
          }
        }
      );
    };
    UsersService2.prototype.delete = /**
    * @param {?} id
    * @param {?} data
    * @return {?}
    */
    function(id2, data) {
      var _this = this;
      return new Promise(
        /**
        * @param {?} resolve
        * @param {?} reject
        * @return {?}
        */
        function(resolve2, reject) {
          _this.firebaseUser.delete(data.email, data.password).then(
            /**
            * @return {?}
            */
            function() {
              _this.db.deleteDocument("users", id2).then(
                /**
                * @return {?}
                */
                function() {
                  _this.deleteImage(data.avatar).then(
                    /**
                    * @return {?}
                    */
                    function() {
                      resolve2();
                    }
                  ).catch(
                    /**
                    * @param {?} error
                    * @return {?}
                    */
                    function(error) {
                      reject(error);
                    }
                  );
                }
              ).catch(
                /**
                * @param {?} error
                * @return {?}
                */
                function(error) {
                  reject(error);
                }
              );
            }
          ).catch(
            /**
            * @param {?} error
            * @return {?}
            */
            function(error) {
              reject(error);
            }
          );
        }
      );
    };
    UsersService2.prototype.countAll = /**
    * @return {?}
    */
    function() {
      return this.db.getDocumentsCount("users");
    };
    UsersService2.prototype.countWhereFn = /**
    * @param {?} queryFn
    * @return {?}
    */
    function(queryFn) {
      return this.db.getDocumentsCount("users", queryFn);
    };
    UsersService2.prototype.countWhere = /**
    * @param {?} field
    * @param {?} operator
    * @param {?} value
    * @return {?}
    */
    function(field, operator, value) {
      return this.countWhereFn(
        /**
        * @param {?} ref
        * @return {?}
        */
        function(ref) {
          return ref.where(field, operator, value);
        }
      );
    };
    UsersService2.decorators = [
      { type: Injectable }
    ];
    UsersService2.ctorParameters = function() {
      return [
        { type: DatabaseService },
        { type: StorageService2 },
        { type: FirebaseUserService }
      ];
    };
    return UsersService2;
  }()
);
if (false) {
  UsersService.prototype.allRoles;
  UsersService.prototype.imagesCache;
  UsersService.prototype.fullNameCache;
  UsersService.prototype.db;
  UsersService.prototype.storage;
  UsersService.prototype.firebaseUser;
}
var CurrentUserService = (
  /** @class */
  function() {
    function CurrentUserService2(users, db2) {
      this.users = users;
      this.db = db2;
      this.data = null;
      this.dataChange = new Subject();
      this.userChange = new Subject();
      this.db.setCurrentUser(this);
    }
    CurrentUserService2.prototype.get = /**
    * @return {?}
    */
    function() {
      return this.data ? this.data : this.dataChange.pipe(take(1)).toPromise();
    };
    CurrentUserService2.prototype.set = /**
    * @param {?} user
    * @return {?}
    */
    function(user) {
      var _this = this;
      this.unsubscribe();
      if (user) {
        this.users.get(user.uid).pipe(takeUntil(this.userChange)).subscribe(
          /**
          * @param {?} user
          * @return {?}
          */
          function(user2) {
            if (user2) {
              user2.avatar = _this.users.getAvatarUrl(
                /** @type {?} */
                user2.avatar
              );
            }
            _this.data = user2;
            _this.dataChange.next(_this.data);
          }
        );
      }
    };
    CurrentUserService2.prototype.unsubscribe = /**
    * @return {?}
    */
    function() {
      this.userChange.next();
    };
    CurrentUserService2.prototype.hasRole = /**
    * @private
    * @param {?} role
    * @return {?}
    */
    function(role) {
      return this.data && this.data.role === role;
    };
    CurrentUserService2.prototype.isAdmin = /**
    * @return {?}
    */
    function() {
      return this.hasRole(UserRole.Administrator);
    };
    CurrentUserService2.prototype.isGuest = /**
    * @return {?}
    */
    function() {
      return this.hasRole(UserRole.Guest);
    };
    CurrentUserService2.decorators = [
      { type: Injectable }
    ];
    CurrentUserService2.ctorParameters = function() {
      return [
        { type: UsersService },
        { type: DatabaseService }
      ];
    };
    return CurrentUserService2;
  }()
);
if (false) {
  CurrentUserService.prototype.data;
  CurrentUserService.prototype.dataChange;
  CurrentUserService.prototype.userChange;
  CurrentUserService.prototype.users;
  CurrentUserService.prototype.db;
}
var FireAdminComponent = (
  /** @class */
  function() {
    function FireAdminComponent2(alert, currentUser) {
      this.alert = alert;
      this.currentUser = currentUser;
    }
    FireAdminComponent2.prototype.ngOnInit = /**
    * @return {?}
    */
    function() {
    };
    FireAdminComponent2.prototype.ngOnDestroy = /**
    * @return {?}
    */
    function() {
      this.currentUser.unsubscribe();
    };
    FireAdminComponent2.prototype.clearAlert = /**
    * @return {?}
    */
    function() {
      if (!this.alert.isPersistent) {
        this.alert.clear();
      }
    };
    FireAdminComponent2.decorators = [
      { type: Component, args: [{
        selector: "fa-root",
        template: '<router-outlet (deactivate)="clearAlert()"></router-outlet>',
        encapsulation: ViewEncapsulation$1.None,
        styles: [`:root{--blue:#007bff;--indigo:#674eec;--purple:#8445f7;--pink:#ff4169;--red:#c4183c;--orange:#fb7906;--yellow:#ffb400;--green:#17c671;--teal:#1adba2;--cyan:#00b8d8;--white:#fff;--gray:#868e96;--gray-dark:#343a40;--primary:#007bff;--secondary:#5a6169;--success:#17c671;--info:#00b8d8;--warning:#ffb400;--danger:#c4183c;--light:#fbfbfb;--dark:#212529;--breakpoint-xs:0;--breakpoint-sm:576px;--breakpoint-md:768px;--breakpoint-lg:992px;--breakpoint-xl:1200px;--font-family-sans-serif:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;--font-family-monospace:"Roboto Mono",Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--salmon:#ff4169;--royal-blue:#674eec;--java:#1adba2}body{color:#5a6169}h1,h2,h3,h4,h5,h6{margin-top:0}.h1,.h2,.h3,.h4,.h5,.h6{display:block}.h1,.h2,.h3,.h4,.h5,.h6,h1,h2,h3,h4,h5,h6{margin-bottom:.75rem;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;font-weight:400;color:#3d5170}.h1,h1{font-size:3.052rem;letter-spacing:-.0625rem;line-height:3rem}.h2,h2{font-size:2.441rem;letter-spacing:-.0625rem;line-height:2.25rem}.h3,h3{font-size:1.953rem;line-height:2.25rem}.h4,h4{font-size:1.563rem;line-height:2rem}.h5,h5{font-size:1.25rem;line-height:1.5rem}.h6,h6{font-size:1rem;line-height:1.5rem}.lead{line-height:1.875rem}.display-1,.display-2,.display-3,.display-4{margin-bottom:.75rem}.display-1{font-size:7.451rem;line-height:1}.display-2{font-size:5.96rem;line-height:1}.display-3{font-size:4.768rem;line-height:1}.display-4{font-size:3.815rem;line-height:1}p{margin-bottom:1.75rem}hr{margin-top:1.125rem;margin-bottom:1.125rem;border-top:1px solid rgba(0,0,0,.1)}.small,small{font-size:80%;font-weight:300}.mark,mark{padding:.2em;background-color:#fff09e}.blockquote{margin-bottom:.75rem;font-size:1.5rem}.blockquote-footer{font-size:1.125rem}.img-thumbnail{padding:0;border:none;background-color:#fff;border-radius:.375rem;box-shadow:none}.figure-img{margin-bottom:.75rem}.figure-caption{font-size:1rem;color:#868e96}code,kbd,pre,samp{font-family:"Roboto Mono",Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}code{font-size:.75rem;padding:.1875rem .8125rem}kbd{padding:.1875rem .8125rem;font-size:.75rem;color:#fff;background-color:#212529;border-radius:.625rem;box-shadow:none}kbd kbd{font-weight:500}pre{margin-bottom:.75rem;font-size:.75rem;color:#212529;line-height:1.375rem}.pre-scrollable{max-height:340px}.table{background-color:transparent}.table td,.table th{padding:.75rem}.table .table{background-color:#fff}.table-sm td,.table-sm th{padding:.3rem}.table-primary,.table-primary>td,.table-primary>th{background-color:#b8daff}.table-hover .table-primary:hover,.table-hover .table-primary:hover>td,.table-hover .table-primary:hover>th{background-color:#9fcdff}.table-secondary,.table-secondary>td,.table-secondary>th{background-color:#d1d3d5}.table-hover .table-secondary:hover,.table-hover .table-secondary:hover>td,.table-hover .table-secondary:hover>th{background-color:#c4c6c9}.table-success,.table-success>td,.table-success>th{background-color:#beefd7}.table-hover .table-success:hover,.table-hover .table-success:hover>td,.table-hover .table-success:hover>th{background-color:#aaeaca}.table-info,.table-info>td,.table-info>th{background-color:#b8ebf4}.table-hover .table-info:hover,.table-hover .table-info:hover>td,.table-hover .table-info:hover>th{background-color:#a2e5f1}.table-warning,.table-warning>td,.table-warning>th{background-color:#ffeab8}.table-hover .table-warning:hover,.table-hover .table-warning:hover>td,.table-hover .table-warning:hover>th{background-color:#ffe29f}.table-danger,.table-danger>td,.table-danger>th{background-color:#eebec8}.table-hover .table-danger:hover,.table-hover .table-danger:hover>td,.table-hover .table-danger:hover>th{background-color:#e9aab7}.table-light,.table-light>td,.table-light>th{background-color:#fefefe}.table-hover .table-light:hover,.table-hover .table-light:hover>td,.table-hover .table-light:hover>th{background-color:#f1f1f1}.table-dark,.table-dark>td,.table-dark>th{background-color:#c1c2c3}.table-hover .table-dark:hover,.table-hover .table-dark:hover>td,.table-hover .table-dark:hover>th{background-color:#b4b5b6}.table-active,.table-active>td,.table-active>th,.table-hover .table-active:hover,.table-hover .table-active:hover>td,.table-hover .table-active:hover>th{background-color:rgba(0,0,0,.075)}.table .thead-dark th{color:#fff;background-color:#212529;border-color:#32383e}.table .thead-light th{color:#495057;background-color:#e9ecef;border-color:#dee2e6}.table-dark{color:#fff;background-color:#212529}.table-dark td,.table-dark th,.table-dark thead th{border-color:#32383e}.table-dark.table-striped tbody tr:nth-of-type(odd){background-color:rgba(255,255,255,.05)}.table-dark.table-hover tbody tr:hover{background-color:rgba(255,255,255,.075)}.form-control{height:auto;padding:.4375rem .75rem;font-size:.8125rem;line-height:1.5;color:#495057;background-color:#fff;border:1px solid #e1e5eb;font-weight:300;will-change:border-color,box-shadow;border-radius:.25rem;box-shadow:none;-webkit-transition:box-shadow 250ms cubic-bezier(.27,.01,.38,1.06),border 250ms cubic-bezier(.27,.01,.38,1.06);transition:box-shadow 250ms cubic-bezier(.27,.01,.38,1.06),border 250ms cubic-bezier(.27,.01,.38,1.06)}.form-control:hover{border-color:#b3bdcc}.form-control:focus{color:#495057;background-color:#fff;border-color:#007bff;box-shadow:0 .313rem .719rem rgba(0,123,255,.1),0 .156rem .125rem rgba(0,0,0,.06)}.form-control:focus:hover{border-color:#007bff}.form-control::-webkit-input-placeholder{color:#868e96}.form-control::-ms-input-placeholder{color:#868e96}.form-control::-moz-placeholder{color:#868e96}.form-control:-ms-input-placeholder{color:#868e96}.form-control::placeholder{color:#868e96}.form-control:disabled,.form-control[readonly]{background-color:#f5f6f7}.form-control:disabled:hover,.form-control[readonly]:hover{border-color:#e1e5eb;cursor:not-allowed}.form-control[readonly]:not(:disabled):focus{box-shadow:none;border-color:#e1e5eb}select.form-control:not([size]):not([multiple]){height:calc(2.09375rem + 2px)}select.form-control:focus::-ms-value{color:#495057;background-color:#fff}form label:hover,select.form-control:hover{cursor:pointer}.col-form-label{padding-top:calc(.4375rem + 1px);padding-bottom:calc(.4375rem + 1px);line-height:1.5}.col-form-label-lg{padding-top:calc(.8125rem + 1px);padding-bottom:calc(.8125rem + 1px);font-size:.875rem;line-height:1.5}.col-form-label-sm{padding-top:calc(.4286rem + 1px);padding-bottom:calc(.4286rem + 1px);font-size:.6875rem;line-height:1.5}.form-control-plaintext{padding-top:.4375rem;padding-bottom:.4375rem;line-height:1.5;font-weight:300}.form-control-sm,.input-group-sm>.form-control,.input-group-sm>.input-group-append>.btn,.input-group-sm>.input-group-append>.input-group-text,.input-group-sm>.input-group-middle>.input-group-text,.input-group-sm>.input-group-prepend>.btn,.input-group-sm>.input-group-prepend>.input-group-text{padding:.4286rem .625rem;font-size:.6875rem;line-height:1.5;border-radius:.25rem}.input-group-sm>.input-group-append>select.btn:not([size]):not([multiple]),.input-group-sm>.input-group-append>select.input-group-text:not([size]):not([multiple]),.input-group-sm>.input-group-middle>select.input-group-text:not([size]):not([multiple]),.input-group-sm>.input-group-prepend>select.btn:not([size]):not([multiple]),.input-group-sm>.input-group-prepend>select.input-group-text:not([size]):not([multiple]),.input-group-sm>select.form-control:not([size]):not([multiple]),select.form-control-sm:not([size]):not([multiple]){height:calc(1.88845rem + 2px)}.form-control-lg,.input-group-lg>.form-control,.input-group-lg>.input-group-append>.btn,.input-group-lg>.input-group-append>.input-group-text,.input-group-lg>.input-group-middle>.input-group-text,.input-group-lg>.input-group-prepend>.btn,.input-group-lg>.input-group-prepend>.input-group-text{padding:.8125rem;font-size:.875rem;line-height:1.5;border-radius:.375rem}.input-group-lg>.input-group-append>select.btn:not([size]):not([multiple]),.input-group-lg>.input-group-append>select.input-group-text:not([size]):not([multiple]),.input-group-lg>.input-group-middle>select.input-group-text:not([size]):not([multiple]),.input-group-lg>.input-group-prepend>select.btn:not([size]):not([multiple]),.input-group-lg>.input-group-prepend>select.input-group-text:not([size]):not([multiple]),.input-group-lg>select.form-control:not([size]):not([multiple]),select.form-control-lg:not([size]):not([multiple]){height:calc(2.9375rem + 2px)}.form-group{margin-bottom:1rem}.form-text{margin-top:.25rem}.form-check{padding-left:1.25rem}.form-check-input{margin-top:.313rem;margin-left:-1.25rem}.form-check-input:disabled~.form-check-label{color:#868e96}.form-check-inline{margin-right:.75rem}.form-check-inline .form-check-input{margin-right:.3125rem}.valid-feedback{margin-top:.25rem;font-size:80%;color:#17c671}.valid-tooltip{background-color:rgba(23,198,113,.8)}.custom-select.is-valid,.form-control.is-valid,.was-validated .custom-select:valid,.was-validated .form-control:valid{border-color:#17c671;box-shadow:0 5px 11.5px rgba(23,198,113,.1)}.custom-select.is-valid:focus,.form-control.is-valid:focus,.was-validated .custom-select:valid:focus,.was-validated .form-control:valid:focus{box-shadow:0 5px 11.5px rgba(23,198,113,.1),0 1px 1px .1rem rgba(23,198,113,.2)}.custom-select.is-valid:hover,.form-control.is-valid:hover,.was-validated .custom-select:valid:hover,.was-validated .form-control:valid:hover{border-color:#17c671}.form-check-input.is-valid~.form-check-label,.was-validated .form-check-input:valid~.form-check-label{color:#17c671}.custom-control-input.is-valid~.custom-control-label,.was-validated .custom-control-input:valid~.custom-control-label{color:#17c671}.custom-control-input.is-valid~.custom-control-label::before,.was-validated .custom-control-input:valid~.custom-control-label::before{background-color:#57eca4;border-color:#2ae68b}.custom-control-input.is-valid:checked~.custom-control-label::before,.was-validated .custom-control-input:valid:checked~.custom-control-label::before{background-color:#2ae68b}.custom-control-input.is-valid:focus~.custom-control-label::before,.was-validated .custom-control-input:valid:focus~.custom-control-label::before{box-shadow:0 .313rem .719rem rgba(23,198,113,.1),0 .156rem .125rem rgba(0,0,0,.06)}.custom-file-input.is-valid~.custom-file-label,.was-validated .custom-file-input:valid~.custom-file-label{color:#17c671;border-color:#17c671}.custom-file-input.is-valid~.custom-file-label::after,.was-validated .custom-file-input:valid~.custom-file-label::after{background-color:#b3f6d5;border-color:#2ae68b;color:#17c671}.custom-file-input:focus.is-valid~.custom-file-label,.was-validated .custom-file-input:focus:valid~.custom-file-label{border-color:#17c671;box-shadow:0 5px 11.5px rgba(23,198,113,.1),0 1px 1px .1rem rgba(23,198,113,.2)}.custom-file-input:hover.is-valid~.custom-file-label,.was-validated .custom-file-input:hover:valid~.custom-file-label{border-color:#17c671}.custom-toggle .custom-control-input:not(:checked).is-valid~.custom-control-label::before,.was-validated .custom-toggle .custom-control-input:not(:checked):valid~.custom-control-label::before{background-color:#fff}.custom-toggle .custom-control-input.is-invalid:focus~.custom-control-label::before,.was-validated .custom-toggle .custom-control-input:invalid:focus~.custom-control-label::before{box-shadow:0 .313rem .719rem rgba(23,198,113,.1),0 .156rem .125rem rgba(0,0,0,.06);box-shadow:0 .313rem .719rem rgba(196,24,60,.1),0 .156rem .125rem rgba(0,0,0,.06)}.invalid-feedback{margin-top:.25rem;font-size:80%;color:#c4183c}.invalid-tooltip{background-color:rgba(196,24,60,.8)}.custom-select.is-invalid,.form-control.is-invalid,.was-validated .custom-select:invalid,.was-validated .form-control:invalid{border-color:#c4183c;box-shadow:0 5px 11.5px rgba(196,24,60,.1)}.custom-select.is-invalid:focus,.form-control.is-invalid:focus,.was-validated .custom-select:invalid:focus,.was-validated .form-control:invalid:focus{box-shadow:0 5px 11.5px rgba(196,24,60,.1),0 1px 1px .1rem rgba(196,24,60,.2)}.custom-select.is-invalid:hover,.form-control.is-invalid:hover,.was-validated .custom-select:invalid:hover,.was-validated .form-control:invalid:hover{border-color:#c4183c}.form-check-input.is-invalid~.form-check-label,.was-validated .form-check-input:invalid~.form-check-label{color:#c4183c}.custom-control-input.is-invalid~.custom-control-label,.was-validated .custom-control-input:invalid~.custom-control-label{color:#c4183c}.custom-control-input.is-invalid~.custom-control-label::before,.was-validated .custom-control-input:invalid~.custom-control-label::before{background-color:#ea5876;border-color:#e52a51}.custom-control-input.is-invalid:checked~.custom-control-label::before,.was-validated .custom-control-input:invalid:checked~.custom-control-label::before{background-color:#e52a51}.custom-control-input.is-invalid:focus~.custom-control-label::before,.was-validated .custom-control-input:invalid:focus~.custom-control-label::before{box-shadow:0 .313rem .719rem rgba(196,24,60,.1),0 .156rem .125rem rgba(0,0,0,.06)}.custom-file-input.is-invalid~.custom-file-label,.was-validated .custom-file-input:invalid~.custom-file-label{color:#c4183c;border-color:#c4183c}.custom-file-input.is-invalid~.custom-file-label::after,.was-validated .custom-file-input:invalid~.custom-file-label::after{background-color:#f6b2c0;border-color:#e52a51;color:#c4183c}.custom-file-input:focus.is-invalid~.custom-file-label,.was-validated .custom-file-input:focus:invalid~.custom-file-label{border-color:#c4183c;box-shadow:0 5px 11.5px rgba(196,24,60,.1),0 1px 1px .1rem rgba(196,24,60,.2)}.custom-file-input:hover.is-invalid~.custom-file-label,.was-validated .custom-file-input:hover:invalid~.custom-file-label{border-color:#c4183c}.custom-toggle .custom-control-input:not(:checked).is-invalid~.custom-control-label::before,.was-validated .custom-toggle .custom-control-input:not(:checked):invalid~.custom-control-label::before{background-color:#fff}.custom-toggle .custom-control-input.is-valid~.custom-control-label::before,.was-validated .custom-toggle .custom-control-input:valid~.custom-control-label::before{background-color:#17c671}.custom-toggle .custom-control-input.is-invalid~.custom-control-label::after,.was-validated .custom-toggle .custom-control-input:invalid~.custom-control-label::after{background-color:#eb8c95}.btn{font-weight:400;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;border:1px solid transparent;padding:.5625rem 1rem;font-size:.75rem;line-height:1.125;border-radius:.25rem;-webkit-transition:250ms cubic-bezier(.27,.01,.38,1.06);transition:250ms cubic-bezier(.27,.01,.38,1.06)}.btn.hover,.btn:hover,.cursor-pointer:hover{cursor:pointer}.btn.focus,.btn:focus{box-shadow:none}.btn:not([disabled]):not(.disabled).active,.btn:not([disabled]):not(.disabled):active{background-image:none;box-shadow:none}.btn.btn-squared{border-radius:0}.btn.btn-pill{border-radius:50px}.btn-primary{color:#fff;border-color:#007bff;background-color:#007bff;box-shadow:none}.btn-primary:hover{color:#fff;background-color:#006fe6;border-color:#006fe6;box-shadow:0 5px 15px rgba(0,0,0,.05),0 4px 10px rgba(0,123,255,.25)}.btn-primary.focus,.btn-primary:focus{box-shadow:0 0 0 3px rgba(0,123,255,.15),0 3px 15px rgba(0,123,255,.2),0 2px 5px rgba(0,0,0,.1)}.btn-primary.disabled,.btn-primary:disabled{background-color:#007bff;border-color:#007bff;box-shadow:none;cursor:not-allowed}.btn-primary:not(:disabled):not(.disabled).active,.btn-primary:not(:disabled):not(.disabled):active,.show>.btn-primary.dropdown-toggle{color:#fff;background-color:#006fe6;border-color:#0062cc;background-image:none;box-shadow:inset 0 3px 5px rgba(0,0,0,.125)!important}.btn-secondary{color:#fff;border-color:#5a6169;background-color:#5a6169;box-shadow:none}.btn-secondary:hover{color:#fff;background-color:#4e545b;border-color:#4e545b;box-shadow:0 5px 15px rgba(0,0,0,.05),0 4px 10px rgba(90,97,105,.25)}.btn-secondary.focus,.btn-secondary:focus{box-shadow:0 0 0 3px rgba(90,97,105,.15),0 3px 15px rgba(90,97,105,.2),0 2px 5px rgba(0,0,0,.1)}.btn-secondary.disabled,.btn-secondary:disabled{background-color:#5a6169;border-color:#5a6169;box-shadow:none;cursor:not-allowed}.btn-secondary:not(:disabled):not(.disabled).active,.btn-secondary:not(:disabled):not(.disabled):active,.show>.btn-secondary.dropdown-toggle{color:#fff;background-color:#4e545b;border-color:#42484e;background-image:none;box-shadow:inset 0 3px 5px rgba(0,0,0,.125)!important}.btn-success{color:#fff;border-color:#17c671;background-color:#17c671;box-shadow:none}.btn-success:hover{color:#fff;background-color:#14af64;border-color:#14af64;box-shadow:0 5px 15px rgba(0,0,0,.05),0 4px 10px rgba(23,198,113,.25)}.btn-success.focus,.btn-success:focus{box-shadow:0 0 0 3px rgba(23,198,113,.15),0 3px 15px rgba(23,198,113,.2),0 2px 5px rgba(0,0,0,.1)}.btn-success.disabled,.btn-success:disabled{background-color:#17c671;border-color:#17c671;box-shadow:none;cursor:not-allowed}.btn-success:not(:disabled):not(.disabled).active,.btn-success:not(:disabled):not(.disabled):active,.show>.btn-success.dropdown-toggle{color:#fff;background-color:#14af64;border-color:#129857;background-image:none;box-shadow:inset 0 3px 5px rgba(0,0,0,.125)!important}.btn-info{color:#fff;border-color:#00b8d8;background-color:#00b8d8;box-shadow:none}.btn-info:hover{color:#fff;background-color:#00a2bf;border-color:#00a2bf;box-shadow:0 5px 15px rgba(0,0,0,.05),0 4px 10px rgba(0,184,216,.25)}.btn-info.focus,.btn-info:focus{box-shadow:0 0 0 3px rgba(0,184,216,.15),0 3px 15px rgba(0,184,216,.2),0 2px 5px rgba(0,0,0,.1)}.btn-info.disabled,.btn-info:disabled{background-color:#00b8d8;border-color:#00b8d8;box-shadow:none;cursor:not-allowed}.btn-info:not(:disabled):not(.disabled).active,.btn-info:not(:disabled):not(.disabled):active,.show>.btn-info.dropdown-toggle{color:#fff;background-color:#00a2bf;border-color:#008da5;background-image:none;box-shadow:inset 0 3px 5px rgba(0,0,0,.125)!important}.btn-warning{color:#212529;border-color:#ffb400;background-color:#ffb400;box-shadow:none}.btn-warning:hover{color:#212529;background-color:#e6a200;border-color:#e6a200;box-shadow:0 5px 15px rgba(0,0,0,.05),0 4px 10px rgba(255,180,0,.25)}.btn-warning.focus,.btn-warning:focus{box-shadow:0 0 0 3px rgba(255,180,0,.15),0 3px 15px rgba(255,180,0,.2),0 2px 5px rgba(0,0,0,.1)}.btn-warning.disabled,.btn-warning:disabled{background-color:#ffb400;border-color:#ffb400;box-shadow:none;cursor:not-allowed}.btn-warning:not(:disabled):not(.disabled).active,.btn-warning:not(:disabled):not(.disabled):active,.show>.btn-warning.dropdown-toggle{color:#212529;background-color:#e6a200;border-color:#cc9000;background-image:none;box-shadow:inset 0 3px 5px rgba(0,0,0,.125)!important}.btn-danger{color:#fff;border-color:#c4183c;background-color:#c4183c;box-shadow:none}.btn-danger:hover{color:#fff;background-color:#ad1535;border-color:#ad1535;box-shadow:0 5px 15px rgba(0,0,0,.05),0 4px 10px rgba(196,24,60,.25)}.btn-danger.focus,.btn-danger:focus{box-shadow:0 0 0 3px rgba(196,24,60,.15),0 3px 15px rgba(196,24,60,.2),0 2px 5px rgba(0,0,0,.1)}.btn-danger.disabled,.btn-danger:disabled{background-color:#c4183c;border-color:#c4183c;box-shadow:none;cursor:not-allowed}.btn-danger:not(:disabled):not(.disabled).active,.btn-danger:not(:disabled):not(.disabled):active,.show>.btn-danger.dropdown-toggle{color:#fff;background-color:#ad1535;border-color:#97122e;background-image:none;box-shadow:inset 0 3px 5px rgba(0,0,0,.125)!important}.btn-light{color:#212529;border-color:#fbfbfb;background-color:#fbfbfb;box-shadow:none}.btn-light:hover{color:#212529;background-color:#eee;border-color:#eee;box-shadow:0 5px 15px rgba(0,0,0,.05),0 4px 10px rgba(251,251,251,.25)}.btn-light.focus,.btn-light:focus{box-shadow:0 0 0 3px rgba(251,251,251,.15),0 3px 15px rgba(251,251,251,.2),0 2px 5px rgba(0,0,0,.1)}.btn-light.disabled,.btn-light:disabled{background-color:#fbfbfb;border-color:#fbfbfb;box-shadow:none;cursor:not-allowed}.btn-light:not(:disabled):not(.disabled).active,.btn-light:not(:disabled):not(.disabled):active,.show>.btn-light.dropdown-toggle{color:#212529;background-color:#eee;border-color:#e2e2e2;background-image:none;box-shadow:inset 0 3px 5px rgba(0,0,0,.125)!important}.btn-dark{color:#fff;border-color:#212529;background-color:#212529;box-shadow:none}.btn-dark:hover{color:#fff;background-color:#16181b;border-color:#16181b;box-shadow:0 5px 15px rgba(0,0,0,.05),0 4px 10px rgba(33,37,41,.25)}.btn-dark.focus,.btn-dark:focus{box-shadow:0 0 0 3px rgba(33,37,41,.15),0 3px 15px rgba(33,37,41,.2),0 2px 5px rgba(0,0,0,.1)}.btn-dark.disabled,.btn-dark:disabled{background-color:#212529;border-color:#212529;box-shadow:none;cursor:not-allowed}.btn-dark:not(:disabled):not(.disabled).active,.btn-dark:not(:disabled):not(.disabled):active,.show>.btn-dark.dropdown-toggle{color:#fff;background-color:#16181b;border-color:#0a0c0d;background-image:none;box-shadow:inset 0 3px 5px rgba(0,0,0,.125)!important}.btn-white{color:#212529;border-color:#fff;background-color:#fff;box-shadow:none}.btn-white:hover{color:#212529;box-shadow:0 5px 15px rgba(0,0,0,.05),0 4px 10px rgba(255,255,255,.25)}.btn-white.focus,.btn-white:focus{box-shadow:0 0 0 3px rgba(255,255,255,.15),0 3px 15px rgba(255,255,255,.2),0 2px 5px rgba(0,0,0,.1)}.btn-white.disabled,.btn-white:disabled{background-color:#fff;border-color:#fff;box-shadow:none;cursor:not-allowed}.btn-white:not(:disabled):not(.disabled).active,.btn-white:not(:disabled):not(.disabled):active,.show>.btn-white.dropdown-toggle{color:#212529;background-color:#f2f2f2;border-color:#e6e6e6;background-image:none;box-shadow:inset 0 3px 5px rgba(0,0,0,.125)!important}.btn-black{color:#fff;border-color:#000;background-color:#000;box-shadow:none}.btn-black:hover{color:#fff;box-shadow:0 5px 15px rgba(0,0,0,.05),0 4px 10px rgba(0,0,0,.25)}.btn-black.focus,.btn-black:focus{box-shadow:0 0 0 3px rgba(0,0,0,.15),0 3px 15px rgba(0,0,0,.2),0 2px 5px rgba(0,0,0,.1)}.btn-black.disabled,.btn-black:disabled{background-color:#000;border-color:#000;box-shadow:none;cursor:not-allowed}.btn-black:not(:disabled):not(.disabled).active,.btn-black:not(:disabled):not(.disabled):active,.show>.btn-black.dropdown-toggle{color:#fff;background-color:#000;border-color:#000;background-image:none;box-shadow:inset 0 3px 5px rgba(0,0,0,.125)!important}.btn-outline-primary{background-color:transparent;background-image:none;border-color:#007bff;color:#007bff}.btn-outline-primary:hover{color:#fff;background-color:#007bff;border-color:#007bff;box-shadow:0 5px 15px rgba(0,0,0,.05),0 4px 10px rgba(0,123,255,.25)}.btn-outline-primary.focus,.btn-outline-primary:focus{box-shadow:0 0 0 3px rgba(0,123,255,.15),0 3px 15px rgba(0,123,255,.2),0 2px 5px rgba(0,0,0,.1)!important}.btn-outline-primary.disabled,.btn-outline-primary:disabled{color:#007bff;background-color:transparent;box-shadow:none}.btn-outline-primary:not(:disabled):not(.disabled).active,.btn-outline-primary:not(:disabled):not(.disabled):active,.show>.btn-outline-primary.dropdown-toggle{color:#fff;background-color:#007bff;border-color:#007bff}.btn-outline-primary:not(:disabled):not(.disabled).active:focus,.btn-outline-primary:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-primary.dropdown-toggle:focus{box-shadow:inset 0 3px 5px rgba(0,0,0,.125)!important}.btn-outline-secondary{background-color:transparent;background-image:none;border-color:#5a6169;color:#5a6169}.btn-outline-secondary:hover{color:#fff;background-color:#5a6169;border-color:#5a6169;box-shadow:0 5px 15px rgba(0,0,0,.05),0 4px 10px rgba(90,97,105,.25)}.btn-outline-secondary.focus,.btn-outline-secondary:focus{box-shadow:0 0 0 3px rgba(90,97,105,.15),0 3px 15px rgba(90,97,105,.2),0 2px 5px rgba(0,0,0,.1)!important}.btn-outline-secondary.disabled,.btn-outline-secondary:disabled{color:#5a6169;background-color:transparent;box-shadow:none}.btn-outline-secondary:not(:disabled):not(.disabled).active,.btn-outline-secondary:not(:disabled):not(.disabled):active,.show>.btn-outline-secondary.dropdown-toggle{color:#fff;background-color:#5a6169;border-color:#5a6169}.btn-outline-secondary:not(:disabled):not(.disabled).active:focus,.btn-outline-secondary:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-secondary.dropdown-toggle:focus{box-shadow:inset 0 3px 5px rgba(0,0,0,.125)!important}.btn-outline-success{background-color:transparent;background-image:none;border-color:#17c671;color:#17c671}.btn-outline-success:hover{color:#fff;background-color:#17c671;border-color:#17c671;box-shadow:0 5px 15px rgba(0,0,0,.05),0 4px 10px rgba(23,198,113,.25)}.btn-outline-success.focus,.btn-outline-success:focus{box-shadow:0 0 0 3px rgba(23,198,113,.15),0 3px 15px rgba(23,198,113,.2),0 2px 5px rgba(0,0,0,.1)!important}.btn-outline-success.disabled,.btn-outline-success:disabled{color:#17c671;background-color:transparent;box-shadow:none}.btn-outline-success:not(:disabled):not(.disabled).active,.btn-outline-success:not(:disabled):not(.disabled):active,.show>.btn-outline-success.dropdown-toggle{color:#fff;background-color:#17c671;border-color:#17c671}.btn-outline-success:not(:disabled):not(.disabled).active:focus,.btn-outline-success:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-success.dropdown-toggle:focus{box-shadow:inset 0 3px 5px rgba(0,0,0,.125)!important}.btn-outline-info{background-color:transparent;background-image:none;border-color:#00b8d8;color:#00b8d8}.btn-outline-info:hover{color:#fff;background-color:#00b8d8;border-color:#00b8d8;box-shadow:0 5px 15px rgba(0,0,0,.05),0 4px 10px rgba(0,184,216,.25)}.btn-outline-info.focus,.btn-outline-info:focus{box-shadow:0 0 0 3px rgba(0,184,216,.15),0 3px 15px rgba(0,184,216,.2),0 2px 5px rgba(0,0,0,.1)!important}.btn-outline-info.disabled,.btn-outline-info:disabled{color:#00b8d8;background-color:transparent;box-shadow:none}.btn-outline-info:not(:disabled):not(.disabled).active,.btn-outline-info:not(:disabled):not(.disabled):active,.show>.btn-outline-info.dropdown-toggle{color:#fff;background-color:#00b8d8;border-color:#00b8d8}.btn-outline-info:not(:disabled):not(.disabled).active:focus,.btn-outline-info:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-info.dropdown-toggle:focus{box-shadow:inset 0 3px 5px rgba(0,0,0,.125)!important}.btn-outline-warning{background-color:transparent;background-image:none;border-color:#ffb400;color:#ffb400}.btn-outline-warning:hover{color:#212529;background-color:#ffb400;border-color:#ffb400;box-shadow:0 5px 15px rgba(0,0,0,.05),0 4px 10px rgba(255,180,0,.25)}.btn-outline-warning.focus,.btn-outline-warning:focus{box-shadow:0 0 0 3px rgba(255,180,0,.15),0 3px 15px rgba(255,180,0,.2),0 2px 5px rgba(0,0,0,.1)!important}.btn-outline-warning.disabled,.btn-outline-warning:disabled{color:#ffb400;background-color:transparent;box-shadow:none}.btn-outline-warning:not(:disabled):not(.disabled).active,.btn-outline-warning:not(:disabled):not(.disabled):active,.show>.btn-outline-warning.dropdown-toggle{color:#212529;background-color:#ffb400;border-color:#ffb400}.btn-outline-warning:not(:disabled):not(.disabled).active:focus,.btn-outline-warning:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-warning.dropdown-toggle:focus{box-shadow:inset 0 3px 5px rgba(0,0,0,.125)!important}.btn-outline-danger{background-color:transparent;background-image:none;border-color:#c4183c;color:#c4183c}.btn-outline-danger:hover{color:#fff;background-color:#c4183c;border-color:#c4183c;box-shadow:0 5px 15px rgba(0,0,0,.05),0 4px 10px rgba(196,24,60,.25)}.btn-outline-danger.focus,.btn-outline-danger:focus{box-shadow:0 0 0 3px rgba(196,24,60,.15),0 3px 15px rgba(196,24,60,.2),0 2px 5px rgba(0,0,0,.1)!important}.btn-outline-danger.disabled,.btn-outline-danger:disabled{color:#c4183c;background-color:transparent;box-shadow:none}.btn-outline-danger:not(:disabled):not(.disabled).active,.btn-outline-danger:not(:disabled):not(.disabled):active,.show>.btn-outline-danger.dropdown-toggle{color:#fff;background-color:#c4183c;border-color:#c4183c}.btn-outline-danger:not(:disabled):not(.disabled).active:focus,.btn-outline-danger:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-danger.dropdown-toggle:focus{box-shadow:inset 0 3px 5px rgba(0,0,0,.125)!important}.btn-outline-light{background-color:transparent;background-image:none;border-color:#fbfbfb;color:#212529}.btn-outline-light:hover{color:#212529;background-color:#fbfbfb;border-color:#fbfbfb;box-shadow:0 5px 15px rgba(0,0,0,.05),0 4px 10px rgba(251,251,251,.25)}.btn-outline-light.focus,.btn-outline-light:focus{box-shadow:0 0 0 3px rgba(251,251,251,.15),0 3px 15px rgba(251,251,251,.2),0 2px 5px rgba(0,0,0,.1)!important}.btn-outline-light.disabled,.btn-outline-light:disabled{color:#fbfbfb;background-color:transparent;box-shadow:none}.btn-outline-light:not(:disabled):not(.disabled).active,.btn-outline-light:not(:disabled):not(.disabled):active,.show>.btn-outline-light.dropdown-toggle{color:#212529;background-color:#fbfbfb;border-color:#fbfbfb}.btn-outline-light:not(:disabled):not(.disabled).active:focus,.btn-outline-light:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-light.dropdown-toggle:focus{box-shadow:inset 0 3px 5px rgba(0,0,0,.125)!important}.btn-outline-dark{background-color:transparent;background-image:none;border-color:#212529;color:#212529}.btn-outline-dark:hover{color:#fff;background-color:#212529;border-color:#212529;box-shadow:0 5px 15px rgba(0,0,0,.05),0 4px 10px rgba(33,37,41,.25)}.btn-outline-dark.focus,.btn-outline-dark:focus{box-shadow:0 0 0 3px rgba(33,37,41,.15),0 3px 15px rgba(33,37,41,.2),0 2px 5px rgba(0,0,0,.1)!important}.btn-outline-dark.disabled,.btn-outline-dark:disabled{color:#212529;background-color:transparent;box-shadow:none}.btn-outline-dark:not(:disabled):not(.disabled).active,.btn-outline-dark:not(:disabled):not(.disabled):active,.show>.btn-outline-dark.dropdown-toggle{color:#fff;background-color:#212529;border-color:#212529}.btn-outline-dark:not(:disabled):not(.disabled).active:focus,.btn-outline-dark:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-dark.dropdown-toggle:focus{box-shadow:inset 0 3px 5px rgba(0,0,0,.125)!important}.btn-outline-white{background-color:transparent;background-image:none;border-color:#fff;color:#fff}.btn-outline-white:hover{color:#212529;background-color:#fff;border-color:#fff;box-shadow:0 5px 15px rgba(0,0,0,.05),0 4px 10px rgba(255,255,255,.25)}.btn-outline-white.focus,.btn-outline-white:focus{box-shadow:0 0 0 3px rgba(255,255,255,.15),0 3px 15px rgba(255,255,255,.2),0 2px 5px rgba(0,0,0,.1)!important}.btn-outline-white.disabled,.btn-outline-white:disabled{color:#fff;background-color:transparent;box-shadow:none}.btn-outline-white:not(:disabled):not(.disabled).active,.btn-outline-white:not(:disabled):not(.disabled):active,.show>.btn-outline-white.dropdown-toggle{color:#212529;background-color:#fff;border-color:#fff}.btn-outline-white:not(:disabled):not(.disabled).active:focus,.btn-outline-white:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-white.dropdown-toggle:focus{box-shadow:inset 0 3px 5px rgba(0,0,0,.125)!important}.btn-outline-white:not(:disabled):not(.disabled).active,.btn-outline-white:not(:disabled):not(.disabled):active{color:#000}.btn-outline-black{background-color:transparent;background-image:none;border-color:#000;color:#000}.btn-outline-black:hover{color:#fff;background-color:#000;border-color:#000;box-shadow:0 5px 15px rgba(0,0,0,.05),0 4px 10px rgba(0,0,0,.25)}.btn-outline-black.focus,.btn-outline-black:focus{box-shadow:0 0 0 3px rgba(0,0,0,.15),0 3px 15px rgba(0,0,0,.2),0 2px 5px rgba(0,0,0,.1)!important}.btn-outline-black.disabled,.btn-outline-black:disabled{color:#000;background-color:transparent;box-shadow:none}.btn-outline-black:not(:disabled):not(.disabled).active,.btn-outline-black:not(:disabled):not(.disabled):active,.show>.btn-outline-black.dropdown-toggle{color:#fff;background-color:#000;border-color:#000}.btn-outline-black:not(:disabled):not(.disabled).active:focus,.btn-outline-black:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-black.dropdown-toggle:focus{box-shadow:inset 0 3px 5px rgba(0,0,0,.125)!important}.btn-outline-black:not(:disabled):not(.disabled).active,.btn-outline-black:not(:disabled):not(.disabled):active{color:#fff}.btn-link{font-weight:300;color:#007bff}.btn-link:hover{color:#0056b3;text-decoration:underline}.btn-link.focus,.btn-link:focus{text-decoration:underline}.btn-link:disabled{color:#868e96}.btn-group-lg>.btn,.btn-lg{padding:.75rem 1.75rem;font-size:1.125rem;line-height:1.5;border-radius:.5rem}.btn-group-sm>.btn,.btn-sm{padding:.4286rem .875rem;font-size:.6875rem;line-height:1.5;border-radius:.25rem}.btn-block+.btn-block{margin-top:.5rem}.fade{-webkit-transition:opacity .2s ease-in-out;transition:opacity .2s ease-in-out}.collapsing{-webkit-transition:height 350ms ease-in-out;transition:height 350ms ease-in-out}i.material-icons{font-size:inherit;position:relative;top:2px}.dropdown-menu{z-index:1000;min-width:10rem;padding:10px 0;margin:0;font-size:1rem;color:#5a6169;background-color:#fff;border:1px solid rgba(0,0,0,.05);border-radius:.375rem;box-shadow:0 .5rem 4rem rgba(0,0,0,.11),0 10px 20px rgba(0,0,0,.05),0 2px 3px rgba(0,0,0,.06)}.dropdown-menu-small{box-shadow:0 .5rem 2rem rgba(0,0,0,.11),0 3px 10px rgba(0,0,0,.05),0 2px 3px rgba(0,0,0,.06);padding:.25rem 0;font-size:.813rem}.dropdown-menu-small .dropdown-item{padding:.375rem .875rem;font-size:.813rem}.dropdown-menu-small .dropdown-divider{margin:.25rem 0}.dropup .dropdown-menu{margin-bottom:0}.dropright .dropdown-menu{margin-left:0}.dropleft .dropdown-menu{margin-right:0}.dropdown-divider{height:0;margin:.75rem 0;overflow:hidden;border-top:1px solid #e9ecef}.dropdown-item{padding:.5rem 1.25rem;font-weight:300;color:#212529;font-size:.9375rem;-webkit-transition:background-color 250ms cubic-bezier(.27,.01,.38,1.06),color 250ms cubic-bezier(.27,.01,.38,1.06);transition:background-color 250ms cubic-bezier(.27,.01,.38,1.06),color 250ms cubic-bezier(.27,.01,.38,1.06)}.dropdown-item:focus,.dropdown-item:hover{color:#16181b;background-color:#eceeef}.dropdown-item.active,.dropdown-item:active{color:#fff;background-color:#c3c7cc}.dropdown-item.disabled,.dropdown-item:disabled{color:#868e96}.dropdown-item.disabled:hover,.dropdown-item:disabled:hover{background:0 0;cursor:not-allowed}.dropdown-header{padding:10px 1.25rem;font-size:.6875rem;color:#868e96}.btn-group .btn+.btn,.btn-group .btn+.btn-group,.btn-group .btn-group+.btn,.btn-group .btn-group+.btn-group,.btn-group-vertical .btn+.btn,.btn-group-vertical .btn+.btn-group,.btn-group-vertical .btn-group+.btn,.btn-group-vertical .btn-group+.btn-group{margin-left:-1px}.btn-group>.btn-group:not(:last-child)>.btn,.btn-group>.btn:not(:last-child):not(.dropdown-toggle){border-top-right-radius:0;border-bottom-right-radius:0}.btn-group>.btn-group:not(:first-child)>.btn,.btn-group>.btn:not(:first-child){border-top-left-radius:0;border-bottom-left-radius:0}.dropdown-toggle-split{padding-right:.75rem;padding-left:.75rem}.btn-group-sm>.btn+.dropdown-toggle-split,.btn-sm+.dropdown-toggle-split{padding-right:.65625rem;padding-left:.65625rem}.btn-group-lg>.btn+.dropdown-toggle-split,.btn-lg+.dropdown-toggle-split{padding-right:1.3125rem;padding-left:1.3125rem}.btn-group.show .dropdown-toggle{box-shadow:inset 0 3px 5px rgba(0,0,0,.125)}.btn-group.show .dropdown-toggle.btn-link{box-shadow:none}.btn-group-vertical>.btn+.btn,.btn-group-vertical>.btn+.btn-group,.btn-group-vertical>.btn-group+.btn,.btn-group-vertical>.btn-group+.btn-group{margin-top:-1px}.btn-group-vertical>.btn-group:not(:last-child)>.btn,.btn-group-vertical>.btn:not(:last-child):not(.dropdown-toggle){border-bottom-right-radius:0;border-bottom-left-radius:0}.btn-group-vertical>.btn-group:not(:first-child)>.btn,.btn-group-vertical>.btn:not(:first-child){border-top-left-radius:0;border-top-right-radius:0}.input-group>.custom-file+.custom-file,.input-group>.custom-file+.custom-select,.input-group>.custom-file+.form-control,.input-group>.custom-select+.custom-file,.input-group>.custom-select+.custom-select,.input-group>.custom-select+.form-control,.input-group>.form-control+.custom-file,.input-group>.form-control+.custom-select,.input-group>.form-control+.form-control{margin-left:-1px}.input-group>.custom-select:not(:last-child),.input-group>.form-control:not(:last-child){border-top-right-radius:0;border-bottom-right-radius:0}.input-group>.custom-select:not(:first-child),.input-group>.form-control:not(:first-child){border-top-left-radius:0;border-bottom-left-radius:0}.input-group>.custom-file:not(:last-child) .custom-file-label,.input-group>.custom-file:not(:last-child) .custom-file-label::after{border-top-right-radius:0;border-bottom-right-radius:0}.input-group>.custom-file:not(:first-child) .custom-file-label,.input-group>.custom-file:not(:first-child) .custom-file-label::after{border-top-left-radius:0;border-bottom-left-radius:0}.input-group.input-group-seamless>.form-control{border-radius:.25rem}.input-group.input-group-seamless>.input-group-append,.input-group.input-group-seamless>.input-group-prepend{position:absolute;top:0;bottom:0;z-index:4}.input-group.input-group-seamless>.input-group-append .input-group-text,.input-group.input-group-seamless>.input-group-prepend .input-group-text{padding:.75rem .625rem;background:0 0;border:none}.input-group.input-group-seamless>.input-group-append{right:0}.input-group.input-group-seamless>.input-group-middle{right:0;left:0}.input-group.input-group-seamless>.input-group-prepend{left:0}.input-group.input-group-seamless>.custom-select:not(:last-child),.input-group.input-group-seamless>.form-control:not(:last-child){padding-right:40px}.input-group-append .btn+.btn,.input-group-append .btn+.input-group-text,.input-group-append .input-group-text+.btn,.input-group-append .input-group-text+.input-group-text,.input-group-prepend .btn+.btn,.input-group-prepend .btn+.input-group-text,.input-group-prepend .input-group-text+.btn,.input-group-prepend .input-group-text+.input-group-text{margin-left:-1px}.input-group-prepend{margin-right:-1px}.input-group-append{margin-left:-1px}.input-group-text{font-weight:300;line-height:1.5;color:#abb6bf;background-color:#fff;border:1px solid #e1e5eb;border-radius:.25rem}.input-group>.input-group-append:last-child>.btn:not(:last-child):not(.dropdown-toggle),.input-group>.input-group-append:last-child>.input-group-text:not(:last-child),.input-group>.input-group-append:not(:last-child)>.btn,.input-group>.input-group-append:not(:last-child)>.input-group-text,.input-group>.input-group-prepend>.btn,.input-group>.input-group-prepend>.input-group-text{border-top-right-radius:0;border-bottom-right-radius:0}.input-group>.input-group-append>.btn,.input-group>.input-group-append>.input-group-text,.input-group>.input-group-prepend:first-child>.btn:not(:first-child),.input-group>.input-group-prepend:first-child>.input-group-text:not(:first-child),.input-group>.input-group-prepend:not(:first-child)>.btn,.input-group>.input-group-prepend:not(:first-child)>.input-group-text{border-top-left-radius:0;border-bottom-left-radius:0}.input-group>.input-group-middle>.btn,.input-group>.input-group-middle>.input-group-text{border-left:0;border-right:0;border-radius:0}.input-group-middle{display:-webkit-box;display:flex}.custom-control{min-height:1.5rem;padding-left:1.688rem}.custom-control .custom-control-label:before{pointer-events:all}.custom-control-inline{margin-right:1rem}.custom-control-input:checked~.custom-control-label::before{color:#fff;border-color:transparent;background-color:#007bff;box-shadow:none}.custom-control-input:focus~.custom-control-label::before{box-shadow:0 .313rem .719rem rgba(0,123,255,.1),0 .156rem .125rem rgba(0,0,0,.06)}.custom-control-input:active~.custom-control-label::before{color:#fff;background-color:#b3d7ff;box-shadow:none}.custom-control-input:disabled~.custom-control-label{color:#868e96}.custom-control-input:disabled~.custom-control-label:hover{cursor:not-allowed}.custom-control-input:disabled~.custom-control-label::before{background-color:#e9ecef}.custom-control-label{position:static}.custom-control-label:hover{cursor:pointer}.custom-control-label::before{top:.1875rem;left:0;width:1.125rem;height:1.125rem;background-color:#fff;border:1px solid #e1e5eb;-webkit-transition:250ms cubic-bezier(.27,.01,.38,1.06);transition:250ms cubic-bezier(.27,.01,.38,1.06);box-shadow:none}.custom-control-label::after{top:.1875rem;width:1.125rem;height:1.125rem;background-size:50% 50%}.custom-checkbox .custom-control-label::before{border-radius:2px}.custom-checkbox .custom-control-label::after{content:"";position:absolute;top:5px;left:7px;width:5px;height:11px;opacity:0;-webkit-transform:rotate(45deg) scale(0);transform:rotate(45deg) scale(0);border-right:2px solid #fff;border-bottom:2px solid #fff;transition:transform 250ms cubic-bezier(.27,.01,.38,1.06),border 250ms cubic-bezier(.27,.01,.38,1.06),-webkit-transform 250ms cubic-bezier(.27,.01,.38,1.06);-webkit-transition:border 250ms cubic-bezier(.27,.01,.38,1.06),-webkit-transform 250ms cubic-bezier(.27,.01,.38,1.06);-webkit-transition-delay:.1s;transition-delay:.1s}.custom-checkbox .custom-control-input:checked~.custom-control-label::before{background-image:none}.custom-checkbox .custom-control-input:checked~.custom-control-label::after{opacity:1;-webkit-transform:rotate(45deg) scale(1);transform:rotate(45deg) scale(1);background-image:none}.custom-checkbox .custom-control-input:indeterminate~.custom-control-label::before{border:none;background-color:#007bff;box-shadow:none}.custom-checkbox .custom-control-input:indeterminate~.custom-control-label::after{content:"";position:absolute;-webkit-transform:scale(1);transform:scale(1);background-image:none;background-color:#fff;border:none;width:10px;height:2px;top:11px;left:4px;opacity:1;-webkit-transition:none;transition:none}.custom-checkbox .custom-control-input:disabled:checked~.custom-control-label::before{background:#e9ecef;border-color:#e1e5eb}.custom-radio .custom-control-label::before{border-radius:50%}.custom-radio .custom-control-label::after{content:"";border-radius:50%;-webkit-transform:scale(0);background-image:none!important;position:absolute;background:#fff;width:8px;height:8px;top:8px;left:5px;-webkit-transition:250ms cubic-bezier(.27,.01,.38,1.06);transition:250ms cubic-bezier(.27,.01,.38,1.06);-webkit-transition-delay:.1s;transition-delay:.1s;opacity:0;transform:scale(0)}.custom-radio .custom-control-input:checked~.custom-control-label::before{background-color:#007bff}.custom-radio .custom-control-input:checked~.custom-control-label::after{opacity:1;-webkit-transform:scale(1);transform:scale(1)}.custom-radio .custom-control-input:disabled:checked~.custom-control-label::before{background:#e9ecef;border-color:#e1e5eb}.custom-select{height:calc(2.09375rem + 2px);padding:.375rem 1.75rem .375rem .75rem;line-height:1.5;color:#495057;background:url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 4 5'%3E%3Cpath fill='%23333' d='M2 0L0 2h4zm0 5L0 3h4z'/%3E%3C/svg%3E") right .75rem center/8px 10px no-repeat #fff;border:1px solid #e1e5eb;font-weight:300;font-size:.8125rem;-webkit-transition:box-shadow 250ms cubic-bezier(.27,.01,.38,1.06),border 250ms cubic-bezier(.27,.01,.38,1.06);transition:box-shadow 250ms cubic-bezier(.27,.01,.38,1.06),border 250ms cubic-bezier(.27,.01,.38,1.06);border-radius:.25rem}.custom-select:focus{border-color:#007bff;box-shadow:0 .313rem .719rem rgba(0,123,255,.1),0 .156rem .125rem rgba(0,0,0,.06)}.custom-select:focus::-ms-value{color:#495057;background-color:#fff}.custom-select:hover:not(:focus):not(:disabled){cursor:pointer;border-color:#b3bdcc}.custom-select[multiple],.custom-select[size]:not([size="1"]){padding-right:.75rem}.custom-select:disabled{color:#868e96;background-color:#e9ecef}.custom-select-sm{height:calc(1.88845rem + 2px);padding-top:.375rem;padding-bottom:.375rem}.custom-select-lg{height:calc(2.9375rem + 2px);font-size:1.25rem;padding-top:.375rem;padding-bottom:.375rem}.custom-file{height:calc(2.0625rem + 2px);font-size:.8125rem;-webkit-transition:box-shadow 250ms cubic-bezier(.27,.01,.38,1.06),border 250ms cubic-bezier(.27,.01,.38,1.06);transition:box-shadow 250ms cubic-bezier(.27,.01,.38,1.06),border 250ms cubic-bezier(.27,.01,.38,1.06)}.custom-file-input{min-width:14rem;height:calc(2.0625rem + 2px)}.custom-file-input:focus~.custom-file-label{border-color:#007bff;color:#495057;box-shadow:0 .313rem .719rem rgba(0,123,255,.1),0 .156rem .125rem rgba(0,0,0,.06)}.custom-file-input:focus~.custom-file-label::after{border-color:#007bff;color:#007bff;background:#e6f2ff}.custom-file-input:focus~.custom-file-label:hover{border-color:#007bff}.custom-file-input:lang(en)~.custom-file-label::after{content:"Browse"}.custom-file-input:not(:disabled):hover{cursor:pointer}.custom-file-input:not(:disabled):hover~.custom-file-label,.custom-file-input:not(:disabled):hover~.custom-file-label:before{border-color:#b3bdcc}.custom-file-input:disabled+.custom-file-label{color:#868e96;background-color:#f8f9fa}.custom-file-label{height:calc(2.0625rem + 2px);padding:.5rem 1rem;line-height:1.5;color:#495057;background-color:#fff;border:1px solid #e1e5eb;font-weight:300;box-shadow:none;-webkit-transition:box-shadow 250ms cubic-bezier(.27,.01,.38,1.06),border-color 250ms cubic-bezier(.27,.01,.38,1.06);transition:box-shadow 250ms cubic-bezier(.27,.01,.38,1.06),border-color 250ms cubic-bezier(.27,.01,.38,1.06);border-radius:.25rem}.custom-file-label::after{padding:.5rem 1rem;height:calc(calc(2.0625rem + 2px) - 1px * 2);line-height:1.5;color:#495057;border-left:1px solid #e1e5eb;background-color:#e9ecef;border-radius:0 .25rem .25rem 0}.custom-toggle{position:relative;padding-left:3.75rem}.custom-toggle .custom-control-label::before{position:absolute;top:0;left:0;display:block;width:3.125rem;height:1.75rem;background:#fff;border-radius:100px;border:.0625rem solid #e1e5eb}.custom-toggle .custom-control-label::after{content:"";position:absolute;top:.25rem;left:.25rem;width:1.25rem;height:1.25rem;background:#e1e5eb;border-radius:6.25rem;-webkit-transition:350ms;transition:350ms}.custom-toggle .custom-control-input:checked~.custom-control-label::before{background:#17c671;border-color:#17c671}.custom-toggle .custom-control-input:checked~.custom-control-label::after{left:2.875rem;-webkit-transform:translateX(-100%);transform:translateX(-100%);background:#fff}.custom-toggle .custom-control-input:checked:disabled~.custom-control-label::before{background:#e9ecef;border-color:#e1e5eb}.custom-toggle .custom-control-input:active:not(:disabled)~.custom-control-label::after{width:1.625rem}.custom-toggle .custom-control-input:active:not(:checked)~.custom-control-label::before{background-color:#fff}.custom-toggle .custom-control-input:disabled:active~.custom-control-label::before{background-color:#e9ecef}.custom-toggle .custom-control-input:focus~.custom-control-label::before{box-shadow:0 .313rem .719rem rgba(23,198,113,.1),0 .156rem .125rem rgba(0,0,0,.06)}.custom-toggle .custom-control-input:focus:not(:checked)~.custom-control-label::before{box-shadow:0 .313rem .719rem rgba(0,123,255,.1),0 .156rem .125rem rgba(0,0,0,.06)}.custom-toggle.custom-toggle-sm{padding-left:2.625rem}.custom-toggle.custom-toggle-sm .custom-control-label::before{top:.1875rem;position:absolute;display:block;width:2.1875rem;height:1.125rem;background:#fff;border-radius:100px;border:.0625rem solid #e1e5eb}.custom-toggle.custom-toggle-sm .custom-control-label::after{content:"";position:absolute;top:.375rem;left:.1875rem;width:.75rem;height:.75rem}.custom-toggle.custom-toggle-sm .custom-control-input:checked~.custom-control-label::after{left:1.9375rem}.custom-toggle.custom-toggle-sm .custom-control-input:active:not(:disabled)~.custom-control-label::after{width:1rem}.nav{font-size:.875rem;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif}.nav-link{padding:.625rem;-webkit-transition:250ms cubic-bezier(.27,.01,.38,1.06);transition:250ms cubic-bezier(.27,.01,.38,1.06)}.nav-link.disabled{color:#868e96}.nav-tabs{border-bottom:1px solid #d1d4d8}.nav-tabs .nav-item{margin-bottom:-1px}.nav-tabs .nav-link{border:1px solid transparent;border-top-left-radius:.375rem;border-top-right-radius:.375rem}.nav-tabs .nav-link:focus,.nav-tabs .nav-link:hover{border-color:#e9ecef}.nav-tabs .nav-link.disabled{color:#868e96}.nav-tabs .nav-link.disabled:hover{cursor:not-allowed;border-color:transparent}.nav-tabs .nav-link:hover{border-color:#e7e9ea}.nav-tabs .nav-item.show .nav-link,.nav-tabs .nav-link.active{color:#495057;background-color:#fff;border-color:#ddd}.nav-tabs .dropdown-menu{margin-top:-1px;border-top-left-radius:0;border-top-right-radius:0}.nav-pills .nav-link{border-radius:.375rem}.nav-pills .nav-link.active,.nav-pills .show>.nav-link{color:#fff;background-color:#007bff}.nav-pills:hover{background-color:#fdfdfd}.nav-outlined-pills .nav-link{border-radius:.375rem;border:1px solid transparent}.nav-outlined-pills .nav-link.active,.show>.nav-outlined-pills .nav-link{background:0 0;color:#007bff;border-color:#007bff}.nav-outlined-pills .nav-link:hover{border-color:#e7e9ea}.nav-blue .nav-link.active{background-color:#007bff;border-color:#0074f0;color:#fff}.nav-blue .nav-link.disabled{color:#868e96}.nav-blue .nav-link.disabled:hover{cursor:not-allowed;border-color:transparent}.nav-blue .nav-link{color:#007bff}.nav-blue.nav-outlined-pills .nav-link.active{background:0 0;border-color:#3395ff;color:#007bff}.nav-blue.nav-outlined-pills .nav-link.active:hover{border-color:#3395ff}.nav-blue.nav-outlined-pills .nav-link{color:#007bff}.nav-indigo .nav-link.active{background-color:#674eec;border-color:#5b40eb;color:#fff}.nav-indigo .nav-link.disabled{color:#868e96}.nav-indigo .nav-link.disabled:hover{cursor:not-allowed;border-color:transparent}.nav-indigo .nav-link{color:#674eec}.nav-indigo.nav-outlined-pills .nav-link.active{background:0 0;border-color:#8f7cf1;color:#674eec}.nav-indigo.nav-outlined-pills .nav-link.active:hover{border-color:#8f7cf1}.nav-indigo.nav-outlined-pills .nav-link{color:#674eec}.nav-purple .nav-link.active{background-color:#8445f7;border-color:#7a36f6;color:#fff}.nav-purple .nav-link.disabled{color:#868e96}.nav-purple .nav-link.disabled:hover{cursor:not-allowed;border-color:transparent}.nav-purple .nav-link{color:#8445f7}.nav-purple.nav-outlined-pills .nav-link.active{background:0 0;border-color:#a476f9;color:#8445f7}.nav-purple.nav-outlined-pills .nav-link.active:hover{border-color:#a476f9}.nav-purple.nav-outlined-pills .nav-link{color:#8445f7}.nav-pink .nav-link.active{background-color:#ff4169;border-color:#ff325d;color:#fff}.nav-pink .nav-link.disabled{color:#868e96}.nav-pink .nav-link.disabled:hover{cursor:not-allowed;border-color:transparent}.nav-pink .nav-link{color:#ff4169}.nav-pink.nav-outlined-pills .nav-link.active{background:0 0;border-color:#ff7491;color:#ff4169}.nav-pink.nav-outlined-pills .nav-link.active:hover{border-color:#ff7491}.nav-pink.nav-outlined-pills .nav-link{color:#ff4169}.nav-red .nav-link.active{background-color:#c4183c;border-color:#b61638;color:#fff}.nav-red .nav-link.disabled{color:#868e96}.nav-red .nav-link.disabled:hover{cursor:not-allowed;border-color:transparent}.nav-red .nav-link{color:#c4183c}.nav-red.nav-outlined-pills .nav-link.active{background:0 0;border-color:#e52a51;color:#c4183c}.nav-red.nav-outlined-pills .nav-link.active:hover{border-color:#e52a51}.nav-red.nav-outlined-pills .nav-link{color:#c4183c}.nav-orange .nav-link.active{background-color:#fb7906;border-color:#ee7204;color:#fff}.nav-orange .nav-link.disabled{color:#868e96}.nav-orange .nav-link.disabled:hover{cursor:not-allowed;border-color:transparent}.nav-orange .nav-link{color:#fb7906}.nav-orange.nav-outlined-pills .nav-link.active{background:0 0;border-color:#fc9438;color:#fb7906}.nav-orange.nav-outlined-pills .nav-link.active:hover{border-color:#fc9438}.nav-orange.nav-outlined-pills .nav-link{color:#fb7906}.nav-yellow .nav-link.active{background-color:#ffb400;border-color:#f0a900;color:#212529}.nav-yellow .nav-link.disabled{color:#868e96}.nav-yellow .nav-link.disabled:hover{cursor:not-allowed;border-color:transparent}.nav-yellow .nav-link{color:#ffb400}.nav-yellow.nav-outlined-pills .nav-link.active{background:0 0;border-color:#ffc333;color:#ffb400}.nav-yellow.nav-outlined-pills .nav-link.active:hover{border-color:#ffc333}.nav-yellow.nav-outlined-pills .nav-link{color:#ffb400}.nav-green .nav-link.active{background-color:#17c671;border-color:#15b869;color:#fff}.nav-green .nav-link.disabled{color:#868e96}.nav-green .nav-link.disabled:hover{cursor:not-allowed;border-color:transparent}.nav-green .nav-link{color:#17c671}.nav-green.nav-outlined-pills .nav-link.active{background:0 0;border-color:#2ae68b;color:#17c671}.nav-green.nav-outlined-pills .nav-link.active:hover{border-color:#2ae68b}.nav-green.nav-outlined-pills .nav-link{color:#17c671}.nav-teal .nav-link.active{background-color:#1adba2;border-color:#18cd98;color:#212529}.nav-teal .nav-link.disabled{color:#868e96}.nav-teal .nav-link.disabled:hover{cursor:not-allowed;border-color:transparent}.nav-teal .nav-link{color:#1adba2}.nav-teal.nav-outlined-pills .nav-link.active{background:0 0;border-color:#40e8b7;color:#1adba2}.nav-teal.nav-outlined-pills .nav-link.active:hover{border-color:#40e8b7}.nav-teal.nav-outlined-pills .nav-link{color:#1adba2}.nav-cyan .nav-link.active{background-color:#00b8d8;border-color:#00abc9;color:#fff}.nav-cyan .nav-link.disabled{color:#868e96}.nav-cyan .nav-link.disabled:hover{cursor:not-allowed;border-color:transparent}.nav-cyan .nav-link{color:#00b8d8}.nav-cyan.nav-outlined-pills .nav-link.active{background:0 0;border-color:#0cdbff;color:#00b8d8}.nav-cyan.nav-outlined-pills .nav-link.active:hover{border-color:#0cdbff}.nav-cyan.nav-outlined-pills .nav-link{color:#00b8d8}.nav-white .nav-link.active{background-color:#fff;border-color:#f7f7f7;color:#212529}.nav-white .nav-link.disabled{color:#868e96}.nav-white .nav-link.disabled:hover{cursor:not-allowed;border-color:transparent}.nav-white .nav-link{color:#fff}.nav-white.nav-outlined-pills .nav-link.active{background:0 0;border-color:#fff;color:#fff}.nav-white.nav-outlined-pills .nav-link.active:hover{border-color:#fff}.nav-white.nav-outlined-pills .nav-link{color:#fff}.nav-gray .nav-link.active{background-color:#868e96;border-color:#7e868f;color:#fff}.nav-gray .nav-link.disabled{color:#868e96}.nav-gray .nav-link.disabled:hover{cursor:not-allowed;border-color:transparent}.nav-gray .nav-link{color:#868e96}.nav-gray.nav-outlined-pills .nav-link.active{background:0 0;border-color:#a1a8ae;color:#868e96}.nav-gray.nav-outlined-pills .nav-link.active:hover{border-color:#a1a8ae}.nav-gray.nav-outlined-pills .nav-link{color:#868e96}.nav-gray-dark .nav-link.active{background-color:#343a40;border-color:#2d3238;color:#fff}.nav-gray-dark .nav-link.disabled{color:#868e96}.nav-gray-dark .nav-link.disabled:hover{cursor:not-allowed;border-color:transparent}.nav-gray-dark .nav-link{color:#343a40}.nav-gray-dark.nav-outlined-pills .nav-link.active{background:0 0;border-color:#4b545c;color:#343a40}.nav-gray-dark.nav-outlined-pills .nav-link.active:hover{border-color:#4b545c}.nav-gray-dark.nav-outlined-pills .nav-link{color:#343a40}.navbar{padding:.75rem 1.5rem}.navbar-brand{padding-top:.7rem;padding-bottom:.7rem;margin-right:1.5rem;font-size:.9rem;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;font-weight:400}.navbar-text{padding-top:.625rem;padding-bottom:.625rem}.navbar-toggler{padding:.5rem;font-size:1rem;background:#fff;border:1px solid transparent;border-radius:.25rem}.navbar-expand .navbar-nav .nav-link{padding-right:.625rem;padding-left:.625rem}.navbar-light .navbar-brand,.navbar-light .navbar-brand:focus,.navbar-light .navbar-brand:hover{color:rgba(0,0,0,.9)}.navbar-light .navbar-nav .nav-link{color:rgba(0,0,0,.5)}.navbar-light .navbar-nav .nav-link:focus,.navbar-light .navbar-nav .nav-link:hover{color:rgba(0,0,0,.7)}.navbar-light .navbar-nav .nav-link.disabled{color:rgba(0,0,0,.3)}.navbar-light .navbar-nav .active>.nav-link,.navbar-light .navbar-nav .nav-link.active,.navbar-light .navbar-nav .nav-link.show,.navbar-light .navbar-nav .show>.nav-link{color:rgba(0,0,0,.9)}.navbar-light .navbar-toggler{color:rgba(0,0,0,.5);border-color:rgba(0,0,0,.1);background:0 0}.navbar-light .navbar-toggler-icon{background-image:url("data:image/svg+xml;charset=utf8,%3Csvg viewBox='0 0 30 30' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath stroke='rgba(0, 0, 0, 0.5)' stroke-width='2' stroke-linecap='round' stroke-miterlimit='10' d='M4 7h22M4 15h22M4 23h22'/%3E%3C/svg%3E")}.navbar-light .navbar-text{color:rgba(0,0,0,.5)}.navbar-light .navbar-text a,.navbar-light .navbar-text a:focus,.navbar-light .navbar-text a:hover{color:rgba(0,0,0,.9)}.navbar-dark .navbar-brand,.navbar-dark .navbar-brand:focus,.navbar-dark .navbar-brand:hover{color:#fff}.navbar-dark .navbar-nav .nav-link{color:rgba(255,255,255,.5)}.navbar-dark .navbar-nav .nav-link:focus,.navbar-dark .navbar-nav .nav-link:hover{color:rgba(255,255,255,.75)}.navbar-dark .navbar-nav .nav-link.disabled{color:rgba(255,255,255,.25)}.navbar-dark .navbar-nav .active>.nav-link,.navbar-dark .navbar-nav .nav-link.active,.navbar-dark .navbar-nav .nav-link.show,.navbar-dark .navbar-nav .show>.nav-link{color:#fff}.navbar-dark .navbar-toggler{color:rgba(255,255,255,.5);border-color:rgba(255,255,255,.1);background:0 0}.navbar-dark .navbar-toggler-icon{background-image:url("data:image/svg+xml;charset=utf8,%3Csvg viewBox='0 0 30 30' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath stroke='rgba(255, 255, 255, 0.5)' stroke-width='2' stroke-linecap='round' stroke-miterlimit='10' d='M4 7h22M4 15h22M4 23h22'/%3E%3C/svg%3E")}.navbar-dark .navbar-text{color:rgba(255,255,255,.5)}.navbar-dark .navbar-text a,.navbar-dark .navbar-text a:focus,.navbar-dark .navbar-text a:hover{color:#fff}.card{background-color:#fff;border:none;border-radius:.625rem;box-shadow:0 .46875rem 2.1875rem rgba(90,97,105,.1),0 .9375rem 1.40625rem rgba(90,97,105,.1),0 .25rem .53125rem rgba(90,97,105,.12),0 .125rem .1875rem rgba(90,97,105,.1)}.card>.list-group:first-child .list-group-item:first-child{border-top-left-radius:.625rem;border-top-right-radius:.625rem}.card>.list-group:last-child .list-group-item:last-child{border-bottom-right-radius:.625rem;border-bottom-left-radius:.625rem}.card .list-group-item{padding:.8125rem 1.875rem}.card .card-text{margin-bottom:1.5625rem}.card a:hover{text-decoration:none}.card-small{box-shadow:0 2px 0 rgba(90,97,105,.11),0 4px 8px rgba(90,97,105,.12),0 10px 10px rgba(90,97,105,.06),0 7px 70px rgba(90,97,105,.1)}.card-small .card-body,.card-small .card-footer,.card-small .card-header{padding:1rem}.card-body{padding:1.875rem}.card-body>p:last-child{margin-bottom:0}.card-title{font-weight:500;margin-bottom:.75rem}.card-subtitle{margin-top:-1.09375rem}.card-link{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif}.card-link+.card-link{margin-left:1.875rem}.card-header{padding:1.09375rem 1.875rem;background-color:#fff;border-bottom:none}.card-header:first-child{border-radius:.625rem .625rem 0 0}.card-footer{padding:1.09375rem 1.875rem;background-color:#fff;border-top:none}.card-footer:last-child{border-radius:0 0 .625rem .625rem}.card-header-tabs{margin-bottom:-1rem;border-bottom:0}.card-header-tabs .nav-link,.card-header-tabs .nav-link:hover{border-bottom:transparent}.card-header-pills{margin-right:-.9375rem;margin-left:-.9375rem}.card-header-pills:hover{background:0 0}.card-img-overlay{padding:1.875rem 2.1875rem;background:rgba(90,97,105,.5);border-radius:.625rem}.card-img-overlay .card-title{color:#fff}.card-img{border-radius:.625rem}.card-img-top{border-top-left-radius:.625rem;border-top-right-radius:.625rem}.card-img-bottom{border-bottom-right-radius:.625rem;border-bottom-left-radius:.625rem}.card-deck .card{margin-bottom:.9375rem}.card-group>.card{box-shadow:0 .46875rem 2.1875rem rgba(90,97,105,.1),0 .9375rem 1.40625rem rgba(90,97,105,.1),0 .25rem .53125rem rgba(90,97,105,.12),0 .125rem .1875rem rgba(90,97,105,.1)}.card-group>.card:last-child .card-body,.card-group>.card:last-child .card-footer{border-right:none}.card-group .card-body,.card-group .card-footer{border-right:1px solid #e7e9ea}.card-columns .card{margin-bottom:2.1875rem}.pagination{padding-left:0;list-style:none;border-radius:.375rem;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;font-size:.875rem}.page-link{padding:.5rem .75rem;line-height:1.25;color:#007bff;background-color:#fff;border:none;margin:0;-webkit-transition:250ms cubic-bezier(.27,.01,.38,1.06);transition:250ms cubic-bezier(.27,.01,.38,1.06)}.page-link:focus,.page-link:hover{color:#0056b3;background-color:#f5f5f6;border-color:#dfe1e3}.page-item{box-shadow:0 .125rem .9375rem rgba(90,97,105,.1),0 .125rem .1875rem rgba(90,97,105,.15)}.page-item:first-child{border-top-left-radius:.375rem;border-bottom-left-radius:.375rem;overflow:hidden}.page-item:last-child{border-top-right-radius:.375rem;border-bottom-right-radius:.375rem;overflow:hidden}.page-item:last-child .page-link{border-right:none}.page-item.active .page-link{color:#fff;background-color:#007bff;border-color:#007bff}.page-item.disabled .page-link{color:#a8aeb4;background-color:#fff;border-color:#dfe1e3}.pagination-lg .page-link{padding:.9375rem 1.5625rem;font-size:.875rem;line-height:1.5}.pagination-lg .page-item:first-child .page-link{border-top-left-radius:.5rem;border-bottom-left-radius:.5rem}.pagination-lg .page-item:last-child .page-link{border-top-right-radius:.5rem;border-bottom-right-radius:.5rem}.pagination-sm .page-link{padding:.25rem .6875rem;font-size:.6875rem;line-height:1.5}.pagination-sm .page-item:first-child .page-link{border-top-left-radius:.35rem;border-bottom-left-radius:.35rem}.pagination-sm .page-item:last-child .page-link{border-top-right-radius:.35rem;border-bottom-right-radius:.35rem}.badge{padding:.375rem .5rem;font-size:75%;font-weight:500;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;color:#fff;border-radius:.375rem}a.badge{-webkit-transition:250ms cubic-bezier(.27,.01,.38,1.06);transition:250ms cubic-bezier(.27,.01,.38,1.06)}.badge-pill{padding-right:.5rem;padding-left:.5rem;border-radius:10rem}.badge-squared{border-radius:0}.badge-primary{color:#fff;background-color:#007bff}.badge-primary[href]:focus,.badge-primary[href]:hover{color:#fff;text-decoration:none;background-color:#0062cc}.badge-outline-primary{background:0 0;border:1px solid #007bff;color:#007bff}.badge-secondary{color:#fff;background-color:#5a6169}.badge-secondary[href]:focus,.badge-secondary[href]:hover{color:#fff;text-decoration:none;background-color:#42484e}.badge-outline-secondary{background:0 0;border:1px solid #5a6169;color:#5a6169}.badge-success{color:#fff;background-color:#17c671}.badge-success[href]:focus,.badge-success[href]:hover{color:#fff;text-decoration:none;background-color:#129857}.badge-outline-success{background:0 0;border:1px solid #17c671;color:#17c671}.badge-info{color:#fff;background-color:#00b8d8}.badge-info[href]:focus,.badge-info[href]:hover{color:#fff;text-decoration:none;background-color:#008da5}.badge-outline-info{background:0 0;border:1px solid #00b8d8;color:#00b8d8}.badge-warning{color:#212529;background-color:#ffb400}.badge-warning[href]:focus,.badge-warning[href]:hover{color:#212529;text-decoration:none;background-color:#cc9000}.badge-outline-warning{background:0 0;border:1px solid #ffb400;color:#ffb400}.badge-danger{color:#fff;background-color:#c4183c}.badge-danger[href]:focus,.badge-danger[href]:hover{color:#fff;text-decoration:none;background-color:#97122e}.badge-outline-danger{background:0 0;border:1px solid #c4183c;color:#c4183c}.badge-light{color:#212529;background-color:#fbfbfb}.badge-light[href]:focus,.badge-light[href]:hover{color:#212529;text-decoration:none;background-color:#e2e2e2}.badge-outline-light{background:0 0;border:1px solid #fbfbfb;color:#212529}.badge-dark{color:#fff;background-color:#212529}.badge-dark[href]:focus,.badge-dark[href]:hover{color:#fff;text-decoration:none;background-color:#0a0c0d}.badge-outline-dark{background:0 0;border:1px solid #212529;color:#212529}.jumbotron{padding:38px 42px;margin-bottom:2rem;background-color:#eceeef;border-radius:.5rem}.alert{padding:.75rem 1.25rem;margin-bottom:1rem;border:none;border-radius:0}.alert-link{font-weight:500}.alert-dismissible .close{top:0;right:0;padding:.75rem 1.25rem;-webkit-transition:250ms cubic-bezier(.27,.01,.38,1.06);transition:250ms cubic-bezier(.27,.01,.38,1.06)}.alert-dismissible .close:hover{cursor:pointer}.alert-primary{color:#f5faff;background-color:#007bff}.alert-primary .alert-link{color:#f5faff}.alert-secondary{color:#d9dcdf;background-color:#5a6169}.alert-secondary .alert-link{color:#d9dcdf}.alert-success{color:#d7fae9;background-color:#17c671}.alert-success .alert-link{color:#d7fae9}.alert-info{color:#cef8ff;background-color:#00b8d8}.alert-info .alert-link{color:#cef8ff}.alert-warning{color:#fffcf5;background-color:#ffb400}.alert-warning .alert-link{color:#fffcf5}.alert-danger{color:#fad7de;background-color:#c4183c}.alert-danger .alert-link{color:#fad7de}.alert-light{background-color:#fbfbfb;color:#212529}.alert-light .alert-link{color:#212529}.alert-dark{color:#959faa;background-color:#212529}.alert-dark .alert-link{color:#959faa}.progress-wrapper{position:relative;color:#5a6169}.progress-wrapper .progress-label{font-size:.8125rem}.progress-wrapper .progress-value{position:absolute;top:6px;right:0;color:#5a6169}.progress{height:.625rem;font-size:.625rem;line-height:.625rem;background-color:#f5f5f6;margin-top:6px;border-radius:1.25rem;box-shadow:inset 0 .1rem .1rem rgba(90,97,105,.15)}.progress-sm{height:.3125rem}.progress-lg,.progress-lg .progress-bar{height:.9375rem}.progress-bar{height:.625rem;line-height:.625rem;color:#fff;background-color:#007bff;-webkit-transition:width .6s;transition:width .6s}.progress-bar-striped{background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-size:.625rem .625rem}.progress-bar-animated{-webkit-animation:1s linear infinite progress-bar-stripes;animation:1s linear infinite progress-bar-stripes}.list-group-small .list-group-item{padding:.625rem 1rem;font-size:.8125rem}.list-group-item-action{color:#5a6169;-webkit-transition:250ms cubic-bezier(.27,.01,.38,1.06);transition:250ms cubic-bezier(.27,.01,.38,1.06)}.list-group-item-action:focus,.list-group-item-action:hover{color:#5a6169;background-color:#f7f8f8}.list-group-item-action:active{color:#5a6169;background-color:#eceeef}.list-group-item{padding:.75rem 1.25rem;margin-bottom:-1px;background-color:#fff;border:1px solid rgba(0,0,0,.125);font-weight:300}.list-group-item:first-child{border-top-left-radius:.375rem;border-top-right-radius:.375rem}.list-group-item:last-child{border-bottom-right-radius:.375rem;border-bottom-left-radius:.375rem}.list-group-item.disabled,.list-group-item:disabled{color:#868e96;background-color:#fff}.list-group-item.active{color:#fff;background-color:#007bff;border-color:#007bff}.list-group-item-primary{color:#004085;background-color:#b8daff}a.list-group-item-primary,button.list-group-item-primary{color:#004085}a.list-group-item-primary:focus,a.list-group-item-primary:hover,button.list-group-item-primary:focus,button.list-group-item-primary:hover{color:#004085;background-color:#9fcdff}a.list-group-item-primary.active,button.list-group-item-primary.active{background-color:#004085;border-color:#004085}.list-group-item-secondary{color:#2f3237;background-color:#d1d3d5}a.list-group-item-secondary,button.list-group-item-secondary{color:#2f3237}a.list-group-item-secondary:focus,a.list-group-item-secondary:hover,button.list-group-item-secondary:focus,button.list-group-item-secondary:hover{color:#2f3237;background-color:#c4c6c9}a.list-group-item-secondary.active,button.list-group-item-secondary.active{background-color:#2f3237;border-color:#2f3237}.list-group-item-success{color:#0c673b;background-color:#beefd7}a.list-group-item-success,button.list-group-item-success{color:#0c673b}a.list-group-item-success:focus,a.list-group-item-success:hover,button.list-group-item-success:focus,button.list-group-item-success:hover{color:#0c673b;background-color:#aaeaca}a.list-group-item-success.active,button.list-group-item-success.active{background-color:#0c673b;border-color:#0c673b}.list-group-item-info{color:#006070;background-color:#b8ebf4}a.list-group-item-info,button.list-group-item-info{color:#006070}a.list-group-item-info:focus,a.list-group-item-info:hover,button.list-group-item-info:focus,button.list-group-item-info:hover{color:#006070;background-color:#a2e5f1}a.list-group-item-info.active,button.list-group-item-info.active{background-color:#006070;border-color:#006070}.list-group-item-warning{color:#855e00;background-color:#ffeab8}a.list-group-item-warning,button.list-group-item-warning{color:#855e00}a.list-group-item-warning:focus,a.list-group-item-warning:hover,button.list-group-item-warning:focus,button.list-group-item-warning:hover{color:#855e00;background-color:#ffe29f}a.list-group-item-warning.active,button.list-group-item-warning.active{background-color:#855e00;border-color:#855e00}.list-group-item-danger{color:#660c1f;background-color:#eebec8}a.list-group-item-danger,button.list-group-item-danger{color:#660c1f}a.list-group-item-danger:focus,a.list-group-item-danger:hover,button.list-group-item-danger:focus,button.list-group-item-danger:hover{color:#660c1f;background-color:#e9aab7}a.list-group-item-danger.active,button.list-group-item-danger.active{background-color:#660c1f;border-color:#660c1f}.list-group-item-light{color:#838383;background-color:#fefefe}a.list-group-item-light,button.list-group-item-light{color:#838383}a.list-group-item-light:focus,a.list-group-item-light:hover,button.list-group-item-light:focus,button.list-group-item-light:hover{color:#838383;background-color:#f1f1f1}a.list-group-item-light.active,button.list-group-item-light.active{background-color:#838383;border-color:#838383}.list-group-item-dark{color:#111315;background-color:#c1c2c3}a.list-group-item-dark,button.list-group-item-dark{color:#111315}a.list-group-item-dark:focus,a.list-group-item-dark:hover,button.list-group-item-dark:focus,button.list-group-item-dark:hover{color:#111315;background-color:#b4b5b6}a.list-group-item-dark.active,button.list-group-item-dark.active{background-color:#111315;border-color:#111315}.close{font-size:1.5rem;font-weight:500;color:#8c949d;text-shadow:none;-webkit-transition:250ms cubic-bezier(.27,.01,.38,1.06);transition:250ms cubic-bezier(.27,.01,.38,1.06)}.close:focus,.close:hover{color:#8c949d}.modal{z-index:1050}.modal-dialog{margin:.625rem}.modal.fade .modal-dialog{transition:transform .3s ease-out;-webkit-transition:-webkit-transform .3s ease-out;transition:transform .3s ease-out,-webkit-transform .3s ease-out}.modal-dialog-centered{min-height:calc(100% - (.625rem * 2))}.modal-content{background-color:#fff;border:none;border-radius:.5rem;box-shadow:0 .46875rem 2.1875rem rgba(90,97,105,.1),0 .9375rem 1.40625rem rgba(90,97,105,.1),0 .25rem .53125rem rgba(90,97,105,.12),0 .125rem .1875rem rgba(90,97,105,.1)}.modal-backdrop{z-index:1040;background-color:#5a6169}.modal-backdrop.show{opacity:.12}.modal-header{padding:.9375rem 2.1875rem;border-bottom:1px solid #dfe1e3}.modal-title{line-height:1.5}.modal-body{padding:1.875rem 2.1875rem}.modal-footer{padding:.9375rem 2.1875rem;border-top:1px solid #dfe1e3}.tooltip{z-index:1070;margin:0;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;font-style:normal;font-weight:300;line-height:1.5;text-align:left;text-align:start;text-decoration:none;text-shadow:none;text-transform:none;letter-spacing:normal;word-break:normal;word-spacing:normal;white-space:normal;line-break:auto;font-size:.6875rem}.tooltip.show{opacity:1}.tooltip .arrow{width:5px;height:5px}.bs-tooltip-auto[x-placement^=top],.bs-tooltip-top{padding:5px 0}.bs-tooltip-auto[x-placement^=top] .arrow::before,.bs-tooltip-top .arrow::before{border-width:5px 2.5px 0;border-top-color:#fff}.bs-tooltip-auto[x-placement^=right],.bs-tooltip-right{padding:0 5px}.bs-tooltip-auto[x-placement^=right] .arrow,.bs-tooltip-right .arrow{width:5px;height:5px}.bs-tooltip-auto[x-placement^=right] .arrow::before,.bs-tooltip-right .arrow::before{border-width:2.5px 5px 2.5px 0;border-right-color:#fff}.bs-tooltip-auto[x-placement^=bottom],.bs-tooltip-bottom{padding:5px 0}.bs-tooltip-auto[x-placement^=bottom] .arrow::before,.bs-tooltip-bottom .arrow::before{border-width:0 2.5px 5px;border-bottom-color:#fff}.bs-tooltip-auto[x-placement^=left],.bs-tooltip-left{padding:0 5px}.bs-tooltip-auto[x-placement^=left] .arrow,.bs-tooltip-left .arrow{width:5px;height:5px}.bs-tooltip-auto[x-placement^=left] .arrow::before,.bs-tooltip-left .arrow::before{border-width:2.5px 0 2.5px 5px;border-left-color:#fff}.tooltip-inner{max-width:200px;padding:7px 13px;color:#5a6169;background-color:#fff;box-shadow:0 3px 15px rgba(90,97,105,.1),0 2px 3px rgba(90,97,105,.2);border-radius:.375rem}.popover{z-index:1060;max-width:276px;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;font-style:normal;font-weight:300;line-height:1.5;text-align:left;text-align:start;text-decoration:none;text-shadow:none;text-transform:none;letter-spacing:normal;word-break:normal;word-spacing:normal;white-space:normal;line-break:auto;font-size:.6875rem;background-color:#fff;border:none;padding:0;border-radius:.5rem;box-shadow:0 3px 15px rgba(90,97,105,.1),0 2px 3px rgba(90,97,105,.2)}.popover .arrow{width:10px;height:5px;margin:0 .5rem}.popover .arrow::after,.popover .arrow::before{border-width:11px}.bs-popover-auto[x-placement^=top],.bs-popover-top{margin-bottom:5px}.bs-popover-auto[x-placement^=top] .arrow,.bs-popover-top .arrow{bottom:calc((5px + 1px) * -1)}.bs-popover-auto[x-placement^=top] .arrow::after,.bs-popover-auto[x-placement^=top] .arrow::before,.bs-popover-top .arrow::after,.bs-popover-top .arrow::before{border-width:5px 5px 0}.bs-popover-auto[x-placement^=top] .arrow::before,.bs-popover-top .arrow::before{border-top-color:rgba(0,0,0,.05)}.bs-popover-auto[x-placement^=top] .arrow::after,.bs-popover-top .arrow::after{bottom:1px;border-top-color:#fff}.bs-popover-auto[x-placement^=right],.bs-popover-right{margin-left:5px}.bs-popover-auto[x-placement^=right] .arrow,.bs-popover-right .arrow{left:calc((5px + 1px) * -1);width:5px;height:10px;margin:.5rem 0}.bs-popover-auto[x-placement^=right] .arrow::after,.bs-popover-auto[x-placement^=right] .arrow::before,.bs-popover-right .arrow::after,.bs-popover-right .arrow::before{border-width:5px 5px 5px 0}.bs-popover-auto[x-placement^=right] .arrow::before,.bs-popover-right .arrow::before{border-right-color:rgba(0,0,0,.05)}.bs-popover-auto[x-placement^=right] .arrow::after,.bs-popover-right .arrow::after{left:1px;border-right-color:#fff}.bs-popover-auto[x-placement^=bottom],.bs-popover-bottom{margin-top:5px}.bs-popover-auto[x-placement^=bottom] .arrow,.bs-popover-bottom .arrow{top:calc((5px + 1px) * -1)}.bs-popover-auto[x-placement^=bottom] .arrow::after,.bs-popover-auto[x-placement^=bottom] .arrow::before,.bs-popover-bottom .arrow::after,.bs-popover-bottom .arrow::before{border-width:0 5px 5px}.bs-popover-auto[x-placement^=bottom] .arrow::before,.bs-popover-bottom .arrow::before{border-bottom-color:rgba(0,0,0,.05)}.bs-popover-auto[x-placement^=bottom] .arrow::after,.bs-popover-bottom .arrow::after{top:1px;border-bottom-color:#fff}.bs-popover-auto[x-placement^=bottom] .popover-header::before,.bs-popover-bottom .popover-header::before{width:10px;margin-left:-5px;border-bottom:1px solid #f5f5f6}.bs-popover-auto[x-placement^=left],.bs-popover-left{margin-right:5px}.bs-popover-auto[x-placement^=left] .arrow,.bs-popover-left .arrow{right:calc((5px + 1px) * -1);width:5px;height:10px;margin:.5rem 0}.bs-popover-auto[x-placement^=left] .arrow::after,.bs-popover-auto[x-placement^=left] .arrow::before,.bs-popover-left .arrow::after,.bs-popover-left .arrow::before{border-width:5px 0 5px 5px}.bs-popover-auto[x-placement^=left] .arrow::before,.bs-popover-left .arrow::before{border-left-color:rgba(0,0,0,.05)}.bs-popover-auto[x-placement^=left] .arrow::after,.bs-popover-left .arrow::after{right:1px;border-left-color:#fff}.popover-header{padding:14px 20px;font-size:1rem;color:#3d5170;line-height:14px;background-color:#f5f5f6;border-bottom:1px solid #e7e9ea;border-top-left-radius:calc(.5rem - 1px);border-top-right-radius:calc(.5rem - 1px)}.popover-body{padding:15px 20px;color:#5a6169}.carousel{box-shadow:0 .46875rem 2.1875rem rgba(90,97,105,.1),0 .9375rem 1.40625rem rgba(90,97,105,.1),0 .25rem .53125rem rgba(90,97,105,.12),0 .125rem .1875rem rgba(90,97,105,.1)}.carousel-item{transition:transform .6s;-webkit-transition:-webkit-transform .6s;transition:transform .6s,-webkit-transform .6s}.carousel-control-next,.carousel-control-prev{width:15%;color:#fff;opacity:.5}.carousel-control-next:focus,.carousel-control-next:hover,.carousel-control-prev:focus,.carousel-control-prev:hover{color:#fff}.carousel-control-next-icon,.carousel-control-prev-icon{width:20px;height:20px}.carousel-control-prev-icon{background-image:url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' viewBox='0 0 8 8'%3E%3Cpath d='M4 0l-4 4 4 4 1.5-1.5-2.5-2.5 2.5-2.5-1.5-1.5z'/%3E%3C/svg%3E")}.carousel-control-next-icon{background-image:url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' viewBox='0 0 8 8'%3E%3Cpath d='M1.5 0l-1.5 1.5 2.5 2.5-2.5 2.5 1.5 1.5 4-4-4-4z'/%3E%3C/svg%3E")}.carousel-indicators{margin-right:15%;margin-left:15%}.carousel-indicators li{width:30px;height:3px;margin-right:3px;margin-left:3px;background-color:rgba(255,255,255,.5);border-radius:3px}.carousel-indicators .active{background-color:#fff}.carousel-caption{right:15%;left:15%;color:#fff}.noUi-target,.noUi-target *{-webkit-touch-callout:none;-webkit-tap-highlight-color:transparent;-webkit-user-select:none;touch-action:none;-ms-user-select:none;-moz-user-select:none;user-select:none;box-sizing:border-box}.noUi-target{position:relative;direction:ltr;background:#eceeef;border-radius:5px;box-shadow:inset 0 1px 2px rgba(90,97,105,.1);margin:35px 0}.noUi-target:focus{outline:0;box-shadow:0 0 8px rgba(0,123,255,.65),0 3px 15px rgba(90,97,105,.1),0 2px 3px rgba(90,97,105,.2)}.noUi-base,.noUi-connects{width:100%;height:100%;position:relative;z-index:1}.noUi-connects{overflow:hidden;z-index:0}.noUi-connect,.noUi-origin{position:absolute;will-change:transform;z-index:1;top:0;left:0;height:100%;width:100%;-webkit-transform-origin:0 0;transform-origin:0 0}.noUi-connect:focus,.noUi-origin:focus{outline:0}.noUi-connect{background:#007bff;border-radius:5px}html:not([dir=rtl]) .noUi-horizontal .noUi-origin{left:auto;right:0}html:not([dir=rtl]) .noUi-horizontal .noUi-handle{right:-17px;left:auto}.noUi-rtl .noUi-value-horizontal{-webkit-transform:translate(50%,50%);transform:translate(50%,50%)}.noUi-rtl .noUi-value-vertical{-webkit-transform:translate(0,50%);transform:translate(0,50%)}.noUi-vertical{width:5px}.noUi-vertical .noUi-origin{width:0}.noUi-vertical .noUi-handle{left:-10px;top:-11.5px}.noUi-vertical .noUi-handle:after,.noUi-vertical .noUi-handle:before{width:14px;height:1px;left:6px;top:14px}.noUi-vertical .noUi-handle:after{top:17px}.noUi-vertical .noUi-tooltip{-webkit-transform:translate(0,-50%);transform:translate(0,-50%);top:50%;right:30px}.noUi-vertical .noUi-draggable{cursor:ns-resize}.noUi-horizontal{height:5px}.noUi-horizontal .noUi-origin{height:0}.noUi-horizontal .noUi-tooltip{-webkit-transform:translate(-50%,0);transform:translate(-50%,0);left:50%;bottom:1.625rem}.noUi-handle{position:absolute;border:1px solid #e7e9ea;border-radius:50%;box-shadow:0 3px 15px rgba(90,97,105,.1),0 2px 3px rgba(90,97,105,.2);background:#fff;-webkit-transition:250ms cubic-bezier(.27,.01,.38,1.06);transition:250ms cubic-bezier(.27,.01,.38,1.06)}.noUi-handle:hover{cursor:grab;cursor:-webkit-grab;cursor:-moz-grab}.noUi-handle:active{cursor:grabbing;cursor:-webkit-grabbing;cursor:-moz-grabbing}.noUi-handle:focus{outline:0;box-shadow:0 0 8px rgba(0,123,255,.65),0 3px 15px rgba(90,97,105,.1),0 2px 3px rgba(90,97,105,.2)}.noUi-handle:after{left:17px}.noUi-state-tap .noUi-connect,.noUi-state-tap .noUi-origin{transition:transform .3s;-webkit-transition:-webkit-transform .3s;transition:transform .3s,-webkit-transform .3s}.noUi-state-drag *{cursor:inherit!important}.noUi-connects{border-radius:5px}.noUi-draggable{cursor:ew-resize}.noUi-active{-webkit-transform:scale(1.1);transform:scale(1.1)}[disabled] .noUi-connect{background:#b8b8b8}[disabled] .noUi-handle,[disabled].noUi-handle,[disabled].noUi-target{cursor:not-allowed}[disabled] .noUi-handle{background:#f2f3f4}[disabled] .noUi-handle:focus{box-shadow:0 3px 15px rgba(90,97,105,.1),0 2px 3px rgba(90,97,105,.2)}.noUi-pips,.noUi-pips *{box-sizing:border-box}.noUi-pips{position:absolute;color:#a8aeb4}.noUi-value{position:absolute;white-space:nowrap;text-align:center}.noUi-value-sub{color:#a8aeb4;font-size:10px}.noUi-marker{position:absolute;background:#a8aeb4}.noUi-marker-large,.noUi-marker-sub{background:#a8aeb4}.noUi-pips-horizontal{padding:10px 0;height:auto;top:100%;left:0;width:100%}.noUi-value-horizontal{-webkit-transform:translate3d(-50%,50%,0);transform:translate3d(-50%,50%,0)}.noUi-marker-horizontal.noUi-marker{margin-left:-1px;width:1px;height:4px}.noUi-marker-horizontal.noUi-marker-sub{height:5px}.noUi-marker-horizontal.noUi-marker-large{height:7px}.noUi-pips-vertical{padding:0 10px;height:100%;top:0;left:100%}.noUi-value-vertical{-webkit-transform:translate3d(0,-50%,0);transform:translate3d(0,-50%,0);padding-left:15px}.noUi-marker-vertical.noUi-marker{width:4px;height:1px;margin-top:-1px}.noUi-marker-vertical.noUi-marker-sub{width:10px}.noUi-marker-vertical.noUi-marker-large{width:7px}.noUi-tooltip{display:block;position:absolute;text-align:center;white-space:nowrap;border-radius:.375rem;background:#fff;color:#5a6169;box-shadow:0 3px 15px rgba(90,97,105,.1),0 2px 3px rgba(90,97,105,.2)}.slider-primary .noUi-connect{background:#007bff}.slider-secondary .noUi-connect{background:#5a6169}.slider-success .noUi-connect{background:#17c671}.slider-info .noUi-connect{background:#00b8d8}.slider-warning .noUi-connect{background:#ffb400}.slider-danger .noUi-connect{background:#c4183c}.slider-light .noUi-connect{background:#fbfbfb}.slider-dark .noUi-connect{background:#212529}.datepicker{border-radius:.625rem;direction:ltr}.datepicker-inline{width:220px}.datepicker-rtl{direction:rtl}.datepicker-rtl.dropdown-menu{left:auto}.datepicker-rtl table tr td span{float:right}.datepicker-dropdown{top:0;left:0;padding:20px 22px}.datepicker-dropdown:after,.datepicker-dropdown:before{content:"";display:inline-block;border-top:0;position:absolute}.datepicker-dropdown:before{border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:7px solid rgba(0,0,0,.2)}.datepicker-dropdown:after{border-left:6px solid transparent;border-right:6px solid transparent;border-bottom:6px solid #fff}.datepicker-dropdown.datepicker-orient-left:before{left:6px}.datepicker-dropdown.datepicker-orient-left:after{left:7px}.datepicker-dropdown.datepicker-orient-right:before{right:6px}.datepicker-dropdown.datepicker-orient-right:after{right:7px}.datepicker-dropdown.datepicker-orient-bottom:before{top:-7px}.datepicker-dropdown.datepicker-orient-bottom:after{top:-6px}.datepicker-dropdown.datepicker-orient-top:before{bottom:-7px;border-bottom:0;border-top:7px solid #c3c7cc}.datepicker-dropdown.datepicker-orient-top:after{bottom:-6px;border-bottom:0;border-top:6px solid #fff}.datepicker table{margin:0;-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.datepicker table tr td{border-radius:50%}.datepicker table tr th{border-radius:.375rem;font-weight:500}.datepicker table tr td,.datepicker table tr th{-webkit-transition:250ms cubic-bezier(.27,.01,.38,1.06);transition:250ms cubic-bezier(.27,.01,.38,1.06);border:none;text-align:center;width:1.875rem;height:1.875rem}.table-striped .datepicker table tr td,.table-striped .datepicker table tr th{background-color:transparent}.datepicker table tr td.new,.datepicker table tr td.old{color:#c3c7cc}.datepicker table tr td.day:hover,.datepicker table tr td.focused{background:#eceeef;cursor:pointer}.datepicker table tr td.disabled,.datepicker table tr td.disabled:hover{background:0 0;color:#e7e9ea;cursor:default}.datepicker table tr td.highlighted{border-radius:0}.datepicker table tr td.highlighted.focused{background:#007bff}.datepicker table tr td.highlighted.disabled,.datepicker table tr td.highlighted.disabled:active{background:#007bff;color:#5a6169}.datepicker table tr td.today{background:#e6f2ff}.datepicker table tr td.today.focused{background:#f5f5f6}.datepicker table tr td.today.disabled,.datepicker table tr td.today.disabled:active{background:#f5f5f6;color:#868e96}.datepicker table tr td.range{background:#007bff;color:#fff;border-radius:0}.datepicker table tr td.range.focused{background:#0067d6}.datepicker table tr td.range.day.disabled:hover,.datepicker table tr td.range.disabled,.datepicker table tr td.range.disabled:active{background:#0062cc;color:#3395ff}.datepicker table tr td.range.highlighted.focused{background:#cbd3da}.datepicker table tr td.range.highlighted.disabled,.datepicker table tr td.range.highlighted.disabled:active{background:#e9ecef;color:#e7e9ea}.datepicker table tr td.range.today.disabled,.datepicker table tr td.range.today.disabled:active{background:#007bff;color:#fff}.datepicker table tr td.day.range-start{border-top-right-radius:0;border-bottom-right-radius:0}.datepicker table tr td.day.range-end{border-top-left-radius:0;border-bottom-left-radius:0}.datepicker table tr td.day.range-start.range-end{border-radius:50%}.datepicker table tr td.active,.datepicker table tr td.active.highlighted,.datepicker table tr td.active.highlighted:hover,.datepicker table tr td.active:hover,.datepicker table tr td.day.range:hover,.datepicker table tr td.selected,.datepicker table tr td.selected.highlighted,.datepicker table tr td.selected.highlighted:hover,.datepicker table tr td.selected:hover{background:#007bff;color:#fff}.datepicker table tr td span{display:block;width:23%;height:54px;line-height:54px;float:left;margin:1%;cursor:pointer;border-radius:4px}.datepicker table tr td span.focused,.datepicker table tr td span:hover{background:#e9ecef}.datepicker table tr td span.disabled,.datepicker table tr td span.disabled:hover{background:0 0;color:#e7e9ea;cursor:default}.datepicker table tr td span.active,.datepicker table tr td span.active.disabled,.datepicker table tr td span.active.disabled:hover,.datepicker table tr td span.active:hover{text-shadow:0 -1px 0 rgba(0,0,0,.25)}.datepicker table tr td span.new,.datepicker table tr td span.old{color:#868e96}.datepicker .datepicker-switch{width:145px}.datepicker .datepicker-switch,.datepicker .next,.datepicker .prev,.datepicker tfoot tr th{cursor:pointer}.datepicker .datepicker-switch:hover,.datepicker .next:hover,.datepicker .prev:hover,.datepicker tfoot tr th:hover{background:#e9ecef}.datepicker .next.disabled,.datepicker .prev.disabled{visibility:hidden}.datepicker .cw{font-size:10px;width:12px;padding:0 2px 0 5px;vertical-align:middle}.input-daterange input{text-align:center}.bg-primary{background-color:#007bff!important}.bg-primary.card .card-body,.bg-primary.card .card-footer,.bg-primary.card .card-header,.bg-primary.card .card-title{background-color:#0062cc!important}.bg-primary.card .card-footer,.bg-primary.card .card-header{background:#0074f0}a.bg-primary:focus,a.bg-primary:hover{background-color:#0062cc!important}.bg-secondary{background-color:#5a6169!important}.bg-secondary.card .card-body,.bg-secondary.card .card-footer,.bg-secondary.card .card-header,.bg-secondary.card .card-title{background-color:#42484e!important}.bg-secondary.card .card-footer,.bg-secondary.card .card-header{background:#535961}a.bg-secondary:focus,a.bg-secondary:hover{background-color:#42484e!important}.bg-success{background-color:#17c671!important}.bg-success.card .card-body,.bg-success.card .card-footer,.bg-success.card .card-header,.bg-success.card .card-title{background-color:#129857!important}.bg-success.card .card-footer,.bg-success.card .card-header{background:#15b869}a.bg-success:focus,a.bg-success:hover{background-color:#129857!important}.bg-info{background-color:#00b8d8!important}.bg-info.card .card-body,.bg-info.card .card-footer,.bg-info.card .card-header,.bg-info.card .card-title{background-color:#008da5!important}.bg-info.card .card-footer,.bg-info.card .card-header{background:#00abc9}a.bg-info:focus,a.bg-info:hover{background-color:#008da5!important}.bg-warning{background-color:#ffb400!important}.bg-warning.card .card-body,.bg-warning.card .card-footer,.bg-warning.card .card-header,.bg-warning.card .card-title{background-color:#cc9000!important}.bg-warning.card .card-footer,.bg-warning.card .card-header{background:#f0a900}a.bg-warning:focus,a.bg-warning:hover{background-color:#cc9000!important}.bg-danger{background-color:#c4183c!important}.bg-danger.card .card-body,.bg-danger.card .card-footer,.bg-danger.card .card-header,.bg-danger.card .card-title{background-color:#97122e!important}.bg-danger.card .card-footer,.bg-danger.card .card-header{background:#b61638}a.bg-danger:focus,a.bg-danger:hover{background-color:#97122e!important}.bg-light{background-color:#fbfbfb!important}.bg-light.card .card-body,.bg-light.card .card-footer,.bg-light.card .card-header,.bg-light.card .card-title{background-color:#e2e2e2!important}.bg-light.card .card-footer,.bg-light.card .card-header{background:#f3f3f3}a.bg-light:focus,a.bg-light:hover{background-color:#e2e2e2!important}.bg-dark{background-color:#212529!important}.bg-dark.card .card-body,.bg-dark.card .card-footer,.bg-dark.card .card-header,.bg-dark.card .card-title{background-color:#0a0c0d!important}.bg-dark.card .card-footer,.bg-dark.card .card-header{background:#1a1d21}a.bg-dark:focus,a.bg-dark:hover{background-color:#0a0c0d!important}.border{border:1px solid #e1e5eb!important}.border-top{border-top:1px solid #e1e5eb!important}.border-right{border-right:1px solid #e1e5eb!important}.border-bottom{border-bottom:1px solid #e1e5eb!important}.border-left{border-left:1px solid #e1e5eb!important}.border-primary{border-color:#007bff!important}.border-secondary{border-color:#5a6169!important}.border-success{border-color:#17c671!important}.border-info{border-color:#00b8d8!important}.border-warning{border-color:#ffb400!important}.border-danger{border-color:#c4183c!important}.border-light{border-color:#fbfbfb!important}.border-dark{border-color:#212529!important}.text-monospace{font-family:"Roboto Mono",Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}.font-weight-normal{font-weight:300}.font-weight-bold{font-weight:500}b,strong{font-weight:700!important}.text-primary{color:#007bff!important}a.text-primary:focus,a.text-primary:hover{color:#0062cc!important}.text-secondary{color:#5a6169!important}a.text-secondary:focus,a.text-secondary:hover{color:#42484e!important}.text-success{color:#17c671!important}a.text-success:focus,a.text-success:hover{color:#129857!important}.text-info{color:#00b8d8!important}a.text-info:focus,a.text-info:hover{color:#008da5!important}.text-warning{color:#ffb400!important}a.text-warning:focus,a.text-warning:hover{color:#cc9000!important}.text-danger{color:#c4183c!important}a.text-danger:focus,a.text-danger:hover{color:#97122e!important}a.text-light:focus,a.text-light:hover{color:#e2e2e2!important}.text-dark{color:#212529!important}a.text-dark:focus,a.text-dark:hover{color:#0a0c0d!important}.text-body{color:#5a6169!important}a.text-white:focus,a.text-white:hover{color:#e6e6e6!important}.text-black{color:#000}a.text-black:focus,a.text-black:hover{color:#000!important}.text-muted{color:#868e96!important}.with-shadows{box-shadow:0 .46875rem 2.1875rem rgba(90,97,105,.1),0 .9375rem 1.40625rem rgba(90,97,105,.1),0 .25rem .53125rem rgba(90,97,105,.12),0 .125rem .1875rem rgba(90,97,105,.1)}html{font-size:16px;font-weight:500}body{background:#f5f6f8;font-size:15px;font-weight:500}a{text-decoration:none;color:#007bff}a:hover{text-decoration:underline;color:#0056b3}label{font-weight:400}.datepicker{font-size:.75rem;padding:.625rem}.btn-black:not([disabled]):not(.disabled).active,.btn-black:not([disabled]):not(.disabled):active,.btn-white:not([disabled]):not(.disabled).active,.btn-white:not([disabled]):not(.disabled):active{box-shadow:none!important;background-color:#007bff;border-color:#007bff;color:#fff}.btn-black:not([disabled]):not(.disabled).active+.btn,.btn-black:not([disabled]):not(.disabled):active+.btn,.btn-white:not([disabled]):not(.disabled).active+.btn,.btn-white:not([disabled]):not(.disabled):active+.btn{border-left:1px solid #007bff}.btn-black:hover,.btn-white:hover{background:#fff;border-color:#fff;box-shadow:0 .125rem .625rem rgba(129,142,163,.2),0 .0625rem .125rem rgba(129,142,163,.3)}.btn.btn-white{border:1px solid #e1e5eb;color:#3d5170}.btn.btn-white:not([disabled]):not(.disabled).active-primary.active,.btn.btn-white:not([disabled]):not(.disabled).active-primary:active{background-color:#007bff;border-color:#007bff;color:#fff}.btn.btn-white:not([disabled]):not(.disabled).active-primary.active+.btn,.btn.btn-white:not([disabled]):not(.disabled).active-primary:active+.btn{border-left:1px solid red}.btn.btn-white:not([disabled]):not(.disabled).active-secondary.active,.btn.btn-white:not([disabled]):not(.disabled).active-secondary:active{background-color:#5a6169;border-color:#5a6169;color:#fff}.btn.btn-white:not([disabled]):not(.disabled).active-secondary.active+.btn,.btn.btn-white:not([disabled]):not(.disabled).active-secondary:active+.btn{border-left:1px solid red}.btn.btn-white:not([disabled]):not(.disabled).active-success.active,.btn.btn-white:not([disabled]):not(.disabled).active-success:active{background-color:#17c671;border-color:#17c671;color:#fff}.btn.btn-white:not([disabled]):not(.disabled).active-success.active+.btn,.btn.btn-white:not([disabled]):not(.disabled).active-success:active+.btn{border-left:1px solid red}.btn.btn-white:not([disabled]):not(.disabled).active-info.active,.btn.btn-white:not([disabled]):not(.disabled).active-info:active{background-color:#00b8d8;border-color:#00b8d8;color:#fff}.btn.btn-white:not([disabled]):not(.disabled).active-info.active+.btn,.btn.btn-white:not([disabled]):not(.disabled).active-info:active+.btn{border-left:1px solid red}.btn.btn-white:not([disabled]):not(.disabled).active-warning.active,.btn.btn-white:not([disabled]):not(.disabled).active-warning:active{background-color:#ffb400;border-color:#ffb400;color:#212529}.btn.btn-white:not([disabled]):not(.disabled).active-warning.active+.btn,.btn.btn-white:not([disabled]):not(.disabled).active-warning:active+.btn{border-left:1px solid red}.btn.btn-white:not([disabled]):not(.disabled).active-danger.active,.btn.btn-white:not([disabled]):not(.disabled).active-danger:active{background-color:#c4183c;border-color:#c4183c;color:#fff}.btn.btn-white:not([disabled]):not(.disabled).active-danger.active+.btn,.btn.btn-white:not([disabled]):not(.disabled).active-danger:active+.btn{border-left:1px solid red}.btn.btn-white:not([disabled]):not(.disabled).active-light.active,.btn.btn-white:not([disabled]):not(.disabled).active-light:active{background-color:#fbfbfb;border-color:#fbfbfb;color:#212529}.btn.btn-white:not([disabled]):not(.disabled).active-light.active+.btn,.btn.btn-white:not([disabled]):not(.disabled).active-light:active+.btn{border-left:1px solid red}.btn.btn-white:not([disabled]):not(.disabled).active-dark.active,.btn.btn-white:not([disabled]):not(.disabled).active-dark:active{background-color:#212529;border-color:#212529;color:#fff}.btn.btn-white:not([disabled]):not(.disabled).active-dark.active+.btn,.btn.btn-white:not([disabled]):not(.disabled).active-dark:active+.btn{border-left:1px solid red}.btn.btn-white:not([disabled]):not(.disabled).active-salmon.active,.btn.btn-white:not([disabled]):not(.disabled).active-salmon:active{background-color:#ff4169;border-color:#ff4169;color:#fff}.btn.btn-white:not([disabled]):not(.disabled).active-salmon.active+.btn,.btn.btn-white:not([disabled]):not(.disabled).active-salmon:active+.btn{border-left:1px solid red}.btn.btn-white:not([disabled]):not(.disabled).active-royal-blue.active,.btn.btn-white:not([disabled]):not(.disabled).active-royal-blue:active{background-color:#674eec;border-color:#674eec;color:#fff}.btn.btn-white:not([disabled]):not(.disabled).active-royal-blue.active+.btn,.btn.btn-white:not([disabled]):not(.disabled).active-royal-blue:active+.btn{border-left:1px solid red}.btn.btn-white:not([disabled]):not(.disabled).active-java.active,.btn.btn-white:not([disabled]):not(.disabled).active-java:active{background-color:#1adba2;border-color:#1adba2;color:#212529}.btn.btn-white:not([disabled]):not(.disabled).active-java.active+.btn,.btn.btn-white:not([disabled]):not(.disabled).active-java:active+.btn{border-left:1px solid red}.btn-salmon{color:#fff;border-color:#ff4169;background-color:#ff4169;box-shadow:none}.btn-salmon:hover{color:#fff;background-color:#ff2855;border-color:#ff2855;box-shadow:0 5px 15px rgba(0,0,0,.05),0 4px 10px rgba(255,65,105,.25)}.btn-salmon.focus,.btn-salmon:focus{box-shadow:0 0 0 3px rgba(255,65,105,.15),0 3px 15px rgba(255,65,105,.2),0 2px 5px rgba(0,0,0,.1)}.btn-salmon.disabled,.btn-salmon:disabled{background-color:#ff4169;border-color:#ff4169;box-shadow:none;cursor:not-allowed}.btn-salmon:not(:disabled):not(.disabled).active,.btn-salmon:not(:disabled):not(.disabled):active,.show>.btn-salmon.dropdown-toggle{color:#fff;background-color:#ff2855;border-color:#ff0e41;background-image:none;box-shadow:inset 0 3px 5px rgba(0,0,0,.125)!important}.btn-royal-blue{color:#fff;border-color:#674eec;background-color:#674eec;box-shadow:none}.btn-royal-blue:hover{color:#fff;background-color:#5337ea;border-color:#5337ea;box-shadow:0 5px 15px rgba(0,0,0,.05),0 4px 10px rgba(103,78,236,.25)}.btn-royal-blue.focus,.btn-royal-blue:focus{box-shadow:0 0 0 3px rgba(103,78,236,.15),0 3px 15px rgba(103,78,236,.2),0 2px 5px rgba(0,0,0,.1)}.btn-royal-blue.disabled,.btn-royal-blue:disabled{background-color:#674eec;border-color:#674eec;box-shadow:none;cursor:not-allowed}.btn-royal-blue:not(:disabled):not(.disabled).active,.btn-royal-blue:not(:disabled):not(.disabled):active,.show>.btn-royal-blue.dropdown-toggle{color:#fff;background-color:#5337ea;border-color:#3f20e7;background-image:none;box-shadow:inset 0 3px 5px rgba(0,0,0,.125)!important}.btn-java{color:#212529;border-color:#1adba2;background-color:#1adba2;box-shadow:none}.btn-java:hover{color:#fff;background-color:#17c491;border-color:#17c491;box-shadow:0 5px 15px rgba(0,0,0,.05),0 4px 10px rgba(26,219,162,.25)}.btn-java.focus,.btn-java:focus{box-shadow:0 0 0 3px rgba(26,219,162,.15),0 3px 15px rgba(26,219,162,.2),0 2px 5px rgba(0,0,0,.1)}.btn-java.disabled,.btn-java:disabled{background-color:#1adba2;border-color:#1adba2;box-shadow:none;cursor:not-allowed}.btn-java:not(:disabled):not(.disabled).active,.btn-java:not(:disabled):not(.disabled):active,.show>.btn-java.dropdown-toggle{color:#fff;background-color:#17c491;border-color:#15ad80;background-image:none;box-shadow:inset 0 3px 5px rgba(0,0,0,.125)!important}.btn-accent{color:#fff;border-color:#007bff;background-color:#007bff;box-shadow:none}.btn-accent:hover{color:#fff;background-color:#006fe6;border-color:#006fe6;box-shadow:0 5px 15px rgba(0,0,0,.05),0 4px 10px rgba(0,123,255,.25)}.btn-accent.focus,.btn-accent:focus{box-shadow:0 0 0 3px rgba(0,123,255,.15),0 3px 15px rgba(0,123,255,.2),0 2px 5px rgba(0,0,0,.1)}.btn-accent.disabled,.btn-accent:disabled{background-color:#007bff;border-color:#007bff;box-shadow:none;cursor:not-allowed}.btn-accent:not(:disabled):not(.disabled).active,.btn-accent:not(:disabled):not(.disabled):active,.show>.btn-accent.dropdown-toggle{color:#fff;background-color:#006fe6;border-color:#0062cc;background-image:none;box-shadow:inset 0 3px 5px rgba(0,0,0,.125)!important}.btn-outline-salmon{background-color:transparent;background-image:none;border-color:#ff4169;color:#ff4169}.btn-outline-salmon:hover{color:#fff;background-color:#ff4169;border-color:#ff4169;box-shadow:0 5px 15px rgba(0,0,0,.05),0 4px 10px rgba(255,65,105,.25)}.btn-outline-salmon.focus,.btn-outline-salmon:focus{box-shadow:0 0 0 3px rgba(255,65,105,.15),0 3px 15px rgba(255,65,105,.2),0 2px 5px rgba(0,0,0,.1)!important}.btn-outline-salmon.disabled,.btn-outline-salmon:disabled{color:#ff4169;background-color:transparent;box-shadow:none}.btn-outline-salmon:not(:disabled):not(.disabled).active,.btn-outline-salmon:not(:disabled):not(.disabled):active,.show>.btn-outline-salmon.dropdown-toggle{color:#fff;background-color:#ff4169;border-color:#ff4169}.btn-outline-salmon:not(:disabled):not(.disabled).active:focus,.btn-outline-salmon:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-salmon.dropdown-toggle:focus{box-shadow:inset 0 3px 5px rgba(0,0,0,.125)!important}.btn-outline-royal-blue{background-color:transparent;background-image:none;border-color:#674eec;color:#674eec}.btn-outline-royal-blue:hover{color:#fff;background-color:#674eec;border-color:#674eec;box-shadow:0 5px 15px rgba(0,0,0,.05),0 4px 10px rgba(103,78,236,.25)}.btn-outline-royal-blue.focus,.btn-outline-royal-blue:focus{box-shadow:0 0 0 3px rgba(103,78,236,.15),0 3px 15px rgba(103,78,236,.2),0 2px 5px rgba(0,0,0,.1)!important}.btn-outline-royal-blue.disabled,.btn-outline-royal-blue:disabled{color:#674eec;background-color:transparent;box-shadow:none}.btn-outline-royal-blue:not(:disabled):not(.disabled).active,.btn-outline-royal-blue:not(:disabled):not(.disabled):active,.show>.btn-outline-royal-blue.dropdown-toggle{color:#fff;background-color:#674eec;border-color:#674eec}.btn-outline-royal-blue:not(:disabled):not(.disabled).active:focus,.btn-outline-royal-blue:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-royal-blue.dropdown-toggle:focus{box-shadow:inset 0 3px 5px rgba(0,0,0,.125)!important}.btn-outline-java{background-color:transparent;background-image:none;border-color:#1adba2;color:#1adba2}.btn-outline-java:hover{color:#212529;background-color:#1adba2;border-color:#1adba2;box-shadow:0 5px 15px rgba(0,0,0,.05),0 4px 10px rgba(26,219,162,.25)}.btn-outline-java.focus,.btn-outline-java:focus{box-shadow:0 0 0 3px rgba(26,219,162,.15),0 3px 15px rgba(26,219,162,.2),0 2px 5px rgba(0,0,0,.1)!important}.btn-outline-java.disabled,.btn-outline-java:disabled{color:#1adba2;background-color:transparent;box-shadow:none}.btn-outline-java:not(:disabled):not(.disabled).active,.btn-outline-java:not(:disabled):not(.disabled):active,.show>.btn-outline-java.dropdown-toggle{color:#212529;background-color:#1adba2;border-color:#1adba2}.btn-outline-java:not(:disabled):not(.disabled).active:focus,.btn-outline-java:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-java.dropdown-toggle:focus{box-shadow:inset 0 3px 5px rgba(0,0,0,.125)!important}.btn-outline-accent{background-color:transparent;background-image:none;border-color:#007bff;color:#007bff}.btn-outline-accent:hover{color:#fff;background-color:#007bff;border-color:#007bff;box-shadow:0 5px 15px rgba(0,0,0,.05),0 4px 10px rgba(0,123,255,.25)}.btn-outline-accent.focus,.btn-outline-accent:focus{box-shadow:0 0 0 3px rgba(0,123,255,.15),0 3px 15px rgba(0,123,255,.2),0 2px 5px rgba(0,0,0,.1)!important}.btn-outline-accent.disabled,.btn-outline-accent:disabled{color:#007bff;background-color:transparent;box-shadow:none;cursor:not-allowed}.btn-outline-accent:not(:disabled):not(.disabled).active,.btn-outline-accent:not(:disabled):not(.disabled):active,.show>.btn-outline-accent.dropdown-toggle{color:#fff;background-color:#007bff;border-color:#007bff}.btn-outline-accent:not(:disabled):not(.disabled).active:focus,.btn-outline-accent:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-accent.dropdown-toggle:focus{box-shadow:inset 0 3px 5px rgba(0,0,0,.125)!important}.btn-group-sm i{-webkit-transform:scale(1.3);transform:scale(1.3)}.navbar-light .navbar-brand{font-weight:500;color:#3d5170}.nav-link{font-size:.8125rem;font-weight:400}.nav-link-icon{color:#818ea3}.nav-link-icon:focus,.nav-link-icon:hover{color:#66748b}.nav-link-icon__wrapper{position:relative}.nav-link-icon i{font-size:1.25rem}.nav-link-icon i.material-icons{font-size:1.5625rem}.badge-salmon{color:#fff;background-color:#ff4169}.badge-salmon[href]:focus,.badge-salmon[href]:hover{color:#fff;text-decoration:none;background-color:#ff0e41}.badge-outline-salmon{background:0 0;border:1px solid #ff4169;color:#ff4169}.badge-royal-blue{color:#fff;background-color:#674eec}.badge-royal-blue[href]:focus,.badge-royal-blue[href]:hover{color:#fff;text-decoration:none;background-color:#3f20e7}.badge-outline-royal-blue{background:0 0;border:1px solid #674eec;color:#674eec}.badge-java{color:#212529;background-color:#1adba2}.badge-java[href]:focus,.badge-java[href]:hover{color:#212529;text-decoration:none;background-color:#15ad80}.badge-outline-java{background:0 0;border:1px solid #1adba2;color:#1adba2}.badge-accent{color:#fff;background-color:#007bff}.badge-accent[href]:focus,.badge-accent[href]:hover{color:#fff;text-decoration:none;background-color:#0062cc}.badge-outline-accent{background:0 0;border:1px solid #007bff;color:#007bff}.alert-salmon{color:#fff;background-color:#ff4169}.alert-salmon .alert-link{color:#fff}.alert-royal-blue{color:#fff;background-color:#674eec}.alert-royal-blue .alert-link{color:#fff}.alert-java{color:#edfdf8;background-color:#1adba2}.alert-java .alert-link{color:#edfdf8}.alert-accent{color:#f5faff;background-color:#007bff}.alert-accent .alert-link{color:#f5faff}.alert-dismissible .close{padding-top:.5rem;padding-bottom:.5rem}.input-group{min-width:7.5rem}.input-group-text{font-size:.8125rem}.input-group.input-group-seamless>.custom-select:not(:first-child),.input-group.input-group-seamless>.form-control:not(:first-child){padding-left:1.875rem}.input-group-text i{-webkit-transform:scale(1.1);transform:scale(1.1)}.input-group-text i.fa{font-size:.75rem}.input-group-text i.material-icons{top:0;font-size:.8125rem}.custom-select-sm{font-size:.6875rem;border-radius:.25rem}.custom-select-lg{border-radius:.25rem}.custom-control{line-height:1.5rem}.custom-checkbox .custom-control-input:disabled:checked~.custom-control-label::after{border-color:#becad6}.custom-radio .custom-control-input:disabled:checked~.custom-control-label::after,.custom-toggle .custom-control-input:checked:disabled~.custom-control-label::after{background:#becad6}.slider-salmon .noUi-connect{background:#ff4169}.slider-royal-blue .noUi-connect{background:#674eec}.slider-java .noUi-connect{background:#1adba2}.slider-accent .noUi-connect{background:#007bff}.noUi-pips{font-size:.625rem}.noUi-tooltip{font-size:.75rem;padding:5px 10px}.noUi-horizontal .noUi-handle{left:-.625rem;top:-.5rem}.noUi-handle{width:23px;height:23px}.sc-legend-container{padding:10px 30px 7px;margin:0}.sc-legend-container li{display:inline-block;margin-right:.75rem;font-size:12px;color:#818ea3}.sc-legend{position:relative;padding-left:25px}.sc-legend__label{position:absolute;width:20px;border-radius:10px;height:2px;left:0;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%)}div[class^=sc-tooltip-]{background:#fff;border-radius:7px;font-size:11px;opacity:1;position:absolute;-webkit-transition:.1s;transition:.1s;-webkit-transform:translate(-50%,0);transform:translate(-50%,0);padding:5px 10px;box-shadow:0 2px 0 rgba(90,97,105,.11),0 4px 8px rgba(90,97,105,.12),0 10px 10px rgba(90,97,105,.06),0 7px 70px rgba(90,97,105,.1);pointer-events:none;min-width:120px;white-space:nowrap}div[class^=sc-tooltip-] thead{text-align:center}div[class^=sc-tooltip-] thead tr th{font-weight:500}.sc-tooltip-key{display:inline-block;width:10px;height:10px;margin-right:10px}.thumbnail{border:1px solid #d4d4d4}.dropdown .fa,.dropdown .material-icons{color:#c3c7cc;margin-right:.25rem}.dropdown .dropdown-item:hover{background-color:#fafafb}.card-header{position:relative}.card-header h1,.card-header h2,.card-header h3,.card-header h4,.card-header h5,.card-header h6{font-weight:500}.card-header .block-handle{position:absolute;background-image:url(data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjMDAwMDAwIiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+ICAgIDxkZWZzPiAgICAgICAgPHBhdGggZD0iTTAgMGgyNHYyNEgwVjB6IiBpZD0iYSIvPiAgICA8L2RlZnM+ICAgIDxjbGlwUGF0aCBpZD0iYiI+ICAgICAgICA8dXNlIG92ZXJmbG93PSJ2aXNpYmxlIiB4bGluazpocmVmPSIjYSIvPiAgICA8L2NsaXBQYXRoPiAgICA8cGF0aCBjbGlwLXBhdGg9InVybCgjYikiIGQ9Ik0yMCA5SDR2MmgxNlY5ek00IDE1aDE2di0ySDR2MnoiLz48L3N2Zz4=);background-position:center center;background-size:95%;width:1.125rem;height:.5rem;top:50%;right:.9375rem;-webkit-transform:translateY(-50%);transform:translateY(-50%);opacity:.15}.card-header .block-handle:hover{cursor:-webkit-grab}.card .view-report{margin-top:auto;margin-bottom:auto;font-size:.75rem}.card .view-report a{color:#3d5170}.card .view-report a:hover{color:#007bff}.overflow-hidden{overflow:hidden}.overflow-visible{overflow:visible}.overflow-scroll{overflow:scroll}.overflow-auto{overflow:auto}.no-shadow{box-shadow:none!important}.bg-salmon{background-color:#ff4169!important}.bg-salmon.card .card-body,.bg-salmon.card .card-footer,.bg-salmon.card .card-header,.bg-salmon.card .card-title{background-color:#ff0e41!important}.bg-salmon.card .card-footer,.bg-salmon.card .card-header{background:#ff325d}a.bg-salmon:focus,a.bg-salmon:hover{background-color:#ff0e41!important}.bg-royal-blue{background-color:#674eec!important}.bg-royal-blue.card .card-body,.bg-royal-blue.card .card-footer,.bg-royal-blue.card .card-header,.bg-royal-blue.card .card-title{background-color:#3f20e7!important}.bg-royal-blue.card .card-footer,.bg-royal-blue.card .card-header{background:#5b40eb}a.bg-royal-blue:focus,a.bg-royal-blue:hover{background-color:#3f20e7!important}.bg-java{background-color:#1adba2!important}.bg-java.card .card-body,.bg-java.card .card-footer,.bg-java.card .card-header,.bg-java.card .card-title{background-color:#15ad80!important}.bg-java.card .card-footer,.bg-java.card .card-header{background:#18cd98}a.bg-java:focus,a.bg-java:hover{background-color:#15ad80!important}.text-salmon{color:#ff4169!important}a.text-salmon:focus,a.text-salmon:hover{color:#ff0e41!important}.text-royal-blue{color:#674eec!important}a.text-royal-blue:focus,a.text-royal-blue:hover{color:#3f20e7!important}.text-java{color:#1adba2!important}a.text-java:focus,a.text-java:hover{color:#15ad80!important}.text-fiord-blue{color:#3d5170!important}a.text-fiord-blue:focus,a.text-fiord-blue:hover{color:#2b394f!important}.text-shuttle-gray{color:#5a6169!important}a.text-shuttle-gray:focus,a.text-shuttle-gray:hover{color:#42484e!important}.text-reagent-gray{color:#818ea3!important}a.text-reagent-gray:focus,a.text-reagent-gray:hover{color:#66748b!important}.text-mischka{color:#cacedb!important}a.text-mischka:focus,a.text-mischka:hover{color:#acb2c6!important}.text-athens-gray{color:#e9ecef!important}a.text-athens-gray:focus,a.text-athens-gray:hover{color:#cbd3da!important}.text-accent{color:#007bff!important}a.text-accent:focus,a.text-accent:hover{color:#0062cc!important}.text-light{color:#818ea3!important}.text-semibold{font-weight:400}.rounded{border-radius:5px!important}.rounded-top{border-top-left-radius:5px!important;border-top-right-radius:5px!important}.rounded-right{border-top-right-radius:5px!important;border-bottom-right-radius:5px!important}.rounded-bottom{border-bottom-right-radius:5px!important;border-bottom-left-radius:5px!important}.rounded-left{border-top-left-radius:5px!important;border-bottom-left-radius:5px!important}.border-salmon{border-color:#ff4169!important}.border-royal-blue{border-color:#674eec!important}.border-java{border-color:#1adba2!important}.border-accent{border-color:#007bff!important}.dataTables_wrapper{background:#fff;border-radius:.375rem}.dataTables_wrapper::after{display:block;clear:both;content:""}.dataTables_wrapper table.dataTable{border-top:1px solid #e1e5eb;font-size:.8125rem;display:table!important;width:100%!important}.dataTables_wrapper table.dataTable thead tr:last-child th{padding-right:1.7rem}.dataTables_wrapper table.dataTable thead th{text-align:center;background-color:#fbfbfb;border:1px solid #e1e5eb;font-weight:400;padding:.75rem 1.0625rem}.dataTables_wrapper table.dataTable thead th:focus{outline:0}.dataTables_wrapper table.dataTable thead th:first-child{border-left:none}.dataTables_wrapper table.dataTable thead th:last-child{border-right:none}.dataTables_wrapper table.dataTable thead th.hide-sort-icons:after{display:none}.dataTables_wrapper table.dataTable thead th.sorting,.dataTables_wrapper table.dataTable thead th.sorting_asc,.dataTables_wrapper table.dataTable thead th.sorting_desc{position:relative}.dataTables_wrapper table.dataTable thead th.sorting:after,.dataTables_wrapper table.dataTable thead th.sorting_asc:after,.dataTables_wrapper table.dataTable thead th.sorting_desc:after{content:"";position:absolute;background-position:center;right:7px;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%);opacity:.2}.dataTables_wrapper table.dataTable thead th.sorting:after{width:10px;height:13px;background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIHdpZHRoPSIxMHB4IiBoZWlnaHQ9IjEzcHgiIHZpZXdCb3g9IjAgMCAxMCAxMyIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj4gICAgICAgIDx0aXRsZT5pY19hcnJvd19kcm9wX2Rvd25fYmxhY2tfMjRweDwvdGl0bGU+ICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPiAgICA8ZGVmcz48L2RlZnM+ICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPiAgICAgICAgPGcgaWQ9ImljX2Fycm93X2Ryb3BfZG93bl9ibGFja18yNHB4LSgxKSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTcuMDAwMDAwLCAtMi4wMDAwMDApIiBmaWxsPSIjMDAwMDAwIiBmaWxsLXJ1bGU9Im5vbnplcm8iPiAgICAgICAgICAgIDxnIGlkPSJpY19hcnJvd19kcm9wX2Rvd25fYmxhY2tfMjRweCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTIuMDAwMDAwLCA4LjUwMDAwMCkgcm90YXRlKC0xODAuMDAwMDAwKSB0cmFuc2xhdGUoLTEyLjAwMDAwMCwgLTguNTAwMDAwKSB0cmFuc2xhdGUoNy4wMDAwMDAsIDIuMDAwMDAwKSI+ICAgICAgICAgICAgICAgIDxwb2x5Z29uIGlkPSJTaGFwZSIgcG9pbnRzPSIxLjQyMTA4NTQ3ZS0xNCA4IDUgMTMgMTAgOCI+PC9wb2x5Z29uPiAgICAgICAgICAgICAgICA8cG9seWdvbiBpZD0iU2hhcGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDUuMDAwMDAwLCAzLjMzMzg5Nykgcm90YXRlKC0xODAuMDAwMDAwKSB0cmFuc2xhdGUoLTUuMDAwMDAwLCAtMy4zMzM4OTcpICIgcG9pbnRzPSIxLjQyMTA4NTQ3ZS0xNCAwLjgzMzg5NjkyMiA1IDUuODMzODk2OTIgMTAgMC44MzM4OTY5MjIiPjwvcG9seWdvbj4gICAgICAgICAgICA8L2c+ICAgICAgICA8L2c+ICAgIDwvZz48L3N2Zz4=);background-size:90%}.dataTables_wrapper table.dataTable thead th.sorting_asc:after{width:10px;height:6px;background-image:url(data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjMDAwMDAwIiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4gICAgPHBhdGggZD0iTTcgMTRsNS01IDUgNXoiLz4gICAgPHBhdGggZD0iTTAgMGgyNHYyNEgweiIgZmlsbD0ibm9uZSIvPjwvc3ZnPg==)}.dataTables_wrapper table.dataTable thead th.sorting_desc:after{width:10px;height:6px;background-image:url(data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjMDAwMDAwIiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4gICAgPHBhdGggZD0iTTcgMTBsNSA1IDUtNXoiLz4gICAgPHBhdGggZD0iTTAgMGgyNHYyNEgweiIgZmlsbD0ibm9uZSIvPjwvc3ZnPg==)}.dataTables_wrapper table.dataTable tbody td{padding:.4375rem 1.0625rem;border:1px solid #e1e5eb;text-align:center}.dataTables_wrapper table.dataTable tbody td:first-child{border-left:none}.dataTables_wrapper table.dataTable tbody td::last-child{border-right:none}.dataTables_wrapper table.dataTable tbody td.dataTables_empty{padding:.8125rem 1.0625rem}.dataTables_wrapper table.dataTable td.child{padding:0!important}.dataTables_wrapper table.dataTable td.child ul{width:100%}.dataTables_wrapper table.dataTable td.child ul li{padding:1rem!important;display:-webkit-box;display:flex}.dataTables_wrapper table.dataTable td.child ul li::after{display:block;clear:both;content:""}.dataTables_wrapper table.dataTable td.child .dtr-title{float:left;text-align:left;margin:auto 0}.dataTables_wrapper table.dataTable td.child .dtr-data{margin-left:auto}.dataTables_wrapper table.dataTable.dtr-inline.collapsed tbody>tr[role=row]>td:first-child:before,.dataTables_wrapper table.dataTable.dtr-inline.collapsed tbody>tr[role=row]>th:first-child:before{box-shadow:none;text-align:center;width:1.25rem;height:1.25rem;line-height:22px;font-size:1rem;left:0;top:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);font-weight:700;box-shadow:0 2px 0 rgba(90,97,105,.11),0 4px 8px rgba(90,97,105,.12),0 10px 10px rgba(90,97,105,.06),0 7px 70px rgba(90,97,105,.1)}.dataTables_filter,.dataTables_info,.dataTables_length,.dataTables_paginate{width:50%;float:left;font-size:13px;padding:15px 20px;color:#818ea3}.dataTables_filter label,.dataTables_info label,.dataTables_length label,.dataTables_paginate label{margin:0}.dataTables_info,.dataTables_paginate{padding:20px;background:#fbfbfb;border-radius:0 0 .375rem .375rem}.dataTables_length select{border:1px solid #e1e5eb;font-size:.625rem;color:#818ea3;height:1.5625rem;background-color:#fff;border-radius:.375rem;margin:0 .1875rem}.dataTables_paginate{text-align:right}.dataTables_paginate .ellipsis,.dataTables_paginate .paginate_button{background:#fff;padding:.4286rem .875rem;border:1px solid #e1e5eb}.dataTables_paginate .paginate_button{border-radius:.25rem;color:#3d5170;will-change:background-color,color,border-color;-webkit-transition:background-color 250ms ease-in-out,color 250ms ease-in-out,border-color 250ms ease-in-out;transition:background-color 250ms ease-in-out,color 250ms ease-in-out,border-color 250ms ease-in-out}.dataTables_paginate .paginate_button:hover{cursor:pointer;text-decoration:none}.dataTables_paginate .paginate_button.current,.dataTables_paginate .paginate_button:not(.disabled):hover{background:#007bff;color:#fff;border-color:#007bff}.dataTables_paginate .paginate_button:focus{outline:0}.dataTables_paginate .paginate_button.disabled{background-color:#f2f4f5}.dataTables_paginate .paginate_button.disabled:hover{cursor:not-allowed}.dataTables_paginate .paginate_button.previous{border-top-right-radius:0;border-bottom-right-radius:0}.dataTables_paginate .paginate_button.next{border-top-left-radius:0;border-bottom-left-radius:0}.dataTables_paginate .ellipsis{border-left:none}.dataTables_paginate span>.paginate_button{border-radius:0;border-left:0}.dataTables_paginate span>.paginate_button:hover{border-color:#007bff}.dataTables_paginate span>.paginate_button:last-child{border-right:0}.dataTables_filter{padding:.625rem}.dataTables_filter label{float:right;font-size:0}.dataTables_filter input{font-size:.75rem;line-height:1.5;color:#495057;background-color:#fff;border:1px solid #e1e5eb;font-weight:300;border-radius:.25rem;margin-left:.3125rem;padding:.4375rem .625rem .4375rem 1.75rem;min-width:11.25rem;background-image:url(data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjQ0FDRURCIiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4gICAgPHBhdGggZD0iTTE1LjUgMTRoLS43OWwtLjI4LS4yN0MxNS40MSAxMi41OSAxNiAxMS4xMSAxNiA5LjUgMTYgNS45MSAxMy4wOSAzIDkuNSAzUzMgNS45MSAzIDkuNSA1LjkxIDE2IDkuNSAxNmMxLjYxIDAgMy4wOS0uNTkgNC4yMy0xLjU3bC4yNy4yOHYuNzlsNSA0Ljk5TDIwLjQ5IDE5bC00Ljk5LTV6bS02IDBDNy4wMSAxNCA1IDExLjk5IDUgOS41UzcuMDEgNSA5LjUgNSAxNCA3LjAxIDE0IDkuNSAxMS45OSAxNCA5LjUgMTR6Ii8+ICAgIDxwYXRoIGQ9Ik0wIDBoMjR2MjRIMHoiIGZpbGw9Im5vbmUiLz48L3N2Zz4=);background-position:left 7px center;background-repeat:no-repeat;background-size:10%;will-change:border-color,box-shadow;box-shadow:none;-webkit-transition:box-shadow 250ms cubic-bezier(.27,.01,.38,1.06),border 250ms cubic-bezier(.27,.01,.38,1.06);transition:box-shadow 250ms cubic-bezier(.27,.01,.38,1.06),border 250ms cubic-bezier(.27,.01,.38,1.06)}.dataTables_filter input:hover{border-color:#b3bdcc}.dataTables_filter input:focus{color:#495057;background-color:#fff;border-color:#007bff;box-shadow:0 .313rem .719rem rgba(0,123,255,.1),0 .156rem .125rem rgba(0,0,0,.06);outline:0}.dataTables_filter input:focus:hover{border-color:#007bff}.dataTables_filter input::-webkit-input-placeholder{color:#868e96}.dataTables_filter input::-ms-input-placeholder{color:#868e96}.dataTables_filter input::-moz-placeholder{color:#868e96}.dataTables_filter input:-ms-input-placeholder{color:#868e96}.dataTables_filter input::placeholder{color:#868e96}.dropzone{color:#818ea3}.dropzone.dz-drag-hover .dz-default{background:#fff;border-color:#cbd3da}.dropzone .dz-default{text-align:center;border:1px dashed #dadfe4;padding:.75rem;position:relative;border-radius:.375rem;will-change:border-color,background;-webkit-transition:border-color 250ms ease-in-out,background 250ms ease-in-out;transition:border-color 250ms ease-in-out,background 250ms ease-in-out}.dropzone .dz-default:hover{cursor:pointer}.dropzone .dz-default+.dz-preview{margin-top:.75rem}.dropzone .dz-preview{width:100%;border:1px solid #e9ecef;border-radius:.375rem;background:#fff;box-shadow:0 1px 1px #e9ecef;padding:.75rem;display:-webkit-box;display:flex;-webkit-box-pack:justify;justify-content:space-between}.dropzone .dz-preview+.dz-preview{margin-top:.75rem}.dropzone .dz-preview .dz-image{max-width:50px;border-radius:.375rem;overflow:hidden;margin-right:20px}.dropzone .dz-preview .dz-image img{width:100%}.dropzone .dz-preview .dz-details,.dropzone .dz-preview .dz-error-message{-webkit-box-pack:center;justify-content:center;display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:reverse;flex-direction:column-reverse}.dropzone .dz-preview .dz-details{margin-right:3rem;-webkit-box-flex:2;flex:2}.dropzone .dz-preview .dz-filename{font-weight:500;color:#3d5170;font-size:.875rem}.dropzone .dz-preview .dz-size{font-size:80%;color:#818ea3}.dropzone .dz-preview .dz-error-message span{background-color:#c4183c;color:#fff;padding:5px 12px;border-radius:5px;font-size:12px}.dropzone .dz-preview .dz-error-mark svg,.dropzone .dz-preview .dz-success-mark svg,.dropzone .dz-preview.dz-error .dz-success-mark{display:none}.bootstrap-tagsinput{padding:.4375rem .375rem;line-height:1.5;color:#495057;background-color:#fff;border:1px solid #e1e5eb;border-radius:.25rem;-webkit-transition:box-shadow 250ms cubic-bezier(.27,.01,.38,1.06),border 250ms cubic-bezier(.27,.01,.38,1.06);transition:box-shadow 250ms cubic-bezier(.27,.01,.38,1.06),border 250ms cubic-bezier(.27,.01,.38,1.06)}.bootstrap-tagsinput.focus{color:#495057;background-color:#fff;border-color:#007bff;box-shadow:0 .313rem .719rem rgba(0,123,255,.1),0 .156rem .125rem rgba(0,0,0,.06)}.bootstrap-tagsinput>input{border:none;padding:0}.bootstrap-tagsinput>input:focus{outline:0}.bootstrap-tagsinput .tag{display:inline-block;background:#fbfbfb;padding:.125rem 1.375rem .125rem .625rem;margin-bottom:.3125rem;border-radius:1.25rem;font-size:.6875rem;position:relative;text-transform:uppercase;border:1px solid #e1e5eb;color:#818ea3}.bootstrap-tagsinput .tag>span{position:absolute;background-image:url(data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjMDAwMDAwIiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4gICAgPHBhdGggZD0iTTE5IDYuNDFMMTcuNTkgNSAxMiAxMC41OSA2LjQxIDUgNSA2LjQxIDEwLjU5IDEyIDUgMTcuNTkgNi40MSAxOSAxMiAxMy40MSAxNy41OSAxOSAxOSAxNy41OSAxMy40MSAxMnoiLz4gICAgPHBhdGggZD0iTTAgMGgyNHYyNEgweiIgZmlsbD0ibm9uZSIvPjwvc3ZnPg==);right:.5rem;top:50%;width:.625rem;height:.625rem;background-repeat:no-repeat;background-position:center center;-webkit-transform:translateY(-50%);transform:translateY(-50%);background-size:100%;opacity:.5}.bootstrap-tagsinput .tag>span:hover{cursor:pointer}html .ql-container.ql-snow,html .ql-toolbar.ql-snow{border-color:#e1e5eb}html .ql-container{border-bottom-left-radius:.25rem;border-bottom-right-radius:.25rem}html .ql-editor b,html .ql-editor strong{font-weight:600}html .ql-toolbar{border-top-left-radius:.25rem;border-top-right-radius:.25rem;color:#3d5170!important}html .ql-toolbar .ql-fill,html .ql-toolbar .ql-stroke.ql-fill{fill:#818ea3}html .ql-toolbar .ql-stroke{stroke:#818ea3}html .ql-toolbar button:active .ql-fill,html .ql-toolbar button:active .ql-stroke.ql-fill,html .ql-toolbar button:focus .ql-fill,html .ql-toolbar button:focus .ql-stroke.ql-fill,html .ql-toolbar button:hover .ql-fill,html .ql-toolbar button:hover .ql-stroke.ql-fill{fill:#007bff!important}html .ql-toolbar button:active .ql-stroke,html .ql-toolbar button:focus .ql-stroke,html .ql-toolbar button:hover .ql-stroke{stroke:#007bff!important}html .ql-toolbar .ql-picker .ql-picker-item:hover{color:#007bff!important}html .ql-toolbar .ql-picker .ql-picker-options{padding:6px 20px;border:0!important;box-shadow:0 .46875rem 2.1875rem rgba(90,97,105,.1),0 .9375rem 1.40625rem rgba(90,97,105,.1),0 .25rem .53125rem rgba(90,97,105,.12),0 .125rem .1875rem rgba(90,97,105,.1);border-radius:.375rem}.fc .fc-toolbar h2{text-transform:uppercase;font-size:.875rem;font-weight:400;letter-spacing:1px;color:#b9c2cd}.fc .fc-divider,.fc .fc-list-heading td,.fc .fc-popover .fc-header{background:#fafbfc!important}.fc .fc-day-header{padding:.5rem 0}.fc .fc-content,.fc .fc-divider,.fc .fc-list-heading td,.fc .fc-list-view,.fc .fc-popover,.fc .fc-row,.fc .fc-view td,.fc .fc-view th,.fc tbody,.fc td,.fc th,.fc thead{border-color:#ededed!important}.fc .fc-day-top .fc-day-number{padding:.625rem .75rem}.fc .fc-event,.fc .fc-event-dot{background:#007bff;border-color:#007bff}.fc .fc-time,.fc .fc-title{color:#fff;margin-left:3px}.fc td.fc-today{background:#fff3e8!important}.fc button.fc-button{background:#fff;box-shadow:none;border-color:#e1e5eb;padding:7px 11px;height:auto;font-size:.6875rem;-webkit-transition:250ms cubic-bezier(.27,.01,.38,1.06);transition:250ms cubic-bezier(.27,.01,.38,1.06)}.fc button.fc-button:focus{outline:0}.fc button.fc-button:hover{box-shadow:0 .125rem .625rem rgba(129,142,163,.2),0 .0625rem .125rem rgba(129,142,163,.3)}.fc .fc-day-grid-event{padding:3px 1px}.main-navbar .navbar{height:3.75rem}.main-navbar .navbar>*{display:-webkit-box;display:flex}.main-navbar .navbar .nav-link{min-width:3.75rem}.main-navbar .navbar .notifications{position:relative}.main-navbar .navbar .notifications .badge{position:absolute;padding:.25rem .375rem;font-size:.5rem;left:50%;top:50%}.main-navbar .navbar .notifications .dropdown-menu{padding:0;min-width:25rem;border-right:0;left:auto}.main-navbar .navbar .notifications .dropdown-menu .dropdown-item{white-space:normal;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-flow:row;padding-top:.625rem;padding-bottom:.625rem;border-bottom:1px solid #e1e5eb}.main-navbar .navbar .notifications .dropdown-menu .dropdown-item:last-child{border-bottom:0}.main-navbar .navbar .notifications .dropdown-menu .notification__icon-wrapper{display:-webkit-box;display:flex;padding:0 5px}.main-navbar .navbar .notifications .dropdown-menu .notification__icon{background-color:#f5f6f8;box-shadow:0 0 0 1px #fff,inset 0 0 3px rgba(0,0,0,.2);width:2.1875rem;height:2.1875rem;line-height:0;display:block;text-align:center;margin:auto;border-radius:50%}.main-navbar .navbar .notifications .dropdown-menu .notification__icon i{color:#818ea3;line-height:2.0625rem;font-size:1.0625rem;margin:0}.main-navbar .navbar .notifications .dropdown-menu .notification__content{padding:0 .625rem}.main-navbar .navbar .notifications .dropdown-menu .notification__content p{margin:0;line-height:1.5;font-size:.75rem}.main-navbar .navbar .notifications .dropdown-menu .notification__category{font-size:.5625rem;color:#818ea3;letter-spacing:.0938rem;display:inline-block;text-transform:uppercase;margin-bottom:5px;font-weight:500}.main-navbar .navbar .notifications .dropdown-menu .notification__all{display:block;font-weight:500;font-size:11px;border-bottom-left-radius:.375rem;border-bottom-right-radius:.375rem}.main-navbar .navbar .user-avatar{max-width:2.5rem}.main-navbar .navbar .navbar-nav .dropdown-menu{position:absolute;right:0;left:auto;width:100%;border-top-left-radius:0;border-top-right-radius:0;border-top:none}.main-navbar .navbar .nav-link-icon i{line-height:2.5rem}.main-content .header-navbar,.main-content>.main-navbar{box-shadow:0 .125rem .625rem rgba(90,97,105,.12)}.main-sidebar{top:0;position:fixed;height:calc(100vh);background:#fff;z-index:1070;will-change:transform;transition:transform .2s ease-in-out;-webkit-transition:-webkit-transform .2s ease-in-out;transition:transform .2s ease-in-out,-webkit-transform .2s ease-in-out;box-shadow:0 .125rem 9.375rem rgba(90,97,105,.1),0 .25rem .5rem rgba(90,97,105,.12),0 .9375rem 1.375rem rgba(90,97,105,.1),0 .4375rem 2.1875rem rgba(165,182,201,.1)}.main-sidebar.open{-webkit-transform:translateX(0);transform:translateX(0);box-shadow:0 .125rem 9.375rem rgba(90,97,105,.1),0 .25rem .5rem rgba(90,97,105,.12),0 .9375rem 1.375rem rgba(90,97,105,.1),0 .4375rem 2.1875rem rgba(165,182,201,.1)}.main-sidebar .toggle-sidebar{position:absolute;right:0;height:100%;padding:1.25rem;font-size:1.25rem;border-left:1px solid #e1e5eb}.main-sidebar .toggle-sidebar:hover{cursor:pointer}.main-sidebar .navbar-brand{overflow:hidden;height:3.75rem;font-size:1rem}.main-sidebar .nav-wrapper{overflow-y:auto;overflow-x:hidden;height:calc(100vh - 3.75rem - 1px)}.main-sidebar .nav .nav-item,.main-sidebar .nav .nav-link{white-space:nowrap;min-width:100%;max-width:100%;overflow:hidden;text-overflow:ellipsis;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;will-change:background-color,box-shadow,color;-webkit-transition:box-shadow .2s,color .2s,background-color .2s;transition:box-shadow .2s,color .2s,background-color .2s;font-size:.85rem}.main-sidebar .nav .nav-item .nav-link{border-bottom:1px solid #e1e5eb;font-weight:400;color:#3d5170;padding:.9375rem 1.5625rem}.main-sidebar .nav .nav-item .nav-link i{min-width:1.25rem;font-size:90%;text-align:center;vertical-align:middle;will-change:color;color:#cacedb;-webkit-transition:color .2s;transition:color .2s;margin-right:.375rem}.main-sidebar .nav .nav-item .nav-link i.material-icons{font-size:1.125rem;top:-1px}.main-sidebar .nav .nav-item .nav-link.active,.main-sidebar .nav .nav-item .nav-link:hover,.main-sidebar .nav .nav-item.active,.main-sidebar .nav .nav-item:hover{box-shadow:inset .1875rem 0 0 #007bff;background-color:#fbfbfb;color:#007bff}.main-sidebar .nav .nav-item .nav-link.active i,.main-sidebar .nav .nav-item .nav-link:hover i,.main-sidebar .nav .nav-item.active i,.main-sidebar .nav .nav-item:hover i{color:#007bff}.main-sidebar .nav--no-borders .nav-item .nav-link{border-bottom:0}.main-sidebar .nav--no-borders .dropdown-menu{box-shadow:inset 0 0 .4375rem rgba(61,81,112,.2)}.main-sidebar .nav--no-borders .dropdown-menu .dropdown-item:first-child{border-top:1px solid #e1e5eb}.main-sidebar .dropdown-menu{position:static!important;-webkit-transform:translate(0)!important;transform:translate(0)!important;box-shadow:none;border-radius:0;width:100%;border:none;padding:0;box-shadow:inset 0 -.1875rem .1875rem rgba(61,81,112,.08)}.main-sidebar .dropdown-menu .dropdown-item{padding:.75rem 1.75rem;border-bottom:1px solid #f0f2f5;color:#3d5170;font-size:.8125rem;font-weight:400}.main-sidebar .dropdown-menu .dropdown-item.active,.main-sidebar .dropdown-menu .dropdown-item:hover{color:#007bff}.main-sidebar .dropdown-menu .dropdown-item:hover{background:0 0}.main-sidebar .dropdown-menu .dropdown-item.active{background-color:#fbfbfb}.main-sidebar .dropdown-menu .dropdown-item:last-of-type{border-bottom:1px solid #e1e5eb}.main-sidebar .dropdown-menu .dropdown-divider{margin:0}.main-sidebar .dropdown-toggle{position:relative}.main-sidebar .dropdown-toggle::after{background-image:url(data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjMDAwMDAwIiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4gICAgPHBhdGggZD0iTTcuNDEgNy44NEwxMiAxMi40Mmw0LjU5LTQuNThMMTggOS4yNWwtNiA2LTYtNnoiLz4gICAgPHBhdGggZD0iTTAtLjc1aDI0djI0SDB6IiBmaWxsPSJub25lIi8+PC9zdmc+);background-position:center center;width:.875rem;height:.5625rem;transition:transform 250ms ease-in-out;-webkit-transition:-webkit-transform 250ms ease-in-out;transition:transform 250ms ease-in-out,-webkit-transform 250ms ease-in-out;border:none;position:absolute;top:50%;right:.625rem;-webkit-transform:translateY(-50%);transform:translateY(-50%);opacity:.1;will-change:transform}.main-sidebar .dropdown.show .dropdown-toggle::after{-webkit-transform:translateY(-50%) rotateZ(180deg);transform:translateY(-50%) rotateZ(180deg)}.main-sidebar__nav-title{text-transform:uppercase;margin:0;font-size:.625rem;letter-spacing:.125rem;padding:1px 1.5625rem;font-weight:500;color:#9ea8b9;border-bottom:1px solid #e1e5eb}.icon-sidebar-nav .main-sidebar{transition:transform .2s ease-in-out,width .2s ease-in-out,-webkit-transform .2s ease-in-out;-webkit-transition:width .2s ease-in-out,-webkit-transform .2s ease-in-out;width:4.75rem}.icon-sidebar-nav .main-sidebar__nav-title{overflow:hidden;text-overflow:ellipsis;padding-right:10px;color:#fff;-webkit-transition:color 250ms ease-in-out;transition:color 250ms ease-in-out;will-change:color}.icon-sidebar-nav .main-sidebar:hover{width:13.75rem}.icon-sidebar-nav .main-sidebar:hover .nav-link{text-overflow:visible}.icon-sidebar-nav .main-sidebar:hover .nav-link span{opacity:1!important;font-size:inherit!important}.icon-sidebar-nav .main-sidebar:hover .main-sidebar__nav-title{color:#9ea8b9}.icon-sidebar-nav .main-sidebar .nav-wrapper{overflow:visible}.icon-sidebar-nav .main-sidebar .nav .nav-link{text-overflow:initial}.icon-sidebar-nav .main-sidebar .nav .nav-link span{opacity:0;font-size:0;-webkit-transition:opacity .2s ease-in-out;transition:opacity .2s ease-in-out}.icon-sidebar-nav .main-sidebar .nav-item{overflow:visible}.icon-sidebar-nav .main-sidebar .dropdown-toggle::after{background-size:100%}.icon-sidebar-nav .main-content{padding:0 0 0 4.75rem}.main-navbar__search .input-group-prepend .input-group-text,.main-sidebar__search .input-group-prepend .input-group-text{font-size:.6875rem;padding:.75rem 1.0625rem}.main-navbar__search input.form-control,.main-sidebar__search input.form-control{border:none;font-size:.8125rem;border-radius:0}.main-navbar__search input.form-control:focus,.main-navbar__search input.form-control:hover,.main-sidebar__search input.form-control:focus,.main-sidebar__search input.form-control:hover{box-shadow:none}.main-content>.main-content-container.container-fluid{min-height:calc(100vh - 7.5rem)}.main-content>.main-content-container.container{min-height:calc(100vh - 11rem)}.main-footer{height:3.75rem}.main-footer .copyright{color:#818ea3}.page-header .page-title{font-size:1.625rem;font-weight:500;line-height:1;margin:0;padding:0}.page-header .page-subtitle{letter-spacing:.125rem;color:#818ea3;font-size:.625rem}.header-navbar i{font-size:.875rem;margin-right:.125rem}.header-navbar .nav-item.dropdown .nav-link{padding-right:1.25rem}.header-navbar .nav-item.dropdown .nav-link:after{content:"";display:block;background-image:url(data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjMDAwMDAwIiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4gICAgPHBhdGggZD0iTTcuNDEgNy44NEwxMiAxMi40Mmw0LjU5LTQuNThMMTggOS4yNWwtNiA2LTYtNnoiLz4gICAgPHBhdGggZD0iTTAtLjc1aDI0djI0SDB6IiBmaWxsPSJub25lIi8+PC9zdmc+);background-position:center center;width:.875rem;height:.5625rem;transition:transform 250ms ease-in-out;-webkit-transition:-webkit-transform 250ms ease-in-out;transition:transform 250ms ease-in-out,-webkit-transform 250ms ease-in-out;border:none;position:absolute;top:45%;right:20px;-webkit-transform:translateY(-50%);transform:translateY(-50%);opacity:.2;will-change:transform;-webkit-transform:scale(.8);transform:scale(.8)}.header-navbar .nav-link{color:#3d5170;border:none;padding:1.125rem 0;margin-right:1.25rem;line-height:1;border-radius:0;font-size:.8125rem;background:0 0;border-bottom:1px solid transparent}.header-navbar .nav-link i{color:#cacedb;-webkit-transition:color .2s;transition:color .2s}.header-navbar .nav-item.dropdown.show .nav-link,.header-navbar .nav-link.active,.header-navbar .nav-link:hover{border-bottom:1px solid #007bff;color:#007bff;cursor:pointer}.header-navbar .nav-item.dropdown.show .nav-link i,.header-navbar .nav-link.active i,.header-navbar .nav-link:hover i{color:#007bff}.country-stats .table td{padding:.5rem 1rem;font-size:.75rem}.country-stats .table tbody tr td{font-weight:400}.country-stats .table tbody tr td:nth-child(1),.country-stats .table tbody tr td:nth-child(2){color:#3d5170}.country-stats .table tbody tr td:nth-child(3){color:#818ea3}.country-stats .country-flag{max-width:1.25rem}.stats-small{min-height:8.7rem;overflow:hidden!important}.stats-small canvas{position:absolute;bottom:0}.stats-small__data{-webkit-box-flex:1;flex:1;display:-webkit-box;display:flex;-webkit-box-pack:center;justify-content:center;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-flow:column;max-width:50%;z-index:1}.stats-small__label{font-size:.625rem;letter-spacing:.0625rem;color:#818ea3}.stats-small__value{font-family:Roboto,-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;font-size:1.5rem;font-weight:500}.stats-small__percentage{position:relative;display:table;margin-left:auto;padding-left:.9375rem}.stats-small__percentage--decrease,.stats-small__percentage--increase{font-size:.75rem}.stats-small__percentage--decrease::before,.stats-small__percentage--increase::before{content:"";width:.75rem;height:.375rem;position:absolute;left:0;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%);background-position:center center;background-repeat:no-repeat}.stats-small__percentage--increase{color:#17c671}.stats-small__percentage--increase::before{background-image:url(data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjMTdjNjcxIiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4gPHBhdGggZD0iTTcgMTRsNS01IDUgNXoiLz4gPHBhdGggZD0iTTAgMGgyNHYyNEgweiIgZmlsbD0ibm9uZSIvPiA8L3N2Zz4=)}.stats-small__percentage--decrease{color:#c4183c}.stats-small__percentage--decrease::before{background-image:url(data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjYzQxODNjIiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4gICAgPHBhdGggZD0iTTcgMTBsNSA1IDUtNXoiLz4gICAgPHBhdGggZD0iTTAgMGgyNHYyNEgweiIgZmlsbD0ibm9uZSIvPjwvc3ZnPg==)}.stats-small--1 .stats-small__data{max-width:100%}.stats-small--1 .stats-small__percentage{margin:0 auto}.stats-small--1 .stats-small__value{font-size:2.0625rem}.stats-small--1 .stats-small__label,.stats-small--1 .stats-small__percentage{font-size:.75rem}.stats-small--1 canvas{opacity:.5}.card-group .stats-small{position:relative;overflow:hidden}.ubd-stats__item,.ubd-stats__legend{display:-webkit-box;display:flex}.ubd-stats__legend{width:100%}.ubd-stats__item{-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;-webkit-box-flex:1;flex:1;text-align:center}.ubd-stats__item i{font-size:1.375rem;margin-bottom:.3125rem}.ubd-stats__category{color:#818ea3;font-size:.8125rem;margin-bottom:.125rem}.ubd-stats__value{font-size:1.0625rem;color:#3d5170;font-weight:500;line-height:1rem}.go-stats .list-group .list-group-item{padding-top:1rem;padding-bottom:1rem}.go-stats__label{margin:0;padding:0;font-size:.95rem;font-weight:500}.go-stats__meta{font-size:.75rem;color:#818ea3}.go-stats__meta strong{color:#3d5170}.go-stats__value{-webkit-box-flex:1;flex:1;padding-right:.625rem}#analytics-overview-date-range{max-width:350px}.sc-stats{font-size:.875rem;font-weight:400}.sc-stats__image{max-width:80px}.sc-stats__image img{width:2.8125rem;height:auto}.sc-stats__title{padding-left:.25rem!important}.sc-stats__percentage{color:#818ea3}.sc-stats .card-body{position:relative;overflow-y:auto;min-height:12.5rem}.sc-stats .container-fluid{position:absolute;height:100%;display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;padding-bottom:1px}.sc-stats .container-fluid .row{display:-webkit-box;display:flex;-webkit-box-flex:1;flex:1;border-bottom:1px solid #e1e5eb;min-height:3.75rem}.sc-stats .container-fluid .row:last-of-type{border-bottom:0}.sc-stats .container-fluid .row>div{display:-webkit-box;display:flex;-webkit-box-pack:center;justify-content:center;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;padding:0}.lo-stats{font-size:.8125rem}.lo-stats table{min-width:600px}.lo-stats thead th{font-size:.75rem;font-weight:400;border-width:1px;border-top:none;padding:.5rem .75rem}.lo-stats td{vertical-align:middle}.lo-stats__image{width:70px}.lo-stats__image img{width:3.125rem;height:3.125rem}.lo-stats__items,.lo-stats__total{font-weight:400}.lo-stats__order-details span{display:block}.lo-stats__order-details span:first-child{font-weight:500;font-size:1rem}.lo-stats__order-details span:last-child{font-size:.625rem;color:#818ea3}.lo-stats .card-body{position:relative;overflow-x:auto;min-height:auto}.lo-stats .container-fluid{overflow-x:auto;position:absolute;height:100%;display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;min-width:41rem}.lo-stats .container-fluid .row:not(.lo-stats__header){display:-webkit-box;display:flex;-webkit-box-flex:1;flex:1;border-bottom:1px solid #e1e5eb;min-height:3.75rem}.lo-stats .container-fluid .row:not(.lo-stats__header):last-of-type{border-bottom:0}.lo-stats .container-fluid .row:not(.lo-stats__header)>div{display:-webkit-box;display:flex;-webkit-box-pack:center;justify-content:center;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}#sales-overview-date-range{max-width:350px}.file-manager__group-title{display:block;font-size:.75rem;font-weight:500;margin:1rem 0}.file-manager-list td,.file-manager-list th{border-left:none!important;border-right:none!important}.file-manager-list .file-manager__item-meta,.file-manager-list .file-manager__item-title{margin:0}.file-manager-list .file-manager__item-title{display:block;font-size:1rem;line-height:1.25rem}.file-manager-list .file-manager__item-meta{display:inline-block;font-size:.6875rem;color:#818ea3;line-height:.8125rem}.file-manager-list .file-manager__item-icon{padding-right:0!important}.file-manager-list .file-manager__item-icon div{border-radius:50%;font-size:.9375rem;text-align:center;color:#818ea3;width:2.1875rem;height:2.1875rem;line-height:2.1875rem;background:#f5f6f8;box-shadow:0 0 0 2px #fff,inset 0 0 3px rgba(0,0,0,.2)}.file-manager-list .file-manager__item-icon i{top:2px}.file-manager-cards__search{max-width:200px}.file-manager-cards .file-manager__item{overflow:hidden;position:relative}.file-manager-cards .file-manager__item .card-footer{display:-webkit-box;display:flex}.file-manager-cards .file-manager__item:hover{cursor:pointer}.file-manager-cards .file-manager__item:after,.file-manager-cards .file-manager__item:before{content:"";position:absolute}.file-manager-cards .file-manager__item:before{background-repeat:no-repeat;background-position:center center;border-radius:50%;background-color:#007bff;background-image:url(data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjRkZGRkZGIiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4gICAgPHBhdGggZD0iTTAgMGgyNHYyNEgweiIgZmlsbD0ibm9uZSIvPiAgICA8cGF0aCBkPSJNOSAxNi4xN0w0LjgzIDEybC0xLjQyIDEuNDFMOSAxOSAyMSA3bC0xLjQxLTEuNDF6Ii8+PC9zdmc+);background-size:1.0625rem;width:1.5625rem;height:1.5625rem;right:.625rem;top:-1.875rem;-webkit-transform:rotate(-90deg);transform:rotate(-90deg);will-change:top,right,opacity,transform;transition:top 150ms cubic-bezier(.27,.01,.38,1.06),right 150ms cubic-bezier(.27,.01,.38,1.06),opacity 150ms cubic-bezier(.27,.01,.38,1.06),transform 150ms cubic-bezier(.27,.01,.38,1.06),-webkit-transform 150ms cubic-bezier(.27,.01,.38,1.06);-webkit-transition:top 150ms cubic-bezier(.27,.01,.38,1.06),right 150ms cubic-bezier(.27,.01,.38,1.06),opacity 150ms cubic-bezier(.27,.01,.38,1.06),-webkit-transform 150ms cubic-bezier(.27,.01,.38,1.06)}.file-manager-cards .file-manager__item:after{top:0;left:0;right:0;bottom:0;z-index:100;border-radius:.625rem;box-shadow:inset 0 0 0 0 rgba(0,123,255,.2);will-change:box-shadow;-webkit-transition:box-shadow 250ms ease-in-out;transition:box-shadow 250ms ease-in-out}.file-manager-cards .file-manager__item--selected:before{top:.625rem;-webkit-transform:rotate(0);transform:rotate(0)}.file-manager-cards .file-manager__item--selected:after{box-shadow:inset 0 0 3.125rem rgba(0,123,255,.2),inset 0 0 .625rem rgba(0,123,255,.4),inset 0 0 0 .125rem rgba(0,123,255,.75)}.file-manager-cards .file-manager__item--directory:before{width:1.25rem;height:1.25rem;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%);right:-1.25rem}.file-manager-cards .file-manager__item--directory.file-manager__item--selected:before{right:10px;background-size:70%}.file-manager-cards .file-manager__item-icon{position:relative;margin-right:.625rem;font-size:1.0625rem;top:2px}.file-manager-cards .file-manager__item-icon i.material-icons{top:0}.file-manager-cards .file-manager__item-title{width:auto;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;margin:0;font-size:.875rem;padding-right:1.25rem}.file-manager-cards .file-manager__item-size{margin:auto 0;font-size:.6875rem}.file-manager-cards .file-manager__item-preview{background:#f8f8f8}.file-manager-cards .file-manager__item-preview img{width:80%;margin-left:auto;margin-right:auto;display:table;box-shadow:0 .125rem .5625rem rgba(0,0,0,.13)}.user-details .card-header{overflow:hidden}.user-details .card-body{margin-top:-3.125rem;z-index:1}.user-details .card-body h4{font-weight:500}.user-details__bg{width:100%;position:relative;max-height:7.1875rem}.user-details__bg img{width:100%}.user-details__bg:after{content:"";position:absolute;top:0;left:0;right:0;bottom:0;background:rgba(90,97,105,.3)}.user-details__avatar{border-radius:50%;overflow:hidden;max-width:6.25rem;box-shadow:0 2px 0 rgba(90,97,105,.11),0 4px 8px rgba(90,97,105,.12),0 10px 10px rgba(90,97,105,.06),0 7px 70px rgba(90,97,105,.1)}.user-details__avatar img{width:100%}.user-details__social{margin:0;padding:0;list-style-type:none}.user-details__social li{display:inline-block}.user-details__social a{display:inline-block;border-radius:50%;text-align:center;width:1.875rem;height:1.875rem;line-height:1.875rem;background:#e9ecef;color:#818ea3}.user-details__user-data .col span{display:block}.user-details__user-data .col span:first-child{font-weight:400;color:#3d5170}.user-details__user-data .col span:last-child{color:#818ea3}.user-details__tags .badge{font-weight:300}.user-stats h4{font-weight:600}.user-stats span{font-size:.6875rem}.user-teams__image{max-width:3.125rem}.user-teams__image img{width:100%;max-width:3.125rem}.user-teams__info span:first-child{font-weight:400}.user-teams__info span:last-child{font-size:80%}.user-teams .card-body{position:relative;overflow-y:auto;min-height:14.0625rem}.user-teams .container-fluid{position:absolute;height:100%;display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.user-teams .container-fluid .row{display:-webkit-box;display:flex;-webkit-box-flex:1;flex:1;border-bottom:1px solid #e1e5eb;min-height:4.6875rem}.user-teams .container-fluid .row:last-of-type{border-bottom:0}.user-teams .container-fluid .row>div{display:-webkit-box;display:flex;-webkit-box-pack:center;justify-content:center;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;padding:0}.user-activity__item{display:-webkit-box;display:flex;margin-left:1.875rem;border-left:1px solid #e9ecef;border-bottom:1px solid #e9ecef;font-weight:400}.user-activity__item:last-child{border-bottom:0}.user-activity__item::after{display:block;clear:both;content:""}.user-activity__item__icon{text-align:center;border-radius:50%;float:left;width:1.875rem;height:1.875rem;min-width:1.875rem;background:#f5f6f8;margin-left:-.9375rem;margin-right:.9375rem;box-shadow:0 0 0 2px #fff,inset 0 0 3px rgba(0,0,0,.2)}.user-activity__item__icon i{font-size:1rem;line-height:1.875rem;color:#aeb9c4}.user-activity__item__content{float:left}.user-activity__item__content p{margin:0}.user-activity__item__content a{font-weight:400}.user-activity__item__content span{font-size:80%}.user-activity__item__action{float:right}.user-activity__item__task-list{list-style:none;margin:0;padding:0}.user-activity__item__task-list .custom-control{line-height:1.5rem}.edit-user-details .card-header{overflow:hidden}.edit-user-details .card-body{z-index:1}.edit-user-details__bg{width:100%;position:relative;max-height:7.1875rem}.edit-user-details__bg img{width:100%}.edit-user-details__bg:after{content:"";position:absolute;top:0;left:0;right:0;bottom:0;background-color:rgba(90,97,105,.5);will-change:background-color;-webkit-transition:background-color 250ms ease-in-out;transition:background-color 250ms ease-in-out}.edit-user-details__bg .edit-user-details__change-background{position:absolute;top:50%;left:50%;z-index:2;opacity:1;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);background-color:rgba(255,255,255,.06);border:1px dashed rgba(233,236,239,.3);padding:.4375rem .9375rem;color:#fff;border-radius:.375rem;box-shadow:.375rem;font-size:.75rem;will-change:opacity;transition:opacity 250ms ease-in-out,transform 250ms ease-in-out,-webkit-transform 250ms ease-in-out;-webkit-transition:opacity 250ms ease-in-out,-webkit-transform 250ms ease-in-out}.edit-user-details__bg .edit-user-details__change-background:hover{cursor:pointer;-webkit-transform:translate(-50%,-50%) scale(1.05);transform:translate(-50%,-50%) scale(1.05)}.edit-user-details__bg .edit-user-details__change-background i{font-size:.9375rem;top:.125rem}.edit-user-details__avatar{border-radius:50%;overflow:hidden;position:relative;max-width:7.5rem;box-shadow:0 2px 0 rgba(90,97,105,.11),0 4px 8px rgba(90,97,105,.12),0 10px 10px rgba(90,97,105,.06),0 7px 70px rgba(90,97,105,.1)}.edit-user-details__avatar img{width:100%}.edit-user-details__avatar__change{margin:0;top:0;left:0;right:0;bottom:0;opacity:0;position:absolute;text-align:center;border-radius:50%;font-size:1.875rem;background:rgba(255,255,255,.95);-webkit-transition:250ms cubic-bezier(.27,.01,.38,1.06);transition:250ms cubic-bezier(.27,.01,.38,1.06)}.edit-user-details__avatar__change i{color:#9ea8b9;line-height:7.5rem}.edit-user-details__avatar:hover .edit-user-details__avatar__change{opacity:1;cursor:pointer}.auth-form{min-width:19.375rem;max-width:350px}.auth-form .card-body{overflow:hidden;box-shadow:inset 0 4px 0 0 #007bff;border-radius:.625rem}.auth-form__logo{max-width:2.5rem}.auth-form__title{font-size:1.125rem;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif}.auth-form__social-icons{margin:0;padding:0}.auth-form__social-icons li{list-style:none;display:inline-block}.auth-form__social-icons li a{padding:0 .75rem;font-size:1.25rem;color:#cacedb;-webkit-transition:color 250ms cubic-bezier(.27,.01,.38,1.06);transition:color 250ms cubic-bezier(.27,.01,.38,1.06)}.auth-form__social-icons li a:hover{color:#007bff}.auth-form__meta a{font-weight:400;color:#818ea3}.auth-form__meta a:hover{color:#3d5170}.quick-post-form{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-flow:column;-webkit-box-flex:1;flex:1}.quick-post-form .form-group:nth-child(2){display:-webkit-box;display:flex;-webkit-box-flex:1;flex:1}.quick-post-form textarea{resize:none;min-height:100px}.blog-comments__avatar img{width:3.125rem;height:3.125rem;border-radius:.25rem}.blog-comments__item{padding:0;border-bottom:1px solid #e1e5eb}.blog-comments__item:last-child{border:0}.blog-comments__actions{font-size:95%}.blog-comments__actions .btn-group button{padding:.25rem .5625rem}.add-new-post__editor{min-height:400px}.card-post .card-body{padding:1.5625rem}.card-post .card-footer,.card-post .card-header{padding-left:1.5625rem;padding-right:1.5625rem}.card-post__image{position:relative;min-height:10.3125rem;border-top-left-radius:.625rem;border-top-right-radius:.625rem;background-size:cover;background-position:center;background-repeat:no-repeat}.card-post__author-avatar{width:2.8125rem;height:2.8125rem;box-shadow:0 0 0 .125rem #fff,0 .1875rem .4375rem rgba(90,97,105,.5);display:block;background-position:center;background-size:cover;border-radius:50%;text-indent:-9999px}.card-post__author-avatar--small{width:2.1875rem;height:2.1875rem}.card-post__author-name{font-weight:500}.card-post--aside{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-flow:row}.card-post--aside .card-post__image{border-top-right-radius:0;border-top-left-radius:.625rem;border-bottom-left-radius:.625rem;min-width:180px}.card-post--1 .card-post__author{-webkit-transform:translateY(50%);transform:translateY(50%);margin-left:1.5625rem;position:absolute;bottom:0}.card-post--1 .card-post__category{top:.9375rem;right:.9375rem;position:absolute;text-transform:uppercase}.card-post--1 .card-body{padding-top:2.1875rem}.card-post--1.card-post--aside .card-body{padding:1.5625rem}.card-post--1.card-post--aside .card-post__author{left:.9375rem;bottom:.9375rem;-webkit-transform:none;transform:none;margin:0}.card-post--1.card-post--aside .card-post__category{right:initial;top:.9375rem;left:.9375rem}.error{height:calc(100vh - 3.75rem);display:-webkit-box;display:flex}.error__content{padding:0 .9375rem;display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-flow:column;margin:auto;-webkit-box-align:center;align-items:center;text-align:center}.error__content h2{color:#cacedb;font-weight:700;font-size:3.75rem;margin-bottom:1.5625rem}.error__content h3{font-weight:500;font-size:2.1875rem;margin-bottom:.625rem}.error__content p{color:#818ea3}@media (max-width:575.98px){html{font-size:15px}.dataTables_filter,.dataTables_info,.dataTables_length,.dataTables_paginate{width:100%;max-width:100%!important}.dataTables_length label{display:table;margin:0 auto}.dataTables_filter{width:100%}.dataTables_filter input,.dataTables_filter label{margin:0!important;width:100%;background-size:5%!important}#analytics-overview-date-range,#sales-overview-date-range{max-width:100%}}@media (min-width:576px){.form-inline .form-check-input{margin-right:.313rem}.navbar-expand-sm .navbar-nav .nav-link{padding-right:.625rem;padding-left:.625rem}.card-deck{margin-right:-.9375rem;margin-left:-.9375rem}.card-deck .card{margin-right:.9375rem;margin-left:.9375rem}.card-group{box-shadow:0 .46875rem 2.1875rem rgba(90,97,105,.1),0 .9375rem 1.40625rem rgba(90,97,105,.1),0 .25rem .53125rem rgba(90,97,105,.12),0 .125rem .1875rem rgba(90,97,105,.1);border-radius:.625rem}.card-group>.card{box-shadow:none}.card-group>.card:first-child{border-top-right-radius:0;border-bottom-right-radius:0}.card-group>.card:last-child{border-top-left-radius:0;border-bottom-left-radius:0}.card-group>.card:only-child{border-radius:.625rem}.card-group>.card:only-child .card-header,.card-group>.card:only-child .card-img-top{border-top-left-radius:.625rem;border-top-right-radius:.625rem}.card-group>.card:only-child .card-footer,.card-group>.card:only-child .card-img-bottom{border-bottom-right-radius:.625rem;border-bottom-left-radius:.625rem}.card-group>.card:not(:first-child):not(:last-child):not(:only-child),.card-group>.card:not(:first-child):not(:last-child):not(:only-child) .card-footer,.card-group>.card:not(:first-child):not(:last-child):not(:only-child) .card-header,.card-group>.card:not(:first-child):not(:last-child):not(:only-child) .card-img-bottom,.card-group>.card:not(:first-child):not(:last-child):not(:only-child) .card-img-top{border-radius:0}.card-columns{-webkit-column-count:3;-moz-column-count:3;column-count:3;-webkit-column-gap:1.25rem;-moz-column-gap:1.25rem;column-gap:1.25rem}.jumbotron{padding:4rem 2rem}.modal-dialog{max-width:500px;margin:1.875rem auto}.modal-dialog-centered{min-height:calc(100% - (1.875rem * 2))}.modal-content{box-shadow:0 .46875rem 2.1875rem rgba(90,97,105,.1),0 .9375rem 1.40625rem rgba(90,97,105,.1),0 .25rem .53125rem rgba(90,97,105,.12),0 .125rem .1875rem rgba(90,97,105,.1)}.modal-sm{max-width:300px}}@media (min-width:768px){.navbar-expand-md .navbar-nav .nav-link{padding-right:.625rem;padding-left:.625rem}.icon-sidebar-nav .main-sidebar .dropdown-menu{border-radius:0 .375rem .375rem 0;position:absolute!important;left:100%!important;width:12.5rem;box-shadow:0 2px 0 rgba(90,97,105,.11),0 4px 8px rgba(90,97,105,.12),0 10px 10px rgba(90,97,105,.06),0 7px 70px rgba(90,97,105,.1);-webkit-transition:opacity 250ms ease-in-out;transition:opacity 250ms ease-in-out;display:block;visibility:hidden;opacity:0}.icon-sidebar-nav .main-sidebar .dropdown-menu.show{opacity:1;visibility:visible}.icon-sidebar-nav .main-sidebar .dropdown-menu .dropdown-item:first-of-type{border-radius:0 .375rem 0 0}.icon-sidebar-nav .main-sidebar .dropdown-menu .dropdown-item:last-of-type{border-bottom:0;border-radius:0 0 .375rem}}@media (min-width:992px){.navbar-expand-lg .navbar-nav .nav-link{padding-right:.625rem;padding-left:.625rem}.modal-lg{max-width:800px}}@media (min-width:1200px){.navbar-expand-xl .navbar-nav .nav-link{padding-right:.625rem;padding-left:.625rem}}@media (-webkit-min-device-pixel-ratio:1.5),(min-resolution:144dpi){html{font-size:16px;font-weight:400}.main-sidebar .dropdown-menu .dropdown-item{font-weight:300}}@media (-webkit-min-device-pixel-ratio:2),(min-resolution:192dpi){body{font-size:13px;font-weight:400}}@media (max-width:991.98px){.dataTables_wrapper table.dataTable{display:block;width:100%;overflow-x:auto;-webkit-overflow-scrolling:touch;-ms-overflow-style:-ms-autohiding-scrollbar;border:0}.main-sidebar .navbar-brand{font-size:90%}.header-navbar .nav-item.dropdown .nav-link{position:relative;border:0;padding-right:0}.header-navbar .nav-item.dropdown .nav-link:after{z-index:1000;right:5px}.header-navbar .nav-item.dropdown .dropdown-menu{position:static!important;-webkit-transform:none!important;transform:none!important;width:100%;border-radius:0;box-shadow:none;border:none}.header-navbar .nav-link{margin-right:0;-webkit-transition:none;transition:none;font-size:.875rem}.header-navbar .dropdown-item{border-radius:5px;font-size:.875rem;padding:.625rem 1.375rem;font-weight:400}.header-navbar .nav-item.dropdown.show .nav-link,.header-navbar .nav-link.active,.header-navbar .nav-link:hover{border:0}.sc-stats__image{max-width:3.125rem}.file-manager-cards__search{max-width:100%}}@media (max-width:767.98px){.dataTables_info,.dataTables_paginate{padding:14px;width:100%;text-align:center!important}.dataTables_info{border-bottom:1px solid #e1e5eb;border-radius:0}.dataTables_paginate .ellipsis,.dataTables_paginate .paginate_button{font-size:.625rem;padding:.4286rem .6rem}.dataTables_filter{max-width:200px;float:right}.main-navbar .navbar .notifications{position:static}.main-navbar .navbar .notifications .dropdown-menu{min-width:100%!important;border-left:none;left:0;right:0}.main-sidebar{-webkit-transform:translateX(-100%);transform:translateX(-100%);box-shadow:none}.main-sidebar__search{box-sizing:border-box;border-right:0!important;padding:.625rem 0;border-bottom:1px solid #e1e5eb}.main-sidebar__search .input-group{margin:0!important}.icon-sidebar-nav .main-sidebar{width:100%}.icon-sidebar-nav .main-sidebar span{opacity:1!important;font-size:inherit!important}.icon-sidebar-nav .main-sidebar .main-sidebar__nav-title{color:#9ea8b9}.icon-sidebar-nav .main-sidebar:hover{width:100%}.icon-sidebar-nav .main-content{padding-left:0}.main-footer{display:block!important;height:auto}.main-footer .nav{width:100%;display:block;border-bottom:1px solid #e1e5eb;padding-bottom:.75rem}.main-footer .copyright{display:inline-block;width:100%;padding:1rem;text-align:center}.page-header .page-title{font-size:2rem}.page-header .page-subtitle{font-size:.8125rem;font-weight:400}}@media screen and (min-width:992px) and (max-width:1170px){.sc-stats{font-size:.75rem}}@media screen and (max-width:1170px){.sc-stats__title{padding-left:.625rem!important}}@media screen and (max-width:992px){.sc-stats .card-body,.user-teams .card-body{min-height:21rem}}`]
      }] }
    ];
    FireAdminComponent2.ctorParameters = function() {
      return [
        { type: AlertService },
        { type: CurrentUserService }
      ];
    };
    return FireAdminComponent2;
  }()
);
if (false) {
  FireAdminComponent.prototype.alert;
  FireAdminComponent.prototype.currentUser;
}
var AuthService = (
  /** @class */
  function() {
    function AuthService2(afa, currentUser) {
      var _this = this;
      this.afa = afa;
      this.currentUser = currentUser;
      this.firebaseUser = null;
      this.lastError = null;
      this.afa.auth.onAuthStateChanged(
        /**
        * @param {?} user
        * @return {?}
        */
        function(user) {
          _this.firebaseUser = user;
          _this.currentUser.set(user);
        }
      );
    }
    AuthService2.prototype.setLastError = /**
    * @private
    * @param {?} error
    * @return {?}
    */
    function(error) {
      this.lastError = error;
      console.error("[" + error.code + "] " + error.message);
    };
    AuthService2.prototype.isSignedIn = /**
    * @return {?}
    */
    function() {
      return this.afa.authState.pipe(first(), map(
        /**
        * @param {?} user
        * @return {?}
        */
        function(user) {
          return !!user;
        }
      )).toPromise();
    };
    AuthService2.prototype.signIn = /**
    * @param {?} email
    * @param {?} password
    * @param {?=} isPersistent
    * @return {?}
    */
    function(email, password, isPersistent) {
      var _this = this;
      if (isPersistent === void 0) {
        isPersistent = false;
      }
      return new Promise(
        /**
        * @param {?} resolve
        * @param {?} reject
        * @return {?}
        */
        function(resolve2, reject) {
          if (!!_this.firebaseUser) {
            console.log("already signed in!");
            resolve2();
          } else {
            var persistence = isPersistent ? (void 0).Auth.Persistence.LOCAL : (void 0).Auth.Persistence.SESSION;
            _this.afa.auth.setPersistence(persistence).then(
              /**
              * @return {?}
              */
              function() {
                _this.afa.auth.signInWithEmailAndPassword(email, password).then(
                  /**
                  * @return {?}
                  */
                  function() {
                    resolve2();
                  }
                ).catch(
                  /**
                  * @param {?} error
                  * @return {?}
                  */
                  function(error) {
                    _this.setLastError(error);
                    reject(_this.lastError);
                  }
                );
              }
            ).catch(
              /**
              * @param {?} error
              * @return {?}
              */
              function(error) {
                _this.setLastError(error);
                reject(_this.lastError);
              }
            );
          }
        }
      );
    };
    AuthService2.prototype.signOut = /**
    * @param {?=} force
    * @return {?}
    */
    function(force) {
      var _this = this;
      if (force === void 0) {
        force = false;
      }
      return new Promise(
        /**
        * @param {?} resolve
        * @param {?} reject
        * @return {?}
        */
        function(resolve2, reject) {
          if (force || !!_this.firebaseUser) {
            _this.afa.auth.signOut().then(
              /**
              * @return {?}
              */
              function() {
                resolve2();
              }
            ).catch(
              /**
              * @param {?} error
              * @return {?}
              */
              function(error) {
                _this.setLastError(error);
                reject(_this.lastError);
              }
            );
          } else {
            resolve2();
          }
        }
      );
    };
    AuthService2.decorators = [
      { type: Injectable }
    ];
    AuthService2.ctorParameters = function() {
      return [
        { type: AngularFireAuth },
        { type: CurrentUserService }
      ];
    };
    return AuthService2;
  }()
);
if (false) {
  AuthService.prototype.firebaseUser;
  AuthService.prototype.lastError;
  AuthService.prototype.afa;
  AuthService.prototype.currentUser;
}
var NavigationService = (
  /** @class */
  function() {
    function NavigationService2(router) {
      this.router = router;
      this.rootPath = null;
      this.rootPath = this.router.config[0].path;
    }
    NavigationService2.prototype.getQueryParams = /**
    * @private
    * @param {?} path
    * @return {?}
    */
    function(path) {
      var queryParams = path.split("?")[1] || "";
      var params = queryParams.length ? queryParams.split("&") : [];
      var pair = null;
      var data = {};
      params.forEach(
        /**
        * @param {?} d
        * @return {?}
        */
        function(d) {
          pair = d.split("=");
          data["" + pair[0]] = pair[1];
        }
      );
      return data;
    };
    NavigationService2.prototype.redirectTo = /**
    * @param {...?} path
    * @return {?}
    */
    function() {
      var path = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        path[_i2] = arguments[_i2];
      }
      this.router.navigate(this.getRouterLink.apply(this, __spread(path)), { queryParams: this.getQueryParams(path[0]) });
    };
    NavigationService2.prototype.getRouterLink = /**
    * @param {...?} path
    * @return {?}
    */
    function() {
      var path = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        path[_i2] = arguments[_i2];
      }
      var root = this.rootPath ? "/" + this.rootPath : [];
      path = path.map(
        /**
        * @param {?} segment
        * @return {?}
        */
        function(segment) {
          return segment.split("?")[0];
        }
      );
      return __spread([root], path);
    };
    NavigationService2.prototype.setRootPath = /**
    * @param {?} path
    * @return {?}
    */
    function(path) {
      this.rootPath = path;
    };
    NavigationService2.decorators = [
      { type: Injectable }
    ];
    NavigationService2.ctorParameters = function() {
      return [
        { type: Router }
      ];
    };
    return NavigationService2;
  }()
);
if (false) {
  NavigationService.prototype.rootPath;
  NavigationService.prototype.router;
}
var LoginComponent = (
  /** @class */
  function() {
    function LoginComponent2(auth2, route, navigation) {
      this.auth = auth2;
      this.route = route;
      this.navigation = navigation;
      this.logo = getLogo();
      this.email = "";
      this.password = "";
      this.rememberMe = false;
      this.error = null;
      this.routeSubscription = null;
    }
    LoginComponent2.prototype.ngOnInit = /**
    * @return {?}
    */
    function() {
      var _this = this;
      this.routeSubscription = this.route.queryParams.subscribe(
        /**
        * @param {?} params
        * @return {?}
        */
        function(params) {
          if (params.email) {
            _this.email = params.email;
          }
          if (params.password) {
            _this.password = params.password;
          }
        }
      );
    };
    LoginComponent2.prototype.ngOnDestroy = /**
    * @return {?}
    */
    function() {
      if (this.routeSubscription) {
        this.routeSubscription.unsubscribe();
      }
    };
    LoginComponent2.prototype.onSubmit = /**
    * @return {?}
    */
    function() {
      var _this = this;
      this.auth.signIn(this.email, this.password, this.rememberMe).then(
        /**
        * @return {?}
        */
        function() {
          _this.navigation.redirectTo("dashboard");
        }
      ).catch(
        /**
        * @param {?} error
        * @return {?}
        */
        function(error) {
          _this.error = error.message;
        }
      );
    };
    LoginComponent2.prototype.dismissError = /**
    * @param {?} event
    * @return {?}
    */
    function(event) {
      event.preventDefault();
      event.stopPropagation();
      this.error = null;
    };
    LoginComponent2.decorators = [
      { type: Component, args: [{
        selector: "fa-login",
        template: `
<div class="container-fluid h-100">
  <div class="row h-100">
    <main class="main-content col">
      <div class="main-content-container container-fluid px-4 my-auto h-100">
        <div class="row no-gutters h-100">
          <div class="col-lg-3 col-md-5 auth-form mx-auto my-auto">
            <div *ngIf="error?.length" class="alert alert-warning alert-dismissible fade show mb-4" role="alert">
              <button type="button" class="close" data-dismiss="alert" aria-label="Close" (click)="dismissError($event)">
                <span aria-hidden="true">×</span>
              </button>
              <i class="fa fa-exclamation mx-2"></i>
              {{ error }}
            </div>
            <div class="card">
              <div class="card-body">
                <img class="auth-form__logo d-table mx-auto mb-3" [src]="logo | escapeUrl" alt="FireAdmin">
                <h5 class="auth-form__title text-center mb-4">{{ 'SignInToYourAccount' | translate }}</h5>
                <form (ngSubmit)="onSubmit()">
                  <div class="form-group">
                    <label for="inputEmail">{{ 'EmailAddress' | translate }}</label>
                    <input type="email" class="form-control" id="inputEmail" name="inputEmail" aria-describedby="emailHelp" placeholder="{{ 'EnterEmail' | translate }}" [(ngModel)]="email">
                  </div>
                  <div class="form-group">
                    <label for="inputPassword">{{ 'Password' | translate }}</label>
                    <input type="password" class="form-control" id="inputPassword" name="inputPassword" placeholder="{{ 'Password' | translate }}" [(ngModel)]="password">
                  </div>
                  <div class="form-group mb-3 d-table mx-auto">
                    <div class="custom-control custom-checkbox mb-1">
                      <input type="checkbox" class="custom-control-input" id="rememberMe" name="rememberMe" [(ngModel)]="rememberMe">
                      <label class="custom-control-label" for="rememberMe">{{ 'RememberMe' | translate }}</label>
                    </div>
                  </div>
                  <button type="submit" class="btn btn-pill btn-accent d-table mx-auto">{{ 'SignIn' | translate }}</button>
                </form>
              </div>
              <!-- <div class="card-footer border-top">
                <ul class="auth-form__social-icons d-table mx-auto">
                  <li><a href="#"><i class="fab fa-facebook-f"></i></a></li>
                  <li><a href="#"><i class="fab fa-twitter"></i></a></li>
                  <li><a href="#"><i class="fab fa-github"></i></a></li>
                  <li><a href="#"><i class="fab fa-google-plus-g"></i></a></li>
                </ul>
              </div> -->
            </div>
            <div class="auth-form__meta d-flex mt-4">
              <a href="#">{{ 'ForgotYourPassword' | translate }}</a>
              <!-- <a class="ml-auto" href="#">Create new account?</a> -->
            </div>
          </div>
        </div>
      </div>
    </main>
  </div>
</div>
`,
        styles: [""]
      }] }
    ];
    LoginComponent2.ctorParameters = function() {
      return [
        { type: AuthService },
        { type: ActivatedRoute },
        { type: NavigationService }
      ];
    };
    return LoginComponent2;
  }()
);
if (false) {
  LoginComponent.prototype.logo;
  LoginComponent.prototype.email;
  LoginComponent.prototype.password;
  LoginComponent.prototype.rememberMe;
  LoginComponent.prototype.error;
  LoginComponent.prototype.routeSubscription;
  LoginComponent.prototype.auth;
  LoginComponent.prototype.route;
  LoginComponent.prototype.navigation;
}
if (false) {
  Post.prototype.id;
  Post.prototype.lang;
  Post.prototype.title;
  Post.prototype.slug;
  Post.prototype.date;
  Post.prototype.image;
  Post.prototype.content;
  Post.prototype.status;
  Post.prototype.categories;
  Post.prototype.createdAt;
  Post.prototype.updatedAt;
  Post.prototype.createdBy;
  Post.prototype.author;
  Post.prototype.updatedBy;
  Post.prototype.translationId;
  Post.prototype.translations;
  Post.prototype.isTranslatable;
}
var PostStatus = {
  Draft: "draft",
  Published: "published",
  Trash: "trash"
};
var DocumentTranslationsService = (
  /** @class */
  function() {
    function DocumentTranslationsService2(db2, collectionPath) {
      this.db = db2;
      this.collectionPath = collectionPath;
    }
    DocumentTranslationsService2.prototype.addTranslation = /**
    * @protected
    * @param {?} lang
    * @param {?} id
    * @param {?=} parentId
    * @return {?}
    */
    function(lang, id2, parentId) {
      var _a3;
      var translation = (_a3 = {}, _a3[lang] = id2, _a3);
      return parentId ? this.db.setDocument(this.collectionPath, parentId, translation) : this.db.addDocument(this.collectionPath, translation);
    };
    DocumentTranslationsService2.prototype.getTranslations = /**
    * @protected
    * @param {?} id
    * @return {?}
    */
    function(id2) {
      return this.db.getDocument(this.collectionPath, id2);
    };
    DocumentTranslationsService2.prototype.getTranslationsWhere = /**
    * @protected
    * @param {?} field
    * @param {?} operator
    * @param {?} value
    * @return {?}
    */
    function(field, operator, value) {
      return this.db.getCollection(
        this.collectionPath,
        /**
        * @param {?} ref
        * @return {?}
        */
        function(ref) {
          return ref.where(field, operator, value);
        }
      );
    };
    DocumentTranslationsService2.prototype.deleteTranslation = /**
    * @protected
    * @param {?} id
    * @param {?=} lang
    * @param {?=} translations
    * @return {?}
    */
    function(id2, lang, translations) {
      var newTranslations = lang && translations ? Object.keys(translations).reduce(
        /**
        * @param {?} object
        * @param {?} key
        * @return {?}
        */
        function(object, key) {
          if (key !== lang) {
            object[key] = translations[key];
          }
          return object;
        },
        {}
      ) : {};
      return Object.keys(newTranslations).length > 0 ? this.db.setDocument(this.collectionPath, id2, newTranslations, false) : this.db.deleteDocument(this.collectionPath, id2);
    };
    return DocumentTranslationsService2;
  }()
);
if (false) {
  DocumentTranslationsService.prototype.db;
  DocumentTranslationsService.prototype.collectionPath;
}
var PostsService = (
  /** @class */
  function(_super) {
    __extends(PostsService2, _super);
    function PostsService2(db2, storage, settings, users) {
      var _this = _super.call(this, db2, "postTranslations") || this;
      _this.db = db2;
      _this.storage = storage;
      _this.settings = settings;
      _this.users = users;
      _this.allStatus = {};
      _this.statusColors = {
        draft: "warning",
        published: "success",
        trash: "danger"
      };
      _this.imagesCache = {};
      Object.keys(PostStatus).forEach(
        /**
        * @param {?} key
        * @return {?}
        */
        function(key) {
          _this.allStatus[PostStatus[key]] = key;
        }
      );
      return _this;
    }
    PostsService2.prototype.getAllStatus = /**
    * @return {?}
    */
    function() {
      return this.allStatus;
    };
    PostsService2.prototype.getAllStatusWithColors = /**
    * @return {?}
    */
    function() {
      return { labels: this.allStatus, colors: this.statusColors };
    };
    PostsService2.prototype.getStatus = /**
    * @param {?} statusKey
    * @return {?}
    */
    function(statusKey) {
      return this.allStatus[statusKey];
    };
    PostsService2.prototype.add = /**
    * @param {?} data
    * @param {?=} translationId
    * @return {?}
    */
    function(data, translationId) {
      var _this = this;
      var post = {
        title: data.title,
        lang: data.lang,
        slug: data.slug,
        date: data.date,
        image: null,
        content: data.content,
        status: data.status,
        categories: data.categories,
        createdAt: now(),
        // timestamp
        updatedAt: null,
        createdBy: this.db.currentUser.id,
        updatedBy: null
      };
      if (translationId && data.image && !isFile(data.image)) {
        post.image = data.image;
      }
      return new Promise(
        /**
        * @param {?} resolve
        * @param {?} reject
        * @return {?}
        */
        function(resolve2, reject) {
          _this.db.addDocument("posts", post).then(
            /**
            * @param {?} doc
            * @return {?}
            */
            function(doc) {
              _this.uploadImage(
                doc.id,
                /** @type {?} */
                data.image
              ).then(
                /**
                * @return {?}
                */
                function() {
                  _this.addTranslation(data.lang, doc.id, translationId).then(
                    /**
                    * @param {?} translation
                    * @return {?}
                    */
                    function(translation) {
                      doc.set({ translationId: translationId || translation.id }, { merge: true }).then(
                        /**
                        * @return {?}
                        */
                        function() {
                          resolve2();
                        }
                      ).catch(
                        /**
                        * @param {?} error
                        * @return {?}
                        */
                        function(error) {
                          reject(error);
                        }
                      );
                    }
                  ).catch(
                    /**
                    * @param {?} error
                    * @return {?}
                    */
                    function(error) {
                      reject(error);
                    }
                  );
                }
              ).catch(
                /**
                * @param {?} error
                * @return {?}
                */
                function(error) {
                  reject(error);
                }
              );
            }
          ).catch(
            /**
            * @param {?} error
            * @return {?}
            */
            function(error) {
              reject(error);
            }
          );
        }
      );
    };
    PostsService2.prototype.translate = /**
    * @param {?} data
    * @return {?}
    */
    function(data) {
      return this.add(data, data.translationId);
    };
    PostsService2.prototype.uploadImage = /**
    * @private
    * @param {?} id
    * @param {?} imageFile
    * @return {?}
    */
    function(id2, imageFile) {
      var _this = this;
      return new Promise(
        /**
        * @param {?} resolve
        * @param {?} reject
        * @return {?}
        */
        function(resolve2, reject) {
          if (imageFile && isFile(imageFile)) {
            var imageName = guid() + "." + imageFile.name.split(".").pop();
            var imagePath_1 = "posts/" + id2 + "/" + imageName;
            _this.storage.upload(imagePath_1, imageFile).then(
              /**
              * @return {?}
              */
              function() {
                _this.db.setDocument("posts", id2, { image: imagePath_1 }).then(
                  /**
                  * @return {?}
                  */
                  function() {
                    resolve2();
                  }
                ).catch(
                  /**
                  * @param {?} error
                  * @return {?}
                  */
                  function(error) {
                    reject(error);
                  }
                );
              }
            ).catch(
              /**
              * @param {?} error
              * @return {?}
              */
              function(error) {
                reject(error);
              }
            );
          } else {
            resolve2();
          }
        }
      );
    };
    PostsService2.prototype.get = /**
    * @param {?} id
    * @return {?}
    */
    function(id2) {
      var _this = this;
      return this.db.getDocument("posts", id2).pipe(mergeMap(
        /**
        * @param {?} post
        * @return {?}
        */
        function(post) {
          return __awaiter(_this, void 0, void 0, function() {
            var translations;
            return __generator(this, function(_a3) {
              switch (_a3.label) {
                case 0:
                  return [4, this.getTranslations(post.translationId).pipe(take(1)).toPromise()];
                case 1:
                  translations = _a3.sent();
                  post.id = id2;
                  post.translations = translations;
                  return [2, post];
              }
            });
          });
        }
      ));
    };
    PostsService2.prototype.getTranslationLanguages = /**
    * @param {?} post
    * @return {?}
    */
    function(post) {
      var postLanguages = Object.keys(post.translations);
      return this.settings.getActiveSupportedLanguages().filter(
        /**
        * @param {?} lang
        * @return {?}
        */
        function(lang) {
          return postLanguages.indexOf(lang.key) === -1;
        }
      );
    };
    PostsService2.prototype.getImageUrl = /**
    * @param {?} imagePath
    * @return {?}
    */
    function(imagePath) {
      var _this = this;
      if (this.imagesCache[imagePath]) {
        return of(this.imagesCache[imagePath]);
      } else {
        return this.storage.get(imagePath).getDownloadURL().pipe(map(
          /**
          * @param {?} imageUrl
          * @return {?}
          */
          function(imageUrl) {
            _this.imagesCache[imagePath] = imageUrl;
            return imageUrl;
          }
        ));
      }
    };
    PostsService2.prototype.pipePosts = /**
    * @private
    * @param {?} postsObservable
    * @return {?}
    */
    function(postsObservable) {
      var _this = this;
      return postsObservable.pipe(mergeMap(
        /**
        * @param {?} posts
        * @return {?}
        */
        function(posts) {
          return __awaiter(_this, void 0, void 0, function() {
            var activeSupportedLanguages, _loop_1, this_1, posts_1, posts_1_1, post, e_1_1;
            var e_1, _a3;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  activeSupportedLanguages = this.settings.getActiveSupportedLanguages().map(
                    /**
                    * @param {?} lang
                    * @return {?}
                    */
                    function(lang) {
                      return lang.key;
                    }
                  );
                  _loop_1 = function(post2) {
                    var _a4, postLanguages;
                    return __generator(this, function(_b2) {
                      switch (_b2.label) {
                        case 0:
                          _a4 = post2;
                          return [4, this_1.getTranslations(post2.translationId).pipe(take(1)).toPromise()];
                        case 1:
                          _a4.translations = _b2.sent();
                          postLanguages = Object.keys(post2.translations);
                          post2.image = {
                            path: post2.image,
                            url: post2.image ? merge(of(getLoadingImage()), this_1.getImageUrl(
                              /** @type {?} */
                              post2.image
                            )) : of(getEmptyImage())
                          };
                          post2.author = post2.createdBy ? this_1.users.getFullName(post2.createdBy) : of(null);
                          post2.isTranslatable = !activeSupportedLanguages.every(
                            /**
                            * @param {?} lang
                            * @return {?}
                            */
                            function(lang) {
                              return postLanguages.includes(lang);
                            }
                          );
                          return [
                            2
                            /*return*/
                          ];
                      }
                    });
                  };
                  this_1 = this;
                  _b.label = 1;
                case 1:
                  _b.trys.push([1, 6, 7, 8]);
                  posts_1 = __values(posts), posts_1_1 = posts_1.next();
                  _b.label = 2;
                case 2:
                  if (!!posts_1_1.done)
                    return [3, 5];
                  post = posts_1_1.value;
                  return [5, _loop_1(post)];
                case 3:
                  _b.sent();
                  _b.label = 4;
                case 4:
                  posts_1_1 = posts_1.next();
                  return [3, 2];
                case 5:
                  return [3, 8];
                case 6:
                  e_1_1 = _b.sent();
                  e_1 = { error: e_1_1 };
                  return [3, 8];
                case 7:
                  try {
                    if (posts_1_1 && !posts_1_1.done && (_a3 = posts_1.return))
                      _a3.call(posts_1);
                  } finally {
                    if (e_1)
                      throw e_1.error;
                  }
                  return [
                    7
                    /*endfinally*/
                  ];
                case 8:
                  return [2, posts];
              }
            });
          });
        }
      ));
    };
    PostsService2.prototype.getAll = /**
    * @return {?}
    */
    function() {
      return this.pipePosts(this.db.getCollection("posts"));
    };
    PostsService2.prototype.getWhere = /**
    * @param {?} field
    * @param {?} operator
    * @param {?} value
    * @param {?=} applyPipe
    * @return {?}
    */
    function(field, operator, value, applyPipe) {
      if (applyPipe === void 0) {
        applyPipe = false;
      }
      return this.getWhereFn(
        /**
        * @param {?} ref
        * @return {?}
        */
        function(ref) {
          return ref.where(field, operator, value);
        },
        applyPipe
      );
    };
    PostsService2.prototype.getWhereFn = /**
    * @param {?} queryFn
    * @param {?=} applyPipe
    * @return {?}
    */
    function(queryFn, applyPipe) {
      if (applyPipe === void 0) {
        applyPipe = false;
      }
      var postsObservable = this.db.getCollection("posts", queryFn);
      return applyPipe ? this.pipePosts(postsObservable) : postsObservable;
    };
    PostsService2.prototype.edit = /**
    * @param {?} id
    * @param {?} data
    * @return {?}
    */
    function(id2, data) {
      var _this = this;
      var post = {
        title: data.title,
        lang: data.lang,
        slug: data.slug,
        date: data.date,
        content: data.content,
        status: data.status,
        categories: data.categories,
        updatedAt: now(),
        updatedBy: this.db.currentUser.id
      };
      if (
        /*data.image !== undefined && */
        data.image === null
      ) {
        post.image = null;
      }
      return new Promise(
        /**
        * @param {?} resolve
        * @param {?} reject
        * @return {?}
        */
        function(resolve2, reject) {
          _this.db.setDocument("posts", id2, post).then(
            /**
            * @return {?}
            */
            function() {
              _this.uploadImage(
                id2,
                /** @type {?} */
                data.image
              ).then(
                /**
                * @return {?}
                */
                function() {
                  resolve2();
                }
              ).catch(
                /**
                * @param {?} error
                * @return {?}
                */
                function(error) {
                  reject(error);
                }
              );
            }
          ).catch(
            /**
            * @param {?} error
            * @return {?}
            */
            function(error) {
              reject(error);
            }
          );
        }
      );
    };
    PostsService2.prototype.deleteImage = /**
    * @private
    * @param {?} imagePath
    * @return {?}
    */
    function(imagePath) {
      var _this = this;
      return new Promise(
        /**
        * @param {?} resolve
        * @param {?} reject
        * @return {?}
        */
        function(resolve2, reject) {
          if (imagePath) {
            _this.storage.delete(imagePath).toPromise().then(
              /**
              * @return {?}
              */
              function() {
                resolve2();
              }
            ).catch(
              /**
              * @param {?} error
              * @return {?}
              */
              function(error) {
                reject(error);
              }
            );
          } else {
            resolve2();
          }
        }
      );
    };
    PostsService2.prototype.delete = /**
    * @param {?} id
    * @param {?} data
    * @return {?}
    */
    function(id2, data) {
      return __awaiter(this, void 0, void 0, function() {
        var posts;
        var _this = this;
        return __generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              if (!data.imagePath)
                return [3, 2];
              return [4, this.getWhere("image", "==", data.imagePath).pipe(take(1)).toPromise()];
            case 1:
              posts = _a3.sent();
              if (posts.length > 1) {
                data.imagePath = null;
              }
              _a3.label = 2;
            case 2:
              return [2, new Promise(
                /**
                * @param {?} resolve
                * @param {?} reject
                * @return {?}
                */
                function(resolve2, reject) {
                  _this.deleteTranslation(data.translationId, data.lang, data.translations).then(
                    /**
                    * @return {?}
                    */
                    function() {
                      _this.db.deleteDocument("posts", id2).then(
                        /**
                        * @return {?}
                        */
                        function() {
                          _this.deleteImage(data.imagePath).then(
                            /**
                            * @return {?}
                            */
                            function() {
                              resolve2();
                            }
                          ).catch(
                            /**
                            * @param {?} error
                            * @return {?}
                            */
                            function(error) {
                              reject(error);
                            }
                          );
                        }
                      ).catch(
                        /**
                        * @param {?} error
                        * @return {?}
                        */
                        function(error) {
                          reject(error);
                        }
                      );
                    }
                  ).catch(
                    /**
                    * @param {?} error
                    * @return {?}
                    */
                    function(error) {
                      reject(error);
                    }
                  );
                }
              )];
          }
        });
      });
    };
    PostsService2.prototype.setStatus = /**
    * @param {?} id
    * @param {?} status
    * @return {?}
    */
    function(id2, status) {
      return this.db.setDocument("posts", id2, { status });
    };
    PostsService2.prototype.isSlugDuplicated = /**
    * @param {?} slug
    * @param {?} lang
    * @param {?=} id
    * @return {?}
    */
    function(slug, lang, id2) {
      var _this = this;
      return new Promise(
        /**
        * @param {?} resolve
        * @param {?} reject
        * @return {?}
        */
        function(resolve2, reject) {
          _this.getWhereFn(
            /**
            * @param {?} ref
            * @return {?}
            */
            function(ref) {
              return ref.where("slug", "==", slug).where("lang", "==", lang);
            }
          ).pipe(take(1)).toPromise().then(
            /**
            * @param {?} posts
            * @return {?}
            */
            function(posts) {
              resolve2(posts && posts.length && (!id2 || /** @type {?} */
              posts[0]["id"] !== id2));
            }
          ).catch(
            /**
            * @param {?} error
            * @return {?}
            */
            function(error) {
              reject(error);
            }
          );
        }
      );
    };
    PostsService2.prototype.countAll = /**
    * @return {?}
    */
    function() {
      return this.db.getDocumentsCount("posts");
    };
    PostsService2.prototype.countWhereFn = /**
    * @param {?} queryFn
    * @return {?}
    */
    function(queryFn) {
      return this.db.getDocumentsCount("posts", queryFn);
    };
    PostsService2.prototype.countWhere = /**
    * @param {?} field
    * @param {?} operator
    * @param {?} value
    * @return {?}
    */
    function(field, operator, value) {
      return this.countWhereFn(
        /**
        * @param {?} ref
        * @return {?}
        */
        function(ref) {
          return ref.where(field, operator, value);
        }
      );
    };
    PostsService2.decorators = [
      { type: Injectable }
    ];
    PostsService2.ctorParameters = function() {
      return [
        { type: DatabaseService },
        { type: StorageService2 },
        { type: SettingsService },
        { type: UsersService }
      ];
    };
    return PostsService2;
  }(DocumentTranslationsService)
);
if (false) {
  PostsService.prototype.allStatus;
  PostsService.prototype.statusColors;
  PostsService.prototype.imagesCache;
  PostsService.prototype.db;
  PostsService.prototype.storage;
  PostsService.prototype.settings;
  PostsService.prototype.users;
}
var PagesService = (
  /** @class */
  function(_super) {
    __extends(PagesService2, _super);
    function PagesService2(db2, settings, users) {
      var _this = _super.call(this, db2, "pageTranslations") || this;
      _this.db = db2;
      _this.settings = settings;
      _this.users = users;
      return _this;
    }
    PagesService2.prototype.formatBlocks = /**
    * @param {?} blocks
    * @return {?}
    */
    function(blocks) {
      var formattedBlocks = {};
      blocks.forEach(
        /**
        * @param {?} block
        * @param {?} index
        * @return {?}
        */
        function(block, index) {
          var key = block.key || index;
          if (formattedBlocks[key]) {
            key += "-" + index;
          }
          formattedBlocks[key] = {
            name: block.name,
            type: block.type,
            content: block.content
          };
        }
      );
      return formattedBlocks;
    };
    PagesService2.prototype.add = /**
    * @param {?} data
    * @param {?=} translationId
    * @return {?}
    */
    function(data, translationId) {
      var _this = this;
      var page = {
        title: data.title,
        lang: data.lang,
        slug: data.slug,
        blocks: data.blocks || {},
        createdAt: now(),
        // timestamp
        updatedAt: null,
        createdBy: this.db.currentUser.id,
        updatedBy: null
      };
      return new Promise(
        /**
        * @param {?} resolve
        * @param {?} reject
        * @return {?}
        */
        function(resolve2, reject) {
          _this.db.addDocument("pages", page).then(
            /**
            * @param {?} doc
            * @return {?}
            */
            function(doc) {
              _this.addTranslation(data.lang, doc.id, translationId).then(
                /**
                * @param {?} translation
                * @return {?}
                */
                function(translation) {
                  doc.set({ translationId: translationId || translation.id }, { merge: true }).then(
                    /**
                    * @return {?}
                    */
                    function() {
                      resolve2();
                    }
                  ).catch(
                    /**
                    * @param {?} error
                    * @return {?}
                    */
                    function(error) {
                      reject(error);
                    }
                  );
                }
              ).catch(
                /**
                * @param {?} error
                * @return {?}
                */
                function(error) {
                  reject(error);
                }
              );
            }
          ).catch(
            /**
            * @param {?} error
            * @return {?}
            */
            function(error) {
              reject(error);
            }
          );
        }
      );
    };
    PagesService2.prototype.translate = /**
    * @param {?} data
    * @return {?}
    */
    function(data) {
      return this.add(data, data.translationId);
    };
    PagesService2.prototype.get = /**
    * @param {?} id
    * @return {?}
    */
    function(id2) {
      var _this = this;
      return this.db.getDocument("pages", id2).pipe(mergeMap(
        /**
        * @param {?} page
        * @return {?}
        */
        function(page) {
          return __awaiter(_this, void 0, void 0, function() {
            var translations, _a3;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  if (!page.translationId)
                    return [3, 2];
                  return [4, this.getTranslations(page.translationId).pipe(take(1)).toPromise()];
                case 1:
                  _a3 = _b.sent();
                  return [3, 3];
                case 2:
                  _a3 = {};
                  _b.label = 3;
                case 3:
                  translations = _a3;
                  page.id = id2;
                  page.translations = translations;
                  return [2, page];
              }
            });
          });
        }
      ));
    };
    PagesService2.prototype.getTranslationLanguages = /**
    * @param {?} page
    * @return {?}
    */
    function(page) {
      var pageLanguages = Object.keys(page.translations);
      return this.settings.getActiveSupportedLanguages().filter(
        /**
        * @param {?} lang
        * @return {?}
        */
        function(lang) {
          return pageLanguages.indexOf(lang.key) === -1;
        }
      );
    };
    PagesService2.prototype.pipePages = /**
    * @private
    * @param {?} pagesObservable
    * @return {?}
    */
    function(pagesObservable) {
      var _this = this;
      return pagesObservable.pipe(mergeMap(
        /**
        * @param {?} pages
        * @return {?}
        */
        function(pages) {
          return __awaiter(_this, void 0, void 0, function() {
            var activeSupportedLanguages, _loop_1, this_1, pages_1, pages_1_1, page, e_1_1;
            var e_1, _a3;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  activeSupportedLanguages = this.settings.getActiveSupportedLanguages().map(
                    /**
                    * @param {?} lang
                    * @return {?}
                    */
                    function(lang) {
                      return lang.key;
                    }
                  );
                  _loop_1 = function(page2) {
                    var _a4, _b2, pageLanguages;
                    return __generator(this, function(_c) {
                      switch (_c.label) {
                        case 0:
                          _a4 = page2;
                          if (!page2.translationId)
                            return [3, 2];
                          return [4, this_1.getTranslations(page2.translationId).pipe(take(1)).toPromise()];
                        case 1:
                          _b2 = _c.sent();
                          return [3, 3];
                        case 2:
                          _b2 = {};
                          _c.label = 3;
                        case 3:
                          _a4.translations = _b2;
                          pageLanguages = Object.keys(page2.translations);
                          page2.author = page2.createdBy ? this_1.users.getFullName(page2.createdBy) : of(null);
                          page2.isTranslatable = !activeSupportedLanguages.every(
                            /**
                            * @param {?} lang
                            * @return {?}
                            */
                            function(lang) {
                              return pageLanguages.includes(lang);
                            }
                          );
                          return [
                            2
                            /*return*/
                          ];
                      }
                    });
                  };
                  this_1 = this;
                  _b.label = 1;
                case 1:
                  _b.trys.push([1, 6, 7, 8]);
                  pages_1 = __values(pages), pages_1_1 = pages_1.next();
                  _b.label = 2;
                case 2:
                  if (!!pages_1_1.done)
                    return [3, 5];
                  page = pages_1_1.value;
                  return [5, _loop_1(page)];
                case 3:
                  _b.sent();
                  _b.label = 4;
                case 4:
                  pages_1_1 = pages_1.next();
                  return [3, 2];
                case 5:
                  return [3, 8];
                case 6:
                  e_1_1 = _b.sent();
                  e_1 = { error: e_1_1 };
                  return [3, 8];
                case 7:
                  try {
                    if (pages_1_1 && !pages_1_1.done && (_a3 = pages_1.return))
                      _a3.call(pages_1);
                  } finally {
                    if (e_1)
                      throw e_1.error;
                  }
                  return [
                    7
                    /*endfinally*/
                  ];
                case 8:
                  return [2, pages];
              }
            });
          });
        }
      ));
    };
    PagesService2.prototype.getAll = /**
    * @return {?}
    */
    function() {
      return this.pipePages(this.db.getCollection("pages"));
    };
    PagesService2.prototype.getWhere = /**
    * @param {?} field
    * @param {?} operator
    * @param {?} value
    * @param {?=} applyPipe
    * @return {?}
    */
    function(field, operator, value, applyPipe) {
      if (applyPipe === void 0) {
        applyPipe = false;
      }
      return this.getWhereFn(
        /**
        * @param {?} ref
        * @return {?}
        */
        function(ref) {
          return ref.where(field, operator, value);
        },
        applyPipe
      );
    };
    PagesService2.prototype.getWhereFn = /**
    * @param {?} queryFn
    * @param {?=} applyPipe
    * @return {?}
    */
    function(queryFn, applyPipe) {
      if (applyPipe === void 0) {
        applyPipe = false;
      }
      var pagesObservable = this.db.getCollection("pages", queryFn);
      return applyPipe ? this.pipePages(pagesObservable) : pagesObservable;
    };
    PagesService2.prototype.edit = /**
    * @param {?} id
    * @param {?} data
    * @return {?}
    */
    function(id2, data) {
      var _this = this;
      var page = {
        title: data.title,
        lang: data.lang,
        slug: data.slug,
        //blocks: data.blocks || {}, // blocks should be replaced instead of been merged
        updatedAt: now(),
        updatedBy: this.db.currentUser.id
      };
      return new Promise(
        /**
        * @param {?} resolve
        * @param {?} reject
        * @return {?}
        */
        function(resolve2, reject) {
          _this.db.setDocument("pages", id2, page).then(
            /**
            * @return {?}
            */
            function() {
              _this.db.updateDocument("pages", id2, { blocks: data.blocks || {} }).then(
                /**
                * @return {?}
                */
                function() {
                  resolve2();
                }
              ).catch(
                /**
                * @param {?} error
                * @return {?}
                */
                function(error) {
                  reject(error);
                }
              );
            }
          ).catch(
            /**
            * @param {?} error
            * @return {?}
            */
            function(error) {
              reject(error);
            }
          );
        }
      );
    };
    PagesService2.prototype.delete = /**
    * @param {?} id
    * @param {?} data
    * @return {?}
    */
    function(id2, data) {
      var _this = this;
      return new Promise(
        /**
        * @param {?} resolve
        * @param {?} reject
        * @return {?}
        */
        function(resolve2, reject) {
          _this.deleteTranslation(data.translationId, data.lang, data.translations).then(
            /**
            * @return {?}
            */
            function() {
              _this.db.deleteDocument("pages", id2).then(
                /**
                * @return {?}
                */
                function() {
                  resolve2();
                }
              ).catch(
                /**
                * @param {?} error
                * @return {?}
                */
                function(error) {
                  reject(error);
                }
              );
            }
          ).catch(
            /**
            * @param {?} error
            * @return {?}
            */
            function(error) {
              reject(error);
            }
          );
        }
      );
    };
    PagesService2.prototype.isSlugDuplicated = /**
    * @param {?} slug
    * @param {?} lang
    * @param {?=} id
    * @return {?}
    */
    function(slug, lang, id2) {
      var _this = this;
      return new Promise(
        /**
        * @param {?} resolve
        * @param {?} reject
        * @return {?}
        */
        function(resolve2, reject) {
          _this.getWhereFn(
            /**
            * @param {?} ref
            * @return {?}
            */
            function(ref) {
              return ref.where("slug", "==", slug).where("lang", "==", lang);
            }
          ).pipe(take(1)).toPromise().then(
            /**
            * @param {?} pages
            * @return {?}
            */
            function(pages) {
              resolve2(pages && pages.length && (!id2 || /** @type {?} */
              pages[0]["id"] !== id2));
            }
          ).catch(
            /**
            * @param {?} error
            * @return {?}
            */
            function(error) {
              reject(error);
            }
          );
        }
      );
    };
    PagesService2.prototype.countAll = /**
    * @return {?}
    */
    function() {
      return this.db.getDocumentsCount("pages");
    };
    PagesService2.prototype.countWhereFn = /**
    * @param {?} queryFn
    * @return {?}
    */
    function(queryFn) {
      return this.db.getDocumentsCount("pages", queryFn);
    };
    PagesService2.prototype.countWhere = /**
    * @param {?} field
    * @param {?} operator
    * @param {?} value
    * @return {?}
    */
    function(field, operator, value) {
      return this.countWhereFn(
        /**
        * @param {?} ref
        * @return {?}
        */
        function(ref) {
          return ref.where(field, operator, value);
        }
      );
    };
    PagesService2.decorators = [
      { type: Injectable }
    ];
    PagesService2.ctorParameters = function() {
      return [
        { type: DatabaseService },
        { type: SettingsService },
        { type: UsersService }
      ];
    };
    return PagesService2;
  }(DocumentTranslationsService)
);
if (false) {
  PagesService.prototype.db;
  PagesService.prototype.settings;
  PagesService.prototype.users;
}
var TranslationsService = (
  /** @class */
  function() {
    function TranslationsService2(db2) {
      this.db = db2;
    }
    TranslationsService2.prototype.add = /**
    * @param {?} data
    * @return {?}
    */
    function(data) {
      var _a3;
      var translation = (_a3 = {}, _a3[data.key] = data.value, _a3);
      return this.db.setDocument("translations", data.lang, translation);
    };
    TranslationsService2.prototype.get = /**
    * @param {?} lang
    * @return {?}
    */
    function(lang) {
      return this.db.getDocument("translations", lang);
    };
    TranslationsService2.prototype.getAll = /**
    * @return {?}
    */
    function() {
      return this.db.getCollection("translations").pipe(map(
        /**
        * @param {?} translations
        * @return {?}
        */
        function(translations) {
          var allTranslations = [];
          translations.forEach(
            /**
            * @param {?} translation
            * @return {?}
            */
            function(translation) {
              var lang = translation.id;
              var keys = Object.keys(translation).filter(
                /**
                * @param {?} key
                * @return {?}
                */
                function(key) {
                  return key !== "id";
                }
              );
              keys.forEach(
                /**
                * @param {?} key
                * @return {?}
                */
                function(key) {
                  allTranslations.push({
                    key,
                    value: translation[key],
                    lang
                  });
                }
              );
            }
          );
          return allTranslations;
        }
      ));
    };
    TranslationsService2.prototype.getWhere = /**
    * @param {?} field
    * @param {?} operator
    * @param {?} value
    * @return {?}
    */
    function(field, operator, value) {
      return this.getWhereFn(
        /**
        * @param {?} ref
        * @return {?}
        */
        function(ref) {
          return ref.where(field, operator, value);
        }
      );
    };
    TranslationsService2.prototype.getWhereFn = /**
    * @param {?} queryFn
    * @return {?}
    */
    function(queryFn) {
      return this.db.getCollection("translations", queryFn);
    };
    TranslationsService2.prototype.edit = /**
    * @param {?} data
    * @return {?}
    */
    function(data) {
      return this.add(data);
    };
    TranslationsService2.prototype.delete = /**
    * @param {?} key
    * @param {?} lang
    * @return {?}
    */
    function(key, lang) {
      var _this = this;
      return new Promise(
        /**
        * @param {?} resolve
        * @param {?} reject
        * @return {?}
        */
        function(resolve2, reject) {
          return __awaiter(_this, void 0, void 0, function() {
            var translations;
            return __generator(this, function(_a3) {
              switch (_a3.label) {
                case 0:
                  return [4, this.get(lang).pipe(take(1)).toPromise()];
                case 1:
                  translations = _a3.sent();
                  if (translations[key]) {
                    delete translations[key];
                    this.db.setDocument("translations", lang, translations, false).then(
                      /**
                      * @return {?}
                      */
                      function() {
                        resolve2();
                      }
                    ).catch(
                      /**
                      * @param {?} error
                      * @return {?}
                      */
                      function(error) {
                        reject(error);
                      }
                    );
                  } else {
                    resolve2();
                  }
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        }
      );
    };
    TranslationsService2.prototype.keyExists = /**
    * @param {?} key
    * @param {?} lang
    * @return {?}
    */
    function(key, lang) {
      var _this = this;
      return new Promise(
        /**
        * @param {?} resolve
        * @param {?} reject
        * @return {?}
        */
        function(resolve2, reject) {
          _this.db.getDocumentRef("translations", lang).get().toPromise().then(
            /**
            * @param {?} doc
            * @return {?}
            */
            function(doc) {
              var translations = doc.data();
              if (translations && translations[key]) {
                resolve2(true);
              } else {
                resolve2(false);
              }
            }
          ).catch(
            /**
            * @param {?} error
            * @return {?}
            */
            function(error) {
              console.log(error);
              resolve2(false);
            }
          );
        }
      );
    };
    TranslationsService2.prototype.count = // async countAll() {
    //   const translations = await this.getAll().pipe(take(1)).toPromise();
    //   return translations ? translations.length : 0;
    // }
    // async countWhereFn(queryFn: QueryFn) {
    //   const translations = await this.getWhereFn(queryFn).pipe(take(1)).toPromise();
    //   return translations ? translations.length : 0;
    // }
    // countWhere(field: string, operator: firebase.firestore.WhereFilterOp, value: string) {
    //   return this.countWhereFn(ref => ref.where(field, operator, value));
    // }
    /**
     * @private
     * @param {?} docs
     * @return {?}
     */
    function(docs) {
      var count = 0;
      docs.forEach(
        /**
        * @param {?} doc
        * @return {?}
        */
        function(doc) {
          count += Object.keys(doc.data()).length;
        }
      );
      return count;
    };
    TranslationsService2.prototype.countAll = /**
    * @return {?}
    */
    function() {
      return __awaiter(this, void 0, void 0, function() {
        var docs;
        return __generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              return [4, this.db.getDocumentsDataAsPromise("translations")];
            case 1:
              docs = _a3.sent();
              return [2, this.count(docs)];
          }
        });
      });
    };
    TranslationsService2.prototype.countWhereFn = /**
    * @param {?} queryFn
    * @return {?}
    */
    function(queryFn) {
      return __awaiter(this, void 0, void 0, function() {
        var docs;
        return __generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              return [4, this.db.getDocumentsDataAsPromise("translations", queryFn)];
            case 1:
              docs = _a3.sent();
              return [2, this.count(docs)];
          }
        });
      });
    };
    TranslationsService2.prototype.countWhere = /**
    * @param {?} field
    * @param {?} operator
    * @param {?} value
    * @return {?}
    */
    function(field, operator, value) {
      return this.countWhereFn(
        /**
        * @param {?} ref
        * @return {?}
        */
        function(ref) {
          return ref.where(field, operator, value);
        }
      );
    };
    TranslationsService2.decorators = [
      { type: Injectable }
    ];
    TranslationsService2.ctorParameters = function() {
      return [
        { type: DatabaseService }
      ];
    };
    return TranslationsService2;
  }()
);
if (false) {
  TranslationsService.prototype.db;
}
var CategoriesService = (
  /** @class */
  function() {
    function CategoriesService2(db2) {
      this.db = db2;
    }
    CategoriesService2.prototype.add = /**
    * @param {?} data
    * @return {?}
    */
    function(data) {
      var category = {
        label: data.label,
        slug: data.slug,
        lang: data.lang,
        createdAt: now(),
        // timestamp
        updatedAt: null,
        createdBy: this.db.currentUser.id,
        updatedBy: null
      };
      return this.db.addDocument("categories", category);
    };
    CategoriesService2.prototype.get = /**
    * @param {?} id
    * @return {?}
    */
    function(id2) {
      return this.db.getDocument("categories", id2).pipe(map(
        /**
        * @param {?} category
        * @return {?}
        */
        function(category) {
          category.id = id2;
          return category;
        }
      ));
    };
    CategoriesService2.prototype.getAll = /**
    * @return {?}
    */
    function() {
      return this.db.getCollection("categories");
    };
    CategoriesService2.prototype.getWhere = /**
    * @param {?} field
    * @param {?} operator
    * @param {?} value
    * @return {?}
    */
    function(field, operator, value) {
      return this.db.getCollection(
        "categories",
        /**
        * @param {?} ref
        * @return {?}
        */
        function(ref) {
          return ref.where(field, operator, value);
        }
      );
    };
    CategoriesService2.prototype.edit = /**
    * @param {?} id
    * @param {?} data
    * @return {?}
    */
    function(id2, data) {
      var category = {
        label: data.label,
        slug: data.slug,
        lang: data.lang,
        updatedAt: now(),
        updatedBy: this.db.currentUser.id
      };
      return this.db.setDocument("categories", id2, category);
    };
    CategoriesService2.prototype.delete = /**
    * @param {?} id
    * @return {?}
    */
    function(id2) {
      return this.db.deleteDocument("categories", id2);
    };
    CategoriesService2.decorators = [
      { type: Injectable }
    ];
    CategoriesService2.ctorParameters = function() {
      return [
        { type: DatabaseService }
      ];
    };
    return CategoriesService2;
  }()
);
if (false) {
  CategoriesService.prototype.db;
}
function initPieChart(selector, data, labels, backgroundColor, hoverBorderColor) {
  if (backgroundColor === void 0) {
    backgroundColor = [];
  }
  if (hoverBorderColor === void 0) {
    hoverBorderColor = "#ffffff";
  }
  var canvas = document.querySelector(selector);
  if (backgroundColor.length === 0) {
    backgroundColor = [
      "rgba(0,123,255,0.9)",
      "rgba(0,123,255,0.5)",
      "rgba(0,123,255,0.3)"
    ];
  }
  var chart = new Chart(canvas, {
    type: "pie",
    data: {
      datasets: [
        {
          hoverBorderColor,
          data,
          backgroundColor
        }
      ],
      labels
    },
    options: {
      legend: { position: "bottom", labels: { padding: 25, boxWidth: 20 } },
      cutoutPercentage: 0,
      tooltips: { custom: false, mode: "index", position: "nearest" }
    }
  });
  return chart;
}
var DashboardComponent = (
  /** @class */
  function() {
    function DashboardComponent2(posts, pages, users, translations, categories, settings, navigation, currentUser, i18n) {
      this.posts = posts;
      this.pages = pages;
      this.users = users;
      this.translations = translations;
      this.categories = categories;
      this.settings = settings;
      this.navigation = navigation;
      this.currentUser = currentUser;
      this.i18n = i18n;
      this.statistics = {};
      this.allPostsCategories = [];
      this.subscription = new Subscription();
      this.postsLanguageChange = new Subject();
      this.postsByStatusLanguageChange = new Subject();
    }
    DashboardComponent2.prototype.ngOnInit = /**
    * @return {?}
    */
    function() {
      var _this = this;
      this.getStatistics();
      this.languages = this.settings.getActiveSupportedLanguages();
      this.postsLanguage = "*";
      this.postsByStatusLanguage = "*";
      this.allPostsStatus = this.posts.getAllStatusWithColors();
      this.subscription.add(this.categories.getAll().pipe(map(
        /**
        * @param {?} categories
        * @return {?}
        */
        function(categories) {
          var allCategories = [];
          categories.forEach(
            /**
            * @param {?} category
            * @return {?}
            */
            function(category) {
              allCategories[category.id] = category;
            }
          );
          return allCategories;
        }
      )).subscribe(
        /**
        * @param {?} categories
        * @return {?}
        */
        function(categories) {
          _this.allPostsCategories = categories;
        }
      ));
      this.getLatestPosts();
      this.getPostsByStatus();
    };
    DashboardComponent2.prototype.ngOnDestroy = /**
    * @return {?}
    */
    function() {
      this.subscription.unsubscribe();
      this.postsLanguageChange.next();
      this.postsByStatusLanguageChange.next();
    };
    DashboardComponent2.prototype.getStatistics = /**
    * @private
    * @return {?}
    */
    function() {
      return __awaiter(this, void 0, void 0, function() {
        var _a3, _b, _c, _d;
        return __generator(this, function(_e2) {
          switch (_e2.label) {
            case 0:
              _a3 = this.statistics;
              return [4, this.posts.countAll()];
            case 1:
              _a3.posts = _e2.sent();
              _b = this.statistics;
              return [4, this.pages.countAll()];
            case 2:
              _b.pages = _e2.sent();
              this.statistics.comments = 0;
              if (!this.currentUser.isAdmin())
                return [3, 4];
              _c = this.statistics;
              return [4, this.users.countAll()];
            case 3:
              _c.users = _e2.sent();
              _e2.label = 4;
            case 4:
              _d = this.statistics;
              return [4, this.translations.countAll()];
            case 5:
              _d.translations = _e2.sent();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    DashboardComponent2.prototype.getLatestPosts = /**
    * @private
    * @return {?}
    */
    function() {
      var _this = this;
      this.latestPosts = this.posts.getWhereFn(
        /**
        * @param {?} ref
        * @return {?}
        */
        function(ref) {
          var query = ref;
          if (_this.postsLanguage !== "*") {
            query = query.where("lang", "==", _this.postsLanguage);
          }
          return query;
        },
        true
      ).pipe(map(
        /**
        * @param {?} posts
        * @return {?}
        */
        function(posts) {
          return posts.sort(
            /**
            * @param {?} a
            * @param {?} b
            * @return {?}
            */
            function(a, b2) {
              return b2.createdAt - a.createdAt;
            }
          ).slice(0, 5);
        }
      ), takeUntil(this.postsLanguageChange));
    };
    DashboardComponent2.prototype.onPostsLanguageChange = /**
    * @return {?}
    */
    function() {
      this.postsLanguageChange.next();
      this.getLatestPosts();
    };
    DashboardComponent2.prototype.getPostsByStatus = /**
    * @private
    * @return {?}
    */
    function() {
      var _this = this;
      this.postsByStatus = this.posts.getWhereFn(
        /**
        * @param {?} ref
        * @return {?}
        */
        function(ref) {
          var query = ref;
          if (_this.postsByStatusLanguage !== "*") {
            query = query.where("lang", "==", _this.postsByStatusLanguage);
          }
          return query;
        },
        true
      ).pipe(map(
        /**
        * @param {?} posts
        * @return {?}
        */
        function(posts) {
          var postsByStatus = [];
          Object.keys(PostStatus).forEach(
            /**
            * @param {?} key
            * @return {?}
            */
            function(key) {
              postsByStatus[PostStatus[key]] = {
                label: key,
                count: 0
              };
            }
          );
          posts.forEach(
            /**
            * @param {?} post
            * @return {?}
            */
            function(post) {
              postsByStatus[post.status].count += 1;
            }
          );
          return postsByStatus;
        }
      ), takeUntil(this.postsByStatusLanguageChange));
      this.subscription.add(this.postsByStatus.subscribe(
        /**
        * @param {?} postsByStatus
        * @return {?}
        */
        function(postsByStatus) {
          var data = Object.keys(postsByStatus).map(
            /**
            * @param {?} key
            * @return {?}
            */
            function(key) {
              return postsByStatus[key].count;
            }
          );
          var labels = Object.keys(postsByStatus).map(
            /**
            * @param {?} key
            * @return {?}
            */
            function(key) {
              return _this.i18n.get(postsByStatus[key].label);
            }
          );
          setTimeout(
            /**
            * @return {?}
            */
            function() {
              initPieChart("#posts-by-status", data, labels);
            },
            0
          );
        }
      ));
    };
    DashboardComponent2.prototype.onPostsByStatusLanguageChange = /**
    * @return {?}
    */
    function() {
      this.postsByStatusLanguageChange.next();
      this.getPostsByStatus();
    };
    DashboardComponent2.decorators = [
      { type: Component, args: [{
        selector: "fa-dashboard",
        template: `<fa-layout>
  <!-- Page Header -->
  <div class="page-header row no-gutters py-4">
    <div class="col-12 col-sm-4 text-center text-sm-left mb-0">
      <span class="text-uppercase page-subtitle">{{ 'Dashboard' | translate }}</span>
    </div>
  </div>
  <!-- End Page Header -->
  <!-- Small Stats Blocks -->
  <div class="row">
    <div class="col-lg col-md-6 col-sm-6 mb-4">
      <div class="stats-small stats-small--1 card card-small">
        <div class="card-body p-0 d-flex">
          <div class="d-flex flex-column m-auto">
            <div class="stats-small__data text-center">
              <span class="stats-small__label text-uppercase">{{ 'Posts' | translate }}</span>
              <h6 class="stats-small__value count my-3">{{ statistics?.posts || 0 }}</h6>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="col-lg col-md-6 col-sm-6 mb-4">
      <div class="stats-small stats-small--1 card card-small">
        <div class="card-body p-0 d-flex">
          <div class="d-flex flex-column m-auto">
            <div class="stats-small__data text-center">
              <span class="stats-small__label text-uppercase">{{ 'Pages' | translate }}</span>
              <h6 class="stats-small__value count my-3">{{ statistics?.pages || 0 }}</h6>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="col-lg col-md-4 col-sm-6 mb-4">
      <div class="stats-small stats-small--1 card card-small">
        <div class="card-body p-0 d-flex">
          <div class="d-flex flex-column m-auto">
            <div class="stats-small__data text-center">
              <span class="stats-small__label text-uppercase">{{ 'Comments' | translate }}</span>
              <h6 class="stats-small__value count my-3">{{ statistics?.comments || 0 }}</h6>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="col-lg col-md-4 col-sm-6 mb-4" *ngIf="currentUser?.isAdmin()">
      <div class="stats-small stats-small--1 card card-small">
        <div class="card-body p-0 d-flex">
          <div class="d-flex flex-column m-auto">
            <div class="stats-small__data text-center">
              <span class="stats-small__label text-uppercase">{{ 'Users' | translate }}</span>
              <h6 class="stats-small__value count my-3">{{ statistics?.users || 0 }}</h6>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="col-lg col-md-4 mb-4" [ngClass]="currentUser?.isAdmin() ? 'col-sm-12' : 'col-sm-6'">
      <div class="stats-small stats-small--1 card card-small">
        <div class="card-body p-0 d-flex">
          <div class="d-flex flex-column m-auto">
            <div class="stats-small__data text-center">
              <span class="stats-small__label text-uppercase">{{ 'Translations' | translate }}</span>
              <h6 class="stats-small__value count my-3">{{ statistics?.translations || 0 }}</h6>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <!-- End Small Stats Blocks -->
  <div class="row">
    <!-- Latest Posts -->
    <div class="col-lg-8 col-md-12 col-sm-12 mb-4">
      <div class="card card-small lo-stats">
        <div class="card-header border-bottom">
          <h6 class="m-0">{{ 'LatestPosts' | translate }}</h6>
          <div class="block-handle"></div>
        </div>
        <div class="card-body p-0">
          <table class="table mb-0">
            <thead class="py-2 bg-light text-semibold border-bottom">
              <tr>
                <th class="text-left" colspan="2">{{ 'PostTitle' | translate }}</th>
                <th class="text-center">{{ 'PostDate' | translate }}</th>
                <th class="text-center">{{ 'PostStatus' | translate }}</th>
                <th class="text-center">{{ 'Categories' | translate }}</th>
                <th class="text-right">{{ 'Actions' | translate }}</th>
              </tr>
            </thead>
            <tbody>
              <ng-container *ngIf="latestPosts | async as posts; else loadingPostsTemplate">
                <tr *ngFor="let post of posts">
                  <td class="lo-stats__image">
                    <img class="border rounded" [src]="post.image.url | async | escapeUrl">
                  </td>
                  <td class="lo-stats__order-details">
                    <span>{{ post.title }}</span>
                    <span>{{ '/' + post.slug }}</span>
                  </td>
                  <td class="text-center">{{ post.date | shortdate }}</td>
                  <td class="text-center">
                    <span class="badge badge-pill badge-{{ allPostsStatus.colors[post.status] || 'primary' }}">{{ allPostsStatus.labels[post.status] | translate }}</span>
                  </td>
                  <td class="text-center text-primary">
                    <ng-container *ngFor="let categoryId of post.categories; let i = index">
                      <i *ngIf="i > 0">, </i>
                      <a [routerLink]="navigation.getRouterLink('posts', 'list', 'category', categoryId)">{{ allPostsCategories[categoryId]?.label }}</a>
                    </ng-container>
                  </td>
                  <td class="text-right">
                    <div class="btn-group btn-group-sm" role="group" aria-label="Table row actions">
                      <button *ngIf="post.isTranslatable" type="button" class="btn btn-white active-light" title="{{ 'Translate' | translate }}" [routerLink]="navigation.getRouterLink('posts', 'translate', post.id)">
                        <i class="material-icons">translate</i>
                      </button>
                      <button type="button" class="btn btn-white active-light" title="{{ 'Edit' | translate }}" [routerLink]="navigation.getRouterLink('posts', 'edit', post.id)">
                        <i class="material-icons">edit</i>
                      </button>
                    </div>
                  </td>
                </tr>
              </ng-container>
              <ng-template #loadingPostsTemplate>
                <tr>
                  <td class="text-center" colspan="6">
                    <fa-loading-indicator size="1x"></fa-loading-indicator>
                  </td>
                </tr>
              </ng-template>
            </tbody>
          </table>
        </div>
        <div class="card-footer border-top">
          <div class="row">
            <div class="col">
              <select class="custom-select custom-select-sm w-auto" style="min-width: 130px" [(ngModel)]="postsLanguage" name="postsLanguage" (change)="onPostsLanguageChange()">
                <option value="" disabled>{{ 'PostLanguage' | translate }}</option>
                <option value="*">{{ 'All' | translate }}</option>
                <option *ngFor="let lang of languages" [value]="lang.key">{{ lang.label | translate }}</option>
              </select>
            </div>
            <div class="col text-right view-report">
              <a [routerLink]="navigation.getRouterLink('posts', 'list')">{{ 'FullList' | translate }} &rarr;</a>
            </div>
          </div>
        </div>
      </div>
    </div>
    <!-- End Latest Posts -->
    <!-- Posts By Status Stats -->
    <div class="col-lg-4 col-md-6 col-sm-12 mb-4">
      <div class="card card-small h-100">
        <div class="card-header border-bottom">
          <h6 class="m-0">{{ 'PostsByStatus' | translate }}</h6>
        </div>
        <div class="card-body d-flex py-0">
          <ng-container *ngIf="postsByStatus | async; else loadingPostsByStatusTemplate">
            <canvas height="220" id="posts-by-status" class="m-auto"></canvas>
          </ng-container>
          <ng-template #loadingPostsByStatusTemplate>
            <fa-loading-indicator size="1x" center="true"></fa-loading-indicator>
          </ng-template>
        </div>
        <div class="card-footer border-top">
          <div class="row">
            <div class="col">
              <select class="custom-select custom-select-sm w-auto" style="min-width: 130px" [(ngModel)]="postsByStatusLanguage" name="postsByStatusLanguage" (change)="onPostsByStatusLanguageChange()">
                <option value="" disabled>{{ 'PostLanguage' | translate }}</option>
                <option value="*">{{ 'All' | translate }}</option>
                <option *ngFor="let lang of languages" [value]="lang.key">{{ lang.label | translate }}</option>
              </select>
            </div>
            <div class="col text-right view-report">
              <a [routerLink]="navigation.getRouterLink('posts', 'list')">{{ 'List' | translate }} &rarr;</a>
            </div>
          </div>
        </div>
      </div>
    </div>
    <!-- End Posts By Status Stats -->
  </div>
</fa-layout>
`,
        styles: [""]
      }] }
    ];
    DashboardComponent2.ctorParameters = function() {
      return [
        { type: PostsService },
        { type: PagesService },
        { type: UsersService },
        { type: TranslationsService },
        { type: CategoriesService },
        { type: SettingsService },
        { type: NavigationService },
        { type: CurrentUserService },
        { type: I18nService }
      ];
    };
    return DashboardComponent2;
  }()
);
if (false) {
  DashboardComponent.prototype.statistics;
  DashboardComponent.prototype.latestPosts;
  DashboardComponent.prototype.postsLanguage;
  DashboardComponent.prototype.postsByStatus;
  DashboardComponent.prototype.postsByStatusLanguage;
  DashboardComponent.prototype.languages;
  DashboardComponent.prototype.allPostsStatus;
  DashboardComponent.prototype.allPostsCategories;
  DashboardComponent.prototype.subscription;
  DashboardComponent.prototype.postsLanguageChange;
  DashboardComponent.prototype.postsByStatusLanguageChange;
  DashboardComponent.prototype.posts;
  DashboardComponent.prototype.pages;
  DashboardComponent.prototype.users;
  DashboardComponent.prototype.translations;
  DashboardComponent.prototype.categories;
  DashboardComponent.prototype.settings;
  DashboardComponent.prototype.navigation;
  DashboardComponent.prototype.currentUser;
  DashboardComponent.prototype.i18n;
}
var AuthGuard = (
  /** @class */
  function() {
    function AuthGuard2(auth2, navigation) {
      this.auth = auth2;
      this.navigation = navigation;
    }
    AuthGuard2.prototype.canActivate = /**
    * @param {?} route
    * @param {?} state
    * @return {?}
    */
    function(route, state) {
      var _this = this;
      return new Promise(
        /**
        * @param {?} resolve
        * @param {?} reject
        * @return {?}
        */
        function(resolve2, reject) {
          return __awaiter(_this, void 0, void 0, function() {
            var isSignedIn;
            return __generator(this, function(_a3) {
              switch (_a3.label) {
                case 0:
                  return [4, this.auth.isSignedIn()];
                case 1:
                  isSignedIn = _a3.sent();
                  if (!isSignedIn) {
                    this.navigation.redirectTo("login");
                    resolve2(false);
                  } else {
                    resolve2(true);
                  }
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        }
      );
    };
    AuthGuard2.decorators = [
      { type: Injectable }
    ];
    AuthGuard2.ctorParameters = function() {
      return [
        { type: AuthService },
        { type: NavigationService }
      ];
    };
    return AuthGuard2;
  }()
);
if (false) {
  AuthGuard.prototype.auth;
  AuthGuard.prototype.navigation;
}
var ConfigService = (
  /** @class */
  function() {
    function ConfigService2(db2) {
      this.db = db2;
    }
    ConfigService2.prototype.getAll = /**
    * @return {?}
    */
    function() {
      return this.db.getCollectionRef("config").get().toPromise();
    };
    ConfigService2.prototype.get = /**
    * @param {?} documentPath
    * @param {...?} keys
    * @return {?}
    */
    function(documentPath) {
      var keys = [];
      for (var _i2 = 1; _i2 < arguments.length; _i2++) {
        keys[_i2 - 1] = arguments[_i2];
      }
      return __awaiter(this, void 0, void 0, function() {
        var doc, data;
        return __generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              return [4, this.db.getDocumentRef("config", documentPath).get().toPromise()];
            case 1:
              doc = _a3.sent();
              data = doc.data();
              return [2, keys.length ? resolve.apply(void 0, __spread([data], keys)) : data];
          }
        });
      });
    };
    ConfigService2.prototype.set = /**
    * @param {?} documentPath
    * @param {?} data
    * @return {?}
    */
    function(documentPath, data) {
      return this.db.setDocument("config", documentPath, data);
    };
    ConfigService2.prototype.isRegistrationEnabled = /**
    * @return {?}
    */
    function() {
      return __awaiter(this, void 0, void 0, function() {
        var enabled;
        return __generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              return [4, this.get("registration", "enabled")];
            case 1:
              enabled = _a3.sent();
              return [2, enabled === false ? false : true];
          }
        });
      });
    };
    ConfigService2.decorators = [
      { type: Injectable }
    ];
    ConfigService2.ctorParameters = function() {
      return [
        { type: DatabaseService }
      ];
    };
    return ConfigService2;
  }()
);
if (false) {
  ConfigService.prototype.db;
}
var LoginGuard = (
  /** @class */
  function() {
    function LoginGuard2(auth2, navigation, config2) {
      this.auth = auth2;
      this.navigation = navigation;
      this.config = config2;
    }
    LoginGuard2.prototype.canActivate = /**
    * @param {?} route
    * @param {?} state
    * @return {?}
    */
    function(route, state) {
      var _this = this;
      return new Promise(
        /**
        * @param {?} resolve
        * @param {?} reject
        * @return {?}
        */
        function(resolve2, reject) {
          return __awaiter(_this, void 0, void 0, function() {
            var isSignedIn, registrationEnabled;
            return __generator(this, function(_a3) {
              switch (_a3.label) {
                case 0:
                  return [4, this.auth.isSignedIn()];
                case 1:
                  isSignedIn = _a3.sent();
                  if (!isSignedIn)
                    return [3, 2];
                  this.navigation.redirectTo("dashboard");
                  resolve2(false);
                  return [3, 4];
                case 2:
                  return [4, this.config.isRegistrationEnabled()];
                case 3:
                  registrationEnabled = _a3.sent();
                  if (!registrationEnabled) {
                    resolve2(true);
                  } else {
                    this.navigation.redirectTo("register");
                    resolve2(false);
                  }
                  _a3.label = 4;
                case 4:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        }
      );
    };
    LoginGuard2.decorators = [
      { type: Injectable }
    ];
    LoginGuard2.ctorParameters = function() {
      return [
        { type: AuthService },
        { type: NavigationService },
        { type: ConfigService }
      ];
    };
    return LoginGuard2;
  }()
);
if (false) {
  LoginGuard.prototype.auth;
  LoginGuard.prototype.navigation;
  LoginGuard.prototype.config;
}
function refreshDataTable(dataTableElement, dataTableTrigger, forceClear) {
  clearDataTable(dataTableElement, forceClear).then(
    /**
    * @return {?}
    */
    function() {
      dataTableTrigger.next();
    }
  );
}
function clearDataTable(dataTableElement, force) {
  return new Promise(
    /**
    * @param {?} resolve
    * @param {?} reject
    * @return {?}
    */
    function(resolve2, reject) {
      if (dataTableElement.dtInstance) {
        dataTableElement.dtInstance.then(
          /**
          * @param {?} dtInstance
          * @return {?}
          */
          function(dtInstance) {
            if (force || dtInstance.data().any()) {
              dtInstance.clear().destroy();
            }
            resolve2();
          }
        );
      } else {
        resolve2();
      }
    }
  );
}
var PostsListComponent = (
  /** @class */
  function() {
    function PostsListComponent2(posts, categories, alert, i18n, route, navigation, currentUser, settings) {
      this.posts = posts;
      this.categories = categories;
      this.alert = alert;
      this.i18n = i18n;
      this.route = route;
      this.navigation = navigation;
      this.currentUser = currentUser;
      this.settings = settings;
      this.selectedPost = null;
      this.dataTableOptions = {
        responsive: true,
        aaSorting: []
      };
      this.dataTableTrigger = new Subject();
      this.subscription = new Subscription();
      this.allCategories = [];
      this.allLanguages = [];
      this.routeParamsChange = new Subject();
      this.isLoading = true;
    }
    PostsListComponent2.prototype.ngOnInit = /**
    * @return {?}
    */
    function() {
      var _this = this;
      this.allStatus = this.posts.getAllStatusWithColors();
      this.subscription.add(this.categories.getAll().pipe(map(
        /**
        * @param {?} categories
        * @return {?}
        */
        function(categories) {
          var allCategories = [];
          categories.forEach(
            /**
            * @param {?} category
            * @return {?}
            */
            function(category) {
              allCategories[category.id] = category;
            }
          );
          return allCategories;
        }
      )).subscribe(
        /**
        * @param {?} categories
        * @return {?}
        */
        function(categories) {
          _this.allCategories = categories;
        }
      ));
      this.settings.supportedLanguages.forEach(
        /**
        * @param {?} language
        * @return {?}
        */
        function(language) {
          _this.allLanguages[language.key] = language;
        }
      );
      this.subscription.add(this.route.params.subscribe(
        /**
        * @param {?} params
        * @return {?}
        */
        function(params) {
          _this.routeParamsChange.next();
          _this.isLoading = true;
          _this.allPosts = _this.posts.getWhereFn(
            /**
            * @param {?} ref
            * @return {?}
            */
            function(ref) {
              var query = ref;
              if (params.status) {
                query = query.where("status", "==", params.status);
              } else if (params.categoryId) {
                query = query.where("categories", "array-contains", params.categoryId);
              } else if (params.authorId) {
                query = query.where("createdBy", "==", params.authorId);
              }
              return query;
            },
            true
          ).pipe(map(
            /**
            * @param {?} posts
            * @return {?}
            */
            function(posts) {
              return posts.sort(
                /**
                * @param {?} a
                * @param {?} b
                * @return {?}
                */
                function(a, b2) {
                  return b2.createdAt - a.createdAt;
                }
              );
            }
          ), takeUntil(_this.routeParamsChange));
          _this.subscription.add(_this.allPosts.subscribe(
            /**
            * @param {?} posts
            * @return {?}
            */
            function(posts) {
              refreshDataTable(_this.dataTableElement, _this.dataTableTrigger);
              _this.isLoading = false;
            }
          ));
        }
      ));
    };
    PostsListComponent2.prototype.ngOnDestroy = /**
    * @return {?}
    */
    function() {
      this.dataTableTrigger.unsubscribe();
      this.subscription.unsubscribe();
      this.routeParamsChange.next();
    };
    PostsListComponent2.prototype.setPostStatus = /**
    * @private
    * @param {?} event
    * @param {?} post
    * @param {?} status
    * @return {?}
    */
    function(event, post, status) {
      var _this = this;
      var target = (
        /** @type {?} */
        event.target
      );
      target.disabled = true;
      this.posts.setStatus(post.id, status).catch(
        /**
        * @param {?} error
        * @return {?}
        */
        function(error) {
          _this.alert.error(error.message);
          target.disabled = false;
        }
      );
    };
    PostsListComponent2.prototype.publishPost = /**
    * @param {?} event
    * @param {?} post
    * @return {?}
    */
    function(event, post) {
      this.setPostStatus(event, post, PostStatus.Published);
    };
    PostsListComponent2.prototype.moveToTrash = /**
    * @param {?} event
    * @param {?} post
    * @return {?}
    */
    function(event, post) {
      this.setPostStatus(event, post, PostStatus.Trash);
    };
    PostsListComponent2.prototype.deletePost = /**
    * @param {?} post
    * @return {?}
    */
    function(post) {
      var _this = this;
      this.posts.delete(post.id, {
        imagePath: (
          /** @type {?} */
          /** @type {?} */
          post.image.path
        ),
        lang: post.lang,
        translationId: post.translationId,
        translations: post.translations
      }).then(
        /**
        * @return {?}
        */
        function() {
          _this.alert.success(_this.i18n.get("PostDeleted", { title: post.title }), false, 5e3);
        }
      ).catch(
        /**
        * @param {?} error
        * @return {?}
        */
        function(error) {
          _this.alert.error(error.message);
        }
      );
    };
    PostsListComponent2.decorators = [
      { type: Component, args: [{
        selector: "fa-posts-list",
        template: `<fa-layout>
  <!-- Page Header -->
  <div class="page-header row no-gutters py-4">
    <div class="col-12 text-center text-sm-left mb-0">
      <span class="text-uppercase page-subtitle">{{ 'Posts' | translate }}</span>
      <h3 class="page-title">{{ 'List' | translate }}</h3>
    </div>
  </div>
  <!-- End Page Header -->
  <fa-loading-indicator [show]="isLoading" [center]="true"></fa-loading-indicator>
  <div class="row">
    <div class="col-12 mb-4">
      <div class="card card-small lo-stats">
        <div class="card-body p-0">
          <table datatable [dtOptions]="dataTableOptions" [dtTrigger]="dataTableTrigger" class="file-manager file-manager-list d-none table-responsive">
            <thead>
              <tr>
                <th class="hide-sort-icons"></th>
                <th class="text-left">{{ 'PostTitle' | translate }}</th>
                <th>{{ 'PostDate' | translate }}</th>
                <th>{{ 'PostStatus' | translate }}</th>
                <th>{{ 'PostLanguage' | translate }}</th>
                <th>{{ 'Categories' | translate }}</th>
                <th>{{ 'PostCreatedAt' | translate }}</th>
                <th>{{ 'PostUpdatedAt' | translate }}</th>
                <th *ngIf="currentUser?.isAdmin()">{{ 'PostAuthor' | translate }}</th>
                <th class="text-right hide-sort-icons">{{ 'Actions' | translate }}</th>
              </tr>
            </thead>
            <tbody>
              <tr *ngFor="let post of allPosts | async">
                <td class="text-left lo-stats__image pr-0">
                  <img class="border rounded" [src]="post.image.url | async | escapeUrl">
                </td>
                <td class="text-left lo-stats__order-details">
                  <span>{{ post.title }}</span>
                  <span>{{ '/' + post.slug }}</span>
                </td>
                <td>{{ post.date | shortdate }}</td>
                <td>
                  <a [routerLink]="navigation.getRouterLink('posts', 'list', 'status', post.status)">
                    <span class="badge badge-pill badge-{{ allStatus.colors[post.status] || 'primary' }}">{{ allStatus.labels[post.status] | translate }}</span>
                  </a>
                </td>
                <td>{{ allLanguages[post.lang].label | translate }}</td>
                <td>
                  <ng-container *ngFor="let categoryId of post.categories; let i = index">
                    <i *ngIf="i > 0">, </i>
                    <a [routerLink]="navigation.getRouterLink('posts', 'list', 'category', categoryId)">{{ allCategories[categoryId]?.label }}</a>
                  </ng-container>
                </td>
                <td>{{ post.createdAt | datetime }}</td>
                <td>{{ post.updatedAt | datetime }}</td>
                <td *ngIf="currentUser?.isAdmin()">
                  <a *ngIf="post.createdBy" [routerLink]="navigation.getRouterLink('users', 'profile', post.createdBy)">
                    {{ post.author | async }}
                  </a>
                </td>
                <td class="text-right">
                  <div class="btn-group btn-group-sm" role="group" aria-label="Table row actions">
                    <button *ngIf="post.status !== 'published'" type="button" class="btn btn-white active-light" title="{{ 'Publish' | translate }}" (click)="publishPost($event, post)">
                      <i class="material-icons">check</i>
                    </button>
                    <button *ngIf="post.isTranslatable" type="button" class="btn btn-white active-light" title="{{ 'Translate' | translate }}" [routerLink]="navigation.getRouterLink('posts', 'translate', post.id)">
                      <i class="material-icons">translate</i>
                    </button>
                    <button type="button" class="btn btn-white active-light" title="{{ 'Edit' | translate }}" [routerLink]="navigation.getRouterLink('posts', 'edit', post.id)">
                      <i class="material-icons">edit</i>
                    </button>
                    <ng-container *ngIf="post.status !== 'trash'; else deleteButton">
                      <button type="button" class="btn btn-white" title="{{ 'MoveToTrash' | translate }}" (click)="moveToTrash($event, post)">
                        <i class="material-icons">delete</i>
                      </button>
                    </ng-container>
                    <ng-template #deleteButton>
                      <button type="button" class="btn btn-danger" title="{{ 'Delete' | translate }}" data-toggle="modal" data-target="#deleteModal" (click)="selectedPost = post">
                        <i class="material-icons">delete_forever</i>
                      </button>
                    </ng-template>
                  </div>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
</fa-layout>

<!-- Delete Modal -->
<div class="modal fade" id="deleteModal" tabindex="-1" role="dialog" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">{{ 'DeletePost' | translate }}</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">×</span>
        </button>
      </div>
      <div class="modal-body" innerHTML="{{ 'ConfirmDeletePost' | translate: {title: selectedPost?.title} }}"></div>
      <div class="modal-footer">
        <button type="button" class="btn btn-white" data-dismiss="modal">{{ 'Cancel' | translate }}</button>
        <button type="button" class="btn btn-danger" data-dismiss="modal" (click)="deletePost(selectedPost)">{{ 'Delete' | translate }}</button>
      </div>
    </div>
  </div>
</div>
`,
        styles: [".lo-stats__order-details{min-width:200px}"]
      }] }
    ];
    PostsListComponent2.ctorParameters = function() {
      return [
        { type: PostsService },
        { type: CategoriesService },
        { type: AlertService },
        { type: I18nService },
        { type: ActivatedRoute },
        { type: NavigationService },
        { type: CurrentUserService },
        { type: SettingsService }
      ];
    };
    PostsListComponent2.propDecorators = {
      dataTableElement: [{ type: ViewChild, args: [DataTableDirective, { static: false }] }]
    };
    return PostsListComponent2;
  }()
);
if (false) {
  PostsListComponent.prototype.allPosts;
  PostsListComponent.prototype.selectedPost;
  PostsListComponent.prototype.dataTableElement;
  PostsListComponent.prototype.dataTableOptions;
  PostsListComponent.prototype.dataTableTrigger;
  PostsListComponent.prototype.subscription;
  PostsListComponent.prototype.allStatus;
  PostsListComponent.prototype.allCategories;
  PostsListComponent.prototype.allLanguages;
  PostsListComponent.prototype.routeParamsChange;
  PostsListComponent.prototype.isLoading;
  PostsListComponent.prototype.posts;
  PostsListComponent.prototype.categories;
  PostsListComponent.prototype.alert;
  PostsListComponent.prototype.i18n;
  PostsListComponent.prototype.route;
  PostsListComponent.prototype.navigation;
  PostsListComponent.prototype.currentUser;
  PostsListComponent.prototype.settings;
}
function initTextEditor(selector, placeholder) {
  if (placeholder === void 0) {
    placeholder = "";
  }
  var quill = new Quill(selector, {
    modules: {
      toolbar: {
        container: [
          [{ header: [1, 2, 3, 4, 5, false] }],
          ["bold", "italic", "underline", "strike"],
          ["blockquote", "code-block"],
          //[{ header: 1 }, { header: 2 }],
          [{ list: "ordered" }, { list: "bullet" }],
          //[{ script: "sub" }, { script: "super" }],
          [{ color: [] }, { background: [] }],
          [{ align: [] }],
          [{ indent: "-1" }, { indent: "+1" }],
          ["link", "image", "video"],
          ["html"]
        ],
        handlers: {
          "html": (
            /**
            * @return {?}
            */
            function() {
            }
          )
        }
      }
    },
    placeholder,
    theme: "snow"
  });
  var htmlButton = document.querySelector(".ql-html");
  htmlButton.addEventListener(
    "click",
    /**
    * @return {?}
    */
    function() {
      var htmlEditor = document.querySelector(".ql-html-editor");
      if (htmlEditor) {
        quill.root.innerHTML = htmlEditor.value.replace(/\n/g, "");
        quill.container.removeChild(htmlEditor);
      } else {
        htmlEditor = document.createElement("textarea");
        htmlEditor.className = "ql-editor ql-html-editor";
        htmlEditor.innerHTML = quill.root.innerHTML;
        quill.container.appendChild(htmlEditor);
      }
    }
  );
  return quill;
}
var PostsAddComponent = (
  /** @class */
  function() {
    function PostsAddComponent2(i18n, settings, categories, alert, posts, navigation) {
      this.i18n = i18n;
      this.settings = settings;
      this.categories = categories;
      this.alert = alert;
      this.posts = posts;
      this.navigation = navigation;
      this.checkedCategories = [];
      this.isSubmitButtonsDisabled = false;
      this.languageChange = new Subject();
    }
    PostsAddComponent2.prototype.ngOnInit = /**
    * @return {?}
    */
    function() {
      this.status = PostStatus.Draft;
      this.languages = this.settings.getActiveSupportedLanguages();
      this.language = this.languages[0].key;
      this.date = (/* @__PURE__ */ new Date()).toISOString().slice(0, 10);
      this.image = null;
      this.imageSrc = getEmptyImage();
      this.setCategoriesObservable();
    };
    PostsAddComponent2.prototype.ngAfterViewInit = /**
    * @return {?}
    */
    function() {
      this.editor = initTextEditor("#editor-container", this.i18n.get("PostContent"));
    };
    PostsAddComponent2.prototype.ngOnDestroy = /**
    * @return {?}
    */
    function() {
      this.languageChange.next();
    };
    PostsAddComponent2.prototype.setCategoriesObservable = /**
    * @private
    * @return {?}
    */
    function() {
      this.categoriesObservable = this.categories.getWhere("lang", "==", this.language).pipe(map(
        /**
        * @param {?} categories
        * @return {?}
        */
        function(categories) {
          return categories.sort(
            /**
            * @param {?} a
            * @param {?} b
            * @return {?}
            */
            function(a, b2) {
              return b2.createdAt - a.createdAt;
            }
          );
        }
      ), takeUntil(this.languageChange));
    };
    PostsAddComponent2.prototype.onTitleInput = /**
    * @return {?}
    */
    function() {
      this.slug = slugify(this.title).substr(0, 50);
    };
    PostsAddComponent2.prototype.onLanguageChange = /**
    * @return {?}
    */
    function() {
      this.languageChange.next();
      this.checkedCategories = [];
      this.setCategoriesObservable();
    };
    PostsAddComponent2.prototype.addCategory = /**
    * @param {?} event
    * @return {?}
    */
    function(event) {
      var _this = this;
      var target = (
        /** @type {?} */
        event.target
      );
      target.disabled = true;
      this.categories.add({
        label: this.newCategory,
        slug: slugify(this.newCategory),
        lang: this.language
      }).catch(
        /**
        * @param {?} error
        * @return {?}
        */
        function(error) {
          _this.alert.error(error.message);
        }
      ).finally(
        /**
        * @return {?}
        */
        function() {
          _this.newCategory = "";
        }
      );
    };
    PostsAddComponent2.prototype.onCategoryCheck = /**
    * @param {?} category
    * @param {?} event
    * @return {?}
    */
    function(category, event) {
      if (event.target.checked) {
        this.checkedCategories.push(category.id);
      } else {
        var index = this.checkedCategories.indexOf(category.id);
        if (index !== -1) {
          this.checkedCategories.splice(index, 1);
        }
      }
    };
    PostsAddComponent2.prototype.onImageChange = /**
    * @param {?} event
    * @return {?}
    */
    function(event) {
      var _this = this;
      this.image = /** @type {?} */
      event.target.files[0];
      var reader = new FileReader();
      reader.onload = /**
      * @return {?}
      */
      function() {
        _this.imageSrc = reader.result;
      };
      reader.readAsDataURL(this.image);
    };
    PostsAddComponent2.prototype.addPost = /**
    * @param {?} event
    * @param {?=} status
    * @return {?}
    */
    function(event, status) {
      var _this = this;
      var target = (
        /** @type {?} */
        event.target
      );
      var startLoading = (
        /**
        * @return {?}
        */
        function() {
          target.isLoading = true;
          _this.isSubmitButtonsDisabled = true;
        }
      );
      var stopLoading = (
        /**
        * @return {?}
        */
        function() {
          target.isLoading = false;
          _this.isSubmitButtonsDisabled = false;
        }
      );
      startLoading();
      this.posts.isSlugDuplicated(this.slug, this.language).then(
        /**
        * @param {?} duplicated
        * @return {?}
        */
        function(duplicated) {
          if (duplicated) {
            _this.alert.warning(_this.i18n.get("PostSlugAlreadyExists"), false, 5e3);
            stopLoading();
          } else {
            if (status) {
              _this.status = status;
            }
            _this.posts.add({
              lang: _this.language,
              title: _this.title,
              slug: _this.slug,
              date: new Date(_this.date).getTime(),
              content: _this.editor.root.innerHTML,
              image: _this.image,
              status: _this.status,
              categories: _this.checkedCategories
            }).then(
              /**
              * @return {?}
              */
              function() {
                _this.alert.success(_this.i18n.get("PostAdded"), false, 5e3, true);
                _this.navigation.redirectTo("posts", "list");
              }
            ).catch(
              /**
              * @param {?} error
              * @return {?}
              */
              function(error) {
                _this.alert.error(error.message);
              }
            ).finally(
              /**
              * @return {?}
              */
              function() {
                stopLoading();
              }
            );
          }
        }
      ).catch(
        /**
        * @param {?} error
        * @return {?}
        */
        function(error) {
          _this.alert.error(error.message);
          stopLoading();
        }
      );
    };
    PostsAddComponent2.prototype.publishPost = /**
    * @param {?} event
    * @return {?}
    */
    function(event) {
      this.addPost(event, PostStatus.Published);
    };
    PostsAddComponent2.decorators = [
      { type: Component, args: [{
        selector: "fa-posts-add",
        template: `<fa-layout>
  <!-- Page Header -->
  <div class="page-header row no-gutters py-4">
    <div class="col-12 text-center text-sm-left mb-0">
      <span class="text-uppercase page-subtitle">{{ 'Posts' | translate }}</span>
      <h3 class="page-title">{{ 'AddNewPost' | translate }}</h3>
    </div>
  </div>
  <!-- End Page Header -->
  <div class="row">
    <div class="col-lg-9 col-md-12">
      <!-- Add New Post Form -->
      <div class="card card-small mb-3">
        <div class="card-body">
          <form class="add-new-post">
            <input class="form-control form-control-lg mb-3" type="text" placeholder="{{ 'PostTitle' | translate }}" [(ngModel)]="title" name="title" (input)="onTitleInput()">
            <div id="editor-container" class="add-new-post__editor mb-1"></div>
          </form>
        </div>
      </div>
      <!-- / Add New Post Form -->
    </div>
    <div class="col-lg-3 col-md-12">
      <!-- Post Overview -->
      <div class="card card-small mb-3">
        <div class="card-header border-bottom">
          <h6 class="m-0">{{ 'Actions' | translate }}</h6>
        </div>
        <div class="card-body p-0">
          <ul class="list-group list-group-flush">
            <li class="list-group-item p-3">
              <span class="d-flex mb-2">
                <i class="material-icons mr-1 mt-1">translate</i><span class="mr-1 mt-1">{{ 'PostLanguage' | translate }}:</span>
                <select class="custom-select col-md-7 ml-auto" [(ngModel)]="language" name="language" (change)="onLanguageChange()">
                  <option *ngFor="let lang of languages" [value]="lang.key">{{ lang.label | translate }}</option>
                </select>
              </span>
              <span class="d-flex mb-2">
                <i class="material-icons mr-1 mt-1">link</i><span class="mr-1 mt-1">{{ 'PostSlug' | translate }}:</span>
                <input type="text" class="form-control col-md-7 ml-auto" [(ngModel)]="slug" name="slug">
              </span>
              <span class="d-flex mb-2">
                <i class="material-icons mr-1 mt-1">calendar_today</i><span class="mr-1 mt-1">{{ 'PostDate' | translate }}:</span>
                <input type="date" class="form-control col-md-7 ml-auto" [(ngModel)]="date" name="date">
              </span>
            </li>
            <li class="list-group-item d-flex px-3 pt-0">
              <button class="btn btn-sm btn-outline-accent mr-3" [disabled]="isSubmitButtonsDisabled || !title?.length || !slug?.length || !date?.length" (click)="addPost($event)" #saveDraftButton>
                <i class="material-icons">save</i> {{ 'SaveDraft' | translate }} <i *ngIf="saveDraftButton.isLoading" class="fas fa-circle-notch fa-spin ml-1"></i>
              </button>
              <button class="btn btn-sm btn-accent ml-auto" [disabled]="isSubmitButtonsDisabled || !title?.length || !slug?.length || !date?.length" (click)="publishPost($event)" #publishButton>
                <i class="material-icons">file_copy</i> {{ 'Publish' | translate }} <i *ngIf="publishButton.isLoading" class="fas fa-circle-notch fa-spin ml-1"></i>
              </button>
            </li>
          </ul>
        </div>
      </div>
      <!-- / Post Overview -->
      <!-- Post Overview -->
      <div class="card card-small mb-3">
        <div class="card-header border-bottom cursor-pointer" (click)="imageCardHeader.isToggled = !imageCardHeader.isToggled" #imageCardHeader>
          <h6 class="m-0">{{ 'PostImage' | translate }}</h6>
          <div class="block-handle"></div>
        </div>
        <div class="card-body p-0" [class.d-none]="!imageCardHeader.isToggled">
          <span class="d-flex">
            <div class="edit-user-details__avatar rounded-0" (click)="postImage.click()">
              <img [src]="imageSrc | escapeUrl" alt="Post image">
              <label class="edit-user-details__avatar__change rounded-0">
                <i class="material-icons mr-1">add_a_photo</i>
                <input type="file" accept="image/*" class="d-none" (change)="onImageChange($event)" #postImage>
              </label>
            </div>
          </span>
        </div>
      </div>
      <!-- / Post Overview -->
      <!-- Post Overview -->
      <div class="card card-small mb-3">
        <div class="card-header border-bottom cursor-pointer" (click)="categoriesCardHeader.isToggled = !categoriesCardHeader.isToggled" #categoriesCardHeader>
          <h6 class="m-0">{{ 'Categories' | translate }}</h6>
          <div class="block-handle"></div>
        </div>
        <div class="card-body p-0" [class.d-none]="categoriesCardHeader.isToggled">
          <ul class="categories-list list-group list-group-flush">
            <li class="list-group-item px-3 pb-2">
              <div class="custom-control custom-checkbox mb-1" *ngFor="let category of categoriesObservable | async; let i = index">
                <input type="checkbox" class="custom-control-input" id="{{ 'category' + i }}" (change)="onCategoryCheck(category, $event)">
                <label class="custom-control-label" for="{{ 'category' + i }}">{{ category.label }}</label>
              </div>
            </li>
            <li class="list-group-item d-flex px-3">
              <div class="input-group">
                <input type="text" class="form-control" placeholder="{{ 'NewCategory' | translate }}" [(ngModel)]="newCategory">
                <div class="input-group-append">
                  <button class="btn btn-white px-2" type="button" [disabled]="!newCategory?.length" (click)="addCategory($event)"><i class="material-icons">add</i></button>
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>
      <!-- / Post Overview -->
    </div>
  </div>
</fa-layout>
`,
        styles: ['.ql-container{min-height:480px}::ng-deep .ql-html:after{content:"#"}::ng-deep #editor-container .ql-html-editor{position:absolute;background:ivory;top:0;left:0;bottom:0;width:100%;border:0;padding:12px;box-sizing:border-box}.categories-list .list-group-item{max-height:150px;overflow-y:auto}.edit-user-details__avatar{width:100%;text-align:center;max-width:100%;box-shadow:none}.edit-user-details__avatar img{width:auto;max-height:9.5rem}.edit-user-details__avatar__change i{line-height:8.5rem}']
      }] }
    ];
    PostsAddComponent2.ctorParameters = function() {
      return [
        { type: I18nService },
        { type: SettingsService },
        { type: CategoriesService },
        { type: AlertService },
        { type: PostsService },
        { type: NavigationService }
      ];
    };
    return PostsAddComponent2;
  }()
);
if (false) {
  PostsAddComponent.prototype.title;
  PostsAddComponent.prototype.editor;
  PostsAddComponent.prototype.status;
  PostsAddComponent.prototype.language;
  PostsAddComponent.prototype.languages;
  PostsAddComponent.prototype.slug;
  PostsAddComponent.prototype.date;
  PostsAddComponent.prototype.image;
  PostsAddComponent.prototype.imageSrc;
  PostsAddComponent.prototype.checkedCategories;
  PostsAddComponent.prototype.categoriesObservable;
  PostsAddComponent.prototype.newCategory;
  PostsAddComponent.prototype.isSubmitButtonsDisabled;
  PostsAddComponent.prototype.languageChange;
  PostsAddComponent.prototype.i18n;
  PostsAddComponent.prototype.settings;
  PostsAddComponent.prototype.categories;
  PostsAddComponent.prototype.alert;
  PostsAddComponent.prototype.posts;
  PostsAddComponent.prototype.navigation;
}
var PostsEditComponent = (
  /** @class */
  function() {
    function PostsEditComponent2(i18n, categories, alert, posts, navigation, route) {
      this.i18n = i18n;
      this.categories = categories;
      this.alert = alert;
      this.posts = posts;
      this.navigation = navigation;
      this.route = route;
      this.checkedCategories = [];
      this.isSubmitButtonsDisabled = false;
      this.allStatus = {};
      this.subscription = new Subscription();
      this.routeParamsChange = new Subject();
    }
    PostsEditComponent2.prototype.ngOnInit = /**
    * @return {?}
    */
    function() {
      var _this = this;
      this.allStatus = this.posts.getAllStatus();
      this.isSubmitButtonsDisabled = true;
      this.subscription.add(this.route.params.subscribe(
        /**
        * @param {?} params
        * @return {?}
        */
        function(params) {
          _this.posts.get(params.id).pipe(take(1)).toPromise().then(
            /**
            * @param {?} post
            * @return {?}
            */
            function(post) {
              if (post) {
                _this.id = post.id;
                _this.title = post.title;
                _this.editor.root.innerHTML = post.content;
                _this.status = post.status;
                _this.slug = post.slug;
                _this.date = new Date(post.date).toISOString().slice(0, 10);
                _this.language = post.lang;
                _this.image = null;
                _this.imageSrc = getEmptyImage();
                if (post.image) {
                  _this.posts.getImageUrl(
                    /** @type {?} */
                    post.image
                  ).pipe(take(1)).toPromise().then(
                    /**
                    * @param {?} imageUrl
                    * @return {?}
                    */
                    function(imageUrl) {
                      _this.imageSrc = imageUrl;
                    }
                  );
                }
                _this.checkedCategories = post.categories ? post.categories : [];
                _this.routeParamsChange.next();
                _this.setCategoriesObservable();
                _this.isSubmitButtonsDisabled = false;
              } else {
                _this.navigation.redirectTo("posts", "list");
              }
            }
          );
        }
      ));
    };
    PostsEditComponent2.prototype.ngAfterViewInit = /**
    * @return {?}
    */
    function() {
      this.editor = initTextEditor("#editor-container", this.i18n.get("PostContent"));
    };
    PostsEditComponent2.prototype.ngOnDestroy = /**
    * @return {?}
    */
    function() {
      this.subscription.unsubscribe();
      this.routeParamsChange.next();
    };
    PostsEditComponent2.prototype.setCategoriesObservable = /**
    * @private
    * @return {?}
    */
    function() {
      this.categoriesObservable = this.categories.getWhere("lang", "==", this.language).pipe(map(
        /**
        * @param {?} categories
        * @return {?}
        */
        function(categories) {
          return categories.sort(
            /**
            * @param {?} a
            * @param {?} b
            * @return {?}
            */
            function(a, b2) {
              return b2.createdAt - a.createdAt;
            }
          );
        }
      ), takeUntil(this.routeParamsChange));
    };
    PostsEditComponent2.prototype.onTitleInput = /**
    * @return {?}
    */
    function() {
      this.slug = slugify(this.title).substr(0, 50);
    };
    PostsEditComponent2.prototype.addCategory = /**
    * @param {?} event
    * @return {?}
    */
    function(event) {
      var _this = this;
      var target = (
        /** @type {?} */
        event.target
      );
      target.disabled = true;
      this.categories.add({
        label: this.newCategory,
        slug: slugify(this.newCategory),
        lang: this.language
      }).catch(
        /**
        * @param {?} error
        * @return {?}
        */
        function(error) {
          _this.alert.error(error.message);
        }
      ).finally(
        /**
        * @return {?}
        */
        function() {
          _this.newCategory = "";
        }
      );
    };
    PostsEditComponent2.prototype.onCategoryCheck = /**
    * @param {?} category
    * @param {?} event
    * @return {?}
    */
    function(category, event) {
      if (event.target.checked) {
        this.checkedCategories.push(category.id);
      } else {
        var index = this.checkedCategories.indexOf(category.id);
        if (index !== -1) {
          this.checkedCategories.splice(index, 1);
        }
      }
    };
    PostsEditComponent2.prototype.onImageChange = /**
    * @param {?} event
    * @return {?}
    */
    function(event) {
      var _this = this;
      this.image = /** @type {?} */
      event.target.files[0];
      var reader = new FileReader();
      reader.onload = /**
      * @return {?}
      */
      function() {
        _this.imageSrc = reader.result;
      };
      reader.readAsDataURL(this.image);
    };
    PostsEditComponent2.prototype.savePost = /**
    * @param {?} event
    * @return {?}
    */
    function(event) {
      var _this = this;
      var target = (
        /** @type {?} */
        event.target
      );
      var startLoading = (
        /**
        * @return {?}
        */
        function() {
          target.isLoading = true;
          _this.isSubmitButtonsDisabled = true;
        }
      );
      var stopLoading = (
        /**
        * @return {?}
        */
        function() {
          target.isLoading = false;
          _this.isSubmitButtonsDisabled = false;
        }
      );
      startLoading();
      this.posts.isSlugDuplicated(this.slug, this.language, this.id).then(
        /**
        * @param {?} duplicated
        * @return {?}
        */
        function(duplicated) {
          if (duplicated) {
            _this.alert.warning(_this.i18n.get("PostSlugAlreadyExists"), false, 5e3);
            stopLoading();
          } else {
            var data = {
              lang: _this.language,
              title: _this.title,
              slug: _this.slug,
              date: new Date(_this.date).getTime(),
              content: _this.editor.root.innerHTML,
              status: _this.status,
              categories: _this.checkedCategories
            };
            if (_this.image) {
              data.image = _this.image;
            }
            _this.posts.edit(_this.id, data).then(
              /**
              * @return {?}
              */
              function() {
                _this.alert.success(_this.i18n.get("PostSaved"), false, 5e3, true);
                _this.navigation.redirectTo("posts", "list");
              }
            ).catch(
              /**
              * @param {?} error
              * @return {?}
              */
              function(error) {
                _this.alert.error(error.message);
              }
            ).finally(
              /**
              * @return {?}
              */
              function() {
                stopLoading();
              }
            );
          }
        }
      ).catch(
        /**
        * @param {?} error
        * @return {?}
        */
        function(error) {
          _this.alert.error(error.message);
          stopLoading();
        }
      );
    };
    PostsEditComponent2.decorators = [
      { type: Component, args: [{
        selector: "fa-posts-edit",
        template: `<fa-layout>
  <!-- Page Header -->
  <div class="page-header row no-gutters py-4">
    <div class="col-12 text-center text-sm-left mb-0">
      <span class="text-uppercase page-subtitle">{{ 'Posts' | translate }}</span>
      <h3 class="page-title">{{ 'EditPost' | translate }}</h3>
    </div>
  </div>
  <!-- End Page Header -->
  <div class="row">
    <div class="col-lg-9 col-md-12">
      <!-- Add New Post Form -->
      <div class="card card-small mb-3">
        <div class="card-body">
          <form class="add-new-post">
            <input class="form-control form-control-lg mb-3" type="text" placeholder="{{ 'PostTitle' | translate }}" [(ngModel)]="title" name="title" (input)="onTitleInput()">
            <div id="editor-container" class="add-new-post__editor mb-1"></div>
          </form>
        </div>
      </div>
      <!-- / Add New Post Form -->
    </div>
    <div class="col-lg-3 col-md-12">
      <!-- Post Overview -->
      <div class="card card-small mb-3">
        <div class="card-header border-bottom">
          <h6 class="m-0">{{ 'Actions' | translate }}</h6>
        </div>
        <div class="card-body p-0">
          <ul class="list-group list-group-flush">
            <li class="list-group-item p-3">
              <span class="d-flex mb-2">
                <i class="material-icons mr-1 mt-1">flag</i><span class="mr-1 mt-1">{{ 'PostStatus' | translate }}:</span>
                <select class="custom-select col-md-7 ml-auto" [(ngModel)]="status" name="status">
                  <option *ngFor="let status of allStatus | keyvalue" [value]="status.key">{{ status.value | translate }}</option>
                </select>
              </span>
              <span class="d-flex mb-2">
                <i class="material-icons mr-1 mt-1">link</i><span class="mr-1 mt-1">{{ 'PostSlug' | translate }}:</span>
                <input type="text" class="form-control col-md-7 ml-auto" [(ngModel)]="slug" name="slug">
              </span>
              <span class="d-flex mb-2">
                <i class="material-icons mr-1 mt-1">calendar_today</i><span class="mr-1 mt-1">{{ 'PostDate' | translate }}:</span>
                <input type="date" class="form-control col-md-7 ml-auto" [(ngModel)]="date" name="date">
              </span>
            </li>
            <li class="list-group-item d-flex px-3 pt-0">
              <button class="btn btn-sm btn-white" [disabled]="isSubmitButtonsDisabled" [routerLink]="navigation.getRouterLink('posts', 'list')">
                {{ 'Cancel' | translate }}
              </button>
              <button class="btn btn-sm btn-accent ml-auto" [disabled]="isSubmitButtonsDisabled || !title?.length || !slug?.length || !date?.length" (click)="savePost($event)" #saveButton>
                <i class="material-icons">save</i> {{ 'Save' | translate }} <i *ngIf="saveButton.isLoading" class="fas fa-circle-notch fa-spin ml-1"></i>
              </button>
            </li>
          </ul>
        </div>
      </div>
      <!-- / Post Overview -->
      <!-- Post Overview -->
      <div class="card card-small mb-3">
        <div class="card-header border-bottom cursor-pointer" (click)="imageCardHeader.isToggled = !imageCardHeader.isToggled" #imageCardHeader>
          <h6 class="m-0">{{ 'PostImage' | translate }}</h6>
          <div class="block-handle"></div>
        </div>
        <div class="card-body p-0" [class.d-none]="!imageCardHeader.isToggled">
          <span class="d-flex">
            <div class="edit-user-details__avatar rounded-0" (click)="postImage.click()">
              <img [src]="imageSrc | escapeUrl" alt="Post image">
              <label class="edit-user-details__avatar__change rounded-0">
                <i class="material-icons mr-1">add_a_photo</i>
                <input type="file" accept="image/*" class="d-none" (change)="onImageChange($event)" #postImage>
              </label>
            </div>
          </span>
        </div>
      </div>
      <!-- / Post Overview -->
      <!-- Post Overview -->
      <div class="card card-small mb-3">
        <div class="card-header border-bottom cursor-pointer" (click)="categoriesCardHeader.isToggled = !categoriesCardHeader.isToggled" #categoriesCardHeader>
          <h6 class="m-0">{{ 'Categories' | translate }}</h6>
          <div class="block-handle"></div>
        </div>
        <div class="card-body p-0" [class.d-none]="categoriesCardHeader.isToggled">
          <ul class="categories-list list-group list-group-flush">
            <li class="list-group-item px-3 pb-2">
              <div class="custom-control custom-checkbox mb-1" *ngFor="let category of categoriesObservable | async; let i = index">
                <input type="checkbox" class="custom-control-input" id="{{ 'category' + i }}" (change)="onCategoryCheck(category, $event)" [checked]="checkedCategories.indexOf(category.id) !== -1">
                <label class="custom-control-label" for="{{ 'category' + i }}">{{ category.label }}</label>
              </div>
            </li>
            <li class="list-group-item d-flex px-3">
              <div class="input-group">
                <input type="text" class="form-control" placeholder="{{ 'NewCategory' | translate }}" [(ngModel)]="newCategory">
                <div class="input-group-append">
                  <button class="btn btn-white px-2" type="button" [disabled]="!newCategory?.length || !categoriesObservable" (click)="addCategory($event)"><i class="material-icons">add</i></button>
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>
      <!-- / Post Overview -->
    </div>
  </div>
</fa-layout>
`,
        styles: ['.ql-container{min-height:480px}::ng-deep .ql-html:after{content:"#"}::ng-deep #editor-container .ql-html-editor{position:absolute;background:ivory;top:0;left:0;bottom:0;width:100%;border:0;padding:12px;box-sizing:border-box}.categories-list .list-group-item{max-height:150px;overflow-y:auto}.edit-user-details__avatar{width:100%;text-align:center;max-width:100%;box-shadow:none}.edit-user-details__avatar img{width:auto;max-height:9.5rem}.edit-user-details__avatar__change i{line-height:8.5rem}']
      }] }
    ];
    PostsEditComponent2.ctorParameters = function() {
      return [
        { type: I18nService },
        { type: CategoriesService },
        { type: AlertService },
        { type: PostsService },
        { type: NavigationService },
        { type: ActivatedRoute }
      ];
    };
    return PostsEditComponent2;
  }()
);
if (false) {
  PostsEditComponent.prototype.id;
  PostsEditComponent.prototype.title;
  PostsEditComponent.prototype.editor;
  PostsEditComponent.prototype.status;
  PostsEditComponent.prototype.language;
  PostsEditComponent.prototype.slug;
  PostsEditComponent.prototype.date;
  PostsEditComponent.prototype.image;
  PostsEditComponent.prototype.imageSrc;
  PostsEditComponent.prototype.checkedCategories;
  PostsEditComponent.prototype.categoriesObservable;
  PostsEditComponent.prototype.newCategory;
  PostsEditComponent.prototype.isSubmitButtonsDisabled;
  PostsEditComponent.prototype.allStatus;
  PostsEditComponent.prototype.subscription;
  PostsEditComponent.prototype.routeParamsChange;
  PostsEditComponent.prototype.i18n;
  PostsEditComponent.prototype.categories;
  PostsEditComponent.prototype.alert;
  PostsEditComponent.prototype.posts;
  PostsEditComponent.prototype.navigation;
  PostsEditComponent.prototype.route;
}
var PostsCategoriesComponent = (
  /** @class */
  function() {
    function PostsCategoriesComponent2(settings, categories, alert, i18n) {
      this.settings = settings;
      this.categories = categories;
      this.alert = alert;
      this.i18n = i18n;
      this.allLanguages = [];
      this.selectedCategory = null;
      this.dataTableOptions = {
        responsive: true,
        aaSorting: []
      };
      this.dataTableTrigger = new Subject();
      this.subscription = new Subscription();
    }
    PostsCategoriesComponent2.prototype.ngOnInit = /**
    * @return {?}
    */
    function() {
      var _this = this;
      this.languages = this.settings.getActiveSupportedLanguages();
      this.language = this.languages[0].key;
      this.settings.supportedLanguages.forEach(
        /**
        * @param {?} language
        * @return {?}
        */
        function(language) {
          _this.allLanguages[language.key] = language;
        }
      );
      this.allCategories = this.categories.getAll().pipe(map(
        /**
        * @param {?} categories
        * @return {?}
        */
        function(categories) {
          return categories.sort(
            /**
            * @param {?} a
            * @param {?} b
            * @return {?}
            */
            function(a, b2) {
              return b2.createdAt - a.createdAt;
            }
          );
        }
      ));
      this.subscription.add(this.allCategories.subscribe(
        /**
        * @param {?} categories
        * @return {?}
        */
        function(categories) {
          refreshDataTable(_this.dataTableElement, _this.dataTableTrigger, true);
        }
      ));
    };
    PostsCategoriesComponent2.prototype.ngOnDestroy = /**
    * @return {?}
    */
    function() {
      this.dataTableTrigger.unsubscribe();
      this.subscription.unsubscribe();
    };
    PostsCategoriesComponent2.prototype.onAddCategoryLabelInput = /**
    * @return {?}
    */
    function() {
      this.slug = slugify(this.label);
    };
    PostsCategoriesComponent2.prototype.addCategory = /**
    * @param {?} event
    * @return {?}
    */
    function(event) {
      var _this = this;
      /** @type {?} */
      event.target.disabled = true;
      this.categories.add({
        label: this.label,
        slug: this.slug,
        lang: this.language
      }).then(
        /**
        * @return {?}
        */
        function() {
          _this.alert.success(_this.i18n.get("CategoryAdded"), false, 5e3);
        }
      ).catch(
        /**
        * @param {?} error
        * @return {?}
        */
        function(error) {
          _this.alert.error(error.message);
        }
      ).finally(
        /**
        * @return {?}
        */
        function() {
          _this.label = _this.slug = "";
        }
      );
    };
    PostsCategoriesComponent2.prototype.deleteCategory = /**
    * @param {?} category
    * @return {?}
    */
    function(category) {
      var _this = this;
      this.categories.delete(category.id).then(
        /**
        * @return {?}
        */
        function() {
          _this.alert.success(_this.i18n.get("CategoryDeleted", { label: category.label }), false, 5e3);
        }
      ).catch(
        /**
        * @param {?} error
        * @return {?}
        */
        function(error) {
          _this.alert.error(error.message);
        }
      );
    };
    PostsCategoriesComponent2.prototype.onEditCategoryLabelInput = /**
    * @return {?}
    */
    function() {
      this.selectedCategory.slug = slugify(this.selectedCategory.label);
    };
    PostsCategoriesComponent2.prototype.editCategory = /**
    * @param {?} category
    * @return {?}
    */
    function(category) {
      var _this = this;
      this.categories.edit(category.id, category).then(
        /**
        * @return {?}
        */
        function() {
          _this.alert.success(_this.i18n.get("CategorySaved", { label: category.label }), false, 5e3);
        }
      ).catch(
        /**
        * @param {?} error
        * @return {?}
        */
        function(error) {
          _this.alert.error(error.message);
        }
      );
    };
    PostsCategoriesComponent2.prototype.setSelectedCategory = /**
    * @param {?} category
    * @return {?}
    */
    function(category) {
      this.selectedCategory = Object.assign({}, category);
    };
    PostsCategoriesComponent2.decorators = [
      { type: Component, args: [{
        selector: "fa-posts-categories",
        template: `<fa-layout>
  <!-- Page Header -->
  <div class="page-header row no-gutters py-4">
    <div class="col-12 text-center text-sm-left mb-0">
      <span class="text-uppercase page-subtitle">{{ 'Posts' | translate }}</span>
      <h3 class="page-title">{{ 'Categories' | translate }}</h3>
    </div>
  </div>
  <!-- End Page Header -->
  <div class="row">
    <div class="col-lg-4 col-md-12">
      <!-- Add New Category Form -->
      <div class="card card-small mb-3">
        <div class="card-header border-bottom">
          <h6 class="m-0">{{ 'NewCategory' | translate }}</h6>
        </div>
        <div class="card-body">
          <form>
            <div class="form-group">
              <input type="text" class="form-control" placeholder="{{ 'CategoryLabel' | translate }}" [(ngModel)]="label" name="label" (input)="onAddCategoryLabelInput()">
            </div>
            <div class="form-group">
              <input type="text" class="form-control" placeholder="{{ 'CategorySlug' | translate }}" [(ngModel)]="slug" name="slug">
            </div>
            <div class="form-group">
              <select class="custom-select" [(ngModel)]="language" name="language">
                <option value="" disabled>{{ 'CategoryLanguage' | translate }}</option>
                <option *ngFor="let lang of languages" [value]="lang.key">{{ lang.label | translate }}</option>
              </select>
            </div>
            <div class="form-group mb-0">
              <button type="submit" class="btn btn-accent" [disabled]="!label?.length || !slug?.length || !language?.length" (click)="addCategory($event)">
                <i class="material-icons">add</i> {{ 'AddCategory' | translate }}
              </button>
            </div>
          </form>
        </div>
      </div>
      <!-- / Add New Category Form -->
    </div>
    <div class="col-lg-8 col-md-12">
      <!-- Categories List -->
      <div class="card card-small mb-3">
        <div class="card-header border-bottom">
          <h6 class="m-0">{{ 'Categories' | translate }}</h6>
        </div>
        <div class="card-body p-0">
          <table datatable [dtOptions]="dataTableOptions" [dtTrigger]="dataTableTrigger" class="file-manager file-manager-list d-none table-responsive">
            <thead>
              <tr>
                <th class="text-left">{{ 'CategoryLabel' | translate }}</th>
                <th>{{ 'CategorySlug' | translate }}</th>
                <th>{{ 'CategoryLanguage' | translate }}</th>
                <th class="text-right hide-sort-icons">{{ 'Actions' | translate }}</th>
              </tr>
            </thead>
            <tbody>
              <tr *ngFor="let category of allCategories | async">
                <td class="text-left">{{ category.label }}</td>
                <td>{{ category.slug }}</td>
                <td>{{ allLanguages[category.lang].label | translate }}</td>
                <td class="text-right">
                  <div class="btn-group btn-group-sm" role="group" aria-label="Table row actions">
                    <button type="button" class="btn btn-white active-light" title="{{ 'Edit' | translate }}" data-toggle="modal" data-target="#editModal" (click)="setSelectedCategory(category)">
                      <i class="material-icons">edit</i>
                    </button>
                    <button type="button" class="btn btn-danger" title="{{ 'Delete' | translate }}" data-toggle="modal" data-target="#deleteModal" (click)="setSelectedCategory(category)">
                      <i class="material-icons">delete</i>
                    </button>
                  </div>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
      <!-- / Categories List -->
    </div>
  </div>
</fa-layout>

<!-- Edit Modal -->
<div class="modal fade" id="editModal" tabindex="-1" role="dialog" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">{{ 'EditCategory' | translate }}</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">×</span>
        </button>
      </div>
      <div class="modal-body">
        <form>
          <div class="form-group">
            <input type="text" class="form-control" placeholder="{{ 'CategoryLabel' | translate }}" [(ngModel)]="selectedCategory && selectedCategory.label" name="label" (input)="onEditCategoryLabelInput()">
          </div>
          <div class="form-group">
            <input type="text" class="form-control" placeholder="{{ 'CategorySlug' | translate }}" [(ngModel)]="selectedCategory && selectedCategory.slug" name="slug">
          </div>
          <div class="form-group mb-0">
            <select class="custom-select" [(ngModel)]="selectedCategory && selectedCategory.lang" name="language">
              <option value="" disabled>{{ 'CategoryLanguage' | translate }}</option>
              <option *ngFor="let lang of languages" [value]="lang.key">{{ lang.label | translate }}</option>
            </select>
          </div>
        </form>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-white" data-dismiss="modal">{{ 'Cancel' | translate }}</button>
        <button type="button" class="btn btn-accent" data-dismiss="modal" [disabled]="!selectedCategory?.label?.length || !selectedCategory?.slug?.length || !selectedCategory?.lang?.length" (click)="editCategory(selectedCategory)">{{ 'Save' | translate }}</button>
      </div>
    </div>
  </div>
</div>

<!-- Delete Modal -->
<div class="modal fade" id="deleteModal" tabindex="-1" role="dialog" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">{{ 'DeleteCategory' | translate }}</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">×</span>
        </button>
      </div>
      <div class="modal-body" innerHTML="{{ 'ConfirmDeleteCategory' | translate: {label: selectedCategory?.label} }}"></div>
      <div class="modal-footer">
        <button type="button" class="btn btn-white" data-dismiss="modal">{{ 'Cancel' | translate }}</button>
        <button type="button" class="btn btn-danger" data-dismiss="modal" (click)="deleteCategory(selectedCategory)">{{ 'Delete' | translate }}</button>
      </div>
    </div>
  </div>
</div>
`,
        styles: [""]
      }] }
    ];
    PostsCategoriesComponent2.ctorParameters = function() {
      return [
        { type: SettingsService },
        { type: CategoriesService },
        { type: AlertService },
        { type: I18nService }
      ];
    };
    PostsCategoriesComponent2.propDecorators = {
      dataTableElement: [{ type: ViewChild, args: [DataTableDirective, { static: false }] }]
    };
    return PostsCategoriesComponent2;
  }()
);
if (false) {
  PostsCategoriesComponent.prototype.label;
  PostsCategoriesComponent.prototype.slug;
  PostsCategoriesComponent.prototype.language;
  PostsCategoriesComponent.prototype.languages;
  PostsCategoriesComponent.prototype.allLanguages;
  PostsCategoriesComponent.prototype.allCategories;
  PostsCategoriesComponent.prototype.selectedCategory;
  PostsCategoriesComponent.prototype.dataTableElement;
  PostsCategoriesComponent.prototype.dataTableOptions;
  PostsCategoriesComponent.prototype.dataTableTrigger;
  PostsCategoriesComponent.prototype.subscription;
  PostsCategoriesComponent.prototype.settings;
  PostsCategoriesComponent.prototype.categories;
  PostsCategoriesComponent.prototype.alert;
  PostsCategoriesComponent.prototype.i18n;
}
var PagesListComponent = (
  /** @class */
  function() {
    function PagesListComponent2(pages, alert, i18n, route, navigation, currentUser, settings) {
      this.pages = pages;
      this.alert = alert;
      this.i18n = i18n;
      this.route = route;
      this.navigation = navigation;
      this.currentUser = currentUser;
      this.settings = settings;
      this.selectedPage = null;
      this.dataTableOptions = {
        responsive: true,
        aaSorting: []
      };
      this.dataTableTrigger = new Subject();
      this.subscription = new Subscription();
      this.routeParamsChange = new Subject();
      this.allLanguages = [];
      this.isLoading = true;
    }
    PagesListComponent2.prototype.ngOnInit = /**
    * @return {?}
    */
    function() {
      var _this = this;
      this.settings.supportedLanguages.forEach(
        /**
        * @param {?} language
        * @return {?}
        */
        function(language) {
          _this.allLanguages[language.key] = language;
        }
      );
      this.subscription.add(this.route.params.subscribe(
        /**
        * @param {?} params
        * @return {?}
        */
        function(params) {
          _this.routeParamsChange.next();
          _this.isLoading = true;
          _this.allPages = _this.pages.getWhereFn(
            /**
            * @param {?} ref
            * @return {?}
            */
            function(ref) {
              var query = ref;
              if (params.authorId) {
                query = query.where("createdBy", "==", params.authorId);
              }
              return query;
            },
            true
          ).pipe(map(
            /**
            * @param {?} pages
            * @return {?}
            */
            function(pages) {
              return pages.sort(
                /**
                * @param {?} a
                * @param {?} b
                * @return {?}
                */
                function(a, b2) {
                  return b2.createdAt - a.createdAt;
                }
              );
            }
          ), takeUntil(_this.routeParamsChange));
          _this.subscription.add(_this.allPages.subscribe(
            /**
            * @param {?} pages
            * @return {?}
            */
            function(pages) {
              refreshDataTable(_this.dataTableElement, _this.dataTableTrigger);
              _this.isLoading = false;
            }
          ));
        }
      ));
    };
    PagesListComponent2.prototype.ngOnDestroy = /**
    * @return {?}
    */
    function() {
      this.dataTableTrigger.unsubscribe();
      this.subscription.unsubscribe();
      this.routeParamsChange.next();
    };
    PagesListComponent2.prototype.deletePage = /**
    * @param {?} page
    * @return {?}
    */
    function(page) {
      var _this = this;
      this.pages.delete(page.id, {
        lang: page.lang,
        translationId: page.translationId,
        translations: page.translations
      }).then(
        /**
        * @return {?}
        */
        function() {
          _this.alert.success(_this.i18n.get("PageDeleted", { title: page.title }), false, 5e3);
        }
      ).catch(
        /**
        * @param {?} error
        * @return {?}
        */
        function(error) {
          _this.alert.error(error.message);
        }
      );
    };
    PagesListComponent2.decorators = [
      { type: Component, args: [{
        selector: "fa-pages-list",
        template: `<fa-layout>
  <!-- Page Header -->
  <div class="page-header row no-gutters py-4">
    <div class="col-12 text-center text-sm-left mb-0">
      <span class="text-uppercase page-subtitle">{{ 'Pages' | translate }}</span>
      <h3 class="page-title">{{ 'List' | translate }}</h3>
    </div>
  </div>
  <!-- End Page Header -->
  <fa-loading-indicator [show]="isLoading" [center]="true"></fa-loading-indicator>
  <div class="row">
    <div class="col-12 mb-4">
      <div class="card card-small lo-stats">
        <div class="card-body p-0">
          <table datatable [dtOptions]="dataTableOptions" [dtTrigger]="dataTableTrigger" class="file-manager file-manager-list d-none table-responsive">
            <thead>
              <tr>
                <th class="hide-sort-icons"></th>
                <th class="text-left">{{ 'PageTitle' | translate }}</th>
                <th>{{ 'PageLanguage' | translate }}</th>
                <th>{{ 'PageCreatedAt' | translate }}</th>
                <th>{{ 'PageUpdatedAt' | translate }}</th>
                <th *ngIf="currentUser?.isAdmin()">{{ 'PageAuthor' | translate }}</th>
                <th class="text-right hide-sort-icons">{{ 'Actions' | translate }}</th>
              </tr>
            </thead>
            <tbody>
              <tr *ngFor="let page of allPages | async">
                <td class="file-manager__item-icon">
                  <div>
                    <i class="material-icons">insert_drive_file</i>
                  </div>
                </td>
                <td class="text-left lo-stats__order-details">
                  <span>{{ page.title }}</span>
                  <span>{{ '/' + page.slug }}</span>
                </td>
                <td>{{ allLanguages[page.lang].label | translate }}</td>
                <td>{{ page.createdAt | datetime }}</td>
                <td>{{ page.updatedAt | datetime }}</td>
                <td *ngIf="currentUser?.isAdmin()">
                  <a *ngIf="page.createdBy" [routerLink]="navigation.getRouterLink('users', 'profile', page.createdBy)">
                    {{ page.author | async }}
                  </a>
                </td>
                <td class="text-right">
                  <div class="btn-group btn-group-sm" role="group" aria-label="Table row actions">
                    <button *ngIf="page.isTranslatable" type="button" class="btn btn-white active-light" title="{{ 'Translate' | translate }}" [routerLink]="navigation.getRouterLink('pages', 'translate', page.id)">
                      <i class="material-icons">translate</i>
                    </button>
                    <button type="button" class="btn btn-white active-light" title="{{ 'Edit' | translate }}" [routerLink]="navigation.getRouterLink('pages', 'edit', page.id)">
                      <i class="material-icons">edit</i>
                    </button>
                    <button type="button" class="btn btn-danger" title="{{ 'Delete' | translate }}" data-toggle="modal" data-target="#deleteModal" (click)="selectedPage = page">
                      <i class="material-icons">delete</i>
                    </button>
                  </div>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
</fa-layout>

<!-- Delete Modal -->
<div class="modal fade" id="deleteModal" tabindex="-1" role="dialog" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">{{ 'DeletePage' | translate }}</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">×</span>
        </button>
      </div>
      <div class="modal-body" innerHTML="{{ 'ConfirmDeletePage' | translate: {title: selectedPage?.title} }}"></div>
      <div class="modal-footer">
        <button type="button" class="btn btn-white" data-dismiss="modal">{{ 'Cancel' | translate }}</button>
        <button type="button" class="btn btn-danger" data-dismiss="modal" (click)="deletePage(selectedPage)">{{ 'Delete' | translate }}</button>
      </div>
    </div>
  </div>
</div>
`,
        styles: [".lo-stats__order-details{min-width:200px}"]
      }] }
    ];
    PagesListComponent2.ctorParameters = function() {
      return [
        { type: PagesService },
        { type: AlertService },
        { type: I18nService },
        { type: ActivatedRoute },
        { type: NavigationService },
        { type: CurrentUserService },
        { type: SettingsService }
      ];
    };
    PagesListComponent2.propDecorators = {
      dataTableElement: [{ type: ViewChild, args: [DataTableDirective, { static: false }] }]
    };
    return PagesListComponent2;
  }()
);
if (false) {
  PagesListComponent.prototype.allPages;
  PagesListComponent.prototype.selectedPage;
  PagesListComponent.prototype.dataTableElement;
  PagesListComponent.prototype.dataTableOptions;
  PagesListComponent.prototype.dataTableTrigger;
  PagesListComponent.prototype.subscription;
  PagesListComponent.prototype.routeParamsChange;
  PagesListComponent.prototype.allLanguages;
  PagesListComponent.prototype.isLoading;
  PagesListComponent.prototype.pages;
  PagesListComponent.prototype.alert;
  PagesListComponent.prototype.i18n;
  PagesListComponent.prototype.route;
  PagesListComponent.prototype.navigation;
  PagesListComponent.prototype.currentUser;
  PagesListComponent.prototype.settings;
}
if (false) {
  Page.prototype.id;
  Page.prototype.title;
  Page.prototype.slug;
  Page.prototype.lang;
  Page.prototype.blocks;
  Page.prototype.createdAt;
  Page.prototype.updatedAt;
  Page.prototype.createdBy;
  Page.prototype.author;
  Page.prototype.updatedBy;
  Page.prototype.translationId;
  Page.prototype.translations;
  Page.prototype.isTranslatable;
}
if (false) {
  PageBlock.prototype.key;
  PageBlock.prototype.name;
  PageBlock.prototype.type;
  PageBlock.prototype.content;
}
var PageBlockType = {
  Text: "text",
  HTML: "html",
  JSON: "json"
};
var PagesAddComponent = (
  /** @class */
  function() {
    function PagesAddComponent2(settings, i18n, pages, alert, navigation) {
      this.settings = settings;
      this.i18n = i18n;
      this.pages = pages;
      this.alert = alert;
      this.navigation = navigation;
      this.blocks = [];
      this.blockTypes = [];
    }
    PagesAddComponent2.prototype.ngOnInit = /**
    * @return {?}
    */
    function() {
      this.languages = this.settings.getActiveSupportedLanguages();
      this.language = this.languages[0].key;
      this.blockTypes = Object.keys(PageBlockType).map(
        /**
        * @param {?} key
        * @return {?}
        */
        function(key) {
          return { label: key, value: PageBlockType[key] };
        }
      );
    };
    PagesAddComponent2.prototype.onTitleInput = /**
    * @return {?}
    */
    function() {
      this.slug = slugify(this.title).substr(0, 50);
    };
    PagesAddComponent2.prototype.addBlock = /**
    * @param {?=} event
    * @return {?}
    */
    function(event) {
      this.blocks.push({
        name: "",
        type: PageBlockType.Text,
        content: ""
      });
    };
    PagesAddComponent2.prototype.removeBlock = /**
    * @param {?} index
    * @return {?}
    */
    function(index) {
      this.blocks.splice(index, 1);
    };
    PagesAddComponent2.prototype.onBlockNameInput = /**
    * @param {?} block
    * @return {?}
    */
    function(block) {
      block.key = slugify(block.name);
    };
    PagesAddComponent2.prototype.addPage = /**
    * @param {?} event
    * @return {?}
    */
    function(event) {
      var _this = this;
      var addButon = (
        /** @type {?} */
        event.target
      );
      var startLoading = (
        /**
        * @return {?}
        */
        function() {
          addButon.isLoading = true;
        }
      );
      var stopLoading = (
        /**
        * @return {?}
        */
        function() {
          addButon.isLoading = false;
        }
      );
      startLoading();
      this.pages.isSlugDuplicated(this.slug, this.language).then(
        /**
        * @param {?} duplicated
        * @return {?}
        */
        function(duplicated) {
          if (duplicated) {
            _this.alert.warning(_this.i18n.get("PageSlugAlreadyExists"), false, 5e3);
            stopLoading();
          } else {
            _this.pages.add({
              lang: _this.language,
              title: _this.title,
              slug: _this.slug,
              blocks: _this.pages.formatBlocks(_this.blocks)
            }).then(
              /**
              * @return {?}
              */
              function() {
                _this.alert.success(_this.i18n.get("PageAdded"), false, 5e3, true);
                _this.navigation.redirectTo("pages", "list");
              }
            ).catch(
              /**
              * @param {?} error
              * @return {?}
              */
              function(error) {
                _this.alert.error(error.message);
              }
            ).finally(
              /**
              * @return {?}
              */
              function() {
                stopLoading();
              }
            );
          }
        }
      ).catch(
        /**
        * @param {?} error
        * @return {?}
        */
        function(error) {
          _this.alert.error(error.message);
          stopLoading();
        }
      );
    };
    PagesAddComponent2.decorators = [
      { type: Component, args: [{
        selector: "fa-pages-add",
        template: `<fa-layout>
  <!-- Page Header -->
  <div class="page-header row no-gutters py-4">
    <div class="col-12 text-center text-sm-left mb-0">
      <span class="text-uppercase page-subtitle">{{ 'Pages' | translate }}</span>
      <h3 class="page-title">{{ 'AddNewPage' | translate }}</h3>
    </div>
  </div>
  <!-- End Page Header -->
  <div class="row">
    <div class="col-lg-9 col-md-12">
      <!-- Add New Page Form -->
      <div class="card card-small mb-3">
        <div class="card-body">
          <form class="add-new-page">
            <input class="form-control form-control-lg" type="text" placeholder="{{ 'PageTitle' | translate }}" [(ngModel)]="title" name="title" (input)="onTitleInput()">
          </form>
        </div>
        <div class="card-footer border-top d-flex">
          <div class="my-auto ml-auto">
            <button class="btn btn-sm btn-white" (click)="addBlock($event)">
              <i class="material-icons">add</i> {{ 'AddBlock' | translate }}
            </button>
          </div>
        </div>
      </div>
      <!-- / Add New Page Form -->
      <div class="row">
        <div class="col">
          <span class="file-manager__group-title text-uppercase text-light">{{ 'PageBlocks' | translate }}</span>
        </div>
      </div>
      <div class="row">
        <div *ngFor="let block of blocks; let i = index" class="col-lg-6">
          <div class="card card-small mb-3">
            <div class="card-header border-bottom d-flex" #blockCardHeader>
              <h6 class="m-0 overflow-hidden">{{ block.key?.length ? block.key : ('PageBlock' | translate) }}</h6>
              <span class="ml-auto cursor-pointer" title="{{ 'RemoveBlock' | translate }}" (click)="removeBlock(i)">
                <i class="material-icons">delete_outline</i>
              </span>
              <span class="ml-4">
                <div class="block-handle cursor-pointer" title="{{ 'CollapseBlock' | translate }}" (click)="blockCardHeader.isToggled = !blockCardHeader.isToggled"></div>
              </span>
            </div>
            <div class="card-body" [class.d-none]="blockCardHeader.isToggled">
              <input class="form-control mb-3" type="text" placeholder="{{ 'BlockName' | translate }}" [(ngModel)]="block.name" name="block-name" (input)="onBlockNameInput(block)">
              <select class="form-control custom-select mb-3" [(ngModel)]="block.type" name="block-type">
                <option value="" disabled>{{ 'BlockType' | translate }}</option>
                <option *ngFor="let type of blockTypes" [value]="type.value">{{ type.label | translate }}</option>
              </select>
              <textarea class="form-control" style="min-height: 100px" placeholder="{{ 'BlockContent' | translate }}" [(ngModel)]="block.content" name="block-content"></textarea>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="col-lg-3 col-md-12">
      <!-- Page Overview -->
      <div class="card card-small mb-3">
        <div class="card-header border-bottom">
          <h6 class="m-0">{{ 'Actions' | translate }}</h6>
        </div>
        <div class="card-body p-0">
          <ul class="list-group list-group-flush">
            <li class="list-group-item p-3">
              <span class="d-flex mb-2">
                <i class="material-icons mr-1 mt-1">translate</i><span class="mr-1 mt-1">{{ 'PageLanguage' | translate }}:</span>
                <select class="custom-select col-md-7 ml-auto" [(ngModel)]="language" name="language">
                  <option *ngFor="let lang of languages" [value]="lang.key">{{ lang.label | translate }}</option>
                </select>
              </span>
              <span class="d-flex mb-2">
                <i class="material-icons mr-1 mt-1">link</i><span class="mr-1 mt-1">{{ 'PageSlug' | translate }}:</span>
                <input type="text" class="form-control col-md-7 ml-auto" [(ngModel)]="slug" name="slug">
              </span>
            </li>
            <li class="list-group-item d-flex px-3 pt-0">
              <button class="btn btn-sm btn-accent m-auto" [disabled]="!title?.length || !slug?.length || addButton.isLoading" (click)="addPage($event)" #addButton>
                <i class="material-icons">note_add</i> {{ 'AddPage' | translate }} <i *ngIf="addButton.isLoading" class="fas fa-circle-notch fa-spin ml-1"></i>
              </button>
            </li>
          </ul>
        </div>
      </div>
      <!-- / Page Overview -->
    </div>
  </div>
</fa-layout>
`,
        styles: [""]
      }] }
    ];
    PagesAddComponent2.ctorParameters = function() {
      return [
        { type: SettingsService },
        { type: I18nService },
        { type: PagesService },
        { type: AlertService },
        { type: NavigationService }
      ];
    };
    return PagesAddComponent2;
  }()
);
if (false) {
  PagesAddComponent.prototype.title;
  PagesAddComponent.prototype.slug;
  PagesAddComponent.prototype.language;
  PagesAddComponent.prototype.languages;
  PagesAddComponent.prototype.blocks;
  PagesAddComponent.prototype.blockTypes;
  PagesAddComponent.prototype.settings;
  PagesAddComponent.prototype.i18n;
  PagesAddComponent.prototype.pages;
  PagesAddComponent.prototype.alert;
  PagesAddComponent.prototype.navigation;
}
var PagesEditComponent = (
  /** @class */
  function() {
    function PagesEditComponent2(i18n, pages, alert, navigation, route) {
      this.i18n = i18n;
      this.pages = pages;
      this.alert = alert;
      this.navigation = navigation;
      this.route = route;
      this.blocks = [];
      this.blockTypes = [];
      this.isSubmitButtonsDisabled = false;
      this.subscription = new Subscription();
      this.routeParamsChange = new Subject();
    }
    PagesEditComponent2.prototype.ngOnInit = /**
    * @return {?}
    */
    function() {
      var _this = this;
      this.blockTypes = Object.keys(PageBlockType).map(
        /**
        * @param {?} key
        * @return {?}
        */
        function(key) {
          return { label: key, value: PageBlockType[key] };
        }
      );
      this.isSubmitButtonsDisabled = true;
      this.subscription.add(this.route.params.subscribe(
        /**
        * @param {?} params
        * @return {?}
        */
        function(params) {
          _this.pages.get(params.id).pipe(take(1)).toPromise().then(
            /**
            * @param {?} page
            * @return {?}
            */
            function(page) {
              if (page) {
                _this.id = page.id;
                _this.title = page.title;
                _this.slug = page.slug;
                _this.language = page.lang;
                _this.blocks = Object.keys(page.blocks).map(
                  /**
                  * @param {?} key
                  * @return {?}
                  */
                  function(key) {
                    var block = page.blocks[key];
                    return {
                      key,
                      name: block.name,
                      type: block.type,
                      content: block.content
                    };
                  }
                );
                _this.routeParamsChange.next();
                _this.isSubmitButtonsDisabled = false;
              } else {
                _this.navigation.redirectTo("pages", "list");
              }
            }
          );
        }
      ));
    };
    PagesEditComponent2.prototype.ngOnDestroy = /**
    * @return {?}
    */
    function() {
      this.subscription.unsubscribe();
      this.routeParamsChange.next();
    };
    PagesEditComponent2.prototype.onTitleInput = /**
    * @return {?}
    */
    function() {
      this.slug = slugify(this.title).substr(0, 50);
    };
    PagesEditComponent2.prototype.addBlock = /**
    * @param {?=} event
    * @return {?}
    */
    function(event) {
      this.blocks.push({
        name: "",
        type: PageBlockType.Text,
        content: ""
      });
    };
    PagesEditComponent2.prototype.removeBlock = /**
    * @param {?} index
    * @return {?}
    */
    function(index) {
      this.blocks.splice(index, 1);
    };
    PagesEditComponent2.prototype.onBlockNameInput = /**
    * @param {?} block
    * @return {?}
    */
    function(block) {
      block.key = slugify(block.name);
    };
    PagesEditComponent2.prototype.savePage = /**
    * @param {?} event
    * @return {?}
    */
    function(event) {
      var _this = this;
      var target = (
        /** @type {?} */
        event.target
      );
      var startLoading = (
        /**
        * @return {?}
        */
        function() {
          target.isLoading = true;
          _this.isSubmitButtonsDisabled = true;
        }
      );
      var stopLoading = (
        /**
        * @return {?}
        */
        function() {
          target.isLoading = false;
          _this.isSubmitButtonsDisabled = false;
        }
      );
      startLoading();
      this.pages.isSlugDuplicated(this.slug, this.language, this.id).then(
        /**
        * @param {?} duplicated
        * @return {?}
        */
        function(duplicated) {
          if (duplicated) {
            _this.alert.warning(_this.i18n.get("PageSlugAlreadyExists"), false, 5e3);
            stopLoading();
          } else {
            var data = {
              lang: _this.language,
              title: _this.title,
              slug: _this.slug,
              blocks: _this.pages.formatBlocks(_this.blocks)
            };
            _this.pages.edit(_this.id, data).then(
              /**
              * @return {?}
              */
              function() {
                _this.alert.success(_this.i18n.get("PageSaved"), false, 5e3, true);
                _this.navigation.redirectTo("pages", "list");
              }
            ).catch(
              /**
              * @param {?} error
              * @return {?}
              */
              function(error) {
                _this.alert.error(error.message);
              }
            ).finally(
              /**
              * @return {?}
              */
              function() {
                stopLoading();
              }
            );
          }
        }
      ).catch(
        /**
        * @param {?} error
        * @return {?}
        */
        function(error) {
          _this.alert.error(error.message);
          stopLoading();
        }
      );
    };
    PagesEditComponent2.decorators = [
      { type: Component, args: [{
        selector: "fa-pages-edit",
        template: `<fa-layout>
  <!-- Page Header -->
  <div class="page-header row no-gutters py-4">
    <div class="col-12 text-center text-sm-left mb-0">
      <span class="text-uppercase page-subtitle">{{ 'Pages' | translate }}</span>
      <h3 class="page-title">{{ 'EditPage' | translate }}</h3>
    </div>
  </div>
  <!-- End Page Header -->
  <div class="row">
    <div class="col-lg-9 col-md-12">
      <!-- Add New Page Form -->
      <div class="card card-small mb-3">
        <div class="card-body">
          <form class="add-new-page">
            <input class="form-control form-control-lg" type="text" placeholder="{{ 'PageTitle' | translate }}" [(ngModel)]="title" name="title" (input)="onTitleInput()">
          </form>
        </div>
        <div class="card-footer border-top d-flex">
          <div class="my-auto ml-auto">
            <button class="btn btn-sm btn-white" (click)="addBlock($event)">
              <i class="material-icons">add</i> {{ 'AddBlock' | translate }}
            </button>
          </div>
        </div>
      </div>
      <!-- / Add New Page Form -->
      <div class="row">
        <div class="col">
          <span class="file-manager__group-title text-uppercase text-light">{{ 'PageBlocks' | translate }}</span>
        </div>
      </div>
      <div class="row">
        <div *ngFor="let block of blocks; let i = index" class="col-lg-6">
          <div class="card card-small mb-3">
            <div class="card-header border-bottom d-flex" #blockCardHeader>
              <h6 class="m-0 overflow-hidden">{{ block.key?.length ? block.key : ('PageBlock' | translate) }}</h6>
              <span class="ml-auto cursor-pointer" title="{{ 'RemoveBlock' | translate }}" (click)="removeBlock(i)">
                <i class="material-icons">delete_outline</i>
              </span>
              <span class="ml-4">
                <div class="block-handle cursor-pointer" title="{{ 'CollapseBlock' | translate }}" (click)="blockCardHeader.isToggled = !blockCardHeader.isToggled"></div>
              </span>
            </div>
            <div class="card-body" [class.d-none]="blockCardHeader.isToggled">
              <input class="form-control mb-3" type="text" placeholder="{{ 'BlockName' | translate }}" [(ngModel)]="block.name" name="block-name" (input)="onBlockNameInput(block)">
              <select class="form-control custom-select mb-3" [(ngModel)]="block.type" name="block-type">
                <option value="" disabled>{{ 'BlockType' | translate }}</option>
                <option *ngFor="let type of blockTypes" [value]="type.value">{{ type.label | translate }}</option>
              </select>
              <textarea class="form-control" style="min-height: 100px" placeholder="{{ 'BlockContent' | translate }}" [(ngModel)]="block.content" name="block-content"></textarea>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="col-lg-3 col-md-12">
      <!-- Page Overview -->
      <div class="card card-small mb-3">
        <div class="card-header border-bottom">
          <h6 class="m-0">{{ 'Actions' | translate }}</h6>
        </div>
        <div class="card-body p-0">
          <ul class="list-group list-group-flush">
            <li class="list-group-item p-3">
              <span class="d-flex mb-2">
                <i class="material-icons mr-1 mt-1">link</i><span class="mr-1 mt-1">{{ 'PageSlug' | translate }}:</span>
                <input type="text" class="form-control col-md-7 ml-auto" [(ngModel)]="slug" name="slug">
              </span>
            </li>
            <li class="list-group-item d-flex px-3 pt-0">
              <button class="btn btn-sm btn-white" [disabled]="isSubmitButtonsDisabled" [routerLink]="navigation.getRouterLink('pages', 'list')">
                {{ 'Cancel' | translate }}
              </button>
              <button class="btn btn-sm btn-accent ml-auto" [disabled]="isSubmitButtonsDisabled || !title?.length || !slug?.length" (click)="savePage($event)" #saveButton>
                <i class="material-icons">save</i> {{ 'Save' | translate }} <i *ngIf="saveButton.isLoading" class="fas fa-circle-notch fa-spin ml-1"></i>
              </button>
            </li>
          </ul>
        </div>
      </div>
      <!-- / Page Overview -->
    </div>
  </div>
</fa-layout>
`,
        styles: [""]
      }] }
    ];
    PagesEditComponent2.ctorParameters = function() {
      return [
        { type: I18nService },
        { type: PagesService },
        { type: AlertService },
        { type: NavigationService },
        { type: ActivatedRoute }
      ];
    };
    return PagesEditComponent2;
  }()
);
if (false) {
  PagesEditComponent.prototype.id;
  PagesEditComponent.prototype.title;
  PagesEditComponent.prototype.slug;
  PagesEditComponent.prototype.language;
  PagesEditComponent.prototype.blocks;
  PagesEditComponent.prototype.blockTypes;
  PagesEditComponent.prototype.isSubmitButtonsDisabled;
  PagesEditComponent.prototype.subscription;
  PagesEditComponent.prototype.routeParamsChange;
  PagesEditComponent.prototype.i18n;
  PagesEditComponent.prototype.pages;
  PagesEditComponent.prototype.alert;
  PagesEditComponent.prototype.navigation;
  PagesEditComponent.prototype.route;
}
var PagesTranslateComponent = (
  /** @class */
  function() {
    function PagesTranslateComponent2(i18n, pages, alert, navigation, route) {
      this.i18n = i18n;
      this.pages = pages;
      this.alert = alert;
      this.navigation = navigation;
      this.route = route;
      this.blocks = [];
      this.blockTypes = [];
      this.isSubmitButtonsDisabled = false;
      this.subscription = new Subscription();
      this.routeParamsChange = new Subject();
    }
    PagesTranslateComponent2.prototype.ngOnInit = /**
    * @return {?}
    */
    function() {
      var _this = this;
      this.blockTypes = Object.keys(PageBlockType).map(
        /**
        * @param {?} key
        * @return {?}
        */
        function(key) {
          return { label: key, value: PageBlockType[key] };
        }
      );
      this.isSubmitButtonsDisabled = true;
      this.subscription.add(this.route.params.subscribe(
        /**
        * @param {?} params
        * @return {?}
        */
        function(params) {
          _this.pages.get(params.id).pipe(take(1)).toPromise().then(
            /**
            * @param {?} page
            * @return {?}
            */
            function(page) {
              if (page) {
                _this.languages = _this.pages.getTranslationLanguages(page);
                if (_this.languages.length) {
                  _this.origin = page;
                  _this.language = _this.languages[0].key;
                  _this.title = page.title;
                  _this.slug = page.slug;
                  _this.blocks = Object.keys(page.blocks).map(
                    /**
                    * @param {?} key
                    * @return {?}
                    */
                    function(key) {
                      var block = page.blocks[key];
                      return {
                        key,
                        name: block.name,
                        type: block.type,
                        content: block.content
                      };
                    }
                  );
                  _this.routeParamsChange.next();
                  _this.isSubmitButtonsDisabled = false;
                } else {
                  _this.navigation.redirectTo("pages", "list");
                }
              } else {
                _this.navigation.redirectTo("pages", "list");
              }
            }
          );
        }
      ));
    };
    PagesTranslateComponent2.prototype.ngOnDestroy = /**
    * @return {?}
    */
    function() {
      this.subscription.unsubscribe();
      this.routeParamsChange.next();
    };
    PagesTranslateComponent2.prototype.onTitleInput = /**
    * @return {?}
    */
    function() {
      this.slug = slugify(this.title).substr(0, 50);
    };
    PagesTranslateComponent2.prototype.addBlock = /**
    * @param {?=} event
    * @return {?}
    */
    function(event) {
      this.blocks.push({
        name: "",
        type: PageBlockType.Text,
        content: ""
      });
    };
    PagesTranslateComponent2.prototype.removeBlock = /**
    * @param {?} index
    * @return {?}
    */
    function(index) {
      this.blocks.splice(index, 1);
    };
    PagesTranslateComponent2.prototype.onBlockNameInput = /**
    * @param {?} block
    * @return {?}
    */
    function(block) {
      block.key = slugify(block.name);
    };
    PagesTranslateComponent2.prototype.addPage = /**
    * @param {?} event
    * @return {?}
    */
    function(event) {
      var _this = this;
      var addButon = (
        /** @type {?} */
        event.target
      );
      var startLoading = (
        /**
        * @return {?}
        */
        function() {
          addButon.isLoading = true;
        }
      );
      var stopLoading = (
        /**
        * @return {?}
        */
        function() {
          addButon.isLoading = false;
        }
      );
      startLoading();
      this.pages.isSlugDuplicated(this.slug, this.language).then(
        /**
        * @param {?} duplicated
        * @return {?}
        */
        function(duplicated) {
          if (duplicated) {
            _this.alert.warning(_this.i18n.get("PageSlugAlreadyExists"), false, 5e3);
            stopLoading();
          } else {
            _this.pages.translate({
              lang: _this.language,
              title: _this.title,
              slug: _this.slug,
              blocks: _this.pages.formatBlocks(_this.blocks),
              translationId: _this.origin.translationId
            }).then(
              /**
              * @return {?}
              */
              function() {
                _this.alert.success(_this.i18n.get("PageAdded"), false, 5e3, true);
                _this.navigation.redirectTo("pages", "list");
              }
            ).catch(
              /**
              * @param {?} error
              * @return {?}
              */
              function(error) {
                _this.alert.error(error.message);
              }
            ).finally(
              /**
              * @return {?}
              */
              function() {
                stopLoading();
              }
            );
          }
        }
      ).catch(
        /**
        * @param {?} error
        * @return {?}
        */
        function(error) {
          _this.alert.error(error.message);
          stopLoading();
        }
      );
    };
    PagesTranslateComponent2.decorators = [
      { type: Component, args: [{
        selector: "fa-pages-translate",
        template: `<fa-layout>
  <!-- Page Header -->
  <div class="page-header row no-gutters py-4">
    <div class="col-12 text-center text-sm-left mb-0">
      <span class="text-uppercase page-subtitle">{{ 'Pages' | translate }}</span>
      <h3 class="page-title">{{ 'TranslatePage' | translate }}</h3>
    </div>
  </div>
  <!-- End Page Header -->
  <div class="row">
    <div class="col-lg-9 col-md-12">
      <!-- Add New Page Form -->
      <div class="card card-small mb-3">
        <div class="card-body">
          <form class="add-new-page">
            <input class="form-control form-control-lg" type="text" placeholder="{{ 'PageTitle' | translate }}" [(ngModel)]="title" name="title" (input)="onTitleInput()">
          </form>
        </div>
        <div class="card-footer border-top d-flex">
          <div class="my-auto ml-auto">
            <button class="btn btn-sm btn-white" (click)="addBlock($event)">
              <i class="material-icons">add</i> {{ 'AddBlock' | translate }}
            </button>
          </div>
        </div>
      </div>
      <!-- / Add New Page Form -->
      <div class="row">
        <div class="col">
          <span class="file-manager__group-title text-uppercase text-light">{{ 'PageBlocks' | translate }}</span>
        </div>
      </div>
      <div class="row">
        <div *ngFor="let block of blocks; let i = index" class="col-lg-6">
          <div class="card card-small mb-3">
            <div class="card-header border-bottom d-flex" #blockCardHeader>
              <h6 class="m-0 overflow-hidden">{{ block.key?.length ? block.key : ('PageBlock' | translate) }}</h6>
              <span class="ml-auto cursor-pointer" title="{{ 'RemoveBlock' | translate }}" (click)="removeBlock(i)">
                <i class="material-icons">delete_outline</i>
              </span>
              <span class="ml-4">
                <div class="block-handle cursor-pointer" title="{{ 'CollapseBlock' | translate }}" (click)="blockCardHeader.isToggled = !blockCardHeader.isToggled"></div>
              </span>
            </div>
            <div class="card-body" [class.d-none]="blockCardHeader.isToggled">
              <input class="form-control mb-3" type="text" placeholder="{{ 'BlockName' | translate }}" [(ngModel)]="block.name" name="block-name" (input)="onBlockNameInput(block)">
              <select class="form-control custom-select mb-3" [(ngModel)]="block.type" name="block-type">
                <option value="" disabled>{{ 'BlockType' | translate }}</option>
                <option *ngFor="let type of blockTypes" [value]="type.value">{{ type.label | translate }}</option>
              </select>
              <textarea class="form-control" style="min-height: 100px" placeholder="{{ 'BlockContent' | translate }}" [(ngModel)]="block.content" name="block-content"></textarea>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="col-lg-3 col-md-12">
      <!-- Page Overview -->
      <div class="card card-small mb-3">
        <div class="card-header border-bottom">
          <h6 class="m-0">{{ 'Actions' | translate }}</h6>
        </div>
        <div class="card-body p-0">
          <ul class="list-group list-group-flush">
            <li class="list-group-item p-3">
              <span class="d-flex mb-2">
                <i class="material-icons mr-1 mt-1">translate</i><span class="mr-1 mt-1">{{ 'PageLanguage' | translate }}:</span>
                <select class="custom-select col-md-7 ml-auto" [(ngModel)]="language" name="language">
                  <option *ngFor="let lang of languages" [value]="lang.key">{{ lang.label | translate }}</option>
                </select>
              </span>
              <span class="d-flex mb-2">
                <i class="material-icons mr-1 mt-1">link</i><span class="mr-1 mt-1">{{ 'PageSlug' | translate }}:</span>
                <input type="text" class="form-control col-md-7 ml-auto" [(ngModel)]="slug" name="slug">
              </span>
            </li>
            <li class="list-group-item d-flex px-3 pt-0">
              <button class="btn btn-sm btn-accent m-auto" [disabled]="isSubmitButtonsDisabled || !title?.length || !slug?.length || addButton.isLoading" (click)="addPage($event)" #addButton>
                <i class="material-icons">note_add</i> {{ 'AddPage' | translate }} <i *ngIf="addButton.isLoading" class="fas fa-circle-notch fa-spin ml-1"></i>
              </button>
            </li>
          </ul>
        </div>
      </div>
      <!-- / Page Overview -->
    </div>
  </div>
</fa-layout>
`,
        styles: [""]
      }] }
    ];
    PagesTranslateComponent2.ctorParameters = function() {
      return [
        { type: I18nService },
        { type: PagesService },
        { type: AlertService },
        { type: NavigationService },
        { type: ActivatedRoute }
      ];
    };
    return PagesTranslateComponent2;
  }()
);
if (false) {
  PagesTranslateComponent.prototype.origin;
  PagesTranslateComponent.prototype.title;
  PagesTranslateComponent.prototype.slug;
  PagesTranslateComponent.prototype.language;
  PagesTranslateComponent.prototype.languages;
  PagesTranslateComponent.prototype.blocks;
  PagesTranslateComponent.prototype.blockTypes;
  PagesTranslateComponent.prototype.isSubmitButtonsDisabled;
  PagesTranslateComponent.prototype.subscription;
  PagesTranslateComponent.prototype.routeParamsChange;
  PagesTranslateComponent.prototype.i18n;
  PagesTranslateComponent.prototype.pages;
  PagesTranslateComponent.prototype.alert;
  PagesTranslateComponent.prototype.navigation;
  PagesTranslateComponent.prototype.route;
}
var SettingsComponent = (
  /** @class */
  function() {
    function SettingsComponent2(settings, navigation, i18n, alert) {
      this.settings = settings;
      this.navigation = navigation;
      this.i18n = i18n;
      this.alert = alert;
    }
    SettingsComponent2.prototype.ngOnInit = /**
    * @return {?}
    */
    function() {
    };
    SettingsComponent2.prototype.saveChanges = /**
    * @param {?} event
    * @return {?}
    */
    function(event) {
      event.preventDefault();
      this.settings.save();
      this.i18n.setLanguage(this.settings.language);
      this.alert.success(this.i18n.get("SettingsSaved"), true);
      window.location.reload();
    };
    SettingsComponent2.prototype.onI18nLanguageInput = /**
    * @return {?}
    */
    function() {
      if (!this.i18nKey || this.i18nKey.length < 2) {
        this.i18nKey = this.i18nLanguage.substr(0, 2).toLowerCase();
      }
    };
    SettingsComponent2.prototype.addSupportedLanguage = /**
    * @return {?}
    */
    function() {
      this.settings.supportedLanguages.push({
        label: this.i18nLanguage,
        key: this.i18nKey,
        isActive: true,
        isRemovable: true
      });
      this.i18nLanguage = this.i18nKey = "";
    };
    SettingsComponent2.prototype.removeSupportedLanguage = /**
    * @param {?} lang
    * @param {?} index
    * @return {?}
    */
    function(lang, index) {
      var activeSupportedLanguages = this.settings.getActiveSupportedLanguages();
      if (activeSupportedLanguages && activeSupportedLanguages.length > 1 || !lang.isActive) {
        this.settings.supportedLanguages.splice(index, 1);
      }
    };
    SettingsComponent2.prototype.onSupportedLanguageCheckboxClick = /**
    * @param {?} event
    * @param {?} lang
    * @return {?}
    */
    function(event, lang) {
      var activeSupportedLanguages = this.settings.getActiveSupportedLanguages();
      if (activeSupportedLanguages.length < 2 && lang.isActive) {
        event.preventDefault();
      }
    };
    SettingsComponent2.decorators = [
      { type: Component, args: [{
        selector: "fa-settings",
        template: `<fa-layout>
  <div class="row">
    <div class="col-lg-8 mx-auto mt-4">
      <!-- Settings Card -->
      <div class="card card-small edit-user-details mb-4">
        <div class="card-header p-0"></div>
        <div class="card-body p-0">
          <div class="border-bottom clearfix d-flex">
            <ul class="nav nav-tabs border-0 mt-auto mx-4 pt-2">
              <li class="nav-item">
                <a class="nav-link active" data-toggle="tab" href="#general">{{ 'General' | translate }}</a>
              </li>
              <li class="nav-item">
                <a class="nav-link" data-toggle="tab" href="#internationalization">{{ 'Internationalization' | translate }}</a>
              </li>
            </ul>
          </div>
          <div class="tab-content py-4">
            <div class="form-row mx-4 tab-pane fade show active" id="general">
              <div class="col-lg-10">
                <div class="form-row">
                  <div class="form-group col-md-6">
                    <label for="language">{{ 'Language' | translate }}</label>
                    <select class="custom-select" [(ngModel)]="settings.language" name="language" id="language">
                      <option value="en">{{ 'English' | translate }}</option>
                      <option value="fr">{{ 'French' | translate }}</option>
                    </select>
                  </div>
                  <div class="form-group col-md-6">
                    <label for="sidebarStyle">{{ 'SidebarStyle' | translate }}</label>
                    <fa-button-group
                      [(value)]="settings.sidebarStyle"
                      [options]="['Expanded', 'Collapsed', 'HeaderBar']"
                      [values]="['expanded', 'collapsed', 'headerbar']"
                    ></fa-button-group>
                    <!-- <select class="custom-select" [(ngModel)]="settings.sidebarStyle" name="sidebarStyle" id="sidebarStyle">
                      <option value="expanded">{{ 'Expanded' | translate }}</option>
                      <option value="collapsed">{{ 'Collapsed' | translate }}</option>
                      <option value="headerbar">{{ 'HeaderBar' | translate }}</option>
                    </select> -->
                  </div>
                </div>
              </div>
            </div>
            <div class="form-row mx-4 tab-pane fade" id="internationalization">
              <div class="col-lg-12">
                <div class="form-row">
                  <div class="form-group col-md-10">
                    <label for="language">{{ 'SupportedLanguages' | translate }}</label>
                    <ul class="list-group list-group-flush">
                      <li class="list-group-item px-0 pb-2">
                        <div *ngFor="let lang of settings.supportedLanguages; let i = index" class="custom-control custom-checkbox mb-1">
                          <input type="checkbox" class="custom-control-input" [id]="'lang' + i" [checked]="lang.isActive"
                            (click)="onSupportedLanguageCheckboxClick($event, lang)"
                            (change)="lang.isActive = $event.target.checked"
                          >
                          <label class="custom-control-label" [for]="'lang' + i" [title]="lang.key">{{ lang.label | translate }}</label>
                          <span *ngIf="lang.isRemovable" class="cursor-pointer ml-2" title="{{ 'Remove' | translate }}" (click)="removeSupportedLanguage(lang, i)">
                            <i class="material-icons">remove_circle_outline</i>
                          </span>
                        </div>
                      </li>
                      <li class="list-group-item d-flex px-0">
                        <div class="input-group">
                          <input type="text" class="form-control" placeholder="{{ 'Language' | translate }}" [(ngModel)]="i18nLanguage" name="i18nLanguage" (input)="onI18nLanguageInput()">
                          <input type="text" class="form-control" placeholder="{{ 'Key' | translate }}" [(ngModel)]="i18nKey" name="i18nKey">
                          <div class="input-group-append">
                            <button class="btn btn-white px-2" type="button" title="{{ 'Add' | translate }}"
                              [disabled]="!i18nLanguage?.length || !i18nKey?.length || i18nKey.length < 2 || settings.supportedLanguageExists(i18nLanguage, i18nKey)"
                              (click)="addSupportedLanguage()"
                            >
                              <i class="material-icons">add</i>
                            </button>
                          </div>
                        </div>
                      </li>
                    </ul>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="card-footer border-top">
          <span class="ml-auto d-table mr-3">
            <a [href]="'.' + navigation.getRouterLink('settings').join('/')" class="btn btn-sm btn-white mr-2">{{ 'Cancel' | translate }}</a>
            <a href="#" class="btn btn-sm btn-accent" (click)="saveChanges($event)">{{ 'SaveChanges' | translate }}</a>
          </span>
        </div>
      </div>
      <!-- End Settings Card -->
    </div>
  </div>
</fa-layout>
`,
        styles: [""]
      }] }
    ];
    SettingsComponent2.ctorParameters = function() {
      return [
        { type: SettingsService },
        { type: NavigationService },
        { type: I18nService },
        { type: AlertService }
      ];
    };
    return SettingsComponent2;
  }()
);
if (false) {
  SettingsComponent.prototype.i18nLanguage;
  SettingsComponent.prototype.i18nKey;
  SettingsComponent.prototype.settings;
  SettingsComponent.prototype.navigation;
  SettingsComponent.prototype.i18n;
  SettingsComponent.prototype.alert;
}
var PostsTranslateComponent = (
  /** @class */
  function() {
    function PostsTranslateComponent2(i18n, categories, alert, posts, navigation, route) {
      this.i18n = i18n;
      this.categories = categories;
      this.alert = alert;
      this.posts = posts;
      this.navigation = navigation;
      this.route = route;
      this.checkedCategories = [];
      this.isSubmitButtonsDisabled = false;
      this.subscription = new Subscription();
      this.languageOrRouteParamsChange = new Subject();
    }
    PostsTranslateComponent2.prototype.ngOnInit = /**
    * @return {?}
    */
    function() {
      var _this = this;
      this.isSubmitButtonsDisabled = true;
      this.subscription.add(this.route.params.subscribe(
        /**
        * @param {?} params
        * @return {?}
        */
        function(params) {
          _this.posts.get(params.id).pipe(take(1)).toPromise().then(
            /**
            * @param {?} post
            * @return {?}
            */
            function(post) {
              if (post) {
                _this.languages = _this.posts.getTranslationLanguages(post);
                if (_this.languages.length) {
                  _this.origin = post;
                  _this.language = _this.languages[0].key;
                  _this.title = post.title;
                  _this.editor.root.innerHTML = post.content;
                  _this.status = PostStatus.Draft;
                  _this.slug = post.slug;
                  _this.date = new Date(post.date).toISOString().slice(0, 10);
                  _this.image = /** @type {?} */
                  post.image;
                  _this.imageSrc = getEmptyImage();
                  if (post.image) {
                    _this.posts.getImageUrl(
                      /** @type {?} */
                      post.image
                    ).pipe(take(1)).toPromise().then(
                      /**
                      * @param {?} imageUrl
                      * @return {?}
                      */
                      function(imageUrl) {
                        _this.imageSrc = imageUrl;
                      }
                    );
                  }
                  _this.checkedCategories = /*post.categories ? post.categories : */
                  [];
                  _this.languageOrRouteParamsChange.next();
                  _this.setCategoriesObservable();
                  _this.isSubmitButtonsDisabled = false;
                } else {
                  _this.navigation.redirectTo("posts", "list");
                }
              } else {
                _this.navigation.redirectTo("posts", "list");
              }
            }
          );
        }
      ));
    };
    PostsTranslateComponent2.prototype.ngAfterViewInit = /**
    * @return {?}
    */
    function() {
      this.editor = initTextEditor("#editor-container", this.i18n.get("PostContent"));
    };
    PostsTranslateComponent2.prototype.ngOnDestroy = /**
    * @return {?}
    */
    function() {
      this.subscription.unsubscribe();
      this.languageOrRouteParamsChange.next();
    };
    PostsTranslateComponent2.prototype.setCategoriesObservable = /**
    * @private
    * @return {?}
    */
    function() {
      this.categoriesObservable = this.categories.getWhere("lang", "==", this.language).pipe(map(
        /**
        * @param {?} categories
        * @return {?}
        */
        function(categories) {
          return categories.sort(
            /**
            * @param {?} a
            * @param {?} b
            * @return {?}
            */
            function(a, b2) {
              return b2.createdAt - a.createdAt;
            }
          );
        }
      ), takeUntil(this.languageOrRouteParamsChange));
    };
    PostsTranslateComponent2.prototype.onTitleInput = /**
    * @return {?}
    */
    function() {
      this.slug = slugify(this.title).substr(0, 50);
    };
    PostsTranslateComponent2.prototype.onLanguageChange = /**
    * @return {?}
    */
    function() {
      this.languageOrRouteParamsChange.next();
      this.checkedCategories = [];
      this.setCategoriesObservable();
    };
    PostsTranslateComponent2.prototype.addCategory = /**
    * @param {?} event
    * @return {?}
    */
    function(event) {
      var _this = this;
      var target = (
        /** @type {?} */
        event.target
      );
      target.disabled = true;
      this.categories.add({
        label: this.newCategory,
        slug: slugify(this.newCategory),
        lang: this.language
      }).catch(
        /**
        * @param {?} error
        * @return {?}
        */
        function(error) {
          _this.alert.error(error.message);
        }
      ).finally(
        /**
        * @return {?}
        */
        function() {
          _this.newCategory = "";
        }
      );
    };
    PostsTranslateComponent2.prototype.onCategoryCheck = /**
    * @param {?} category
    * @param {?} event
    * @return {?}
    */
    function(category, event) {
      if (event.target.checked) {
        this.checkedCategories.push(category.id);
      } else {
        var index = this.checkedCategories.indexOf(category.id);
        if (index !== -1) {
          this.checkedCategories.splice(index, 1);
        }
      }
    };
    PostsTranslateComponent2.prototype.onImageChange = /**
    * @param {?} event
    * @return {?}
    */
    function(event) {
      var _this = this;
      this.image = /** @type {?} */
      event.target.files[0];
      var reader = new FileReader();
      reader.onload = /**
      * @return {?}
      */
      function() {
        _this.imageSrc = reader.result;
      };
      reader.readAsDataURL(this.image);
    };
    PostsTranslateComponent2.prototype.addPost = /**
    * @param {?} event
    * @param {?=} status
    * @return {?}
    */
    function(event, status) {
      var _this = this;
      var target = (
        /** @type {?} */
        event.target
      );
      var startLoading = (
        /**
        * @return {?}
        */
        function() {
          target.isLoading = true;
          _this.isSubmitButtonsDisabled = true;
        }
      );
      var stopLoading = (
        /**
        * @return {?}
        */
        function() {
          target.isLoading = false;
          _this.isSubmitButtonsDisabled = false;
        }
      );
      startLoading();
      this.posts.isSlugDuplicated(this.slug, this.language, this.origin.id).then(
        /**
        * @param {?} duplicated
        * @return {?}
        */
        function(duplicated) {
          if (duplicated) {
            _this.alert.warning(_this.i18n.get("PostSlugAlreadyExists"), false, 5e3);
            stopLoading();
          } else {
            if (status) {
              _this.status = status;
            }
            _this.posts.translate({
              lang: _this.language,
              title: _this.title,
              slug: _this.slug,
              date: new Date(_this.date).getTime(),
              content: _this.editor.root.innerHTML,
              image: _this.image,
              status: _this.status,
              categories: _this.checkedCategories,
              translationId: _this.origin.translationId
            }).then(
              /**
              * @return {?}
              */
              function() {
                _this.alert.success(_this.i18n.get("PostAdded"), false, 5e3, true);
                _this.navigation.redirectTo("posts", "list");
              }
            ).catch(
              /**
              * @param {?} error
              * @return {?}
              */
              function(error) {
                _this.alert.error(error.message);
              }
            ).finally(
              /**
              * @return {?}
              */
              function() {
                stopLoading();
              }
            );
          }
        }
      ).catch(
        /**
        * @param {?} error
        * @return {?}
        */
        function(error) {
          _this.alert.error(error.message);
          stopLoading();
        }
      );
    };
    PostsTranslateComponent2.prototype.publishPost = /**
    * @param {?} event
    * @return {?}
    */
    function(event) {
      this.addPost(event, PostStatus.Published);
    };
    PostsTranslateComponent2.decorators = [
      { type: Component, args: [{
        selector: "fa-posts-translate",
        template: `<fa-layout>
  <!-- Page Header -->
  <div class="page-header row no-gutters py-4">
    <div class="col-12 text-center text-sm-left mb-0">
      <span class="text-uppercase page-subtitle">{{ 'Posts' | translate }}</span>
      <h3 class="page-title">{{ 'TranslatePost' | translate }}</h3>
    </div>
  </div>
  <!-- End Page Header -->
  <div class="row">
    <div class="col-lg-9 col-md-12">
      <!-- Add New Post Form -->
      <div class="card card-small mb-3">
        <div class="card-body">
          <form class="add-new-post">
            <input class="form-control form-control-lg mb-3" type="text" placeholder="{{ 'PostTitle' | translate }}" [(ngModel)]="title" name="title" (input)="onTitleInput()">
            <div id="editor-container" class="add-new-post__editor mb-1"></div>
          </form>
        </div>
      </div>
      <!-- / Add New Post Form -->
    </div>
    <div class="col-lg-3 col-md-12">
      <!-- Post Overview -->
      <div class="card card-small mb-3">
        <div class="card-header border-bottom">
          <h6 class="m-0">{{ 'Actions' | translate }}</h6>
        </div>
        <div class="card-body p-0">
          <ul class="list-group list-group-flush">
            <li class="list-group-item p-3">
              <span class="d-flex mb-2">
                <i class="material-icons mr-1 mt-1">translate</i><span class="mr-1 mt-1">{{ 'PostLanguage' | translate }}:</span>
                <select class="custom-select col-md-7 ml-auto" [(ngModel)]="language" name="language" (change)="onLanguageChange()">
                  <option *ngFor="let lang of languages" [value]="lang.key">{{ lang.label | translate }}</option>
                </select>
              </span>
              <span class="d-flex mb-2">
                <i class="material-icons mr-1 mt-1">link</i><span class="mr-1 mt-1">{{ 'PostSlug' | translate }}:</span>
                <input type="text" class="form-control col-md-7 ml-auto" [(ngModel)]="slug" name="slug">
              </span>
              <span class="d-flex mb-2">
                <i class="material-icons mr-1 mt-1">calendar_today</i><span class="mr-1 mt-1">{{ 'PostDate' | translate }}:</span>
                <input type="date" class="form-control col-md-7 ml-auto" [(ngModel)]="date" name="date">
              </span>
            </li>
            <li class="list-group-item d-flex px-3 pt-0">
              <button class="btn btn-sm btn-outline-accent" [disabled]="isSubmitButtonsDisabled || !title?.length || !slug?.length || !date?.length" (click)="addPost($event)" #addDraftButton>
                <i class="material-icons">save</i> {{ 'SaveDraft' | translate }} <i *ngIf="addDraftButton.isLoading" class="fas fa-circle-notch fa-spin ml-1"></i>
              </button>
              <button class="btn btn-sm btn-accent ml-auto" [disabled]="isSubmitButtonsDisabled || !title?.length || !slug?.length || !date?.length" (click)="publishPost($event)" #publishButton>
                <i class="material-icons">file_copy</i> {{ 'Publish' | translate }} <i *ngIf="publishButton.isLoading" class="fas fa-circle-notch fa-spin ml-1"></i>
              </button>
            </li>
          </ul>
        </div>
      </div>
      <!-- / Post Overview -->
      <!-- Post Overview -->
      <div class="card card-small mb-3">
        <div class="card-header border-bottom cursor-pointer" (click)="imageCardHeader.isToggled = !imageCardHeader.isToggled" #imageCardHeader>
          <h6 class="m-0">{{ 'PostImage' | translate }}</h6>
          <div class="block-handle"></div>
        </div>
        <div class="card-body p-0" [class.d-none]="!imageCardHeader.isToggled">
          <span class="d-flex">
            <div class="edit-user-details__avatar rounded-0" (click)="postImage.click()">
              <img [src]="imageSrc | escapeUrl" alt="Post image">
              <label class="edit-user-details__avatar__change rounded-0">
                <i class="material-icons mr-1">add_a_photo</i>
                <input type="file" accept="image/*" class="d-none" (change)="onImageChange($event)" #postImage>
              </label>
            </div>
          </span>
        </div>
      </div>
      <!-- / Post Overview -->
      <!-- Post Overview -->
      <div class="card card-small mb-3">
        <div class="card-header border-bottom cursor-pointer" (click)="categoriesCardHeader.isToggled = !categoriesCardHeader.isToggled" #categoriesCardHeader>
          <h6 class="m-0">{{ 'Categories' | translate }}</h6>
          <div class="block-handle"></div>
        </div>
        <div class="card-body p-0" [class.d-none]="categoriesCardHeader.isToggled">
          <ul class="categories-list list-group list-group-flush">
            <li class="list-group-item px-3 pb-2">
              <div class="custom-control custom-checkbox mb-1" *ngFor="let category of categoriesObservable | async; let i = index">
                <input type="checkbox" class="custom-control-input" id="{{ 'category' + i }}" (change)="onCategoryCheck(category, $event)" [checked]="checkedCategories.indexOf(category.id) !== -1">
                <label class="custom-control-label" for="{{ 'category' + i }}">{{ category.label }}</label>
              </div>
            </li>
            <li class="list-group-item d-flex px-3">
              <div class="input-group">
                <input type="text" class="form-control" placeholder="{{ 'NewCategory' | translate }}" [(ngModel)]="newCategory">
                <div class="input-group-append">
                  <button class="btn btn-white px-2" type="button" [disabled]="!newCategory?.length || !categoriesObservable" (click)="addCategory($event)"><i class="material-icons">add</i></button>
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>
      <!-- / Post Overview -->
    </div>
  </div>
</fa-layout>
`,
        styles: ['.ql-container{min-height:480px}::ng-deep .ql-html:after{content:"#"}::ng-deep #editor-container .ql-html-editor{position:absolute;background:ivory;top:0;left:0;bottom:0;width:100%;border:0;padding:12px;box-sizing:border-box}.categories-list .list-group-item{max-height:150px;overflow-y:auto}.edit-user-details__avatar{width:100%;text-align:center;max-width:100%;box-shadow:none}.edit-user-details__avatar img{width:auto;max-height:9.5rem}.edit-user-details__avatar__change i{line-height:8.5rem}']
      }] }
    ];
    PostsTranslateComponent2.ctorParameters = function() {
      return [
        { type: I18nService },
        { type: CategoriesService },
        { type: AlertService },
        { type: PostsService },
        { type: NavigationService },
        { type: ActivatedRoute }
      ];
    };
    return PostsTranslateComponent2;
  }()
);
if (false) {
  PostsTranslateComponent.prototype.origin;
  PostsTranslateComponent.prototype.title;
  PostsTranslateComponent.prototype.editor;
  PostsTranslateComponent.prototype.status;
  PostsTranslateComponent.prototype.language;
  PostsTranslateComponent.prototype.languages;
  PostsTranslateComponent.prototype.slug;
  PostsTranslateComponent.prototype.date;
  PostsTranslateComponent.prototype.image;
  PostsTranslateComponent.prototype.imageSrc;
  PostsTranslateComponent.prototype.checkedCategories;
  PostsTranslateComponent.prototype.categoriesObservable;
  PostsTranslateComponent.prototype.newCategory;
  PostsTranslateComponent.prototype.isSubmitButtonsDisabled;
  PostsTranslateComponent.prototype.subscription;
  PostsTranslateComponent.prototype.languageOrRouteParamsChange;
  PostsTranslateComponent.prototype.i18n;
  PostsTranslateComponent.prototype.categories;
  PostsTranslateComponent.prototype.alert;
  PostsTranslateComponent.prototype.posts;
  PostsTranslateComponent.prototype.navigation;
  PostsTranslateComponent.prototype.route;
}
var UsersListComponent = (
  /** @class */
  function() {
    function UsersListComponent2(users, alert, i18n, route, currentUser, navigation) {
      this.users = users;
      this.alert = alert;
      this.i18n = i18n;
      this.route = route;
      this.currentUser = currentUser;
      this.navigation = navigation;
      this.selectedUser = null;
      this.dataTableOptions = {
        responsive: true,
        aaSorting: []
      };
      this.dataTableTrigger = new Subject();
      this.subscription = new Subscription();
      this.allRoles = {};
      this.routeParamsChange = new Subject();
      this.isLoading = true;
    }
    UsersListComponent2.prototype.ngOnInit = /**
    * @return {?}
    */
    function() {
      var _this = this;
      this.allRoles = this.users.getAllRoles();
      this.subscription.add(this.route.params.subscribe(
        /**
        * @param {?} params
        * @return {?}
        */
        function(params) {
          _this.routeParamsChange.next();
          _this.isLoading = true;
          _this.allUsers = _this.users.getAll().pipe(
            //skip(this.currentUser.data ? 1 : 0), // workaround to skip first emitted value when currentUser subscription is running (not working when we only have 1 user)
            map(
              /**
              * @param {?} users
              * @return {?}
              */
              function(users) {
                if (params.role) {
                  users = users.filter(
                    /**
                    * @param {?} user
                    * @return {?}
                    */
                    function(user) {
                      return user.role === params.role;
                    }
                  );
                }
                users.forEach(
                  /**
                  * @param {?} user
                  * @return {?}
                  */
                  function(user) {
                    user.avatar = {
                      path: user.avatar,
                      // we need to keep track of avatar path for delete purpose
                      url: _this.users.getAvatarUrl(
                        /** @type {?} */
                        user.avatar
                      )
                    };
                    if (user.createdBy) {
                      user.creator = _this.users.getFullName(user.createdBy);
                    }
                  }
                );
                return users.sort(
                  /**
                  * @param {?} a
                  * @param {?} b
                  * @return {?}
                  */
                  function(a, b2) {
                    return b2.createdAt - a.createdAt;
                  }
                );
              }
            ),
            takeUntil(_this.routeParamsChange)
          );
          _this.subscription.add(_this.allUsers.subscribe(
            /**
            * @param {?} users
            * @return {?}
            */
            function(users) {
              refreshDataTable(_this.dataTableElement, _this.dataTableTrigger);
              _this.isLoading = false;
            }
          ));
        }
      ));
    };
    UsersListComponent2.prototype.ngOnDestroy = /**
    * @return {?}
    */
    function() {
      this.dataTableTrigger.unsubscribe();
      this.subscription.unsubscribe();
      this.routeParamsChange.next();
    };
    UsersListComponent2.prototype.deleteUser = /**
    * @param {?} user
    * @return {?}
    */
    function(user) {
      var _this = this;
      this.users.delete(user.id, {
        email: user.email,
        password: user.password,
        avatar: (
          /** @type {?} */
          user.avatar.path
        )
      }).then(
        /**
        * @return {?}
        */
        function() {
          _this.alert.success(_this.i18n.get("UserDeleted", { name: user.firstName + " " + user.lastName }), false, 5e3);
        }
      ).catch(
        /**
        * @param {?} error
        * @return {?}
        */
        function(error) {
          _this.alert.error(error.message);
        }
      );
    };
    UsersListComponent2.decorators = [
      { type: Component, args: [{
        selector: "fa-users-list",
        template: `<fa-layout>
  <!-- Page Header -->
  <div class="page-header row no-gutters py-4">
    <div class="col-12 text-center text-sm-left mb-0">
      <span class="text-uppercase page-subtitle">{{ 'Users' | translate }}</span>
      <h3 class="page-title">{{ 'List' | translate }}</h3>
    </div>
  </div>
  <!-- End Page Header -->
  <fa-loading-indicator [show]="isLoading" [center]="true"></fa-loading-indicator>
  <div class="row">
    <div class="col-12 mb-4">
      <div class="card card-small lo-stats">
        <div class="card-body p-0">
          <table datatable [dtOptions]="dataTableOptions" [dtTrigger]="dataTableTrigger" class="file-manager file-manager-list d-none table-responsive">
            <thead>
              <tr>
                <th class="hide-sort-icons"></th>
                <th class="text-left">{{ 'UserName' | translate }}</th>
                <th>{{ 'Email' | translate }}</th>
                <th>{{ 'BirthDate' | translate }}</th>
                <th>{{ 'Role' | translate }}</th>
                <th>{{ 'CreatedAt' | translate }}</th>
                <th>{{ 'UpdatedAt' | translate }}</th>
                <th>{{ 'CreatedBy' | translate }}</th>
                <th class="text-right hide-sort-icons">{{ 'Actions' | translate }}</th>
              </tr>
            </thead>
            <tbody>
              <tr *ngFor="let user of allUsers | async">
                <td class="text-left lo-stats__image pr-0">
                  <img class="border rounded" [src]="user.avatar?.url | async | escapeUrl">
                </td>
                <td class="text-left lo-stats__order-details">
                  <span>{{ user.firstName + ' ' + user.lastName }}</span>
                  <span>{{ allRoles[user.role] | translate }}</span>
                </td>
                <td>{{ user.email }}</td>
                <td>{{ user.birthDate | shortdate }}</td>
                <td>
                  <a [routerLink]="navigation.getRouterLink('users', 'list', 'role', user.role)">{{ allRoles[user.role] | translate }}</a>
                </td>
                <td>{{ user.createdAt | datetime }}</td>
                <td>{{ user.updatedAt | datetime }}</td>
                <td>
                  <a *ngIf="user.createdBy" [routerLink]="navigation.getRouterLink('users', 'profile', user.createdBy)">
                    <span *ngIf="user.creator | async as creator">{{ creator }}</span>
                  </a>
                </td>
                <td class="text-right">
                  <div class="btn-group btn-group-sm" role="group" aria-label="Table row actions">
                    <button type="button" class="btn btn-white active-light" title="{{ 'Edit' | translate }}" [routerLink]="navigation.getRouterLink('users', 'edit', user.id)">
                      <i class="material-icons">edit</i>
                    </button>
                    <button type="button" class="btn btn-danger" title="{{ 'Delete' | translate }}" data-toggle="modal" data-target="#deleteModal" (click)="selectedUser = user">
                      <i class="material-icons">delete</i>
                    </button>
                  </div>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
</fa-layout>

<!-- Delete Modal -->
<div class="modal fade" id="deleteModal" tabindex="-1" role="dialog" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">{{ 'DeleteUser' | translate }}</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">×</span>
        </button>
      </div>
      <div class="modal-body" innerHTML="{{ 'ConfirmDeleteUser' | translate: {name: selectedUser?.firstName + ' ' + selectedUser?.lastName} }}"></div>
      <div class="modal-footer">
        <button type="button" class="btn btn-white" data-dismiss="modal">{{ 'Cancel' | translate }}</button>
        <button type="button" class="btn btn-danger" data-dismiss="modal" (click)="deleteUser(selectedUser)">{{ 'Delete' | translate }}</button>
      </div>
    </div>
  </div>
</div>
`,
        styles: [""]
      }] }
    ];
    UsersListComponent2.ctorParameters = function() {
      return [
        { type: UsersService },
        { type: AlertService },
        { type: I18nService },
        { type: ActivatedRoute },
        { type: CurrentUserService },
        { type: NavigationService }
      ];
    };
    UsersListComponent2.propDecorators = {
      dataTableElement: [{ type: ViewChild, args: [DataTableDirective, { static: false }] }]
    };
    return UsersListComponent2;
  }()
);
if (false) {
  UsersListComponent.prototype.allUsers;
  UsersListComponent.prototype.selectedUser;
  UsersListComponent.prototype.dataTableElement;
  UsersListComponent.prototype.dataTableOptions;
  UsersListComponent.prototype.dataTableTrigger;
  UsersListComponent.prototype.subscription;
  UsersListComponent.prototype.allRoles;
  UsersListComponent.prototype.routeParamsChange;
  UsersListComponent.prototype.isLoading;
  UsersListComponent.prototype.users;
  UsersListComponent.prototype.alert;
  UsersListComponent.prototype.i18n;
  UsersListComponent.prototype.route;
  UsersListComponent.prototype.currentUser;
  UsersListComponent.prototype.navigation;
}
var UsersAddComponent = (
  /** @class */
  function() {
    function UsersAddComponent2(users, alert, i18n, navigation) {
      this.users = users;
      this.alert = alert;
      this.i18n = i18n;
      this.navigation = navigation;
      this.allRoles = {};
    }
    UsersAddComponent2.prototype.ngOnInit = /**
    * @return {?}
    */
    function() {
      this.allRoles = this.users.getAllRoles();
      this.role = UserRole.Guest;
      this.avatar = null;
      this.avatarSrc = getDefaultAvatar();
      this.bio = null;
    };
    UsersAddComponent2.prototype.onAvatarChange = /**
    * @param {?} event
    * @return {?}
    */
    function(event) {
      var _this = this;
      this.avatar = /** @type {?} */
      event.target.files[0];
      var reader = new FileReader();
      reader.onload = /**
      * @return {?}
      */
      function() {
        _this.avatarSrc = reader.result;
      };
      reader.readAsDataURL(this.avatar);
    };
    UsersAddComponent2.prototype.addUser = /**
    * @param {?} event
    * @param {?} form
    * @return {?}
    */
    function(event, form) {
      var _this = this;
      form.isSubmitted = true;
      if (form.checkValidity()) {
        var target_1 = (
          /** @type {?} */
          event.target
        );
        var startLoading = (
          /**
          * @return {?}
          */
          function() {
            target_1.isDisabled = true;
            target_1.isLoading = true;
          }
        );
        var stopLoading_1 = (
          /**
          * @return {?}
          */
          function() {
            target_1.isDisabled = false;
            target_1.isLoading = false;
          }
        );
        startLoading();
        this.users.add({
          firstName: this.firstName,
          lastName: this.lastName,
          email: this.email,
          password: this.password,
          birthDate: this.birthDate ? new Date(this.birthDate).getTime() : null,
          role: this.role,
          bio: this.bio,
          avatar: this.avatar
        }).then(
          /**
          * @return {?}
          */
          function() {
            _this.alert.success(_this.i18n.get("UserAdded"), false, 5e3, true);
            _this.navigation.redirectTo("users", "list");
          }
        ).catch(
          /**
          * @param {?} error
          * @return {?}
          */
          function(error) {
            _this.alert.error(error.message);
          }
        ).finally(
          /**
          * @return {?}
          */
          function() {
            stopLoading_1();
          }
        );
      }
    };
    UsersAddComponent2.decorators = [
      { type: Component, args: [{
        selector: "fa-users-add",
        template: `<fa-layout>
  <!-- Page Header -->
  <div class="page-header row no-gutters py-4">
    <div class="col-12 text-center text-sm-left mb-0">
      <span class="text-uppercase page-subtitle">{{ 'Users' | translate }}</span>
      <h3 class="page-title">{{ 'AddNewUser' | translate }}</h3>
    </div>
  </div>
  <!-- End Page Header -->
  <div class="row">
    <div class="col-12">
      <!-- Add New Post Form -->
      <div class="card card-small mb-3">
        <div class="card-header border-bottom">
          <h6 class="m-0">{{ 'NewUser' | translate }}</h6>
        </div>
        <div class="card-body">
          <form class="add-new-user" #addUserForm>
            <div class="form-row">
              <div class="col-lg-8">
                <div class="form-row">
                  <div class="form-group col-md-6">
                    <label for="firstName">{{ 'FirstName' | translate }}</label>
                    <input type="text" class="form-control" id="firstName" [(ngModel)]="firstName" name="firstName" [class.is-invalid]="addUserForm.isSubmitted && !firstNameInput.checkValidity()" required #firstNameInput>
                  </div>
                  <div class="form-group col-md-6">
                    <label for="lastName">{{ 'LastName' | translate }}</label>
                    <input type="text" class="form-control" id="lastName" [(ngModel)]="lastName" name="lastName" [class.is-invalid]="addUserForm.isSubmitted && !lastNameInput.checkValidity()" required #lastNameInput>
                  </div>
                  <div class="form-group col-md-6">
                    <label for="emailAddress">{{ 'Email' | translate }}</label>
                    <div class="input-group input-group-seamless">
                      <div class="input-group-prepend">
                        <div class="input-group-text">
                          <i class="material-icons">&#xE0BE;</i>
                        </div>
                      </div>
                      <input type="email" class="form-control" id="emailAddress" [(ngModel)]="email" name="email" [class.is-invalid]="addUserForm.isSubmitted && !emailInput.checkValidity()" required #emailInput>
                    </div>
                  </div>
                  <div class="form-group col-md-6">
                    <label for="password">{{ 'Password' | translate }}</label>
                    <div class="input-group input-group-seamless">
                      <div class="input-group-prepend">
                        <div class="input-group-text">
                          <i class="material-icons">lock</i>
                        </div>
                      </div>
                      <input type="password" class="form-control" id="password" [(ngModel)]="password" name="password" [class.is-invalid]="addUserForm.isSubmitted && !passwordInput.checkValidity()" minlength="6" required #passwordInput>
                    </div>
                  </div>
                  <div class="form-group col-md-6">
                    <label for="birthDate">{{ 'BirthDate' | translate }}</label>
                    <div class="input-group input-group-seamless">
                      <div class="input-group-prepend">
                        <div class="input-group-text">
                          <i class="material-icons">calendar_today</i>
                        </div>
                      </div>
                      <input type="date" class="form-control" id="birthDate" [(ngModel)]="birthDate" name="birthDate">
                    </div>
                  </div>
                  <div class="form-group col-md-6">
                    <label for="displayEmail">{{ 'Role' | translate }}</label>
                    <select class="custom-select" [(ngModel)]="role" name="role">
                      <option *ngFor="let role of allRoles | keyvalue; let i = index" [value]="role.key">{{ role.value | translate }}</option>
                    </select>
                  </div>
                </div>
              </div>
              <div class="col-lg-4">
                <label for="userProfilePicture" class="text-center w-100 mb-4">{{ 'ProfilePicture' | translate }}</label>
                <div class="edit-user-details__avatar m-auto">
                  <img [src]="avatarSrc | escapeUrl" alt="User Avatar">
                  <label class="edit-user-details__avatar__change">
                    <i class="material-icons mr-1">&#xE439;</i>
                    <input type="file" accept="image/*" id="userProfilePicture" class="d-none" (change)="onAvatarChange($event)" #userAvatar>
                  </label>
                </div>
                <button class="btn btn-sm btn-white d-table mx-auto mt-4" (click)="userAvatar.click()"><i class="material-icons">&#xE2C3;</i> {{ 'UploadImage' | translate }}</button>
              </div>
            </div>
            <div class="form-row">
              <div class="form-group col-md-8">
                <label for="userBio">{{ 'Bio' | translate }}</label>
                <textarea style="min-height: 87px;" id="userBio" [(ngModel)]="bio" name="userBio" class="form-control" placeholder="{{ 'BioPlaceholder' | translate }}"></textarea>
              </div>
            </div>
            <button type="submit" class="btn btn-accent" [disabled]="addButon.isDisabled" (click)="addUser($event, addUserForm)" #addButon>
              {{ 'AddUser' | translate }} <i *ngIf="addButon.isLoading" class="fas fa-circle-notch fa-spin ml-1"></i>
            </button>
          </form>
        </div>
      </div>
      <!-- / Add New Post Form -->
    </div>
  </div>
</fa-layout>
`,
        styles: [".edit-user-details__avatar img{height:120px}"]
      }] }
    ];
    UsersAddComponent2.ctorParameters = function() {
      return [
        { type: UsersService },
        { type: AlertService },
        { type: I18nService },
        { type: NavigationService }
      ];
    };
    return UsersAddComponent2;
  }()
);
if (false) {
  UsersAddComponent.prototype.firstName;
  UsersAddComponent.prototype.lastName;
  UsersAddComponent.prototype.email;
  UsersAddComponent.prototype.password;
  UsersAddComponent.prototype.birthDate;
  UsersAddComponent.prototype.role;
  UsersAddComponent.prototype.allRoles;
  UsersAddComponent.prototype.bio;
  UsersAddComponent.prototype.avatar;
  UsersAddComponent.prototype.avatarSrc;
  UsersAddComponent.prototype.users;
  UsersAddComponent.prototype.alert;
  UsersAddComponent.prototype.i18n;
  UsersAddComponent.prototype.navigation;
}
var UsersProfileComponent = (
  /** @class */
  function() {
    function UsersProfileComponent2(navigation, users, posts, categories, settings, route, pages, currentUser) {
      this.navigation = navigation;
      this.users = users;
      this.posts = posts;
      this.categories = categories;
      this.settings = settings;
      this.route = route;
      this.pages = pages;
      this.currentUser = currentUser;
      this.allRoles = {};
      this.allPostsCategories = [];
      this.subscription = new Subscription();
      this.routeParamsChange = new Subject();
      this.postsLanguageChange = new Subject();
      this.statistics = {};
    }
    UsersProfileComponent2.prototype.ngOnInit = /**
    * @return {?}
    */
    function() {
      var _this = this;
      this.allRoles = this.users.getAllRoles();
      this.languages = this.settings.getActiveSupportedLanguages();
      this.postsLanguage = "*";
      this.allPostsStatus = this.posts.getAllStatusWithColors();
      this.subscription.add(this.categories.getAll().pipe(map(
        /**
        * @param {?} categories
        * @return {?}
        */
        function(categories) {
          var allCategories = [];
          categories.forEach(
            /**
            * @param {?} category
            * @return {?}
            */
            function(category) {
              allCategories[category.id] = category;
            }
          );
          return allCategories;
        }
      )).subscribe(
        /**
        * @param {?} categories
        * @return {?}
        */
        function(categories) {
          _this.allPostsCategories = categories;
        }
      ));
      this.subscription.add(this.route.params.subscribe(
        /**
        * @param {?} params
        * @return {?}
        */
        function(params) {
          _this.routeParamsChange.next();
          _this.postsLanguageChange.next();
          _this.users.get(params.id).pipe(map(
            /**
            * @param {?} user
            * @return {?}
            */
            function(user) {
              user.avatar = _this.users.getAvatarUrl(
                /** @type {?} */
                user.avatar
              );
              return user;
            }
          ), takeUntil(_this.routeParamsChange)).subscribe(
            /**
            * @param {?} user
            * @return {?}
            */
            function(user) {
              if (user) {
                _this.user = user;
                _this.user.id = params.id;
                _this.getStatistics();
                _this.getLatestPosts();
              } else {
                _this.navigation.redirectTo("users", "list");
              }
            }
          );
        }
      ));
    };
    UsersProfileComponent2.prototype.ngOnDestroy = /**
    * @return {?}
    */
    function() {
      this.subscription.unsubscribe();
      this.routeParamsChange.next();
      this.postsLanguageChange.next();
    };
    UsersProfileComponent2.prototype.getLatestPosts = /**
    * @private
    * @return {?}
    */
    function() {
      var _this = this;
      this.latestPosts = this.posts.getWhereFn(
        /**
        * @param {?} ref
        * @return {?}
        */
        function(ref) {
          var query = ref;
          query = query.where("createdBy", "==", _this.user.id);
          if (_this.postsLanguage !== "*") {
            query = query.where("lang", "==", _this.postsLanguage);
          }
          return query;
        },
        true
      ).pipe(map(
        /**
        * @param {?} posts
        * @return {?}
        */
        function(posts) {
          return posts.sort(
            /**
            * @param {?} a
            * @param {?} b
            * @return {?}
            */
            function(a, b2) {
              return b2.createdAt - a.createdAt;
            }
          ).slice(0, 5);
        }
      ), takeUntil(this.postsLanguageChange));
    };
    UsersProfileComponent2.prototype.onPostsLanguageChange = /**
    * @return {?}
    */
    function() {
      this.postsLanguageChange.next();
      this.getLatestPosts();
    };
    UsersProfileComponent2.prototype.getStatistics = /**
    * @private
    * @return {?}
    */
    function() {
      return __awaiter(this, void 0, void 0, function() {
        var _a3, publishedPosts, _b;
        var _this = this;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              if (!(this.user && this.user.id))
                return [3, 4];
              _a3 = this.statistics;
              return [4, this.posts.countWhere("createdBy", "==", this.user.id)];
            case 1:
              _a3.posts = _c.sent();
              return [4, this.posts.countWhereFn(
                /**
                * @param {?} ref
                * @return {?}
                */
                function(ref) {
                  return ref.where("createdBy", "==", _this.user.id).where("status", "==", PostStatus.Published);
                }
              )];
            case 2:
              publishedPosts = _c.sent();
              this.statistics.publishedPosts = Math.round(publishedPosts / this.statistics.posts * 100);
              this.statistics.comments = 0;
              _b = this.statistics;
              return [4, this.pages.countWhere("createdBy", "==", this.user.id)];
            case 3:
              _b.pages = _c.sent();
              _c.label = 4;
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    UsersProfileComponent2.prototype.canEditProfile = /**
    * @return {?}
    */
    function() {
      return !this.currentUser.isGuest();
    };
    UsersProfileComponent2.decorators = [
      { type: Component, args: [{
        selector: "fa-users-profile",
        template: `<fa-layout>
  <!-- Page Header -->
  <div class="page-header row no-gutters py-4">
    <div class="col-12 text-center text-sm-left mb-0">
      <span class="text-uppercase page-subtitle">{{ 'Users' | translate }}</span>
      <h3 class="page-title">{{ 'UserProfile' | translate }}</h3>
    </div>
  </div>
  <!-- End Page Header -->
  <div class="row">
    <div class="col-sm-12 col-lg-4">
      <!-- User Details Card -->
      <div class="card card-small mb-4 pt-3">
        <div class="card-body p-0">
          <div class="user-details__avatar mx-auto">
            <img [src]="user?.avatar | async | escapeUrl" alt="User Avatar">
          </div>
          <h4 class="text-center m-0 mt-2">{{ (user?.firstName || '') + ' ' + (user?.lastName || '') }}</h4>
          <p class="text-center text-light m-0 mb-2">{{ (allRoles[user?.role] || '') | translate }}</p>
          <ul class="user-details__social user-details__social--primary d-table mx-auto mb-4">
            <li class="mx-1" *ngIf="canEditProfile()">
              <a [routerLink]="navigation.getRouterLink('users', 'edit', user?.id || '')" title="{{ 'EditUser' | translate }}"><i class="far fa-edit"></i></a>
            </li>
          </ul>
          <div class="user-details__user-data border-top p-4">
            <div class="row mb-3">
              <div class="col w-50">
                <span>{{ 'FirstName' | translate }}</span>
                <span>{{ user?.firstName || '' }}</span>
              </div>
              <div class="col w-50">
                <span>{{ 'LastName' | translate }}</span>
                <span>{{ user?.lastName || '' }}</span>
              </div>
            </div>
            <div class="row">
              <div class="col w-50">
                <span>{{ 'Email' | translate }}</span>
                <span>{{ user?.email || '' }}</span>
              </div>
              <div class="col w-50">
                <span>{{ 'BirthDate' | translate }}</span>
                <span>{{ (user?.birthDate | shortdate) || '' }}</span>
              </div>
            </div>
          </div>
          <div class="user-details__tags border-top p-4" *ngIf="user?.bio">{{ user.bio }}</div>
        </div>
      </div>
      <!-- End User Details Card -->
    </div>
    <div class="col-lg-8">
      <!-- User Statistics -->
      <div class="card card-small user-stats mb-4">
        <div class="card-body">
          <div class="row">
            <div class="col-6 col-sm-3 text-center">
              <h4 class="m-0">{{ statistics?.posts || 0 }}</h4>
              <span class="text-light text-uppercase">{{ 'Posts' | translate }}</span>
            </div>
            <div class="col-6 col-sm-3 text-center">
              <h4 class="m-0">{{ statistics?.publishedPosts || 0 }}%</h4>
              <span class="text-light text-uppercase">{{ 'Published' | translate }}</span>
            </div>
            <div class="col-6 col-sm-3 text-center">
              <h4 class="m-0">{{ statistics?.comments || 0 }}</h4>
              <span class="text-light text-uppercase">{{ 'Comments' | translate }}</span>
            </div>
            <div class="col-6 col-sm-3 text-center">
              <h4 class="m-0">{{ statistics?.pages || 0 }}</h4>
              <span class="text-light text-uppercase">{{ 'Pages' | translate }}</span>
            </div>
          </div>
        </div>
      </div>
      <!-- End User Statistics -->
      <!-- Latest Posts -->
      <div class="card card-small lo-stats mb-4">
        <div class="card-header border-bottom">
          <h6 class="m-0">{{ 'LatestPosts' | translate }}</h6>
          <div class="block-handle"></div>
        </div>
        <div class="card-body p-0">
          <table class="table mb-0">
            <thead class="py-2 bg-light text-semibold border-bottom">
              <tr>
                <th class="text-left" colspan="2">{{ 'PostTitle' | translate }}</th>
                <th class="text-center">{{ 'PostDate' | translate }}</th>
                <th class="text-center">{{ 'PostStatus' | translate }}</th>
                <th class="text-center">{{ 'Categories' | translate }}</th>
                <th class="text-right">{{ 'Actions' | translate }}</th>
              </tr>
            </thead>
            <tbody>
              <ng-container *ngIf="latestPosts | async as posts; else loadingPostsTemplate">
                <tr *ngFor="let post of posts">
                  <td class="lo-stats__image">
                    <img class="border rounded" [src]="post.image.url | async | escapeUrl">
                  </td>
                  <td class="lo-stats__order-details">
                    <span>{{ post.title }}</span>
                    <span>{{ '/' + post.slug }}</span>
                  </td>
                  <td class="text-center">{{ post.date | shortdate }}</td>
                  <td class="text-center">
                    <span class="badge badge-pill badge-{{ allPostsStatus.colors[post.status] || 'primary' }}">{{ allPostsStatus.labels[post.status] | translate }}</span>
                  </td>
                  <td class="text-center text-primary">
                    <ng-container *ngFor="let categoryId of post.categories; let i = index">
                      <i *ngIf="i > 0">, </i>
                      <a [routerLink]="navigation.getRouterLink('posts', 'list', 'category', categoryId)">{{ allPostsCategories[categoryId]?.label }}</a>
                    </ng-container>
                  </td>
                  <td class="text-right">
                    <div class="btn-group btn-group-sm" role="group" aria-label="Table row actions">
                      <button *ngIf="post.isTranslatable" type="button" class="btn btn-white active-light" title="{{ 'Translate' | translate }}" [routerLink]="navigation.getRouterLink('posts', 'translate', post.id)">
                        <i class="material-icons">translate</i>
                      </button>
                      <button type="button" class="btn btn-white active-light" title="{{ 'Edit' | translate }}" [routerLink]="navigation.getRouterLink('posts', 'edit', post.id)">
                        <i class="material-icons">edit</i>
                      </button>
                    </div>
                  </td>
                </tr>
              </ng-container>
              <ng-template #loadingPostsTemplate>
                <tr>
                  <td class="text-center" colspan="6">
                    <fa-loading-indicator size="1x"></fa-loading-indicator>
                  </td>
                </tr>
              </ng-template>
            </tbody>
          </table>
        </div>
        <div class="card-footer border-top">
          <div class="row">
            <div class="col">
              <select class="custom-select custom-select-sm w-auto" style="min-width: 130px" [(ngModel)]="postsLanguage" name="postsLanguage" (change)="onPostsLanguageChange()">
                <option value="" disabled>{{ 'PostLanguage' | translate }}</option>
                <option value="*">{{ 'All' | translate }}</option>
                <option *ngFor="let lang of languages" [value]="lang.key">{{ lang.label | translate }}</option>
              </select>
            </div>
            <div class="col text-right view-report">
              <a [routerLink]="navigation.getRouterLink('posts', 'list', 'author', user?.id || '')">{{ 'FullList' | translate }} &rarr;</a>
            </div>
          </div>
        </div>
      </div>
      <!-- End Latest Posts -->
    </div>
  </div>
</fa-layout>
`,
        styles: [".user-details__avatar img{height:100px}"]
      }] }
    ];
    UsersProfileComponent2.ctorParameters = function() {
      return [
        { type: NavigationService },
        { type: UsersService },
        { type: PostsService },
        { type: CategoriesService },
        { type: SettingsService },
        { type: ActivatedRoute },
        { type: PagesService },
        { type: CurrentUserService }
      ];
    };
    return UsersProfileComponent2;
  }()
);
if (false) {
  UsersProfileComponent.prototype.user;
  UsersProfileComponent.prototype.allRoles;
  UsersProfileComponent.prototype.latestPosts;
  UsersProfileComponent.prototype.postsLanguage;
  UsersProfileComponent.prototype.languages;
  UsersProfileComponent.prototype.allPostsStatus;
  UsersProfileComponent.prototype.allPostsCategories;
  UsersProfileComponent.prototype.subscription;
  UsersProfileComponent.prototype.routeParamsChange;
  UsersProfileComponent.prototype.postsLanguageChange;
  UsersProfileComponent.prototype.statistics;
  UsersProfileComponent.prototype.navigation;
  UsersProfileComponent.prototype.users;
  UsersProfileComponent.prototype.posts;
  UsersProfileComponent.prototype.categories;
  UsersProfileComponent.prototype.settings;
  UsersProfileComponent.prototype.route;
  UsersProfileComponent.prototype.pages;
  UsersProfileComponent.prototype.currentUser;
}
var UsersEditComponent = (
  /** @class */
  function() {
    function UsersEditComponent2(users, i18n, alert, route, navigation) {
      this.users = users;
      this.i18n = i18n;
      this.alert = alert;
      this.route = route;
      this.navigation = navigation;
      this.allRoles = {};
      this.subscription = new Subscription();
    }
    UsersEditComponent2.prototype.ngOnInit = /**
    * @return {?}
    */
    function() {
      var _this = this;
      this.allRoles = this.users.getAllRoles();
      this.subscription.add(this.route.params.subscribe(
        /**
        * @param {?} params
        * @return {?}
        */
        function(params) {
          _this.users.get(params.id).pipe(take(1)).toPromise().then(
            /**
            * @param {?} user
            * @return {?}
            */
            function(user) {
              if (user) {
                _this.userData = user;
                _this.id = params.id;
                _this.firstName = user.firstName;
                _this.lastName = user.lastName;
                _this.email = user.email;
                _this.password = user.password;
                _this.birthDate = user.birthDate ? new Date(user.birthDate).toISOString().slice(0, 10) : null;
                _this.role = user.role;
                _this.bio = user.bio;
                _this.avatar = null;
                _this.subscription.add(_this.users.getAvatarUrl(
                  /** @type {?} */
                  user.avatar
                ).subscribe(
                  /**
                  * @param {?} imageUrl
                  * @return {?}
                  */
                  function(imageUrl) {
                    _this.avatarSrc = imageUrl;
                  }
                ));
              } else {
                _this.navigation.redirectTo("users", "list");
              }
            }
          );
        }
      ));
    };
    UsersEditComponent2.prototype.ngOnDestroy = /**
    * @return {?}
    */
    function() {
      this.subscription.unsubscribe();
    };
    UsersEditComponent2.prototype.onAvatarChange = /**
    * @param {?} event
    * @return {?}
    */
    function(event) {
      var _this = this;
      this.avatar = /** @type {?} */
      event.target.files[0];
      var reader = new FileReader();
      reader.onload = /**
      * @return {?}
      */
      function() {
        _this.avatarSrc = reader.result;
      };
      reader.readAsDataURL(this.avatar);
    };
    UsersEditComponent2.prototype.updateUser = /**
    * @param {?} event
    * @param {?} form
    * @return {?}
    */
    function(event, form) {
      var _this = this;
      form.isSubmitted = true;
      if (form.checkValidity()) {
        var target_1 = (
          /** @type {?} */
          event.target
        );
        var startLoading = (
          /**
          * @return {?}
          */
          function() {
            target_1.isDisabled = true;
            target_1.isLoading = true;
          }
        );
        var stopLoading_1 = (
          /**
          * @return {?}
          */
          function() {
            target_1.isDisabled = false;
            target_1.isLoading = false;
          }
        );
        startLoading();
        var data_1 = {
          firstName: this.firstName,
          lastName: this.lastName,
          email: this.email,
          password: this.password,
          birthDate: this.birthDate ? new Date(this.birthDate).getTime() : null,
          role: this.role,
          bio: this.bio
        };
        if (this.avatar) {
          data_1.avatar = this.avatar;
        }
        this.users.edit(this.id, data_1, {
          email: this.userData.email,
          password: this.userData.password
        }).then(
          /**
          * @return {?}
          */
          function() {
            _this.userData = __assign({}, _this.userData, data_1);
            _this.alert.success(_this.i18n.get("UserUpdated"), false, 5e3);
          }
        ).catch(
          /**
          * @param {?} error
          * @return {?}
          */
          function(error) {
            _this.alert.error(error.message);
          }
        ).finally(
          /**
          * @return {?}
          */
          function() {
            stopLoading_1();
          }
        );
      }
    };
    UsersEditComponent2.decorators = [
      { type: Component, args: [{
        selector: "fa-users-edit",
        template: `<fa-layout>
  <!-- Page Header -->
  <div class="page-header row no-gutters py-4">
    <div class="col-12 text-center text-sm-left mb-0">
      <span class="text-uppercase page-subtitle">{{ 'Users' | translate }}</span>
      <h3 class="page-title">{{ 'EditUser' | translate }}</h3>
    </div>
  </div>
  <!-- End Page Header -->
  <!-- Default Light Table -->
  <div class="row">
    <div class="col-lg-4">
      <div class="card card-small mb-4 pt-3">
        <div class="card-header border-bottom text-center">
          <div class="edit-user-details__avatar mb-3 mx-auto">
            <img [src]="avatarSrc | escapeUrl" alt="User Avatar">
            <label class="edit-user-details__avatar__change">
              <i class="material-icons mr-1">&#xE439;</i>
              <input type="file" accept="image/*" id="userProfilePicture" class="d-none" (change)="onAvatarChange($event)">
            </label>
          </div>
          <h4 class="mb-0" title="{{ (userData?.birthDate | shortdate) || '' }}">
            {{ (userData?.firstName || '') + ' ' + (userData?.lastName || '') }}
          </h4>
          <span class="text-muted d-block mb-2">{{ allRoles[userData?.role] || '' }}</span>
          <button type="button" class="mb-2 btn btn-sm btn-pill btn-outline-primary mr-2" [routerLink]="navigation.getRouterLink('users', 'profile', id || '')">
            <i class="material-icons mr-1">person</i>{{ 'Profile' | translate }}
          </button>
        </div>
        <ul class="list-group list-group-flush">
          <li class="list-group-item px-4">
            <strong class="text-muted d-block mb-2">{{ 'Email' | translate }}</strong>
            <span>{{ userData?.email || '' }}</span>
          </li>
          <li class="list-group-item p-4">
            <strong class="text-muted d-block mb-2">{{ 'Bio' | translate }}</strong>
            <span>{{ userData?.bio || '' }}</span>
          </li>
        </ul>
      </div>
    </div>
    <div class="col-lg-8">
      <div class="card card-small mb-4">
        <div class="card-header border-bottom">
          <h6 class="m-0">{{ 'UserDetails' | translate }}</h6>
        </div>
        <ul class="list-group list-group-flush">
          <li class="list-group-item p-3">
            <div class="row">
              <div class="col">
                <form #editUserForm>
                  <div class="form-row">
                    <div class="form-group col-md-6">
                      <label for="firstName">{{ 'FirstName' | translate }}</label>
                      <input type="text" class="form-control" id="firstName" [(ngModel)]="firstName" name="firstName" [class.is-invalid]="editUserForm.isSubmitted && !firstNameInput.checkValidity()" required #firstNameInput>
                    </div>
                    <div class="form-group col-md-6">
                      <label for="lastName">{{ 'LastName' | translate }}</label>
                      <input type="text" class="form-control" id="lastName" [(ngModel)]="lastName" name="lastName" [class.is-invalid]="editUserForm.isSubmitted && !lastNameInput.checkValidity()" required #lastNameInput>
                    </div>
                  </div>
                  <div class="form-row">
                    <div class="form-group col-md-6">
                      <label for="emailAddress">{{ 'Email' | translate }}</label>
                      <div class="input-group input-group-seamless">
                        <div class="input-group-prepend">
                          <div class="input-group-text">
                            <i class="material-icons">&#xE0BE;</i>
                          </div>
                        </div>
                        <input type="email" class="form-control" id="emailAddress" [(ngModel)]="email" name="email" [class.is-invalid]="editUserForm.isSubmitted && !emailInput.checkValidity()" required #emailInput>
                      </div>
                    </div>
                    <div class="form-group col-md-6">
                      <label for="password">{{ 'Password' | translate }}</label>
                      <div class="input-group input-group-seamless">
                        <div class="input-group-prepend">
                          <div class="input-group-text">
                            <i class="material-icons">lock</i>
                          </div>
                        </div>
                        <input type="password" class="form-control" id="password" [(ngModel)]="password" name="password" [class.is-invalid]="editUserForm.isSubmitted && !passwordInput.checkValidity()" minlength="6" required #passwordInput>
                      </div>
                    </div>
                  </div>
                  <div class="form-row">
                    <div class="form-group col-md-6">
                      <label for="birthDate">{{ 'BirthDate' | translate }}</label>
                      <div class="input-group input-group-seamless">
                        <div class="input-group-prepend">
                          <div class="input-group-text">
                            <i class="material-icons">calendar_today</i>
                          </div>
                        </div>
                        <input type="date" class="form-control" id="birthDate" [(ngModel)]="birthDate" name="birthDate">
                      </div>
                    </div>
                    <div class="form-group col-md-6">
                      <label for="displayEmail">{{ 'Role' | translate }}</label>
                      <select class="custom-select" [(ngModel)]="role" name="role">
                        <option *ngFor="let role of allRoles | keyvalue; let i = index" [value]="role.key">{{ role.value | translate }}</option>
                      </select>
                    </div>
                  </div>
                  <div class="form-row">
                    <div class="form-group col-md-8">
                      <label for="userBio">{{ 'Bio' | translate }}</label>
                      <textarea style="min-height: 87px;" id="userBio" [(ngModel)]="bio" name="userBio" class="form-control" placeholder="{{ 'BioPlaceholder' | translate }}"></textarea>
                    </div>
                  </div>
                  <button type="submit" class="btn btn-accent" [disabled]="updateButon.isDisabled" (click)="updateUser($event, editUserForm)" #updateButon>
                    {{ 'UpdateUser' | translate }} <i *ngIf="updateButon.isLoading" class="fas fa-circle-notch fa-spin ml-1"></i>
                  </button>
                </form>
              </div>
            </div>
          </li>
        </ul>
      </div>
    </div>
  </div>
  <!-- End Default Light Table -->
</fa-layout>
`,
        styles: [".edit-user-details__avatar{box-shadow:none}.edit-user-details__avatar img{height:120px}.list-group-item{margin-bottom:0}"]
      }] }
    ];
    UsersEditComponent2.ctorParameters = function() {
      return [
        { type: UsersService },
        { type: I18nService },
        { type: AlertService },
        { type: ActivatedRoute },
        { type: NavigationService }
      ];
    };
    return UsersEditComponent2;
  }()
);
if (false) {
  UsersEditComponent.prototype.id;
  UsersEditComponent.prototype.firstName;
  UsersEditComponent.prototype.lastName;
  UsersEditComponent.prototype.email;
  UsersEditComponent.prototype.password;
  UsersEditComponent.prototype.birthDate;
  UsersEditComponent.prototype.role;
  UsersEditComponent.prototype.allRoles;
  UsersEditComponent.prototype.bio;
  UsersEditComponent.prototype.avatar;
  UsersEditComponent.prototype.avatarSrc;
  UsersEditComponent.prototype.subscription;
  UsersEditComponent.prototype.userData;
  UsersEditComponent.prototype.users;
  UsersEditComponent.prototype.i18n;
  UsersEditComponent.prototype.alert;
  UsersEditComponent.prototype.route;
  UsersEditComponent.prototype.navigation;
}
$.extend($.easing, {
  easeOutSine: (
    /**
    * @param {?} e
    * @param {?} t
    * @param {?} a
    * @param {?} r
    * @param {?} n
    * @return {?}
    */
    function(e, t, a, r2, n2) {
      return r2 * Math.sin(t / n2 * (Math.PI / 2)) + a;
    }
  )
});
function initLayout() {
  function t() {
    var e = $(".nav-wrapper");
    var t2 = e.height();
    e[0] && e[0].scrollHeight > t2 ? e.css("overflowY", "auto") : e.css("overflowY", "none");
  }
  $(window).resize(t);
  t();
}
function initDropdown() {
  /** @type {?} */
  $(".dropdown-toggle").dropdown();
  var e = { duration: 270, easing: "easeOutSine" };
  $(":not(.main-sidebar--icons-only) .dropdown").on(
    "show.bs.dropdown",
    /**
    * @return {?}
    */
    function() {
      $(this).find(".dropdown-menu").first().stop(true, true).slideDown(e);
    }
  );
  $(":not(.main-sidebar--icons-only) .dropdown").on(
    "hide.bs.dropdown",
    /**
    * @return {?}
    */
    function() {
      $(this).find(".dropdown-menu").first().stop(true, true).slideUp(e);
    }
  );
}
function toggleSidebar() {
  if ($(".header-navbar").length) {
    /** @type {?} */
    $(".header-navbar").collapse("toggle");
  } else {
    $(".main-sidebar").toggleClass("open");
  }
}
function initPopover(selector) {
  if (selector === void 0) {
    selector = ".popover";
  }
  $(selector).popover({
    trigger: "manual",
    html: true,
    animation: false
  }).on(
    "mouseenter",
    /**
    * @return {?}
    */
    function() {
      var _this = this;
      $(this).popover("show");
      $(".popover").on(
        "mouseleave",
        /**
        * @return {?}
        */
        function() {
          $(_this).popover("hide");
        }
      );
    }
  ).on(
    "mouseleave",
    /**
    * @return {?}
    */
    function() {
      var _this = this;
      setTimeout(
        /**
        * @return {?}
        */
        function() {
          if (!$(".popover:hover").length) {
            $(_this).popover("hide");
          }
        },
        300
      );
    }
  );
}
var TranslationsComponent = (
  /** @class */
  function() {
    function TranslationsComponent2(settings, translations, alert, i18n) {
      this.settings = settings;
      this.translations = translations;
      this.alert = alert;
      this.i18n = i18n;
      this.allLanguages = [];
      this.selectedTranslation = null;
      this.dataTableOptions = {
        responsive: true,
        aaSorting: []
      };
      this.dataTableTrigger = new Subject();
      this.subscription = new Subscription();
    }
    TranslationsComponent2.prototype.ngOnInit = /**
    * @return {?}
    */
    function() {
      var _this = this;
      this.languages = this.settings.getActiveSupportedLanguages();
      this.language = this.languages[0].key;
      this.settings.supportedLanguages.forEach(
        /**
        * @param {?} language
        * @return {?}
        */
        function(language) {
          _this.allLanguages[language.key] = language;
        }
      );
      this.allTranslations = this.translations.getAll();
      this.subscription.add(this.allTranslations.subscribe(
        /**
        * @param {?} translations
        * @return {?}
        */
        function(translations) {
          refreshDataTable(_this.dataTableElement, _this.dataTableTrigger, true);
        }
      ));
    };
    TranslationsComponent2.prototype.ngOnDestroy = /**
    * @return {?}
    */
    function() {
      this.dataTableTrigger.unsubscribe();
      this.subscription.unsubscribe();
    };
    TranslationsComponent2.prototype.ngAfterViewInit = /**
    * @return {?}
    */
    function() {
      initPopover("#translations-tooltip");
    };
    TranslationsComponent2.prototype.addTranslation = /**
    * @param {?} event
    * @return {?}
    */
    function(event) {
      var _this = this;
      var addButton = (
        /** @type {?} */
        event.target
      );
      addButton.disabled = true;
      this.translations.keyExists(this.key, this.language).then(
        /**
        * @param {?} exists
        * @return {?}
        */
        function(exists) {
          if (exists) {
            var lang = _this.i18n.get(_this.allLanguages[_this.language].label);
            _this.alert.warning(_this.i18n.get("TranslationKeyAlreadyExists", { key: _this.key, lang }), false, 5e3);
            addButton.disabled = false;
          } else {
            _this.translations.add({
              key: _this.key,
              value: _this.value,
              lang: _this.language
            }).then(
              /**
              * @return {?}
              */
              function() {
                _this.alert.success(_this.i18n.get("TranslationAdded"), false, 5e3);
              }
            ).catch(
              /**
              * @param {?} error
              * @return {?}
              */
              function(error) {
                _this.alert.error(error.message);
              }
            ).finally(
              /**
              * @return {?}
              */
              function() {
                _this.key = _this.value = "";
              }
            );
          }
        }
      );
    };
    TranslationsComponent2.prototype.deleteTranslation = /**
    * @param {?} translation
    * @return {?}
    */
    function(translation) {
      var _this = this;
      this.translations.delete(translation.key, translation.lang).then(
        /**
        * @return {?}
        */
        function() {
          _this.alert.success(_this.i18n.get("TranslationDeleted", { key: translation.key }), false, 5e3);
        }
      ).catch(
        /**
        * @param {?} error
        * @return {?}
        */
        function(error) {
          _this.alert.error(error.message);
        }
      );
    };
    TranslationsComponent2.prototype.editTranslation = /**
    * @param {?} translation
    * @return {?}
    */
    function(translation) {
      var _this = this;
      this.translations.edit(translation).then(
        /**
        * @return {?}
        */
        function() {
          _this.alert.success(_this.i18n.get("TranslationSaved", { key: translation.key }), false, 5e3);
        }
      ).catch(
        /**
        * @param {?} error
        * @return {?}
        */
        function(error) {
          _this.alert.error(error.message);
        }
      );
    };
    TranslationsComponent2.prototype.setSelectedTranslation = /**
    * @param {?} translation
    * @return {?}
    */
    function(translation) {
      this.selectedTranslation = Object.assign({}, translation);
    };
    TranslationsComponent2.decorators = [
      { type: Component, args: [{
        selector: "fa-translations",
        template: `<fa-layout>
  <!-- Page Header -->
  <div class="page-header row no-gutters py-4">
    <div class="col-12 text-center text-sm-left mb-0">
      <span class="text-uppercase page-subtitle">{{ 'Translations' | translate }}</span>
      <span id="translations-tooltip" class="ml-1 align-middle cursor-pointer" data-toggle="popover" data-placement="right" [attr.data-content]="'TranslationsTooltip' | translate">
        <i class="far fa-question-circle"></i>
      </span>
    </div>
  </div>
  <!-- End Page Header -->
  <div class="row">
    <div class="col-lg-4 col-md-12">
      <!-- Add New Translation Form -->
      <div class="card card-small mb-3">
        <div class="card-header border-bottom">
          <h6 class="m-0">{{ 'NewTranslation' | translate }}</h6>
        </div>
        <div class="card-body">
          <form>
            <div class="form-group">
              <input type="text" class="form-control" placeholder="{{ 'TranslationKey' | translate }}" [(ngModel)]="key" name="key">
            </div>
            <div class="form-group">
              <input type="text" class="form-control" placeholder="{{ 'TranslationValue' | translate }}" [(ngModel)]="value" name="value">
            </div>
            <div class="form-group">
              <select class="custom-select" [(ngModel)]="language" name="language">
                <option value="" disabled>{{ 'TranslationLanguage' | translate }}</option>
                <option *ngFor="let lang of languages" [value]="lang.key">{{ lang.label | translate }}</option>
              </select>
            </div>
            <div class="form-group mb-0">
              <button type="submit" class="btn btn-accent" [disabled]="!key?.length || key === 'id' || !value?.length || !language?.length" (click)="addTranslation($event)">
                <i class="material-icons">add</i> {{ 'AddTranslation' | translate }}
              </button>
            </div>
          </form>
        </div>
      </div>
      <!-- / Add New Translation Form -->
    </div>
    <div class="col-lg-8 col-md-12">
      <!-- Translations List -->
      <div class="card card-small mb-3">
        <div class="card-header border-bottom">
          <h6 class="m-0">{{ 'Translations' | translate }}</h6>
        </div>
        <div class="card-body p-0">
          <table datatable [dtOptions]="dataTableOptions" [dtTrigger]="dataTableTrigger" class="file-manager file-manager-list d-none table-responsive">
            <thead>
              <tr>
                <th class="text-left">{{ 'TranslationKey' | translate }}</th>
                <th>{{ 'TranslationValue' | translate }}</th>
                <th>{{ 'TranslationLanguage' | translate }}</th>
                <th class="text-right hide-sort-icons">{{ 'Actions' | translate }}</th>
              </tr>
            </thead>
            <tbody>
              <tr *ngFor="let translation of allTranslations | async">
                <td class="text-left">{{ translation.key }}</td>
                <td>{{ translation.value }}</td>
                <td>{{ allLanguages[translation.lang].label | translate }}</td>
                <td class="text-right">
                  <div class="btn-group btn-group-sm" role="group" aria-label="Table row actions">
                    <button type="button" class="btn btn-white active-light" title="{{ 'Edit' | translate }}" data-toggle="modal" data-target="#editModal" (click)="setSelectedTranslation(translation)">
                      <i class="material-icons">edit</i>
                    </button>
                    <button type="button" class="btn btn-danger" title="{{ 'Delete' | translate }}" data-toggle="modal" data-target="#deleteModal" (click)="setSelectedTranslation(translation)">
                      <i class="material-icons">delete</i>
                    </button>
                  </div>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
      <!-- / Translations List -->
    </div>
  </div>
</fa-layout>

<!-- Edit Modal -->
<div class="modal fade" id="editModal" tabindex="-1" role="dialog" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">{{ 'EditTranslation' | translate }}</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">×</span>
        </button>
      </div>
      <div class="modal-body">
        <form>
          <!-- <div class="form-group">
            <input type="text" class="form-control" placeholder="{{ 'TranslationKey' | translate }}" [(ngModel)]="selectedTranslation && selectedTranslation.key" name="key">
          </div> -->
          <div class="form-group">
            <input type="text" class="form-control" placeholder="{{ 'TranslationValue' | translate }}" [(ngModel)]="selectedTranslation && selectedTranslation.value" name="value">
          </div>
          <!-- <div class="form-group mb-0">
            <select class="custom-select" [(ngModel)]="selectedTranslation && selectedTranslation.lang" name="language">
              <option value="" disabled>{{ 'TranslationLanguage' | translate }}</option>
              <option *ngFor="let lang of languages" [value]="lang.key">{{ lang.label | translate }}</option>
            </select>
          </div> -->
        </form>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-white" data-dismiss="modal">{{ 'Cancel' | translate }}</button>
        <button type="button" class="btn btn-accent" data-dismiss="modal" [disabled]="!selectedTranslation?.key?.length || selectedTranslation?.key === 'id' || !selectedTranslation?.value?.length || !selectedTranslation?.lang?.length" (click)="editTranslation(selectedTranslation)">{{ 'Save' | translate }}</button>
      </div>
    </div>
  </div>
</div>

<!-- Delete Modal -->
<div class="modal fade" id="deleteModal" tabindex="-1" role="dialog" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">{{ 'DeleteTranslation' | translate }}</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">×</span>
        </button>
      </div>
      <div class="modal-body" innerHTML="{{ 'ConfirmDeleteTranslation' | translate: {key: selectedTranslation?.key} }}"></div>
      <div class="modal-footer">
        <button type="button" class="btn btn-white" data-dismiss="modal">{{ 'Cancel' | translate }}</button>
        <button type="button" class="btn btn-danger" data-dismiss="modal" (click)="deleteTranslation(selectedTranslation)">{{ 'Delete' | translate }}</button>
      </div>
    </div>
  </div>
</div>
`,
        styles: [""]
      }] }
    ];
    TranslationsComponent2.ctorParameters = function() {
      return [
        { type: SettingsService },
        { type: TranslationsService },
        { type: AlertService },
        { type: I18nService }
      ];
    };
    TranslationsComponent2.propDecorators = {
      dataTableElement: [{ type: ViewChild, args: [DataTableDirective, { static: false }] }]
    };
    return TranslationsComponent2;
  }()
);
if (false) {
  TranslationsComponent.prototype.key;
  TranslationsComponent.prototype.value;
  TranslationsComponent.prototype.language;
  TranslationsComponent.prototype.languages;
  TranslationsComponent.prototype.allLanguages;
  TranslationsComponent.prototype.allTranslations;
  TranslationsComponent.prototype.selectedTranslation;
  TranslationsComponent.prototype.dataTableElement;
  TranslationsComponent.prototype.dataTableOptions;
  TranslationsComponent.prototype.dataTableTrigger;
  TranslationsComponent.prototype.subscription;
  TranslationsComponent.prototype.settings;
  TranslationsComponent.prototype.translations;
  TranslationsComponent.prototype.alert;
  TranslationsComponent.prototype.i18n;
}
var UserGuard = (
  /** @class */
  function() {
    function UserGuard2(currentUser, navigation) {
      this.currentUser = currentUser;
      this.navigation = navigation;
    }
    UserGuard2.prototype.canActivate = /**
    * @param {?} route
    * @param {?} state
    * @return {?}
    */
    function(route, state) {
      var _this = this;
      return new Promise(
        /**
        * @param {?} resolve
        * @param {?} reject
        * @return {?}
        */
        function(resolve2, reject) {
          return __awaiter(_this, void 0, void 0, function() {
            var user;
            return __generator(this, function(_a3) {
              switch (_a3.label) {
                case 0:
                  return [4, this.currentUser.get()];
                case 1:
                  user = _a3.sent();
                  if (user.role === UserRole.Administrator) {
                    resolve2(true);
                  } else {
                    if (route.url[0].path === "profile" && route.params["id"] === user.id) {
                      resolve2(true);
                    } else if (user.role === UserRole.Editor && route.url[0].path === "edit" && route.params["id"] === user.id) {
                      resolve2(true);
                    } else {
                      this.navigation.redirectTo("dashboard");
                      resolve2(false);
                    }
                  }
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        }
      );
    };
    UserGuard2.decorators = [
      { type: Injectable }
    ];
    UserGuard2.ctorParameters = function() {
      return [
        { type: CurrentUserService },
        { type: NavigationService }
      ];
    };
    return UserGuard2;
  }()
);
if (false) {
  UserGuard.prototype.currentUser;
  UserGuard.prototype.navigation;
}
var RegisterComponent = (
  /** @class */
  function() {
    function RegisterComponent2(navigation, users) {
      this.navigation = navigation;
      this.users = users;
      this.logo = getLogo();
      this.email = "";
      this.password = "";
      this.passwordConfirmation = "";
      this.error = null;
    }
    RegisterComponent2.prototype.ngOnInit = /**
    * @return {?}
    */
    function() {
    };
    RegisterComponent2.prototype.onSubmit = /**
    * @param {?} event
    * @param {?} submitButton
    * @return {?}
    */
    function(event, submitButton) {
      var _this = this;
      var form = (
        /** @type {?} */
        event.target
      );
      form.isSubmitted = true;
      if (form.checkValidity() && this.password === this.passwordConfirmation) {
        var startLoading = (
          /**
          * @return {?}
          */
          function() {
            submitButton.isDisabled = true;
            submitButton.isLoading = true;
          }
        );
        var stopLoading_1 = (
          /**
          * @return {?}
          */
          function() {
            submitButton.isDisabled = false;
            submitButton.isLoading = false;
          }
        );
        startLoading();
        this.users.register({
          firstName: "Super",
          lastName: "Admin",
          email: this.email,
          password: this.password,
          role: UserRole.Administrator,
          birthDate: null,
          bio: null
        }).then(
          /**
          * @return {?}
          */
          function() {
            _this.navigation.redirectTo("login?email=" + _this.email + "&password=" + _this.password);
          }
        ).catch(
          /**
          * @param {?} error
          * @return {?}
          */
          function(error) {
            _this.error = error.message;
          }
        ).finally(
          /**
          * @return {?}
          */
          function() {
            stopLoading_1();
          }
        );
      }
    };
    RegisterComponent2.prototype.dismissError = /**
    * @param {?} event
    * @return {?}
    */
    function(event) {
      event.preventDefault();
      event.stopPropagation();
      this.error = null;
    };
    RegisterComponent2.decorators = [
      { type: Component, args: [{
        selector: "fa-register",
        template: `
<div class="container-fluid icon-sidebar-nav h-100">
  <div class="row h-100">
    <main class="main-content col">
      <div class="main-content-container container-fluid px-4 my-auto h-100">
        <div class="row no-gutters h-100">
          <div class="col-lg-3 col-md-5 auth-form mx-auto my-auto">
            <div *ngIf="error?.length" class="alert alert-warning alert-dismissible fade show mb-4" role="alert">
              <button type="button" class="close" data-dismiss="alert" aria-label="Close" (click)="dismissError($event)">
                <span aria-hidden="true">×</span>
              </button>
              <i class="fa fa-exclamation mx-2"></i>
              {{ error }}
            </div>
            <div class="card">
              <div class="card-body">
                <img class="auth-form__logo d-table mx-auto mb-3" [src]="logo | escapeUrl" alt="FireAdmin">
                <h5 class="auth-form__title text-center mb-4">{{ 'WelcomeToFireAdmin' | translate }}</h5>
                <form (ngSubmit)="onSubmit($event, submitButton)" #registerForm>
                  <div class="form-group">
                    <label for="inputEmail">{{ 'EmailAddress' | translate }}</label>
                    <input type="email" class="form-control" id="inputEmail" name="inputEmail" aria-describedby="emailHelp" placeholder="{{ 'EnterEmail' | translate }}" [(ngModel)]="email" [class.is-invalid]="registerForm.isSubmitted && !emailInput.checkValidity()" required #emailInput>
                  </div>
                  <div class="form-group">
                    <label for="inputPassword">{{ 'Password' | translate }}</label>
                    <input type="password" class="form-control" id="inputPassword" name="inputPassword" placeholder="{{ 'Password' | translate }}" [(ngModel)]="password" [class.is-invalid]="registerForm.isSubmitted && (!passwordInput.checkValidity() || password !== passwordConfirmation)" required #passwordInput>
                  </div>
                  <div class="form-group mb-4">
                    <label for="inputPasswordConfirmation">{{ 'RepeatPassword' | translate }}</label>
                    <input type="password" class="form-control" id="inputPasswordConfirmation" name="inputPasswordConfirmation" placeholder="{{ 'RepeatPassword' | translate }}" [(ngModel)]="passwordConfirmation" [class.is-invalid]="registerForm.isSubmitted && (!passwordConfirmationInput.checkValidity() || password !== passwordConfirmation)" required #passwordConfirmationInput>
                  </div>
                  <button type="submit" class="btn btn-pill btn-accent d-table mx-auto" [disabled]="submitButton.isDisabled" #submitButton>
                    {{ 'CreateAccount' | translate }} <i *ngIf="submitButton.isLoading" class="fas fa-circle-notch fa-spin ml-1"></i>
                  </button>
                </form>
              </div>
            </div>
            <div class="auth-form__meta d-flex mt-4">
              <a [routerLink]="navigation.getRouterLink('login')">{{ ('SignIn' | translate) + '?' }}</a>
            </div>
          </div>
        </div>
      </div>
    </main>
  </div>
</div>
`,
        styles: [""]
      }] }
    ];
    RegisterComponent2.ctorParameters = function() {
      return [
        { type: NavigationService },
        { type: UsersService }
      ];
    };
    return RegisterComponent2;
  }()
);
if (false) {
  RegisterComponent.prototype.logo;
  RegisterComponent.prototype.email;
  RegisterComponent.prototype.password;
  RegisterComponent.prototype.passwordConfirmation;
  RegisterComponent.prototype.error;
  RegisterComponent.prototype.navigation;
  RegisterComponent.prototype.users;
}
var RegisterGuard = (
  /** @class */
  function() {
    function RegisterGuard2(navigation, config2) {
      this.navigation = navigation;
      this.config = config2;
    }
    RegisterGuard2.prototype.canActivate = /**
    * @param {?} route
    * @param {?} state
    * @return {?}
    */
    function(route, state) {
      var _this = this;
      return new Promise(
        /**
        * @param {?} resolve
        * @param {?} reject
        * @return {?}
        */
        function(resolve2, reject) {
          return __awaiter(_this, void 0, void 0, function() {
            var registrationEnabled;
            return __generator(this, function(_a3) {
              switch (_a3.label) {
                case 0:
                  return [4, this.config.isRegistrationEnabled()];
                case 1:
                  registrationEnabled = _a3.sent();
                  if (registrationEnabled) {
                    resolve2(true);
                  } else {
                    this.navigation.redirectTo("login");
                    resolve2(false);
                  }
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        }
      );
    };
    RegisterGuard2.decorators = [
      { type: Injectable }
    ];
    RegisterGuard2.ctorParameters = function() {
      return [
        { type: NavigationService },
        { type: ConfigService }
      ];
    };
    return RegisterGuard2;
  }()
);
if (false) {
  RegisterGuard.prototype.navigation;
  RegisterGuard.prototype.config;
}
var LogoutComponent = (
  /** @class */
  function() {
    function LogoutComponent2(auth2, alert, navigation) {
      this.auth = auth2;
      this.alert = alert;
      this.navigation = navigation;
    }
    LogoutComponent2.prototype.ngOnInit = /**
    * @return {?}
    */
    function() {
      var _this = this;
      this.auth.signOut().then(
        /**
        * @return {?}
        */
        function() {
          _this.navigation.redirectTo("login");
        }
      ).catch(
        /**
        * @param {?} error
        * @return {?}
        */
        function(error) {
          _this.alert.error(error.message);
        }
      );
    };
    LogoutComponent2.decorators = [
      { type: Component, args: [{
        selector: "fa-logout",
        template: "<fa-alert></fa-alert>\n",
        styles: [""]
      }] }
    ];
    LogoutComponent2.ctorParameters = function() {
      return [
        { type: AuthService },
        { type: AlertService },
        { type: NavigationService }
      ];
    };
    return LogoutComponent2;
  }()
);
if (false) {
  LogoutComponent.prototype.auth;
  LogoutComponent.prototype.alert;
  LogoutComponent.prototype.navigation;
}
var routes = [
  {
    path: "",
    component: FireAdminComponent,
    children: [
      // Login
      {
        path: "login",
        component: LoginComponent,
        canActivate: [LoginGuard]
      },
      // Logout
      {
        path: "logout",
        component: LogoutComponent
      },
      // Register
      {
        path: "register",
        component: RegisterComponent,
        canActivate: [RegisterGuard]
      },
      // Dashboard
      {
        path: "dashboard",
        component: DashboardComponent,
        canActivate: [AuthGuard]
      },
      // Settings
      {
        path: "settings",
        component: SettingsComponent,
        canActivate: [AuthGuard]
      },
      // Pages
      {
        path: "pages",
        canActivate: [AuthGuard],
        children: [
          {
            path: "list",
            component: PagesListComponent
          },
          {
            path: "list/author/:authorId",
            component: PagesListComponent
          },
          {
            path: "add",
            component: PagesAddComponent
          },
          {
            path: "edit/:id",
            component: PagesEditComponent
          },
          {
            path: "translate/:id",
            component: PagesTranslateComponent
          },
          {
            path: "**",
            redirectTo: "list"
          }
        ]
      },
      // Posts
      {
        path: "posts",
        canActivate: [AuthGuard],
        children: [
          {
            path: "list",
            component: PostsListComponent
          },
          {
            path: "list/status/:status",
            component: PostsListComponent
          },
          {
            path: "list/category/:categoryId",
            component: PostsListComponent
          },
          {
            path: "list/author/:authorId",
            component: PostsListComponent
          },
          {
            path: "add",
            component: PostsAddComponent
          },
          {
            path: "edit/:id",
            component: PostsEditComponent
          },
          {
            path: "translate/:id",
            component: PostsTranslateComponent
          },
          {
            path: "categories",
            component: PostsCategoriesComponent
          },
          {
            path: "**",
            redirectTo: "list"
          }
        ]
      },
      // Users
      {
        path: "users",
        canActivate: [AuthGuard],
        children: [
          {
            path: "list",
            component: UsersListComponent,
            canActivate: [UserGuard]
          },
          {
            path: "list/role/:role",
            component: UsersListComponent,
            canActivate: [UserGuard]
          },
          {
            path: "add",
            component: UsersAddComponent,
            canActivate: [UserGuard]
          },
          {
            path: "edit/:id",
            component: UsersEditComponent,
            canActivate: [UserGuard]
          },
          {
            path: "profile/:id",
            component: UsersProfileComponent,
            canActivate: [UserGuard]
          },
          {
            path: "**",
            redirectTo: "list"
          }
        ]
      },
      // Translations
      {
        path: "translations",
        component: TranslationsComponent,
        canActivate: [AuthGuard]
      },
      // 404
      {
        path: "**",
        redirectTo: "dashboard"
      }
    ]
  }
];
var FireAdminRoutingModule = (
  /** @class */
  function() {
    function FireAdminRoutingModule2() {
    }
    FireAdminRoutingModule2.decorators = [
      { type: NgModule, args: [{
        imports: [RouterModule.forChild(routes)],
        exports: [RouterModule]
      }] }
    ];
    return FireAdminRoutingModule2;
  }()
);
var SidebarComponent = (
  /** @class */
  function() {
    function SidebarComponent2(navigation, currentUser) {
      this.navigation = navigation;
      this.currentUser = currentUser;
      this.style = "expanded";
      this.logo = getLogo();
    }
    SidebarComponent2.prototype.ngOnInit = /**
    * @return {?}
    */
    function() {
    };
    SidebarComponent2.prototype.ngAfterViewInit = /**
    * @return {?}
    */
    function() {
      initDropdown();
    };
    SidebarComponent2.prototype.isRouteActive = /**
    * @private
    * @param {...?} path
    * @return {?}
    */
    function() {
      var _a3;
      var path = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        path[_i2] = arguments[_i2];
      }
      var link = (_a3 = this.navigation).getRouterLink.apply(_a3, __spread(path)).join("/");
      return this.navigation.router.isActive(link, false);
    };
    SidebarComponent2.prototype.isActive = /**
    * @param {...?} routes
    * @return {?}
    */
    function() {
      var _this = this;
      var routes2 = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        routes2[_i2] = arguments[_i2];
      }
      var isActive = false;
      routes2.forEach(
        /**
        * @param {?} path
        * @return {?}
        */
        function(path) {
          if (_this.isRouteActive.apply(_this, __spread(path))) {
            isActive = true;
          }
        }
      );
      return isActive;
    };
    SidebarComponent2.prototype.toggle = /**
    * @return {?}
    */
    function() {
      toggleSidebar();
    };
    SidebarComponent2.decorators = [
      { type: Component, args: [{
        selector: "fa-sidebar",
        template: `
<ng-container *ngIf="style !== 'headerbar'; else headerBarTemplate">
  <!-- Main Sidebar -->
  <aside class="main-sidebar col-12 col-md-3 col-lg-2 px-0">
    <div class="main-navbar">
      <nav class="navbar align-items-stretch navbar-light bg-white flex-md-nowrap border-bottom p-0">
        <a class="navbar-brand w-100 mr-0" [routerLink]="navigation.getRouterLink('dashboard')" style="line-height: 25px;">
          <div class="d-table m-auto">
            <img id="main-logo" class="d-inline-block align-top mr-1" style="max-width: 25px;" [src]="logo | escapeUrl" alt="FireAdmin">
            <span class="d-none" [ngClass]="{ 'd-md-inline ml-1': style !== 'collapsed' }">FireAdmin</span>
          </div>
        </a>
        <a class="toggle-sidebar d-sm-inline d-md-none d-lg-none" (click)="toggle()">
          <i class="material-icons">&#xE5C4;</i>
        </a>
      </nav>
    </div>
    <div class="nav-wrapper">
      <ng-container *ngTemplateOutlet="navItemsTemplate"></ng-container>
    </div>
  </aside>
  <!-- End Main Sidebar -->
</ng-container>
<ng-template #headerBarTemplate>
  <div class="header-navbar collapse d-lg-flex p-0 bg-white border-top">
    <div class="container">
      <div class="row">
        <div class="col">
          <ng-container *ngTemplateOutlet="navItemsTemplate"></ng-container>
        </div>
      </div>
    </div>
  </div>
</ng-template>

<ng-template #navItemsTemplate>
  <ul class="nav flex-column" [ngClass]="{ 'nav-tabs border-0 flex-lg-row': style === 'headerbar' }">
    <li class="nav-item">
      <a class="nav-link" [routerLink]="navigation.getRouterLink('dashboard')" routerLinkActive="active">
        <i class="material-icons">&#xE917;</i>
        <span>{{ 'Dashboard' | translate }}</span>
      </a>
    </li>
    <li class="nav-item dropdown">
      <a class="nav-link dropdown-toggle" [class.active]="isActive(['pages', 'list'], ['pages', 'add'], ['pages', 'edit'], ['pages', 'translate'])" data-toggle="dropdown" href="#" role="button" aria-haspopup="true" aria-expanded="true">
        <i class="material-icons">insert_drive_file</i>
        <span>{{ 'Pages' | translate }}</span>
      </a>
      <div class="dropdown-menu dropdown-menu-small" [class.show]="style === 'expanded' && isActive(['pages', 'list'], ['pages', 'add'], ['pages', 'edit'], ['pages', 'translate'])">
        <a class="dropdown-item " [routerLink]="navigation.getRouterLink('pages', 'list')" routerLinkActive="active">{{ 'List' | translate }}</a>
        <a class="dropdown-item " [routerLink]="navigation.getRouterLink('pages', 'add')" routerLinkActive="active">{{ 'Add' | translate }}</a>
      </div>
    </li>
    <li class="nav-item dropdown">
      <a class="nav-link dropdown-toggle" [class.active]="isActive(['posts', 'list'], ['posts', 'add'], ['posts', 'edit'], ['posts', 'translate'], ['posts', 'categories'])" data-toggle="dropdown" href="#" role="button" aria-haspopup="true" aria-expanded="true">
        <i class="material-icons">description</i>
        <span>{{ 'Posts' | translate }}</span>
      </a>
      <div class="dropdown-menu dropdown-menu-small" [class.show]="style === 'expanded' && isActive(['posts', 'list'], ['posts', 'add'], ['posts', 'edit'], ['posts', 'translate'], ['posts', 'categories'])">
        <a class="dropdown-item " [routerLink]="navigation.getRouterLink('posts', 'list')" routerLinkActive="active">{{ 'List' | translate }}</a>
        <a class="dropdown-item " [routerLink]="navigation.getRouterLink('posts', 'add')" routerLinkActive="active">{{ 'Add' | translate }}</a>
        <a class="dropdown-item " [routerLink]="navigation.getRouterLink('posts', 'categories')" routerLinkActive="active">{{ 'Categories' | translate }}</a>
      </div>
    </li>
    <li class="nav-item dropdown" [class.d-none]="!currentUser.isAdmin()">
      <a class="nav-link dropdown-toggle" [class.active]="isActive(['users', 'list'], ['users', 'add'], ['users', 'edit'], ['users', 'profile'])" data-toggle="dropdown" href="#" role="button" aria-haspopup="true" aria-expanded="true">
        <i class="material-icons">person</i>
        <span>{{ 'Users' | translate }}</span>
      </a>
      <div class="dropdown-menu dropdown-menu-small" [class.show]="style === 'expanded' && isActive(['users', 'list'], ['users', 'add'], ['users', 'edit'], ['users', 'profile'])">
        <a class="dropdown-item " [routerLink]="navigation.getRouterLink('users', 'list')" routerLinkActive="active">{{ 'List' | translate }}</a>
        <a class="dropdown-item " [routerLink]="navigation.getRouterLink('users', 'add')" routerLinkActive="active">{{ 'Add' | translate }}</a>
      </div>
    </li>
    <li class="nav-item">
      <a class="nav-link" [routerLink]="navigation.getRouterLink('translations')" routerLinkActive="active">
        <i class="material-icons">language</i>
        <span>{{ 'Translations' | translate }}</span>
      </a>
    </li>
    <!-- <li class="nav-item">
      <a class="nav-link" [routerLink]="navigation.getRouterLink('menus')" routerLinkActive="active">
        <i class="material-icons">menu</i>
        <span>{{ 'Menus' | translate }}</span>
      </a>
    </li> -->
    <!-- <li class="nav-item dropdown">
      <a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button" aria-haspopup="true" aria-expanded="true">
        <i class="material-icons">comment</i>
        <span>{{ 'Comments' | translate }}</span>
      </a>
      <div class="dropdown-menu dropdown-menu-small">
        <a class="dropdown-item " href="#">{{ 'List' | translate }}</a>
        <a class="dropdown-item " href="#">{{ 'Add' | translate }}</a>
      </div>
    </li> -->
    <!-- <li class="nav-item dropdown">
      <a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button" aria-haspopup="true" aria-expanded="true">
        <i class="material-icons">&#xE251;</i>
        <span>{{ 'Media' | translate }}</span>
      </a>
      <div class="dropdown-menu dropdown-menu-small">
        <a class="dropdown-item " href="#">{{ 'List' | translate }}</a>
        <a class="dropdown-item " href="#">{{ 'Add' | translate }}</a>
      </div>
    </li> -->
  </ul>
</ng-template>
`,
        styles: [""]
      }] }
    ];
    SidebarComponent2.ctorParameters = function() {
      return [
        { type: NavigationService },
        { type: CurrentUserService }
      ];
    };
    SidebarComponent2.propDecorators = {
      style: [{ type: Input }]
    };
    return SidebarComponent2;
  }()
);
if (false) {
  SidebarComponent.prototype.style;
  SidebarComponent.prototype.logo;
  SidebarComponent.prototype.navigation;
  SidebarComponent.prototype.currentUser;
}
var NavbarComponent = (
  /** @class */
  function() {
    function NavbarComponent2(currentUser, navigation, auth2) {
      this.currentUser = currentUser;
      this.navigation = navigation;
      this.auth = auth2;
      this.isSticky = true;
      this.isCentered = false;
      this.showBrand = false;
      this.logo = getLogo();
      this.defaultAvatar = getDefaultAvatar();
    }
    NavbarComponent2.prototype.ngOnInit = /**
    * @return {?}
    */
    function() {
    };
    NavbarComponent2.prototype.getUserName = /**
    * @return {?}
    */
    function() {
      return this.currentUser.data ? this.currentUser.data.firstName + " " + this.currentUser.data.lastName : this.auth.firebaseUser ? this.auth.firebaseUser.providerData[0].displayName || this.auth.firebaseUser.providerData[0].email : "unknown";
    };
    NavbarComponent2.prototype.toggleSidebar = /**
    * @param {?} event
    * @return {?}
    */
    function(event) {
      event.preventDefault();
      event.stopPropagation();
      toggleSidebar();
    };
    NavbarComponent2.decorators = [
      { type: Component, args: [{
        selector: "fa-navbar",
        template: `
<!-- Main Navbar -->
<div class="main-navbar bg-white" [class.sticky-top]="isSticky">
  <nav class="navbar align-items-stretch navbar-light flex-md-nowrap p-0" [class.container]="isCentered">
    <a *ngIf="showBrand" class="navbar-brand" [routerLink]="navigation.getRouterLink('dashboard')" style="line-height: 25px;">
      <div class="d-table m-auto">
        <img id="main-logo" class="d-inline-block align-top mr-1 ml-3" style="max-width: 25px;" [src]="logo | escapeUrl" alt="FireAdmin">
        <span class="d-none d-md-inline ml-1">FireAdmin</span>
      </div>
    </a>
    <ul class="navbar-nav border-left flex-row ml-auto" [class.border-right]="isCentered">
      <li class="nav-item dropdown">
        <a class="nav-link dropdown-toggle text-nowrap px-3" data-toggle="dropdown" href="#" role="button" aria-haspopup="true" aria-expanded="false">
          <img class="user-avatar rounded-circle mr-2" [src]="((currentUser.data?.avatar | async) || defaultAvatar) | escapeUrl" alt="User Avatar">
          <span class="d-none d-md-inline-block align-middle">{{ getUserName() }}</span>
        </a>
        <div class="dropdown-menu dropdown-menu-small">
          <a class="dropdown-item" [routerLink]="navigation.getRouterLink('posts', 'add')"><i class="material-icons">note_add</i> {{ 'AddPost' | translate }}</a>
          <a class="dropdown-item" [routerLink]="navigation.getRouterLink('users', 'profile', currentUser.data?.id || '')"><i class="material-icons">person</i> {{ 'Profile' | translate }}</a>
          <a class="dropdown-item" [routerLink]="navigation.getRouterLink('settings')"><i class="material-icons">&#xE8B8;</i> {{ 'Settings' | translate }}</a>
          <div class="dropdown-divider"></div>
          <a class="dropdown-item text-danger" [routerLink]="navigation.getRouterLink('logout')">
            <i class="material-icons text-danger">&#xE879;</i> {{ 'Logout' | translate }}
          </a>
        </div>
      </li>
      <li class="nav-item nav d-sm-inline d-md-none">
        <a
          href="#"
          class="nav-link nav-link-icon toggle-sidebar text-center border-left"
          data-toggle="collapse"
          data-target=".header-navbar"
          aria-expanded="false"
          aria-controls="header-navbar"
          (click)="toggleSidebar($event)"
        >
          <i class="material-icons">&#xE5D2;</i>
        </a>
      </li>
    </ul>
  </nav>
</div>
<!-- / .main-navbar -->
`,
        styles: [".dropdown-toggle::after{vertical-align:middle}"]
      }] }
    ];
    NavbarComponent2.ctorParameters = function() {
      return [
        { type: CurrentUserService },
        { type: NavigationService },
        { type: AuthService }
      ];
    };
    NavbarComponent2.propDecorators = {
      isSticky: [{ type: Input }],
      isCentered: [{ type: Input }],
      showBrand: [{ type: Input }]
    };
    return NavbarComponent2;
  }()
);
if (false) {
  NavbarComponent.prototype.isSticky;
  NavbarComponent.prototype.isCentered;
  NavbarComponent.prototype.showBrand;
  NavbarComponent.prototype.logo;
  NavbarComponent.prototype.defaultAvatar;
  NavbarComponent.prototype.currentUser;
  NavbarComponent.prototype.navigation;
  NavbarComponent.prototype.auth;
}
var TranslatePipe = (
  /** @class */
  function() {
    function TranslatePipe2(i18nService) {
      this.i18nService = i18nService;
    }
    TranslatePipe2.prototype.transform = /**
    * @param {?} key
    * @param {?=} substitutions
    * @return {?}
    */
    function(key, substitutions) {
      return this.i18nService.get(key, substitutions);
    };
    TranslatePipe2.decorators = [
      { type: Pipe, args: [{
        name: "translate"
      }] }
    ];
    TranslatePipe2.ctorParameters = function() {
      return [
        { type: I18nService }
      ];
    };
    return TranslatePipe2;
  }()
);
if (false) {
  TranslatePipe.prototype.i18nService;
}
var FooterComponent = (
  /** @class */
  function() {
    function FooterComponent2(navigation) {
      this.navigation = navigation;
    }
    FooterComponent2.prototype.ngOnInit = /**
    * @return {?}
    */
    function() {
    };
    FooterComponent2.decorators = [
      { type: Component, args: [{
        selector: "fa-footer",
        template: `<footer class="main-footer d-flex p-2 px-3 bg-white border-top">
  <ul class="nav">
    <li class="nav-item">
      <a class="nav-link" [routerLink]="navigation.getRouterLink('dashboard')">{{ 'Dashboard' | translate }}</a>
    </li>
    <li class="nav-item">
      <a class="nav-link" [routerLink]="navigation.getRouterLink('pages', 'list')">{{ 'Pages' | translate }}</a>
    </li>
    <li class="nav-item">
      <a class="nav-link" [routerLink]="navigation.getRouterLink('posts', 'list')">{{ 'Posts' | translate }}</a>
    </li>
  </ul>
  <span class="copyright ml-auto my-auto mr-2">
    Made with <i class="material-icons heart">favorite</i> by <a href="https://github.com/AXeL-dev" target="_blank">AXeL</a>
  </span>
</footer>
`,
        styles: [".heart{color:#e25555}"]
      }] }
    ];
    FooterComponent2.ctorParameters = function() {
      return [
        { type: NavigationService }
      ];
    };
    return FooterComponent2;
  }()
);
if (false) {
  FooterComponent.prototype.navigation;
}
var LayoutComponent = (
  /** @class */
  function() {
    function LayoutComponent2(settings) {
      this.settings = settings;
    }
    LayoutComponent2.prototype.ngOnInit = /**
    * @return {?}
    */
    function() {
    };
    LayoutComponent2.prototype.ngAfterViewInit = /**
    * @return {?}
    */
    function() {
      initLayout();
    };
    LayoutComponent2.decorators = [
      { type: Component, args: [{
        selector: "fa-layout",
        template: `<div class="container-fluid" [class.icon-sidebar-nav]="settings.sidebarStyle === 'collapsed'">
  <div class="row">
    <ng-container *ngIf="settings.sidebarStyle !== 'headerbar'; else headerBarLayoutTemplate">
      <fa-sidebar [style]="settings.sidebarStyle"></fa-sidebar>
      <main class="main-content" [ngClass]="settings.sidebarStyle === 'collapsed' ? 'col' : 'col-lg-10 col-md-9 col-sm-12 p-0 offset-lg-2 offset-md-3'">
        <fa-navbar></fa-navbar>
        <fa-alert></fa-alert>
        <ng-container *ngTemplateOutlet="mainContainerTemplate"></ng-container>
        <fa-footer></fa-footer>
      </main>
    </ng-container>
    <ng-template #headerBarLayoutTemplate>
      <main class="main-content col-lg-12 col-md-12 col-sm-12 p-0">
        <fa-navbar [isSticky]="false" [isCentered]="true" [showBrand]="true"></fa-navbar>
        <fa-sidebar [style]="settings.sidebarStyle"></fa-sidebar>
        <fa-alert></fa-alert>
        <ng-container *ngTemplateOutlet="mainContainerTemplate"></ng-container>
        <fa-footer></fa-footer>
      </main>
    </ng-template>
  </div>
</div>

<ng-template #mainContainerTemplate>
  <div class="main-content-container" [ngClass]="settings.sidebarStyle === 'headerbar' ? 'container' : 'container-fluid px-4'">
    <ng-content></ng-content>
  </div>
</ng-template>
`,
        styles: [""]
      }] }
    ];
    LayoutComponent2.ctorParameters = function() {
      return [
        { type: SettingsService }
      ];
    };
    return LayoutComponent2;
  }()
);
if (false) {
  LayoutComponent.prototype.settings;
}
var AlertComponent = (
  /** @class */
  function() {
    function AlertComponent2(alert) {
      this.alert = alert;
    }
    AlertComponent2.prototype.ngOnInit = /**
    * @return {?}
    */
    function() {
    };
    AlertComponent2.prototype.dismissAlert = /**
    * @param {?} event
    * @return {?}
    */
    function(event) {
      event.preventDefault();
      event.stopPropagation();
      this.alert.clear();
    };
    AlertComponent2.decorators = [
      { type: Component, args: [{
        selector: "fa-alert",
        template: '<div class="container-fluid px-0">\n  <div *ngIf="alert.message?.length" class="alert alert-{{ alert.type }} alert-dismissible fade show m-0" role="alert">\n    <i *ngIf="alert.icon" class="fa fa-{{ alert.icon }} mx-2"></i> <span [innerHTML]="alert.message"></span>\n    <button type="button" class="close" data-dismiss="alert" aria-label="Close" (click)="dismissAlert($event)">\n      <span aria-hidden="true">&times;</span>\n    </button>\n  </div>\n</div>\n',
        styles: [""]
      }] }
    ];
    AlertComponent2.ctorParameters = function() {
      return [
        { type: AlertService }
      ];
    };
    return AlertComponent2;
  }()
);
if (false) {
  AlertComponent.prototype.alert;
}
var ButtonGroupComponent = (
  /** @class */
  function() {
    function ButtonGroupComponent2() {
      this.values = [];
      this.valueChange = new EventEmitter();
    }
    ButtonGroupComponent2.prototype.ngOnInit = /**
    * @return {?}
    */
    function() {
    };
    ButtonGroupComponent2.prototype.isActive = /**
    * @param {?} option
    * @param {?} index
    * @return {?}
    */
    function(option, index) {
      return this.value === this.getValue(option, index);
    };
    ButtonGroupComponent2.prototype.getValue = /**
    * @param {?} option
    * @param {?} index
    * @return {?}
    */
    function(option, index) {
      return this.values && this.values[index] ? this.values[index] : option;
    };
    ButtonGroupComponent2.prototype.setValue = /**
    * @param {?} option
    * @param {?} index
    * @return {?}
    */
    function(option, index) {
      var value = this.getValue(option, index);
      this.value = value;
      this.valueChange.emit(value);
    };
    ButtonGroupComponent2.decorators = [
      { type: Component, args: [{
        selector: "fa-button-group",
        template: '<div class="btn-group btn-group-toggle w-100" data-toggle="buttons">\n  <ng-container *ngFor="let option of options; let i = index">\n    <label class="btn btn-white" [class.active]="isActive(option, i)" (click)="setValue(option, i)">\n      <input type="radio" [attr.checked]="isActive(option, i)"> {{ option | translate }}\n    </label>\n  </ng-container>\n</div>\n',
        styles: [""]
      }] }
    ];
    ButtonGroupComponent2.ctorParameters = function() {
      return [];
    };
    ButtonGroupComponent2.propDecorators = {
      value: [{ type: Input }],
      options: [{ type: Input }],
      values: [{ type: Input }],
      valueChange: [{ type: Output }]
    };
    return ButtonGroupComponent2;
  }()
);
if (false) {
  ButtonGroupComponent.prototype.value;
  ButtonGroupComponent.prototype.options;
  ButtonGroupComponent.prototype.values;
  ButtonGroupComponent.prototype.valueChange;
}
var EscapeUrlPipe = (
  /** @class */
  function() {
    function EscapeUrlPipe2(sanitizer) {
      this.sanitizer = sanitizer;
    }
    EscapeUrlPipe2.prototype.transform = /**
    * @param {?} content
    * @return {?}
    */
    function(content) {
      return this.sanitizer.bypassSecurityTrustUrl(content);
    };
    EscapeUrlPipe2.decorators = [
      { type: Pipe, args: [{
        name: "escapeUrl",
        pure: false
      }] }
    ];
    EscapeUrlPipe2.ctorParameters = function() {
      return [
        { type: DomSanitizer }
      ];
    };
    return EscapeUrlPipe2;
  }()
);
if (false) {
  EscapeUrlPipe.prototype.sanitizer;
}
var LoadingIndicatorComponent = (
  /** @class */
  function() {
    function LoadingIndicatorComponent2() {
      this.show = true;
      this.icon = "fas fa-circle-notch";
      this.size = "2x";
      this.animation = "spin";
      this.center = false;
    }
    LoadingIndicatorComponent2.prototype.ngOnInit = /**
    * @return {?}
    */
    function() {
    };
    LoadingIndicatorComponent2.decorators = [
      { type: Component, args: [{
        selector: "fa-loading-indicator",
        template: '<div *ngIf="show" [class.centered]="center">\n  <i class="{{ icon }} fa-{{ animation }} fa-{{ size }}"></i>\n</div>\n',
        styles: [".centered{position:absolute;left:50%;top:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);z-index:1}"]
      }] }
    ];
    LoadingIndicatorComponent2.ctorParameters = function() {
      return [];
    };
    LoadingIndicatorComponent2.propDecorators = {
      show: [{ type: Input }],
      icon: [{ type: Input }],
      size: [{ type: Input }],
      animation: [{ type: Input }],
      center: [{ type: Input }]
    };
    return LoadingIndicatorComponent2;
  }()
);
if (false) {
  LoadingIndicatorComponent.prototype.show;
  LoadingIndicatorComponent.prototype.icon;
  LoadingIndicatorComponent.prototype.size;
  LoadingIndicatorComponent.prototype.animation;
  LoadingIndicatorComponent.prototype.center;
}
var ShortDatePipe = (
  /** @class */
  function(_super) {
    __extends(ShortDatePipe2, _super);
    function ShortDatePipe2(i18nService) {
      var _this = _super.call(this, i18nService.getCurrentLanguage()) || this;
      _this.i18nService = i18nService;
      return _this;
    }
    ShortDatePipe2.prototype.transform = /**
    * @param {?} value
    * @param {?=} format
    * @param {?=} timezone
    * @param {?=} locale
    * @return {?}
    */
    function(value, format, timezone, locale) {
      return _super.prototype.transform.call(this, value, format || "dd MMMM yyyy", timezone, locale || this.i18nService.getCurrentLanguage());
    };
    ShortDatePipe2.decorators = [
      { type: Pipe, args: [{
        name: "shortdate"
      }] }
    ];
    ShortDatePipe2.ctorParameters = function() {
      return [
        { type: I18nService }
      ];
    };
    return ShortDatePipe2;
  }(DatePipe)
);
if (false) {
  ShortDatePipe.prototype.i18nService;
}
var DateTimePipe = (
  /** @class */
  function(_super) {
    __extends(DateTimePipe2, _super);
    function DateTimePipe2(i18nService) {
      var _this = _super.call(this, i18nService.getCurrentLanguage()) || this;
      _this.i18nService = i18nService;
      return _this;
    }
    DateTimePipe2.prototype.transform = /**
    * @param {?} value
    * @param {?=} format
    * @param {?=} timezone
    * @param {?=} locale
    * @return {?}
    */
    function(value, format, timezone, locale) {
      return _super.prototype.transform.call(this, value, format || "dd MMMM yyyy HH:mm", timezone, locale || this.i18nService.getCurrentLanguage());
    };
    DateTimePipe2.decorators = [
      { type: Pipe, args: [{
        name: "datetime"
      }] }
    ];
    DateTimePipe2.ctorParameters = function() {
      return [
        { type: I18nService }
      ];
    };
    return DateTimePipe2;
  }(DatePipe)
);
if (false) {
  DateTimePipe.prototype.i18nService;
}
registerLocaleData(fr_default);
registerLocaleData(ar_default);
var ɵ0 = FireAdminService.getFirebaseConfig;
var FireAdminModule = (
  /** @class */
  function() {
    function FireAdminModule2() {
    }
    FireAdminModule2.initialize = /**
    * @param {?} firebaseConfig
    * @return {?}
    */
    function(firebaseConfig) {
      return {
        ngModule: FireAdminModule2,
        providers: [
          FireAdminService,
          {
            provide: FirebaseOptionsToken,
            useValue: firebaseConfig
          }
        ]
      };
    };
    FireAdminModule2.decorators = [
      { type: NgModule, args: [{
        declarations: [
          FireAdminComponent,
          LoginComponent,
          DashboardComponent,
          SidebarComponent,
          NavbarComponent,
          TranslatePipe,
          FooterComponent,
          PagesListComponent,
          PagesAddComponent,
          PagesEditComponent,
          PostsListComponent,
          PostsAddComponent,
          PostsEditComponent,
          PostsCategoriesComponent,
          SettingsComponent,
          LayoutComponent,
          AlertComponent,
          ButtonGroupComponent,
          EscapeUrlPipe,
          PostsTranslateComponent,
          UsersListComponent,
          UsersAddComponent,
          UsersProfileComponent,
          UsersEditComponent,
          LoadingIndicatorComponent,
          TranslationsComponent,
          PagesTranslateComponent,
          RegisterComponent,
          LogoutComponent,
          ShortDatePipe,
          DateTimePipe
        ],
        imports: [
          CommonModule,
          FireAdminRoutingModule,
          FormsModule,
          AngularFireModule,
          AngularFirestoreModule,
          AngularFireAuthModule,
          AngularFireStorageModule,
          DataTablesModule
        ],
        exports: [
          FireAdminComponent
        ],
        providers: [
          I18nService,
          TranslatePipe,
          AuthService,
          AuthGuard,
          LoginGuard,
          RegisterGuard,
          UserGuard,
          NavigationService,
          AlertService,
          LocalStorageService,
          SettingsService,
          DatabaseService,
          CategoriesService,
          PostsService,
          EscapeUrlPipe,
          StorageService2,
          UsersService,
          FirebaseUserService,
          TranslationsService,
          PagesService,
          CurrentUserService,
          ConfigService,
          // Set database config (for AngularFireModule)
          {
            provide: FirebaseOptionsToken,
            useFactory: ɵ0,
            deps: [FireAdminService]
          }
        ]
      }] }
    ];
    return FireAdminModule2;
  }()
);
export {
  FireAdminComponent,
  FireAdminModule,
  FireAdminService,
  AlertService as ɵa,
  LocalStorageService as ɵb,
  PostsAddComponent as ɵba,
  PostsEditComponent as ɵbb,
  PostsCategoriesComponent as ɵbc,
  SettingsComponent as ɵbd,
  LayoutComponent as ɵbe,
  AlertComponent as ɵbf,
  ButtonGroupComponent as ɵbg,
  EscapeUrlPipe as ɵbh,
  PostsTranslateComponent as ɵbi,
  UsersListComponent as ɵbj,
  UsersAddComponent as ɵbk,
  UsersProfileComponent as ɵbl,
  UsersEditComponent as ɵbm,
  LoadingIndicatorComponent as ɵbn,
  TranslationsComponent as ɵbo,
  PagesTranslateComponent as ɵbp,
  RegisterComponent as ɵbq,
  LogoutComponent as ɵbr,
  ShortDatePipe as ɵbs,
  DateTimePipe as ɵbt,
  FireAdminRoutingModule as ɵbu,
  LoginGuard as ɵbv,
  ConfigService as ɵbw,
  RegisterGuard as ɵbx,
  AuthGuard as ɵby,
  UserGuard as ɵbz,
  CurrentUserService as ɵc,
  UsersService as ɵd,
  DatabaseService as ɵe,
  I18nService as ɵf,
  SettingsService as ɵg,
  StorageService2 as ɵh,
  FirebaseUserService as ɵi,
  LoginComponent as ɵj,
  AuthService as ɵk,
  NavigationService as ɵl,
  DashboardComponent as ɵm,
  PostsService as ɵn,
  DocumentTranslationsService as ɵo,
  PagesService as ɵp,
  TranslationsService as ɵq,
  CategoriesService as ɵr,
  SidebarComponent as ɵs,
  NavbarComponent as ɵt,
  TranslatePipe as ɵu,
  FooterComponent as ɵv,
  PagesListComponent as ɵw,
  PagesAddComponent as ɵx,
  PagesEditComponent as ɵy,
  PostsListComponent as ɵz
};
/*! Bundled license information:

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

@firebase/util/dist/index.cjs.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/component/dist/index.cjs.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/logger/dist/index.esm.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/app/dist/index.cjs.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase-admin/lib/utils/deep-copy.js:
  (*! firebase-admin v12.1.0 *)
  (*!
   * @license
   * Copyright 2017 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase-admin/lib/utils/error.js:
  (*! firebase-admin v12.1.0 *)
  (*!
   * @license
   * Copyright 2017 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase-admin/lib/utils/validator.js:
  (*! firebase-admin v12.1.0 *)
  (*!
   * @license
   * Copyright 2017 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase-admin/lib/utils/api-request.js:
  (*! firebase-admin v12.1.0 *)
  (*!
   * @license
   * Copyright 2017 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

firebase-admin/lib/app/credential-internal.js:
  (*! firebase-admin v12.1.0 *)
  (*!
   * @license
   * Copyright 2020 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase-admin/lib/utils/index.js:
  (*! firebase-admin v12.1.0 *)
  (*!
   * @license
   * Copyright 2017 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase-admin/lib/app/firebase-app.js:
  (*! firebase-admin v12.1.0 *)
  (*!
   * @license
   * Copyright 2017 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase-admin/lib/app/lifecycle.js:
  (*! firebase-admin v12.1.0 *)
  (*!
   * @license
   * Copyright 2021 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase-admin/lib/app/credential-factory.js:
  (*! firebase-admin v12.1.0 *)
  (*!
   * @license
   * Copyright 2021 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase-admin/lib/app/index.js:
  (*! firebase-admin v12.1.0 *)
  (*!
   * @license
   * Copyright 2021 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

jquery/dist/jquery.js:
  (*!
   * jQuery JavaScript Library v3.7.1
   * https://jquery.com/
   *
   * Copyright OpenJS Foundation and other contributors
   * Released under the MIT license
   * https://jquery.org/license
   *
   * Date: 2023-08-28T13:37Z
   *)

popper.js/dist/esm/popper.js:
  (**!
   * @fileOverview Kickass library to create and place poppers near their reference elements.
   * @version 1.16.1
   * @license
   * Copyright (c) 2016 Federico Zivolo and contributors
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   *)

bootstrap/dist/js/bootstrap.js:
  (*!
    * Bootstrap v4.6.2 (https://getbootstrap.com/)
    * Copyright 2011-2022 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
    * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
    *)

firebase/app/dist/index.esm.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/util/dist/index.esm.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/util/dist/index.esm.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/util/dist/index.esm.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/util/dist/index.esm.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/util/dist/index.esm.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/util/dist/index.esm.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/util/dist/index.esm.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/util/dist/index.esm.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/util/dist/index.esm.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/util/dist/index.esm.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/util/dist/index.esm.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/util/dist/index.esm.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/util/dist/index.esm.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/webchannel-wrapper/dist/index.esm.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

@firebase/component/dist/index.esm.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/firestore/dist/index.esm.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
  * @license
  * Copyright 2020 Google LLC
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/storage/dist/index.esm.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

angular-datatables/src/angular-datatables.directive.js:
  (**
   * @license
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://raw.githubusercontent.com/l-lin/angular-datatables/master/LICENSE
   *)

angular-datatables/src/angular-datatables.module.js:
  (**
   * @license
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://raw.githubusercontent.com/l-lin/angular-datatables/master/LICENSE
   *)

angular-datatables/index.js:
  (**
   * @license
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://raw.githubusercontent.com/l-lin/angular-datatables/master/LICENSE
   *)

@angular/common/locales/fr.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/common/locales/ar.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)
*/
//# sourceMappingURL=ng-fire-admin.js.map
